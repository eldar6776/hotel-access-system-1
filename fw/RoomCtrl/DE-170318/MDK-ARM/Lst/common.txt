; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\common.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\common.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\common.crf ..\Src\common.c]
                          THUMB

                          AREA ||i.BaseToPower||, CODE, READONLY, ALIGN=1

                  BaseToPower PROC
;;;239    
;;;240    uint32_t BaseToPower(uint8_t base, uint8_t power)
000000  4603              MOV      r3,r0
;;;241    {   
;;;242    	uint32_t result = 1U;
000002  2001              MOVS     r0,#1
000004  e000              B        |L1.8|
                  |L1.6|
;;;243        
;;;244    	while(power--) result *= base;
000006  4358              MULS     r0,r3,r0
                  |L1.8|
000008  1e49              SUBS     r1,r1,#1
00000a  b2c9              UXTB     r1,r1
00000c  d2fb              BCS      |L1.6|
;;;245    	return (result);
;;;246    }
00000e  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i.Bcd2Dec||, CODE, READONLY, ALIGN=1

                  Bcd2Dec PROC
;;;34     /* Program Code  -------------------------------------------------------------*/
;;;35     uint8_t Bcd2Dec(uint8_t bcd)
000000  f000010f          AND      r1,r0,#0xf
;;;36     {
;;;37     	return(((bcd >> 4U) * 10U) + (bcd & 0x0fU));
000004  0900              LSRS     r0,r0,#4
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  eb010040          ADD      r0,r1,r0,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;38     }
000010  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.CalcCRC||, CODE, READONLY, ALIGN=1

                  CalcCRC PROC
;;;56     
;;;57     uint8_t CalcCRC(uint8_t *buff, uint8_t size)
000000  2200              MOVS     r2,#0
                  |L3.2|
;;;58     {
;;;59     	uint32_t g = 0U;
;;;60         uint32_t h = size;
;;;61      
;;;62         do
;;;63         {
;;;64             g += *buff;
000002  f8103b01          LDRB     r3,[r0],#1
000006  441a              ADD      r2,r2,r3
;;;65             ++buff;
;;;66             --h;
000008  1e49              SUBS     r1,r1,#1
;;;67             
;;;68         }while(h != 0U);
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L3.2|
;;;69     
;;;70     	return(((~g) & 0xffU) + 1U);
00000e  43d0              MVNS     r0,r2
000010  1c40              ADDS     r0,r0,#1
000012  b2c0              UXTB     r0,r0
;;;71     }
000014  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.CharToBin||, CODE, READONLY, ALIGN=2

                  CharToBin PROC
;;;231    
;;;232    void CharToBin(unsigned char c, char *out) 
000000  b570              PUSH     {r4-r6,lr}
;;;233    {
;;;234    	*(unsigned long long*)out = 3472328296227680304ULL +
000002  4a0c              LDR      r2,|L4.52|
000004  2300              MOVS     r3,#0
000006  fba05602          UMULL    r5,r6,r0,r2
00000a  0114              LSLS     r4,r2,#4
00000c  fb036202          MLA      r2,r3,r2,r6
000010  fb002004          MLA      r0,r0,r4,r2
000014  09ea              LSRS     r2,r5,#7
000016  ea426240          ORR      r2,r2,r0,LSL #25
00001a  09c0              LSRS     r0,r0,#7
00001c  f0023301          AND      r3,r2,#0x1010101
000020  f0003201          AND      r2,r0,#0x1010101
000024  f04f3030          MOV      r0,#0x30303030
000028  1818              ADDS     r0,r3,r0
00002a  f1423230          ADC      r2,r2,#0x30303030
00002e  c105              STM      r1!,{r0,r2}
;;;235        (((c * 9241421688590303745ULL) / 128) & 72340172838076673ULL);
;;;236    }
000030  bd70              POP      {r4-r6,pc}
;;;237    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x08040201

                          AREA ||i.ClearBuffer||, CODE, READONLY, ALIGN=1

                  ClearBuffer PROC
;;;153    }	
;;;154    void ClearBuffer(uint8_t *buffer, uint16_t size)
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156    	uint32_t t = 0U;
000002  2200              MOVS     r2,#0
;;;157        
;;;158    	while(t < size) buffer[t++] = 0U;
000004  2300              MOVS     r3,#0
000006  e002              B        |L5.14|
                  |L5.8|
000008  4614              MOV      r4,r2
00000a  1c52              ADDS     r2,r2,#1
00000c  5503              STRB     r3,[r0,r4]
                  |L5.14|
00000e  428a              CMP      r2,r1
000010  d3fa              BCC      |L5.8|
;;;159    }
000012  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.Dec2Bcd||, CODE, READONLY, ALIGN=1

                  Dec2Bcd PROC
;;;40     
;;;41     uint8_t Dec2Bcd(uint8_t dec)
000000  2100              MOVS     r1,#0
;;;42     {
000002  e002              B        |L6.10|
                  |L6.4|
;;;43     	uint32_t r = 0U;
;;;44         
;;;45     	while(dec > 9U)
;;;46     	{
;;;47     		dec -= 10U;
000004  380a              SUBS     r0,r0,#0xa
000006  b2c0              UXTB     r0,r0
;;;48     		++r;
000008  1c49              ADDS     r1,r1,#1
                  |L6.10|
00000a  2809              CMP      r0,#9                 ;45
00000c  d8fa              BHI      |L6.4|
;;;49     	}
;;;50     
;;;51     	r <<= 4U;
00000e  0109              LSLS     r1,r1,#4
;;;52     	r += dec;
000010  4408              ADD      r0,r0,r1
;;;53     	return (r);
000012  b2c0              UXTB     r0,r0
;;;54     }
000014  4770              BX       lr
;;;55     
                          ENDP


                          AREA ||i.Hex2Str||, CODE, READONLY, ALIGN=1

                  Hex2Str PROC
;;;137    
;;;138    void Hex2Str(uint8_t *p_hex, uint16_t lenght, uint8_t *p_str)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
;;;140    	uint32_t hex_cnt = 0U, str_cnt = 0U;
000002  2400              MOVS     r4,#0
000004  2300              MOVS     r3,#0
000006  e01c              B        |L7.66|
                  |L7.8|
;;;141    	
;;;142    	while(lenght)
;;;143    	{
;;;144    		if((p_hex[hex_cnt] >> 4U) > 9U) p_str[str_cnt] = (p_hex[hex_cnt] >> 4U) + 55U; // convert to upper ascii letter
000008  5d05              LDRB     r5,[r0,r4]
00000a  2609              MOVS     r6,#9
00000c  ebb61f15          CMP      r6,r5,LSR #4
000010  d204              BCS      |L7.28|
000012  2637              MOVS     r6,#0x37
000014  eb061515          ADD      r5,r6,r5,LSR #4
000018  54d5              STRB     r5,[r2,r3]
00001a  e003              B        |L7.36|
                  |L7.28|
;;;145    		else p_str[str_cnt] = (p_hex[hex_cnt] >> 4U) + 48U;
00001c  2630              MOVS     r6,#0x30
00001e  eb061515          ADD      r5,r6,r5,LSR #4
000022  54d5              STRB     r5,[r2,r3]
                  |L7.36|
;;;146    		++str_cnt;
000024  1c5b              ADDS     r3,r3,#1
;;;147    		if((p_hex[hex_cnt] & 0x0fU) > 9U) p_str[str_cnt] = (p_hex[hex_cnt] & 0x0fU) + 55U; // convert to upper ascii letter
000026  5d05              LDRB     r5,[r0,r4]
000028  f005050f          AND      r5,r5,#0xf
00002c  2d09              CMP      r5,#9
00002e  d902              BLS      |L7.54|
000030  3537              ADDS     r5,r5,#0x37
000032  54d5              STRB     r5,[r2,r3]
000034  e001              B        |L7.58|
                  |L7.54|
;;;148    		else p_str[str_cnt]  = (p_hex[hex_cnt]& 0x0fU) + 48U;
000036  3530              ADDS     r5,r5,#0x30
000038  54d5              STRB     r5,[r2,r3]
                  |L7.58|
;;;149    		++str_cnt;
00003a  1c5b              ADDS     r3,r3,#1
;;;150    		++hex_cnt;
00003c  1c64              ADDS     r4,r4,#1
;;;151    		--lenght;
00003e  1e49              SUBS     r1,r1,#1
000040  b289              UXTH     r1,r1
                  |L7.66|
000042  2900              CMP      r1,#0                 ;142
000044  d1e0              BNE      |L7.8|
;;;152    	}
;;;153    }	
000046  bd70              POP      {r4-r6,pc}
;;;154    void ClearBuffer(uint8_t *buffer, uint16_t size)
                          ENDP


                          AREA ||i.Int2Str||, CODE, READONLY, ALIGN=2

                  Int2Str PROC
;;;72     
;;;73     void Int2Str(uint8_t *p_str, uint32_t intnum)
000000  b5f0              PUSH     {r4-r7,lr}
;;;74     {
;;;75     	uint32_t i, divider = 1000000000U, pos = 0U, status = 0U;
000002  4b0f              LDR      r3,|L8.64|
000004  2200              MOVS     r2,#0
000006  2500              MOVS     r5,#0
;;;76     
;;;77     	for (i = 0U; i < 10U; i++)
000008  2400              MOVS     r4,#0
;;;78     	{
;;;79     		p_str[pos++] = (intnum / divider) + 48U;
;;;80     
;;;81     		intnum = intnum % divider;
;;;82     		divider /= 10U;
00000a  270a              MOVS     r7,#0xa
                  |L8.12|
00000c  fbb1f6f3          UDIV     r6,r1,r3              ;79
000010  3630              ADDS     r6,r6,#0x30           ;79
000012  4694              MOV      r12,r2                ;79
000014  1c52              ADDS     r2,r2,#1              ;79
000016  f800600c          STRB     r6,[r0,r12]           ;79
00001a  fbb1f6f3          UDIV     r6,r1,r3              ;81
00001e  fb031116          MLS      r1,r3,r6,r1           ;81
000022  fbb3f3f7          UDIV     r3,r3,r7
;;;83     		
;;;84     		if ((p_str[pos-1] == '0') & (status == 0U))
000026  1886              ADDS     r6,r0,r2
000028  f8166c01          LDRB     r6,[r6,#-1]
00002c  2e30              CMP      r6,#0x30
00002e  d100              BNE      |L8.50|
000030  b125              CBZ      r5,|L8.60|
                  |L8.50|
;;;85     		{
;;;86     			pos = 0U;
;;;87     		}
;;;88     		else
;;;89     		{
;;;90     			status++;
000032  1c6d              ADDS     r5,r5,#1
                  |L8.52|
000034  1c64              ADDS     r4,r4,#1              ;77
000036  2c0a              CMP      r4,#0xa               ;77
000038  d3e8              BCC      |L8.12|
;;;91     		}
;;;92     	}
;;;93     }
00003a  bdf0              POP      {r4-r7,pc}
                  |L8.60|
00003c  2200              MOVS     r2,#0                 ;86
00003e  e7f9              B        |L8.52|
;;;94     
                          ENDP

                  |L8.64|
                          DCD      0x3b9aca00

                          AREA ||i.Int2StrSized||, CODE, READONLY, ALIGN=2

                  Int2StrSized PROC
;;;95     
;;;96     void Int2StrSized(uint8_t *p_str, uint32_t intnum, uint8_t size)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;97     {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;98     	uint8_t result[16];
;;;99     	uint32_t i, divider = 1000000000U, pos = 0U;
00000a  4d14              LDR      r5,|L9.92|
00000c  2400              MOVS     r4,#0
;;;100    
;;;101    	ClearBuffer(result, 16U);
00000e  2110              MOVS     r1,#0x10
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       ClearBuffer
;;;102    	
;;;103    	for (i = 0U; i < 10U; i++)
000016  2200              MOVS     r2,#0
;;;104    	{
;;;105    		result[pos++] = (intnum / divider) + 48U;
;;;106    		intnum = intnum % divider;
;;;107    		divider /= 10U;
000018  230a              MOVS     r3,#0xa
00001a  4669              MOV      r1,sp                 ;98
                  |L9.28|
00001c  fbb7f0f5          UDIV     r0,r7,r5              ;105
000020  3030              ADDS     r0,r0,#0x30           ;105
000022  46a4              MOV      r12,r4                ;105
000024  1c64              ADDS     r4,r4,#1              ;105
000026  f801000c          STRB     r0,[r1,r12]           ;105
00002a  fbb7f0f5          UDIV     r0,r7,r5              ;106
00002e  fb057710          MLS      r7,r5,r0,r7           ;106
000032  fbb5f5f3          UDIV     r5,r5,r3
000036  1c52              ADDS     r2,r2,#1              ;103
000038  2a0a              CMP      r2,#0xa               ;103
00003a  d3ef              BCC      |L9.28|
;;;108    	}
;;;109    	
;;;110    	pos -= 1U;
00003c  1e64              SUBS     r4,r4,#1
;;;111    	
;;;112    	while(size && pos)
00003e  e007              B        |L9.80|
                  |L9.64|
;;;113    	{
;;;114    		p_str[size - 1U] = result[pos];
000040  eb080206          ADD      r2,r8,r6
000044  5d08              LDRB     r0,[r1,r4]
000046  f8020c01          STRB     r0,[r2,#-1]
;;;115    		size--;
00004a  1e76              SUBS     r6,r6,#1
00004c  b2f6              UXTB     r6,r6
;;;116    		pos--;
00004e  1e64              SUBS     r4,r4,#1
                  |L9.80|
000050  2e00              CMP      r6,#0                 ;112
000052  d001              BEQ      |L9.88|
000054  2c00              CMP      r4,#0                 ;112
000056  d1f3              BNE      |L9.64|
                  |L9.88|
;;;117    	}
;;;118    }
000058  e8bd81ff          POP      {r0-r8,pc}
;;;119    
                          ENDP

                  |L9.92|
                          DCD      0x3b9aca00

                          AREA ||i.Str2Hex||, CODE, READONLY, ALIGN=1

                  Str2Hex PROC
;;;120    
;;;121    void Str2Hex(uint8_t *p_str, uint16_t lenght, uint8_t *p_hex)
000000  b5f0              PUSH     {r4-r7,lr}
;;;122    {
;;;123    	uint32_t hex_cnt = 0U, str_cnt = 0U;
000002  2300              MOVS     r3,#0
000004  2500              MOVS     r5,#0
000006  e027              B        |L10.88|
                  |L10.8|
;;;124    	
;;;125    	while(lenght)
;;;126    	{
;;;127    		if((p_str[str_cnt] - 48U) > 9U) p_hex[hex_cnt] = CONVERTHEX_ALPHA(p_str[str_cnt]) << 4U;
000008  5d44              LDRB     r4,[r0,r5]
00000a  f1a40630          SUB      r6,r4,#0x30
00000e  2e09              CMP      r6,#9
000010  d908              BLS      |L10.36|
000012  3e11              SUBS     r6,r6,#0x11
000014  2e05              CMP      r6,#5
000016  d801              BHI      |L10.28|
000018  3c37              SUBS     r4,r4,#0x37
00001a  e000              B        |L10.30|
                  |L10.28|
00001c  3c57              SUBS     r4,r4,#0x57
                  |L10.30|
00001e  0124              LSLS     r4,r4,#4
000020  54d4              STRB     r4,[r2,r3]
000022  e001              B        |L10.40|
                  |L10.36|
;;;128    		else p_hex[hex_cnt] = CONVERTDEC(p_str[str_cnt]) << 4U;
000024  0134              LSLS     r4,r6,#4
000026  54d4              STRB     r4,[r2,r3]
                  |L10.40|
;;;129    		++str_cnt;
000028  1c6d              ADDS     r5,r5,#1
;;;130    		if((p_str[str_cnt] - 48U) > 9U) p_hex[hex_cnt] += CONVERTHEX_ALPHA(p_str[str_cnt]);
00002a  5d44              LDRB     r4,[r0,r5]
00002c  f1a40630          SUB      r6,r4,#0x30
000030  2e09              CMP      r6,#9
000032  d909              BLS      |L10.72|
000034  5cd7              LDRB     r7,[r2,r3]
000036  3e11              SUBS     r6,r6,#0x11
000038  2e05              CMP      r6,#5
00003a  d801              BHI      |L10.64|
00003c  3c37              SUBS     r4,r4,#0x37
00003e  e000              B        |L10.66|
                  |L10.64|
000040  3c57              SUBS     r4,r4,#0x57
                  |L10.66|
000042  443c              ADD      r4,r4,r7
000044  54d4              STRB     r4,[r2,r3]
000046  e003              B        |L10.80|
                  |L10.72|
;;;131    		else p_hex[hex_cnt] += CONVERTDEC(p_str[str_cnt]);
000048  5cd6              LDRB     r6,[r2,r3]
00004a  4434              ADD      r4,r4,r6
00004c  3c30              SUBS     r4,r4,#0x30
00004e  54d4              STRB     r4,[r2,r3]
                  |L10.80|
;;;132    		++str_cnt;
000050  1c6d              ADDS     r5,r5,#1
;;;133    		++hex_cnt;
000052  1c5b              ADDS     r3,r3,#1
;;;134    		--lenght;
000054  1e49              SUBS     r1,r1,#1
000056  b289              UXTH     r1,r1
                  |L10.88|
000058  2900              CMP      r1,#0                 ;125
00005a  d1d5              BNE      |L10.8|
;;;135    	}
;;;136    }
00005c  bdf0              POP      {r4-r7,pc}
;;;137    
                          ENDP


                          AREA ||i.Str2Int||, CODE, READONLY, ALIGN=1

                  Str2Int PROC
;;;161    
;;;162    uint32_t Str2Int(uint8_t *p_inputstr, uint32_t *p_intnum)
000000  b5f0              PUSH     {r4-r7,lr}
;;;163    {
000002  4605              MOV      r5,r0
;;;164      uint32_t i = 0U, res = 0U;
000004  2400              MOVS     r4,#0
000006  2000              MOVS     r0,#0
;;;165      uint32_t val = 0U;
000008  2200              MOVS     r2,#0
;;;166    
;;;167      if ((p_inputstr[0] == '0') && ((p_inputstr[1] == 'x') || (p_inputstr[1] == 'X')))
00000a  782b              LDRB     r3,[r5,#0]
00000c  2b30              CMP      r3,#0x30
00000e  d150              BNE      |L11.178|
000010  786b              LDRB     r3,[r5,#1]
000012  2b78              CMP      r3,#0x78
000014  d001              BEQ      |L11.26|
000016  2b58              CMP      r3,#0x58
000018  d14b              BNE      |L11.178|
                  |L11.26|
;;;168      {
;;;169        i = 2U;
00001a  2402              MOVS     r4,#2
;;;170        while ((i < 11U) && (p_inputstr[i] != '\0'))
00001c  e018              B        |L11.80|
                  |L11.30|
;;;171        {
;;;172          if (ISVALIDHEX(p_inputstr[i]))
00001e  f1a30641          SUB      r6,r3,#0x41
000022  4637              MOV      r7,r6
000024  2e05              CMP      r6,#5
000026  d905              BLS      |L11.52|
000028  3e20              SUBS     r6,r6,#0x20
00002a  2e05              CMP      r6,#5
00002c  d902              BLS      |L11.52|
00002e  3631              ADDS     r6,r6,#0x31
000030  2e09              CMP      r6,#9
000032  d818              BHI      |L11.102|
                  |L11.52|
;;;173          {
;;;174            val = (val << 4U) + CONVERTHEX(p_inputstr[i]);
000034  f1a30630          SUB      r6,r3,#0x30
000038  2e09              CMP      r6,#9
00003a  d801              BHI      |L11.64|
00003c  4633              MOV      r3,r6
00003e  e004              B        |L11.74|
                  |L11.64|
000040  2f05              CMP      r7,#5
000042  d801              BHI      |L11.72|
000044  3b37              SUBS     r3,r3,#0x37
000046  e000              B        |L11.74|
                  |L11.72|
000048  3b57              SUBS     r3,r3,#0x57
                  |L11.74|
00004a  eb031202          ADD      r2,r3,r2,LSL #4
;;;175          }
;;;176          else
;;;177          {
;;;178            /* Return 0, Invalid input */
;;;179            res = 0U;
;;;180            break;
;;;181          }
;;;182          i++;
00004e  1c64              ADDS     r4,r4,#1
                  |L11.80|
000050  2c0b              CMP      r4,#0xb               ;170
000052  d202              BCS      |L11.90|
000054  5d2b              LDRB     r3,[r5,r4]            ;170
000056  2b00              CMP      r3,#0                 ;170
000058  d1e1              BNE      |L11.30|
                  |L11.90|
;;;183        }
;;;184    
;;;185        /* valid result */
;;;186        if (p_inputstr[i] == '\0')
00005a  5d2b              LDRB     r3,[r5,r4]
00005c  2b00              CMP      r3,#0                 ;180
00005e  d101              BNE      |L11.100|
;;;187        {
;;;188          *p_intnum = val;
000060  600a              STR      r2,[r1,#0]
;;;189          res = 1U;
000062  2001              MOVS     r0,#1
                  |L11.100|
;;;190        }
;;;191      }
;;;192      else /* max 10-digit decimal input */
;;;193      {
;;;194        while ((i < 11U) && (res != 1U))
;;;195        {
;;;196          if (p_inputstr[i] == '\0')
;;;197          {
;;;198            *p_intnum = val;
;;;199            /* return 1 */
;;;200            res = 1U;
;;;201          }
;;;202          else if (((p_inputstr[i] == 'k') || (p_inputstr[i] == 'K')) && (i > 0U))
;;;203          {
;;;204            val = val << 10U;
;;;205            *p_intnum = val;
;;;206            res = 1U;
;;;207          }
;;;208          else if (((p_inputstr[i] == 'm') || (p_inputstr[i] == 'M')) && (i > 0U))
;;;209          {
;;;210            val = val << 20;
;;;211            *p_intnum = val;
;;;212            res = 1U;
;;;213          }
;;;214          else if (ISVALIDDEC(p_inputstr[i]))
;;;215          {
;;;216            val = val * 10U + CONVERTDEC(p_inputstr[i]);
;;;217          }
;;;218          else
;;;219          {
;;;220            /* return 0, Invalid input */
;;;221            res = 0U;
;;;222            break;
;;;223          }
;;;224          i++;
;;;225        }
;;;226      }
;;;227    
;;;228      return res;
;;;229    }
000064  bdf0              POP      {r4-r7,pc}
                  |L11.102|
000066  2000              MOVS     r0,#0                 ;179
000068  e7f7              B        |L11.90|
                  |L11.106|
00006a  5d2b              LDRB     r3,[r5,r4]            ;196
00006c  b123              CBZ      r3,|L11.120|
00006e  2b6b              CMP      r3,#0x6b              ;202
000070  d005              BEQ      |L11.126|
000072  2b4b              CMP      r3,#0x4b              ;202
000074  d003              BEQ      |L11.126|
000076  e007              B        |L11.136|
                  |L11.120|
000078  600a              STR      r2,[r1,#0]            ;198
00007a  2001              MOVS     r0,#1                 ;200
00007c  e018              B        |L11.176|
                  |L11.126|
00007e  b11c              CBZ      r4,|L11.136|
000080  0292              LSLS     r2,r2,#10             ;204
000082  600a              STR      r2,[r1,#0]            ;205
000084  2001              MOVS     r0,#1                 ;206
000086  e013              B        |L11.176|
                  |L11.136|
000088  2b6d              CMP      r3,#0x6d              ;208
00008a  d001              BEQ      |L11.144|
00008c  2b4d              CMP      r3,#0x4d              ;208
00008e  d104              BNE      |L11.154|
                  |L11.144|
000090  b11c              CBZ      r4,|L11.154|
000092  0512              LSLS     r2,r2,#20             ;210
000094  600a              STR      r2,[r1,#0]            ;211
000096  2001              MOVS     r0,#1                 ;212
000098  e00a              B        |L11.176|
                  |L11.154|
00009a  f1a30630          SUB      r6,r3,#0x30           ;214
00009e  2e09              CMP      r6,#9                 ;214
0000a0  d80c              BHI      |L11.188|
0000a2  eb020282          ADD      r2,r2,r2,LSL #2       ;216
0000a6  f06f062f          MVN      r6,#0x2f              ;216
0000aa  eb060242          ADD      r2,r6,r2,LSL #1       ;216
0000ae  441a              ADD      r2,r2,r3              ;216
                  |L11.176|
0000b0  1c64              ADDS     r4,r4,#1              ;224
                  |L11.178|
0000b2  2c0b              CMP      r4,#0xb               ;194
0000b4  d2d6              BCS      |L11.100|
0000b6  2801              CMP      r0,#1                 ;194
0000b8  d1d7              BNE      |L11.106|
0000ba  bdf0              POP      {r4-r7,pc}
                  |L11.188|
0000bc  2000              MOVS     r0,#0                 ;221
0000be  bdf0              POP      {r4-r7,pc}
;;;230    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Src\\common.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_common_c_Bcd2Dec____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_common_c_Bcd2Dec____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_common_c_Bcd2Dec____REVSH|
#line 456
|__asm___8_common_c_Bcd2Dec____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_common_c_Bcd2Dec____RRX|
#line 643
|__asm___8_common_c_Bcd2Dec____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
