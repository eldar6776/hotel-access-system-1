; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_rtc.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_rtc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_rtc.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rtc.c]
                          THUMB

                          AREA ||i.HAL_RTC_AlarmAEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTC_AlarmAEventCallback PROC
;;;1208     */
;;;1209   __WEAK void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1210   {
;;;1211     /* Prevent unused argument(s) compilation warning */
;;;1212     UNUSED(hrtc);
;;;1213     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1214               the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;1215      */
;;;1216   }
;;;1217   
                          ENDP


                          AREA ||i.HAL_RTC_AlarmIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTC_AlarmIRQHandler PROC
;;;1180     */
;;;1181   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
000000  b510              PUSH     {r4,lr}
;;;1182   {  
000002  4604              MOV      r4,r0
;;;1183     if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA))
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  0789              LSLS     r1,r1,#30
00000a  d509              BPL      |L2.32|
;;;1184     {
;;;1185       /* Get the status of the Interrupt */
;;;1186       if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != (uint32_t)RESET)
00000c  6840              LDR      r0,[r0,#4]
00000e  0780              LSLS     r0,r0,#30
000010  d506              BPL      |L2.32|
;;;1187       {
;;;1188         /* AlarmA callback */ 
;;;1189         HAL_RTC_AlarmAEventCallback(hrtc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
;;;1190         
;;;1191         /* Clear the Alarm interrupt pending bit */
;;;1192         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
000018  6821              LDR      r1,[r4,#0]
00001a  f06f0002          MVN      r0,#2
00001e  6048              STR      r0,[r1,#4]
                  |L2.32|
;;;1193       }
;;;1194     }
;;;1195     
;;;1196     /* Clear the EXTI's line Flag for RTC Alarm */
;;;1197     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000020  4903              LDR      r1,|L2.48|
000022  f44f3000          MOV      r0,#0x20000
000026  6008              STR      r0,[r1,#0]
;;;1198     
;;;1199     /* Change RTC state */
;;;1200     hrtc->State = HAL_RTC_STATE_READY; 
000028  2001              MOVS     r0,#1
00002a  7460              STRB     r0,[r4,#0x11]
;;;1201   }
00002c  bd10              POP      {r4,pc}
;;;1202   
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40010414

                          AREA ||i.HAL_RTC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DeInit PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359      /* Check input parameters */
;;;360      if(hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d00b              BEQ      |L3.32|
;;;361      {
;;;362         return HAL_ERROR;
;;;363      }
;;;364      
;;;365      /* Check the parameters */
;;;366      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;367    
;;;368      /* Set RTC state */
;;;369      hrtc->State = HAL_RTC_STATE_BUSY; 
000008  2002              MOVS     r0,#2
00000a  7460              STRB     r0,[r4,#0x11]
;;;370      
;;;371      /* Set Initialization mode */
;;;372      if(RTC_EnterInitMode(hrtc) != HAL_OK)
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RTC_EnterInitMode
;;;373      {
;;;374        /* Set RTC state */
;;;375        hrtc->State = HAL_RTC_STATE_ERROR;
000012  2604              MOVS     r6,#4
000014  2500              MOVS     r5,#0
000016  b128              CBZ      r0,|L3.36|
000018  7466              STRB     r6,[r4,#0x11]
;;;376        
;;;377        /* Release Lock */
;;;378        __HAL_UNLOCK(hrtc);
00001a  7425              STRB     r5,[r4,#0x10]
;;;379    
;;;380        return HAL_ERROR;
00001c  2001              MOVS     r0,#1
;;;381      }  
;;;382      else
;;;383      {
;;;384        CLEAR_REG(hrtc->Instance->CNTL);
;;;385        CLEAR_REG(hrtc->Instance->CNTH);
;;;386        WRITE_REG(hrtc->Instance->PRLL, 0x00008000U);
;;;387        CLEAR_REG(hrtc->Instance->PRLH);
;;;388    
;;;389        /* Reset All CRH/CRL bits */
;;;390        CLEAR_REG(hrtc->Instance->CRH);
;;;391        CLEAR_REG(hrtc->Instance->CRL);
;;;392        
;;;393        if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;394        {       
;;;395          hrtc->State = HAL_RTC_STATE_ERROR;
;;;396          
;;;397          /* Process Unlocked */ 
;;;398          __HAL_UNLOCK(hrtc);
;;;399          
;;;400          return HAL_ERROR;
;;;401        }
;;;402      }
;;;403    
;;;404      /* Wait for synchro*/
;;;405      HAL_RTC_WaitForSynchro(hrtc);
;;;406    
;;;407      /* Clear RSF flag */
;;;408      CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
;;;409        
;;;410      /* De-Initialize RTC MSP */
;;;411      HAL_RTC_MspDeInit(hrtc);
;;;412    
;;;413      hrtc->State = HAL_RTC_STATE_RESET; 
;;;414      
;;;415      /* Release Lock */
;;;416      __HAL_UNLOCK(hrtc);
;;;417    
;;;418      return HAL_OK;
;;;419    }
00001e  bd70              POP      {r4-r6,pc}
                  |L3.32|
000020  2001              MOVS     r0,#1                 ;362
000022  bd70              POP      {r4-r6,pc}
                  |L3.36|
000024  6820              LDR      r0,[r4,#0]            ;384
000026  61c5              STR      r5,[r0,#0x1c]         ;384
000028  6820              LDR      r0,[r4,#0]            ;385
00002a  6185              STR      r5,[r0,#0x18]         ;385
00002c  6821              LDR      r1,[r4,#0]            ;386
00002e  f44f4000          MOV      r0,#0x8000            ;386
000032  60c8              STR      r0,[r1,#0xc]          ;386
000034  6820              LDR      r0,[r4,#0]            ;387
000036  6085              STR      r5,[r0,#8]            ;387
000038  6820              LDR      r0,[r4,#0]            ;390
00003a  6005              STR      r5,[r0,#0]            ;390
00003c  6820              LDR      r0,[r4,#0]            ;391
00003e  6045              STR      r5,[r0,#4]            ;391
000040  4620              MOV      r0,r4                 ;393
000042  f7fffffe          BL       RTC_ExitInitMode
000046  b118              CBZ      r0,|L3.80|
000048  7466              STRB     r6,[r4,#0x11]         ;395
00004a  7425              STRB     r5,[r4,#0x10]         ;398
00004c  2001              MOVS     r0,#1                 ;400
00004e  bd70              POP      {r4-r6,pc}
                  |L3.80|
000050  4620              MOV      r0,r4                 ;405
000052  f7fffffe          BL       HAL_RTC_WaitForSynchro
000056  6820              LDR      r0,[r4,#0]            ;408
000058  6841              LDR      r1,[r0,#4]            ;408
00005a  f0210108          BIC      r1,r1,#8              ;408
00005e  6041              STR      r1,[r0,#4]            ;408
000060  4620              MOV      r0,r4                 ;411
000062  f7fffffe          BL       HAL_RTC_MspDeInit
000066  7465              STRB     r5,[r4,#0x11]         ;413
000068  7425              STRB     r5,[r4,#0x10]         ;416
00006a  2000              MOVS     r0,#0                 ;418
00006c  bd70              POP      {r4-r6,pc}
;;;420    
                          ENDP


                          AREA ||i.HAL_RTC_DeactivateAlarm||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DeactivateAlarm PROC
;;;1110     */
;;;1111   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1112   {
000004  4604              MOV      r4,r0
;;;1113     /* Prevent unused argument(s) compilation warning */
;;;1114     UNUSED(Alarm);
;;;1115   
;;;1116     /* Check the parameters */
;;;1117     assert_param(IS_RTC_ALARM(Alarm));
;;;1118     
;;;1119     /* Check input parameters */
;;;1120     if(hrtc == NULL)
000006  2c00              CMP      r4,#0
000008  d016              BEQ      |L4.56|
;;;1121     {
;;;1122        return HAL_ERROR;
;;;1123     }
;;;1124     
;;;1125     /* Process Locked */ 
;;;1126     __HAL_LOCK(hrtc);
00000a  7c20              LDRB     r0,[r4,#0x10]
00000c  2801              CMP      r0,#1
00000e  d015              BEQ      |L4.60|
000010  2601              MOVS     r6,#1
000012  7426              STRB     r6,[r4,#0x10]
;;;1127     
;;;1128     hrtc->State = HAL_RTC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  7460              STRB     r0,[r4,#0x11]
;;;1129     
;;;1130     /* In case of interrupt mode is used, the interrupt source must disabled */ 
;;;1131     __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210102          BIC      r1,r1,#2
000020  6001              STR      r1,[r0,#0]
;;;1132     
;;;1133     /* Set Initialization mode */
;;;1134     if(RTC_EnterInitMode(hrtc) != HAL_OK)
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RTC_EnterInitMode
000028  2500              MOVS     r5,#0
;;;1135     {
;;;1136       /* Set RTC state */
;;;1137       hrtc->State = HAL_RTC_STATE_ERROR;
00002a  2704              MOVS     r7,#4
00002c  b140              CBZ      r0,|L4.64|
00002e  7467              STRB     r7,[r4,#0x11]
;;;1138       
;;;1139       /* Process Unlocked */ 
;;;1140       __HAL_UNLOCK(hrtc);
000030  7425              STRB     r5,[r4,#0x10]
;;;1141       
;;;1142       return HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L4.52|
;;;1143     } 
;;;1144     else
;;;1145     {
;;;1146       /* Clear flag alarm A */
;;;1147       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1148       
;;;1149       /* Set to default values ALRH & ALRL registers */
;;;1150       WRITE_REG(hrtc->Instance->ALRH, RTC_ALARM_RESETVALUE_REGISTER);
;;;1151       WRITE_REG(hrtc->Instance->ALRL, RTC_ALARM_RESETVALUE_REGISTER);
;;;1152   
;;;1153       /* RTC Alarm Interrupt Configuration: Disable EXTI configuration */
;;;1154       __HAL_RTC_ALARM_EXTI_DISABLE_IT();
;;;1155       
;;;1156       /* Wait for synchro */
;;;1157       if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;1158       {       
;;;1159         hrtc->State = HAL_RTC_STATE_ERROR;
;;;1160         
;;;1161         /* Process Unlocked */ 
;;;1162         __HAL_UNLOCK(hrtc);
;;;1163         
;;;1164         return HAL_ERROR;
;;;1165       }
;;;1166     }
;;;1167     hrtc->State = HAL_RTC_STATE_READY; 
;;;1168     
;;;1169     /* Process Unlocked */ 
;;;1170     __HAL_UNLOCK(hrtc);  
;;;1171     
;;;1172     return HAL_OK; 
;;;1173   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L4.56|
000038  2001              MOVS     r0,#1                 ;1122
00003a  e7fb              B        |L4.52|
                  |L4.60|
00003c  2002              MOVS     r0,#2                 ;1126
00003e  e7f9              B        |L4.52|
                  |L4.64|
000040  6821              LDR      r1,[r4,#0]            ;1147
000042  f06f0002          MVN      r0,#2                 ;1147
000046  6048              STR      r0,[r1,#4]            ;1147
000048  6821              LDR      r1,[r4,#0]            ;1150
00004a  0c00              LSRS     r0,r0,#16             ;1150
00004c  6208              STR      r0,[r1,#0x20]         ;1150
00004e  6821              LDR      r1,[r4,#0]            ;1151
000050  6248              STR      r0,[r1,#0x24]         ;1151
000052  4808              LDR      r0,|L4.116|
000054  6801              LDR      r1,[r0,#0]            ;1154
000056  f4213100          BIC      r1,r1,#0x20000        ;1154
00005a  6001              STR      r1,[r0,#0]            ;1154
00005c  4620              MOV      r0,r4                 ;1157
00005e  f7fffffe          BL       RTC_ExitInitMode
000062  b118              CBZ      r0,|L4.108|
000064  7467              STRB     r7,[r4,#0x11]         ;1159
000066  7425              STRB     r5,[r4,#0x10]         ;1162
000068  2001              MOVS     r0,#1                 ;1164
00006a  e7e3              B        |L4.52|
                  |L4.108|
00006c  7466              STRB     r6,[r4,#0x11]         ;1167
00006e  7425              STRB     r5,[r4,#0x10]         ;1170
000070  2000              MOVS     r0,#0                 ;1172
000072  e7df              B        |L4.52|
;;;1174   
                          ENDP

                  |L4.116|
                          DCD      0x40010400

                          AREA ||i.HAL_RTC_GetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetAlarm PROC
;;;1065     */
;;;1066   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;1067   {
000002  460c              MOV      r4,r1
000004  461d              MOV      r5,r3
;;;1068     uint32_t counter_alarm = 0U;
;;;1069   
;;;1070     /* Prevent unused argument(s) compilation warning */
;;;1071     UNUSED(Alarm);
;;;1072   
;;;1073     /* Check input parameters */
;;;1074     if((hrtc == NULL) || (sAlarm == NULL))
000006  2800              CMP      r0,#0
000008  d02c              BEQ      |L5.100|
00000a  b35c              CBZ      r4,|L5.100|
;;;1075     {
;;;1076       return HAL_ERROR;
;;;1077     }
;;;1078     
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_RTC_FORMAT(Format));
;;;1081     assert_param(IS_RTC_ALARM(Alarm));
;;;1082     
;;;1083     /* Read Alarm counter in RTC registers */
;;;1084     counter_alarm = RTC_ReadAlarmCounter(hrtc);
00000c  f7fffffe          BL       RTC_ReadAlarmCounter
;;;1085   
;;;1086     /* Fill the structure with the read parameters */
;;;1087     /* Set hours in a day range (between 0 to 24)*/
;;;1088     sAlarm->AlarmTime.Hours   = (uint32_t)((counter_alarm / 3600U) % 24U);
000010  f44f6161          MOV      r1,#0xe10
000014  fbb0f2f1          UDIV     r2,r0,r1
000018  2318              MOVS     r3,#0x18
00001a  fbb2f6f3          UDIV     r6,r2,r3
00001e  fb032216          MLS      r2,r3,r6,r2
000022  7022              STRB     r2,[r4,#0]
;;;1089     sAlarm->AlarmTime.Minutes = (uint32_t)((counter_alarm % 3600U) / 60U);
000024  fbb0f3f1          UDIV     r3,r0,r1
000028  fb010613          MLS      r6,r1,r3,r0
00002c  233c              MOVS     r3,#0x3c
00002e  fbb6f6f3          UDIV     r6,r6,r3
000032  7066              STRB     r6,[r4,#1]
;;;1090     sAlarm->AlarmTime.Seconds = (uint32_t)((counter_alarm % 3600U) % 60U);
000034  fbb0f6f1          UDIV     r6,r0,r1
000038  fb010016          MLS      r0,r1,r6,r0
00003c  fbb0f1f3          UDIV     r1,r0,r3
000040  fb030011          MLS      r0,r3,r1,r0
000044  70a0              STRB     r0,[r4,#2]
;;;1091     
;;;1092     if(Format != RTC_FORMAT_BIN)
000046  b15d              CBZ      r5,|L5.96|
;;;1093     {
;;;1094       sAlarm->AlarmTime.Hours   = RTC_ByteToBcd2(sAlarm->AlarmTime.Hours);
000048  4610              MOV      r0,r2
00004a  f7fffffe          BL       RTC_ByteToBcd2
00004e  7020              STRB     r0,[r4,#0]
;;;1095       sAlarm->AlarmTime.Minutes = RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes);
000050  7860              LDRB     r0,[r4,#1]
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  7060              STRB     r0,[r4,#1]
;;;1096       sAlarm->AlarmTime.Seconds = RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds);
000058  78a0              LDRB     r0,[r4,#2]
00005a  f7fffffe          BL       RTC_ByteToBcd2
00005e  70a0              STRB     r0,[r4,#2]
                  |L5.96|
;;;1097     }  
;;;1098     
;;;1099     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;1100   }
000062  bd70              POP      {r4-r6,pc}
                  |L5.100|
000064  2001              MOVS     r0,#1                 ;1076
000066  bd70              POP      {r4-r6,pc}
;;;1101   
                          ENDP


                          AREA ||i.HAL_RTC_GetDate||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetDate PROC
;;;803      */
;;;804    HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b5f8              PUSH     {r3-r7,lr}
;;;805    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;806      RTC_TimeTypeDef stime = {0U};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;807      
;;;808      /* Check input parameters */
;;;809      if((hrtc == NULL) || (sDate == NULL))
00000c  2d00              CMP      r5,#0
00000e  d008              BEQ      |L6.34|
000010  b13c              CBZ      r4,|L6.34|
;;;810      {
;;;811         return HAL_ERROR;
;;;812      }
;;;813      
;;;814      /* Check the parameters */
;;;815      assert_param(IS_RTC_FORMAT(Format));
;;;816      
;;;817      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;818      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000012  2200              MOVS     r2,#0
000014  4669              MOV      r1,sp
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       HAL_RTC_GetTime
00001c  b118              CBZ      r0,|L6.38|
;;;819      {
;;;820        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
;;;821      }
;;;822    
;;;823      /* Fill the structure fields with the read parameters */
;;;824      sDate->WeekDay  = hrtc->DateToUpdate.WeekDay;
;;;825      sDate->Year     = hrtc->DateToUpdate.Year;
;;;826      sDate->Month    = hrtc->DateToUpdate.Month;
;;;827      sDate->Date     = hrtc->DateToUpdate.Date;
;;;828    
;;;829      /* Check the input parameters format */
;;;830      if(Format != RTC_FORMAT_BIN)
;;;831      {    
;;;832        /* Convert the date structure parameters to BCD format */
;;;833        sDate->Year   = (uint8_t)RTC_ByteToBcd2(sDate->Year);
;;;834        sDate->Month  = (uint8_t)RTC_ByteToBcd2(sDate->Month);
;;;835        sDate->Date   = (uint8_t)RTC_ByteToBcd2(sDate->Date);  
;;;836      }
;;;837      return HAL_OK;
;;;838    }
000020  bdf8              POP      {r3-r7,pc}
                  |L6.34|
000022  2001              MOVS     r0,#1                 ;811
000024  bdf8              POP      {r3-r7,pc}
                  |L6.38|
000026  7b28              LDRB     r0,[r5,#0xc]          ;824
000028  7020              STRB     r0,[r4,#0]            ;824
00002a  7be8              LDRB     r0,[r5,#0xf]          ;825
00002c  70e0              STRB     r0,[r4,#3]            ;825
00002e  7b69              LDRB     r1,[r5,#0xd]          ;826
000030  7061              STRB     r1,[r4,#1]            ;826
000032  7ba9              LDRB     r1,[r5,#0xe]          ;827
000034  70a1              STRB     r1,[r4,#2]            ;827
000036  b156              CBZ      r6,|L6.78|
000038  f7fffffe          BL       RTC_ByteToBcd2
00003c  70e0              STRB     r0,[r4,#3]            ;833
00003e  7860              LDRB     r0,[r4,#1]            ;834
000040  f7fffffe          BL       RTC_ByteToBcd2
000044  7060              STRB     r0,[r4,#1]            ;834
000046  78a0              LDRB     r0,[r4,#2]            ;835
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  70a0              STRB     r0,[r4,#2]            ;835
                  |L6.78|
00004e  2000              MOVS     r0,#0                 ;837
000050  bdf8              POP      {r3-r7,pc}
;;;839    
                          ENDP


                          AREA ||i.HAL_RTC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetState PROC
;;;1279     */
;;;1280   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef* hrtc)
000000  7c40              LDRB     r0,[r0,#0x11]
;;;1281   {
;;;1282     return hrtc->State;
;;;1283   }
000002  4770              BX       lr
;;;1284   
                          ENDP


                          AREA ||i.HAL_RTC_GetTime||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetTime PROC
;;;578      */
;;;579    HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;580    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;581      uint32_t counter_time = 0U, counter_alarm = 0U, days_elapsed = 0U, hours = 0U;
;;;582      
;;;583      /* Check input parameters */
;;;584      if((hrtc == NULL) || (sTime == NULL))
00000a  2f00              CMP      r7,#0
00000c  d007              BEQ      |L8.30|
00000e  b134              CBZ      r4,|L8.30|
;;;585      {
;;;586         return HAL_ERROR;
;;;587      }
;;;588    
;;;589      /* Check the parameters */
;;;590      assert_param(IS_RTC_FORMAT(Format));
;;;591    
;;;592      /* Check if counter overflow occurred */
;;;593      if (__HAL_RTC_OVERFLOW_GET_FLAG(hrtc, RTC_FLAG_OW))
000010  6838              LDR      r0,[r7,#0]
000012  6840              LDR      r0,[r0,#4]
000014  0740              LSLS     r0,r0,#29
000016  d504              BPL      |L8.34|
;;;594      {
;;;595          return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L8.26|
;;;596      }
;;;597    
;;;598      /* Read the time counter*/
;;;599      counter_time = RTC_ReadTimeCounter(hrtc);
;;;600    
;;;601      /* Fill the structure fields with the read parameters */
;;;602      hours = counter_time / 3600U;
;;;603      sTime->Minutes  = (uint8_t)((counter_time % 3600U) / 60U);
;;;604      sTime->Seconds  = (uint8_t)((counter_time % 3600U) % 60U);
;;;605    
;;;606      if (hours >= 24U)
;;;607      {
;;;608        /* Get number of days elapsed from last calculation */
;;;609        days_elapsed = (hours / 24U);
;;;610    
;;;611        /* Set Hours in RTC_TimeTypeDef structure*/
;;;612        sTime->Hours = (hours % 24U);    
;;;613    
;;;614        /* Read Alarm counter in RTC registers */
;;;615        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;616    
;;;617        /* Calculate remaining time to reach alarm (only if set and not yet expired)*/
;;;618        if ((counter_alarm != RTC_ALARM_RESETVALUE) && (counter_alarm > counter_time))
;;;619        {
;;;620          counter_alarm -= counter_time;
;;;621        }
;;;622        else 
;;;623        {
;;;624          /* In case of counter_alarm < counter_time */
;;;625          /* Alarm expiration already occurred but alarm not deactivated */
;;;626          counter_alarm = RTC_ALARM_RESETVALUE;
;;;627        }
;;;628    
;;;629        /* Set updated time in decreasing counter by number of days elapsed */
;;;630        counter_time -= (days_elapsed * 24U * 3600U);
;;;631        
;;;632        /* Write time counter in RTC registers */
;;;633        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
;;;634        {
;;;635          return HAL_ERROR;
;;;636        }
;;;637    
;;;638        /* Set updated alarm to be set */
;;;639        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;640        {
;;;641          counter_alarm += counter_time;
;;;642          
;;;643          /* Write time counter in RTC registers */
;;;644          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;645          {
;;;646            return HAL_ERROR;
;;;647          }
;;;648        }
;;;649        else
;;;650        {
;;;651          /* Alarm already occurred. Set it to reset values to avoid unexpected expiration */
;;;652          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;653          {
;;;654            return HAL_ERROR;
;;;655          }
;;;656        }
;;;657        
;;;658        /* Update date */
;;;659        RTC_DateUpdate(hrtc, days_elapsed);
;;;660      }
;;;661      else 
;;;662      {
;;;663        sTime->Hours = hours;    
;;;664      }
;;;665    
;;;666      /* Check the input parameters format */
;;;667      if(Format != RTC_FORMAT_BIN)
;;;668      {
;;;669        /* Convert the time structure parameters to BCD format */
;;;670        sTime->Hours    = (uint8_t)RTC_ByteToBcd2(sTime->Hours);
;;;671        sTime->Minutes  = (uint8_t)RTC_ByteToBcd2(sTime->Minutes);
;;;672        sTime->Seconds  = (uint8_t)RTC_ByteToBcd2(sTime->Seconds);  
;;;673      }
;;;674      
;;;675      return HAL_OK;
;;;676    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L8.30|
00001e  2001              MOVS     r0,#1                 ;586
000020  e7fb              B        |L8.26|
                  |L8.34|
000022  4638              MOV      r0,r7                 ;599
000024  f7fffffe          BL       RTC_ReadTimeCounter
000028  4605              MOV      r5,r0                 ;599
00002a  f44f6061          MOV      r0,#0xe10             ;602
00002e  fbb5f1f0          UDIV     r1,r5,r0              ;602
000032  fbb5f2f0          UDIV     r2,r5,r0              ;603
000036  fb005312          MLS      r3,r0,r2,r5           ;603
00003a  223c              MOVS     r2,#0x3c              ;603
00003c  fbb3f3f2          UDIV     r3,r3,r2              ;603
000040  7063              STRB     r3,[r4,#1]            ;603
000042  fbb5f3f0          UDIV     r3,r5,r0              ;604
000046  fb005013          MLS      r0,r0,r3,r5           ;604
00004a  fbb0f3f2          UDIV     r3,r0,r2              ;604
00004e  fb020013          MLS      r0,r2,r3,r0           ;604
000052  70a0              STRB     r0,[r4,#2]            ;604
000054  2918              CMP      r1,#0x18              ;606
000056  d336              BCC      |L8.198|
000058  2018              MOVS     r0,#0x18              ;609
00005a  fbb1f9f0          UDIV     r9,r1,r0              ;609
00005e  fbb1f2f0          UDIV     r2,r1,r0              ;612
000062  fb001012          MLS      r0,r0,r2,r1           ;612
000066  7020              STRB     r0,[r4,#0]            ;612
000068  4638              MOV      r0,r7                 ;615
00006a  f7fffffe          BL       RTC_ReadAlarmCounter
00006e  1c41              ADDS     r1,r0,#1              ;618
000070  d003              BEQ      |L8.122|
000072  42a8              CMP      r0,r5                 ;618
000074  d901              BLS      |L8.122|
000076  1b46              SUBS     r6,r0,r5              ;620
000078  e001              B        |L8.126|
                  |L8.122|
00007a  f04f36ff          MOV      r6,#0xffffffff        ;626
                  |L8.126|
00007e  eba91009          SUB      r0,r9,r9,LSL #4       ;630
000082  eb000040          ADD      r0,r0,r0,LSL #1       ;630
000086  ebc01000          RSB      r0,r0,r0,LSL #4       ;630
00008a  eb0515c0          ADD      r5,r5,r0,LSL #7       ;630
00008e  4629              MOV      r1,r5                 ;633
000090  4638              MOV      r0,r7                 ;633
000092  f7fffffe          BL       RTC_WriteTimeCounter
000096  b108              CBZ      r0,|L8.156|
000098  2001              MOVS     r0,#1                 ;635
00009a  e7be              B        |L8.26|
                  |L8.156|
00009c  1c70              ADDS     r0,r6,#1              ;639
00009e  d006              BEQ      |L8.174|
0000a0  1971              ADDS     r1,r6,r5              ;641
0000a2  4638              MOV      r0,r7                 ;644
0000a4  f7fffffe          BL       RTC_WriteAlarmCounter
0000a8  b140              CBZ      r0,|L8.188|
0000aa  2001              MOVS     r0,#1                 ;646
0000ac  e7b5              B        |L8.26|
                  |L8.174|
0000ae  4631              MOV      r1,r6                 ;652
0000b0  4638              MOV      r0,r7                 ;652
0000b2  f7fffffe          BL       RTC_WriteAlarmCounter
0000b6  b108              CBZ      r0,|L8.188|
0000b8  2001              MOVS     r0,#1                 ;654
0000ba  e7ae              B        |L8.26|
                  |L8.188|
0000bc  4649              MOV      r1,r9                 ;659
0000be  4638              MOV      r0,r7                 ;659
0000c0  f7fffffe          BL       RTC_DateUpdate
0000c4  e000              B        |L8.200|
                  |L8.198|
0000c6  7021              STRB     r1,[r4,#0]            ;663
                  |L8.200|
0000c8  f1b80f00          CMP      r8,#0                 ;667
0000cc  d00b              BEQ      |L8.230|
0000ce  7820              LDRB     r0,[r4,#0]            ;670
0000d0  f7fffffe          BL       RTC_ByteToBcd2
0000d4  7020              STRB     r0,[r4,#0]            ;670
0000d6  7860              LDRB     r0,[r4,#1]            ;671
0000d8  f7fffffe          BL       RTC_ByteToBcd2
0000dc  7060              STRB     r0,[r4,#1]            ;671
0000de  78a0              LDRB     r0,[r4,#2]            ;672
0000e0  f7fffffe          BL       RTC_ByteToBcd2
0000e4  70a0              STRB     r0,[r4,#2]            ;672
                  |L8.230|
0000e6  2000              MOVS     r0,#0                 ;675
0000e8  e797              B        |L8.26|
;;;677    
                          ENDP


                          AREA ||i.HAL_RTC_Init||, CODE, READONLY, ALIGN=2

                  HAL_RTC_Init PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246      uint32_t prescaler = 0U;
;;;247      /* Check input parameters */
;;;248      if(hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L9.16|
;;;249      {
;;;250         return HAL_ERROR;
;;;251      }
;;;252      
;;;253      /* Check the parameters */
;;;254      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;255      assert_param(IS_RTC_CALIB_OUTPUT(hrtc->Init.OutPut));
;;;256      assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;257        
;;;258      if(hrtc->State == HAL_RTC_STATE_RESET)
000008  7c60              LDRB     r0,[r4,#0x11]
00000a  2600              MOVS     r6,#0
00000c  b110              CBZ      r0,|L9.20|
00000e  e005              B        |L9.28|
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;250
;;;259      {
;;;260        /* Allocate lock resource and initialize it */
;;;261        hrtc->Lock = HAL_UNLOCKED;
;;;262        
;;;263        /* Initialize RTC MSP */
;;;264        HAL_RTC_MspInit(hrtc);
;;;265      }
;;;266      
;;;267      /* Set RTC state */  
;;;268      hrtc->State = HAL_RTC_STATE_BUSY;  
;;;269           
;;;270      /* Waiting for synchro */
;;;271      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;272      {
;;;273        /* Set RTC state */
;;;274        hrtc->State = HAL_RTC_STATE_ERROR;
;;;275        
;;;276        return HAL_ERROR;
;;;277      } 
;;;278    
;;;279      /* Set Initialization mode */
;;;280      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;281      {
;;;282        /* Set RTC state */
;;;283        hrtc->State = HAL_RTC_STATE_ERROR;
;;;284        
;;;285        return HAL_ERROR;
;;;286      } 
;;;287      else
;;;288      { 
;;;289        /* Clear Flags Bits */
;;;290        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_OW | RTC_FLAG_ALRAF | RTC_FLAG_SEC));
;;;291        
;;;292        if(hrtc->Init.OutPut != RTC_OUTPUTSOURCE_NONE)
;;;293        {
;;;294          /* Disable the selected Tamper pin */
;;;295          CLEAR_BIT(BKP->CR, BKP_CR_TPE);
;;;296        }
;;;297        
;;;298        /* Set the signal which will be routed to RTC Tamper pin*/
;;;299        MODIFY_REG(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE | BKP_RTCCR_ASOS), hrtc->Init.OutPut);
;;;300    
;;;301        if (hrtc->Init.AsynchPrediv != RTC_AUTO_1_SECOND)
;;;302        {
;;;303          /* RTC Prescaler provided directly by end-user*/
;;;304          prescaler = hrtc->Init.AsynchPrediv;
;;;305        }
;;;306        else
;;;307        {
;;;308          /* RTC Prescaler will be automatically calculated to get 1 second timebase */
;;;309          /* Get the RTCCLK frequency */
;;;310          prescaler = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_RTC);
;;;311    
;;;312          /* Check that RTC clock is enabled*/
;;;313          if (prescaler == 0U)
;;;314          {
;;;315            /* Should not happen. Frequency is not available*/
;;;316            hrtc->State = HAL_RTC_STATE_ERROR;
;;;317            return HAL_ERROR;
;;;318          }
;;;319          else
;;;320          {
;;;321            /* RTC period = RTCCLK/(RTC_PR + 1) */
;;;322            prescaler = prescaler - 1U;
;;;323          }
;;;324        }
;;;325        
;;;326        /* Configure the RTC_PRLH / RTC_PRLL */
;;;327        MODIFY_REG(hrtc->Instance->PRLH, RTC_PRLH_PRL, (prescaler >> 16U));
;;;328        MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
;;;329          
;;;330        /* Wait for synchro */
;;;331        if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;332        {       
;;;333          hrtc->State = HAL_RTC_STATE_ERROR;
;;;334          
;;;335          return HAL_ERROR;
;;;336        }
;;;337        
;;;338        /* Initialize date to 1st of January 2000 */
;;;339        hrtc->DateToUpdate.Year = 0x00U;
;;;340        hrtc->DateToUpdate.Month = RTC_MONTH_JANUARY;
;;;341        hrtc->DateToUpdate.Date = 0x01U;
;;;342    
;;;343        /* Set RTC state */
;;;344        hrtc->State = HAL_RTC_STATE_READY;
;;;345        
;;;346        return HAL_OK;
;;;347      }
;;;348    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  7426              STRB     r6,[r4,#0x10]         ;261
000016  4620              MOV      r0,r4                 ;264
000018  f7fffffe          BL       HAL_RTC_MspInit
                  |L9.28|
00001c  2002              MOVS     r0,#2                 ;268
00001e  7460              STRB     r0,[r4,#0x11]         ;268
000020  4620              MOV      r0,r4                 ;271
000022  f7fffffe          BL       HAL_RTC_WaitForSynchro
000026  2504              MOVS     r5,#4                 ;274
000028  b110              CBZ      r0,|L9.48|
00002a  7465              STRB     r5,[r4,#0x11]         ;274
00002c  2001              MOVS     r0,#1                 ;276
00002e  bd70              POP      {r4-r6,pc}
                  |L9.48|
000030  4620              MOV      r0,r4                 ;280
000032  f7fffffe          BL       RTC_EnterInitMode
000036  b110              CBZ      r0,|L9.62|
000038  7465              STRB     r5,[r4,#0x11]         ;283
00003a  2001              MOVS     r0,#1                 ;285
00003c  bd70              POP      {r4-r6,pc}
                  |L9.62|
00003e  6820              LDR      r0,[r4,#0]            ;290
000040  6841              LDR      r1,[r0,#4]            ;290
000042  f0210107          BIC      r1,r1,#7              ;290
000046  6041              STR      r1,[r0,#4]            ;290
000048  68a0              LDR      r0,[r4,#8]            ;292
00004a  b120              CBZ      r0,|L9.86|
00004c  4818              LDR      r0,|L9.176|
00004e  6801              LDR      r1,[r0,#0]            ;295
000050  f0210101          BIC      r1,r1,#1              ;295
000054  6001              STR      r1,[r0,#0]            ;295
                  |L9.86|
000056  4816              LDR      r0,|L9.176|
000058  1f00              SUBS     r0,r0,#4              ;299
00005a  6801              LDR      r1,[r0,#0]            ;299
00005c  68a2              LDR      r2,[r4,#8]            ;299
00005e  f4217160          BIC      r1,r1,#0x380          ;299
000062  4311              ORRS     r1,r1,r2              ;299
000064  6001              STR      r1,[r0,#0]            ;299
000066  6860              LDR      r0,[r4,#4]            ;301
000068  1c41              ADDS     r1,r0,#1              ;301
00006a  d104              BNE      |L9.118|
00006c  2001              MOVS     r0,#1                 ;310
00006e  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000072  b198              CBZ      r0,|L9.156|
000074  1e40              SUBS     r0,r0,#1              ;322
                  |L9.118|
000076  6821              LDR      r1,[r4,#0]            ;327
000078  688a              LDR      r2,[r1,#8]            ;327
00007a  f022020f          BIC      r2,r2,#0xf            ;327
00007e  ea424210          ORR      r2,r2,r0,LSR #16      ;327
000082  608a              STR      r2,[r1,#8]            ;327
000084  6821              LDR      r1,[r4,#0]            ;328
000086  68ca              LDR      r2,[r1,#0xc]          ;328
000088  f360020f          BFI      r2,r0,#0,#16          ;328
00008c  60ca              STR      r2,[r1,#0xc]          ;328
00008e  4620              MOV      r0,r4                 ;331
000090  f7fffffe          BL       RTC_ExitInitMode
000094  b128              CBZ      r0,|L9.162|
000096  7465              STRB     r5,[r4,#0x11]         ;333
000098  2001              MOVS     r0,#1                 ;335
00009a  bd70              POP      {r4-r6,pc}
                  |L9.156|
00009c  7465              STRB     r5,[r4,#0x11]         ;316
00009e  2001              MOVS     r0,#1                 ;317
0000a0  bd70              POP      {r4-r6,pc}
                  |L9.162|
0000a2  73e6              STRB     r6,[r4,#0xf]          ;339
0000a4  2001              MOVS     r0,#1                 ;340
0000a6  7360              STRB     r0,[r4,#0xd]          ;340
0000a8  73a0              STRB     r0,[r4,#0xe]          ;341
0000aa  7460              STRB     r0,[r4,#0x11]         ;344
0000ac  2000              MOVS     r0,#0                 ;346
0000ae  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

                  |L9.176|
                          DCD      0x40006c30

                          AREA ||i.HAL_RTC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspDeInit PROC
;;;441      */
;;;442    __WEAK void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
000000  4770              BX       lr
;;;443    {
;;;444      /* Prevent unused argument(s) compilation warning */
;;;445      UNUSED(hrtc);
;;;446      /* NOTE : This function Should not be modified, when the callback is needed,
;;;447                the HAL_RTC_MspDeInit could be implemented in the user file
;;;448       */ 
;;;449    }
;;;450    
                          ENDP


                          AREA ||i.HAL_RTC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspInit PROC
;;;426      */
;;;427    __WEAK void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
000000  4770              BX       lr
;;;428    {
;;;429      /* Prevent unused argument(s) compilation warning */
;;;430      UNUSED(hrtc);
;;;431      /* NOTE : This function Should not be modified, when the callback is needed,
;;;432                the HAL_RTC_MspInit could be implemented in the user file
;;;433       */ 
;;;434    }
;;;435    
                          ENDP


                          AREA ||i.HAL_RTC_PollForAlarmAEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTC_PollForAlarmAEvent PROC
;;;1224     */
;;;1225   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1226   {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1227     uint32_t tickstart = HAL_GetTick();   
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;1228     
;;;1229     /* Check input parameters */
;;;1230     if(hrtc == NULL)
00000c  b964              CBNZ     r4,|L12.40|
;;;1231     {
;;;1232        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
;;;1233     }
;;;1234     
;;;1235     while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
;;;1236     {
;;;1237       if(Timeout != HAL_MAX_DELAY)
;;;1238       {
;;;1239         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1240         {
;;;1241           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1242           return HAL_TIMEOUT;
;;;1243         }
;;;1244       }
;;;1245     }
;;;1246     
;;;1247     /* Clear the Alarm interrupt pending bit */
;;;1248     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1249     
;;;1250     /* Change RTC state */
;;;1251     hrtc->State = HAL_RTC_STATE_READY; 
;;;1252     
;;;1253     return HAL_OK;  
;;;1254   }
000010  bd70              POP      {r4-r6,pc}
                  |L12.18|
000012  1c68              ADDS     r0,r5,#1              ;1237
000014  d008              BEQ      |L12.40|
000016  b125              CBZ      r5,|L12.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6              ;1239
00001e  42a8              CMP      r0,r5                 ;1239
000020  d902              BLS      |L12.40|
                  |L12.34|
000022  2003              MOVS     r0,#3                 ;1241
000024  7460              STRB     r0,[r4,#0x11]         ;1241
000026  bd70              POP      {r4-r6,pc}
                  |L12.40|
000028  6820              LDR      r0,[r4,#0]            ;1235
00002a  6840              LDR      r0,[r0,#4]            ;1235
00002c  0780              LSLS     r0,r0,#30             ;1235
00002e  d5f0              BPL      |L12.18|
000030  6821              LDR      r1,[r4,#0]            ;1248
000032  f06f0002          MVN      r0,#2                 ;1248
000036  6048              STR      r0,[r1,#4]            ;1248
000038  2001              MOVS     r0,#1                 ;1251
00003a  7460              STRB     r0,[r4,#0x11]         ;1251
00003c  2000              MOVS     r0,#0                 ;1253
00003e  bd70              POP      {r4-r6,pc}
;;;1255   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm PROC
;;;868      */
;;;869    HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;870    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;871      uint32_t counter_alarm = 0U, counter_time;
;;;872      RTC_TimeTypeDef stime = {0U};
00000a  2600              MOVS     r6,#0
00000c  9600              STR      r6,[sp,#0]
;;;873      
;;;874      /* Check input parameters */
;;;875      if((hrtc == NULL) || (sAlarm == NULL))
00000e  2c00              CMP      r4,#0
000010  d010              BEQ      |L13.52|
000012  b17d              CBZ      r5,|L13.52|
;;;876      {
;;;877         return HAL_ERROR;
;;;878      }
;;;879      
;;;880      /* Check the parameters */
;;;881      assert_param(IS_RTC_FORMAT(Format));
;;;882      assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;883    
;;;884      /* Process Locked */ 
;;;885      __HAL_LOCK(hrtc);
000014  7c20              LDRB     r0,[r4,#0x10]
000016  2801              CMP      r0,#1
000018  d00e              BEQ      |L13.56|
00001a  2701              MOVS     r7,#1
00001c  7427              STRB     r7,[r4,#0x10]
;;;886      
;;;887      hrtc->State = HAL_RTC_STATE_BUSY;
00001e  2002              MOVS     r0,#2
000020  7460              STRB     r0,[r4,#0x11]
;;;888      
;;;889      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;890      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000022  2200              MOVS     r2,#0
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_RTC_GetTime
00002c  b130              CBZ      r0,|L13.60|
;;;891      {
;;;892        return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L13.48|
;;;893      }
;;;894    
;;;895      /* Convert time in seconds */
;;;896      counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600U) + \
;;;897                          ((uint32_t)stime.Minutes * 60U) + \
;;;898                          ((uint32_t)stime.Seconds));  
;;;899    
;;;900      if(Format == RTC_FORMAT_BIN)
;;;901      {
;;;902        assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;903        assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;904        assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;905        
;;;906        counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600U) + \
;;;907                            ((uint32_t)sAlarm->AlarmTime.Minutes * 60U) + \
;;;908                            ((uint32_t)sAlarm->AlarmTime.Seconds));  
;;;909      }
;;;910      else
;;;911      {
;;;912        assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;913        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;914        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;915        
;;;916        counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600U) + \
;;;917                  ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60U) + \
;;;918                  ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));   
;;;919      }
;;;920    
;;;921      /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;922      if (counter_alarm < counter_time)
;;;923      {
;;;924        /* Add 1 day to alarm counter*/
;;;925        counter_alarm += (uint32_t)(24U * 3600U);
;;;926      }
;;;927    
;;;928      /* Write Alarm counter in RTC registers */
;;;929      if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;930      {
;;;931        /* Set RTC state */
;;;932        hrtc->State = HAL_RTC_STATE_ERROR;
;;;933        
;;;934        /* Process Unlocked */ 
;;;935        __HAL_UNLOCK(hrtc);
;;;936        
;;;937        return HAL_ERROR;
;;;938      }
;;;939      else
;;;940      {
;;;941        hrtc->State = HAL_RTC_STATE_READY;
;;;942      
;;;943       __HAL_UNLOCK(hrtc); 
;;;944         
;;;945       return HAL_OK;
;;;946      }
;;;947    }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L13.52|
000034  2001              MOVS     r0,#1                 ;877
000036  e7fb              B        |L13.48|
                  |L13.56|
000038  2002              MOVS     r0,#2                 ;885
00003a  e7f9              B        |L13.48|
                  |L13.60|
00003c  f89d1000          LDRB     r1,[sp,#0]            ;896
000040  f44f6061          MOV      r0,#0xe10             ;896
000044  4341              MULS     r1,r0,r1              ;896
000046  f89d0001          LDRB     r0,[sp,#1]            ;896
00004a  ebc01000          RSB      r0,r0,r0,LSL #4       ;896
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;896
000052  f89d1002          LDRB     r1,[sp,#2]            ;896
000056  eb000801          ADD      r8,r0,r1              ;896
00005a  f1b90f00          CMP      r9,#0                 ;900
00005e  d01f              BEQ      |L13.160|
000060  7828              LDRB     r0,[r5,#0]            ;916
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  f44f6161          MOV      r1,#0xe10             ;916
00006a  fb00f901          MUL      r9,r0,r1              ;916
00006e  7868              LDRB     r0,[r5,#1]            ;916
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  ebc01000          RSB      r0,r0,r0,LSL #4       ;916
000078  eb090980          ADD      r9,r9,r0,LSL #2       ;916
00007c  78a8              LDRB     r0,[r5,#2]            ;916
00007e  f7fffffe          BL       RTC_Bcd2ToByte
000082  eb090100          ADD      r1,r9,r0              ;916
                  |L13.134|
000086  4541              CMP      r1,r8                 ;922
000088  d201              BCS      |L13.142|
00008a  480d              LDR      r0,|L13.192|
00008c  4401              ADD      r1,r1,r0              ;925
                  |L13.142|
00008e  4620              MOV      r0,r4                 ;929
000090  f7fffffe          BL       RTC_WriteAlarmCounter
000094  b180              CBZ      r0,|L13.184|
000096  2004              MOVS     r0,#4                 ;932
000098  7460              STRB     r0,[r4,#0x11]         ;932
00009a  7426              STRB     r6,[r4,#0x10]         ;935
00009c  2001              MOVS     r0,#1                 ;937
00009e  e7c7              B        |L13.48|
                  |L13.160|
0000a0  7829              LDRB     r1,[r5,#0]            ;906
0000a2  f44f6061          MOV      r0,#0xe10             ;906
0000a6  4341              MULS     r1,r0,r1              ;906
0000a8  7868              LDRB     r0,[r5,#1]            ;906
0000aa  ebc01000          RSB      r0,r0,r0,LSL #4       ;906
0000ae  eb010080          ADD      r0,r1,r0,LSL #2       ;906
0000b2  78a9              LDRB     r1,[r5,#2]            ;906
0000b4  4401              ADD      r1,r1,r0              ;906
0000b6  e7e6              B        |L13.134|
                  |L13.184|
0000b8  7467              STRB     r7,[r4,#0x11]         ;941
0000ba  7426              STRB     r6,[r4,#0x10]         ;943
0000bc  2000              MOVS     r0,#0                 ;945
0000be  e7b7              B        |L13.48|
;;;948    
                          ENDP

                  |L13.192|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_SetAlarm_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm_IT PROC
;;;960      */
;;;961    HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;962    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;963      uint32_t counter_alarm = 0U, counter_time;
;;;964      RTC_TimeTypeDef stime = {0U};
00000a  2600              MOVS     r6,#0
00000c  9600              STR      r6,[sp,#0]
;;;965      
;;;966      /* Check input parameters */
;;;967      if((hrtc == NULL) || (sAlarm == NULL))
00000e  2c00              CMP      r4,#0
000010  d010              BEQ      |L14.52|
000012  b17d              CBZ      r5,|L14.52|
;;;968      {
;;;969         return HAL_ERROR;
;;;970      }
;;;971      
;;;972      /* Check the parameters */
;;;973      assert_param(IS_RTC_FORMAT(Format));
;;;974      assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;975    
;;;976      /* Process Locked */ 
;;;977      __HAL_LOCK(hrtc);
000014  7c20              LDRB     r0,[r4,#0x10]
000016  2801              CMP      r0,#1
000018  d00e              BEQ      |L14.56|
00001a  2701              MOVS     r7,#1
00001c  7427              STRB     r7,[r4,#0x10]
;;;978      
;;;979      hrtc->State = HAL_RTC_STATE_BUSY;
00001e  2002              MOVS     r0,#2
000020  7460              STRB     r0,[r4,#0x11]
;;;980      
;;;981      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;982      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000022  2200              MOVS     r2,#0
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_RTC_GetTime
00002c  b130              CBZ      r0,|L14.60|
;;;983      {
;;;984        return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L14.48|
;;;985      }
;;;986    
;;;987      /* Convert time in seconds */
;;;988      counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600U) + \
;;;989                          ((uint32_t)stime.Minutes * 60U) + \
;;;990                          ((uint32_t)stime.Seconds));  
;;;991    
;;;992      if(Format == RTC_FORMAT_BIN)
;;;993      {
;;;994        assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;995        assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;996        assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;997        
;;;998        counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600U) + \
;;;999          ((uint32_t)sAlarm->AlarmTime.Minutes * 60U) + \
;;;1000           ((uint32_t)sAlarm->AlarmTime.Seconds));  
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1005       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1006       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1007       
;;;1008       counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600U) + \
;;;1009                        ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60U) + \
;;;1010                        ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));   
;;;1011     }
;;;1012     
;;;1013     /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;1014     if (counter_alarm < counter_time)
;;;1015     {
;;;1016       /* Add 1 day to alarm counter*/
;;;1017       counter_alarm += (uint32_t)(24U * 3600U);
;;;1018     }
;;;1019   
;;;1020     /* Write alarm counter in RTC registers */
;;;1021     if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;1022     {
;;;1023       /* Set RTC state */
;;;1024       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1025       
;;;1026       /* Process Unlocked */ 
;;;1027       __HAL_UNLOCK(hrtc);
;;;1028       
;;;1029       return HAL_ERROR;
;;;1030     }
;;;1031     else
;;;1032     {
;;;1033       /* Clear flag alarm A */
;;;1034       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1035       
;;;1036       /* Configure the Alarm interrupt */
;;;1037       __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
;;;1038       
;;;1039       /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;1040       __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;1041       
;;;1042       __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
;;;1043   
;;;1044       hrtc->State = HAL_RTC_STATE_READY;
;;;1045     
;;;1046      __HAL_UNLOCK(hrtc); 
;;;1047        
;;;1048      return HAL_OK;
;;;1049     }
;;;1050   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L14.52|
000034  2001              MOVS     r0,#1                 ;969
000036  e7fb              B        |L14.48|
                  |L14.56|
000038  2002              MOVS     r0,#2                 ;977
00003a  e7f9              B        |L14.48|
                  |L14.60|
00003c  f89d1000          LDRB     r1,[sp,#0]            ;988
000040  f44f6061          MOV      r0,#0xe10             ;988
000044  4341              MULS     r1,r0,r1              ;988
000046  f89d0001          LDRB     r0,[sp,#1]            ;988
00004a  ebc01000          RSB      r0,r0,r0,LSL #4       ;988
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;988
000052  f89d1002          LDRB     r1,[sp,#2]            ;988
000056  eb000801          ADD      r8,r0,r1              ;988
00005a  f1b90f00          CMP      r9,#0                 ;992
00005e  d01f              BEQ      |L14.160|
000060  7828              LDRB     r0,[r5,#0]            ;1008
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  f44f6161          MOV      r1,#0xe10             ;1008
00006a  fb00f901          MUL      r9,r0,r1              ;1008
00006e  7868              LDRB     r0,[r5,#1]            ;1008
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  ebc01000          RSB      r0,r0,r0,LSL #4       ;1008
000078  eb090980          ADD      r9,r9,r0,LSL #2       ;1008
00007c  78a8              LDRB     r0,[r5,#2]            ;1008
00007e  f7fffffe          BL       RTC_Bcd2ToByte
000082  eb090100          ADD      r1,r9,r0              ;1008
                  |L14.134|
000086  4541              CMP      r1,r8                 ;1014
000088  d201              BCS      |L14.142|
00008a  4817              LDR      r0,|L14.232|
00008c  4401              ADD      r1,r1,r0              ;1017
                  |L14.142|
00008e  4620              MOV      r0,r4                 ;1021
000090  f7fffffe          BL       RTC_WriteAlarmCounter
000094  b180              CBZ      r0,|L14.184|
000096  2004              MOVS     r0,#4                 ;1024
000098  7460              STRB     r0,[r4,#0x11]         ;1024
00009a  7426              STRB     r6,[r4,#0x10]         ;1027
00009c  2001              MOVS     r0,#1                 ;1029
00009e  e7c7              B        |L14.48|
                  |L14.160|
0000a0  7829              LDRB     r1,[r5,#0]            ;998
0000a2  f44f6061          MOV      r0,#0xe10             ;998
0000a6  4341              MULS     r1,r0,r1              ;998
0000a8  7868              LDRB     r0,[r5,#1]            ;998
0000aa  ebc01000          RSB      r0,r0,r0,LSL #4       ;998
0000ae  eb010080          ADD      r0,r1,r0,LSL #2       ;998
0000b2  78a9              LDRB     r1,[r5,#2]            ;998
0000b4  4401              ADD      r1,r1,r0              ;998
0000b6  e7e6              B        |L14.134|
                  |L14.184|
0000b8  6821              LDR      r1,[r4,#0]            ;1034
0000ba  f06f0002          MVN      r0,#2                 ;1034
0000be  6048              STR      r0,[r1,#4]            ;1034
0000c0  6820              LDR      r0,[r4,#0]            ;1037
0000c2  6801              LDR      r1,[r0,#0]            ;1037
0000c4  f0410102          ORR      r1,r1,#2              ;1037
0000c8  6001              STR      r1,[r0,#0]            ;1037
0000ca  4808              LDR      r0,|L14.236|
0000cc  6801              LDR      r1,[r0,#0]            ;1040
0000ce  f4413100          ORR      r1,r1,#0x20000        ;1040
0000d2  6001              STR      r1,[r0,#0]            ;1040
0000d4  4805              LDR      r0,|L14.236|
0000d6  3008              ADDS     r0,r0,#8              ;1042
0000d8  6801              LDR      r1,[r0,#0]            ;1042
0000da  f4413100          ORR      r1,r1,#0x20000        ;1042
0000de  6001              STR      r1,[r0,#0]            ;1042
0000e0  7467              STRB     r7,[r4,#0x11]         ;1044
0000e2  7426              STRB     r6,[r4,#0x10]         ;1046
0000e4  2000              MOVS     r0,#0                 ;1048
0000e6  e7a3              B        |L14.48|
;;;1051   
                          ENDP

                  |L14.232|
                          DCD      0x00015180
                  |L14.236|
                          DCD      0x40010400

                          AREA ||i.HAL_RTC_SetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetDate PROC
;;;689      */
;;;690    HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;691    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;692      uint32_t counter_time = 0U, counter_alarm = 0U, hours = 0U;
;;;693      
;;;694      /* Check input parameters */
;;;695      if((hrtc == NULL) || (sDate == NULL))
000008  2c00              CMP      r4,#0
00000a  d03f              BEQ      |L15.140|
00000c  b3e5              CBZ      r5,|L15.136|
;;;696      {
;;;697         return HAL_ERROR;
;;;698      }
;;;699      
;;;700      /* Check the parameters */
;;;701      assert_param(IS_RTC_FORMAT(Format));
;;;702      
;;;703     /* Process Locked */ 
;;;704     __HAL_LOCK(hrtc);
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2801              CMP      r0,#1
000012  d03d              BEQ      |L15.144|
000014  2601              MOVS     r6,#1
000016  7426              STRB     r6,[r4,#0x10]
;;;705      
;;;706      hrtc->State = HAL_RTC_STATE_BUSY; 
000018  2002              MOVS     r0,#2
00001a  7460              STRB     r0,[r4,#0x11]
00001c  b3aa              CBZ      r2,|L15.138|
;;;707      
;;;708      if(Format == RTC_FORMAT_BIN)
;;;709      {   
;;;710        assert_param(IS_RTC_YEAR(sDate->Year));
;;;711        assert_param(IS_RTC_MONTH(sDate->Month));
;;;712        assert_param(IS_RTC_DATE(sDate->Date)); 
;;;713    
;;;714        /* Change the current date */
;;;715        hrtc->DateToUpdate.Year  = sDate->Year;
;;;716        hrtc->DateToUpdate.Month = sDate->Month;
;;;717        hrtc->DateToUpdate.Date  = sDate->Date;
;;;718      }
;;;719      else
;;;720      {   
;;;721        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;722        assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;723        assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;724        
;;;725        /* Change the current date */
;;;726        hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
00001e  78e8              LDRB     r0,[r5,#3]
000020  f7fffffe          BL       RTC_Bcd2ToByte
000024  73e0              STRB     r0,[r4,#0xf]
;;;727        hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
000026  7868              LDRB     r0,[r5,#1]
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  7360              STRB     r0,[r4,#0xd]
;;;728        hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
00002e  78a8              LDRB     r0,[r5,#2]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  73a0              STRB     r0,[r4,#0xe]
                  |L15.54|
;;;729      }
;;;730    
;;;731      /* WeekDay set by user can be ignored because automatically calculated */
;;;732      hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(hrtc->DateToUpdate.Year, hrtc->DateToUpdate.Month, hrtc->DateToUpdate.Date);
000036  7ba2              LDRB     r2,[r4,#0xe]
000038  7b61              LDRB     r1,[r4,#0xd]
00003a  7be0              LDRB     r0,[r4,#0xf]
00003c  f7fffffe          BL       RTC_WeekDayNum
000040  7320              STRB     r0,[r4,#0xc]
;;;733      sDate->WeekDay = hrtc->DateToUpdate.WeekDay;
000042  7028              STRB     r0,[r5,#0]
;;;734    
;;;735      /* Reset time to be aligned on the same day */
;;;736      /* Read the time counter*/
;;;737      counter_time = RTC_ReadTimeCounter(hrtc);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RTC_ReadTimeCounter
;;;738    
;;;739      /* Fill the structure fields with the read parameters */
;;;740      hours = counter_time / 3600U;
00004a  f44f6161          MOV      r1,#0xe10
00004e  fbb0f1f1          UDIV     r1,r0,r1
;;;741      if (hours > 24U)
000052  2500              MOVS     r5,#0
000054  2918              CMP      r1,#0x18
000056  d936              BLS      |L15.198|
;;;742      {
;;;743        /* Set updated time in decreasing counter by number of days elapsed */
;;;744        counter_time -= ((hours / 24U) * 24U * 3600U);
000058  2218              MOVS     r2,#0x18
00005a  fbb1f1f2          UDIV     r1,r1,r2
00005e  eba11101          SUB      r1,r1,r1,LSL #4
000062  eb010141          ADD      r1,r1,r1,LSL #1
000066  ebc11101          RSB      r1,r1,r1,LSL #4
00006a  eb0017c1          ADD      r7,r0,r1,LSL #7
;;;745        /* Write time counter in RTC registers */
;;;746        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
00006e  4639              MOV      r1,r7
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       RTC_WriteTimeCounter
;;;747        {
;;;748          /* Set RTC state */
;;;749          hrtc->State = HAL_RTC_STATE_ERROR;
000076  f04f0804          MOV      r8,#4
00007a  b190              CBZ      r0,|L15.162|
00007c  f8848011          STRB     r8,[r4,#0x11]
;;;750          
;;;751          /* Process Unlocked */ 
;;;752          __HAL_UNLOCK(hrtc);
000080  7425              STRB     r5,[r4,#0x10]
;;;753          
;;;754          return HAL_ERROR;
000082  2001              MOVS     r0,#1
                  |L15.132|
;;;755        }
;;;756    
;;;757        /* Read current Alarm counter in RTC registers */
;;;758        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;759    
;;;760        /* Set again alarm to match with new time if enabled */
;;;761        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;762        {
;;;763          if(counter_alarm < counter_time)
;;;764          {
;;;765            /* Add 1 day to alarm counter*/
;;;766            counter_alarm += (uint32_t)(24U * 3600U);
;;;767            
;;;768            /* Write new Alarm counter in RTC registers */
;;;769            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;770            {
;;;771              /* Set RTC state */
;;;772              hrtc->State = HAL_RTC_STATE_ERROR;
;;;773              
;;;774              /* Process Unlocked */ 
;;;775              __HAL_UNLOCK(hrtc);
;;;776              
;;;777              return HAL_ERROR;
;;;778            }
;;;779          }
;;;780        }
;;;781        
;;;782    
;;;783      }
;;;784    
;;;785      hrtc->State = HAL_RTC_STATE_READY ;
;;;786      
;;;787      /* Process Unlocked */ 
;;;788      __HAL_UNLOCK(hrtc);
;;;789      
;;;790      return HAL_OK;    
;;;791    }
000084  e8bd81f0          POP      {r4-r8,pc}
                  |L15.136|
000088  e000              B        |L15.140|
                  |L15.138|
00008a  e003              B        |L15.148|
                  |L15.140|
00008c  2001              MOVS     r0,#1                 ;697
00008e  e7f9              B        |L15.132|
                  |L15.144|
000090  2002              MOVS     r0,#2                 ;704
000092  e7f7              B        |L15.132|
                  |L15.148|
000094  78e8              LDRB     r0,[r5,#3]            ;715
000096  73e0              STRB     r0,[r4,#0xf]          ;715
000098  7868              LDRB     r0,[r5,#1]            ;716
00009a  7360              STRB     r0,[r4,#0xd]          ;716
00009c  78a8              LDRB     r0,[r5,#2]            ;717
00009e  73a0              STRB     r0,[r4,#0xe]          ;717
0000a0  e7c9              B        |L15.54|
                  |L15.162|
0000a2  4620              MOV      r0,r4                 ;758
0000a4  f7fffffe          BL       RTC_ReadAlarmCounter
0000a8  1c41              ADDS     r1,r0,#1              ;761
0000aa  d00c              BEQ      |L15.198|
0000ac  42b8              CMP      r0,r7                 ;763
0000ae  d20a              BCS      |L15.198|
0000b0  4907              LDR      r1,|L15.208|
0000b2  4401              ADD      r1,r1,r0              ;766
0000b4  4620              MOV      r0,r4                 ;769
0000b6  f7fffffe          BL       RTC_WriteAlarmCounter
0000ba  b120              CBZ      r0,|L15.198|
0000bc  f8848011          STRB     r8,[r4,#0x11]         ;772
0000c0  7425              STRB     r5,[r4,#0x10]         ;775
0000c2  2001              MOVS     r0,#1                 ;777
0000c4  e7de              B        |L15.132|
                  |L15.198|
0000c6  7466              STRB     r6,[r4,#0x11]         ;785
0000c8  7425              STRB     r5,[r4,#0x10]         ;788
0000ca  2000              MOVS     r0,#0                 ;790
0000cc  e7da              B        |L15.132|
;;;792    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L15.208|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_SetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetTime PROC
;;;479      */
;;;480    HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;481    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;482      uint32_t counter_time = 0U, counter_alarm = 0U;
;;;483      
;;;484      /* Check input parameters */
;;;485      if((hrtc == NULL) || (sTime == NULL))
000008  2c00              CMP      r4,#0
00000a  d028              BEQ      |L16.94|
00000c  b33d              CBZ      r5,|L16.94|
;;;486      {
;;;487         return HAL_ERROR;
;;;488      }
;;;489      
;;;490     /* Check the parameters */
;;;491      assert_param(IS_RTC_FORMAT(Format));
;;;492      
;;;493      /* Process Locked */ 
;;;494      __HAL_LOCK(hrtc);
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2801              CMP      r0,#1
000012  d026              BEQ      |L16.98|
000014  2601              MOVS     r6,#1
000016  7426              STRB     r6,[r4,#0x10]
;;;495      
;;;496      hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  7460              STRB     r0,[r4,#0x11]
00001c  b31a              CBZ      r2,|L16.102|
;;;497      
;;;498      if(Format == RTC_FORMAT_BIN)
;;;499      {
;;;500        assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;501        assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;502        assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;503    
;;;504        counter_time = (uint32_t)(((uint32_t)sTime->Hours * 3600U) + \
;;;505                            ((uint32_t)sTime->Minutes * 60U) + \
;;;506                            ((uint32_t)sTime->Seconds));  
;;;507      }
;;;508      else
;;;509      {
;;;510        assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;511        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;512        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;513    
;;;514        counter_time = (((uint32_t)(RTC_Bcd2ToByte(sTime->Hours)) * 3600U) + \
00001e  7828              LDRB     r0,[r5,#0]
000020  f7fffffe          BL       RTC_Bcd2ToByte
000024  f44f6161          MOV      r1,#0xe10
000028  fb00f701          MUL      r7,r0,r1
00002c  7868              LDRB     r0,[r5,#1]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  ebc01000          RSB      r0,r0,r0,LSL #4
000036  eb070780          ADD      r7,r7,r0,LSL #2
00003a  78a8              LDRB     r0,[r5,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  183d              ADDS     r5,r7,r0
                  |L16.66|
;;;515                  ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60U) + \
;;;516                  ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));   
;;;517      }
;;;518    
;;;519      /* Write time counter in RTC registers */
;;;520      if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
000042  4629              MOV      r1,r5
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RTC_WriteTimeCounter
00004a  2700              MOVS     r7,#0
;;;521      {
;;;522        /* Set RTC state */
;;;523        hrtc->State = HAL_RTC_STATE_ERROR;
00004c  f04f0804          MOV      r8,#4
000050  b1a8              CBZ      r0,|L16.126|
000052  f8848011          STRB     r8,[r4,#0x11]
;;;524        
;;;525        /* Process Unlocked */ 
;;;526        __HAL_UNLOCK(hrtc);
000056  7427              STRB     r7,[r4,#0x10]
;;;527        
;;;528        return HAL_ERROR;
000058  2001              MOVS     r0,#1
                  |L16.90|
;;;529      }
;;;530      else
;;;531      {
;;;532        /* Clear Second and overflow flags */
;;;533        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_SEC | RTC_FLAG_OW));
;;;534        
;;;535        /* Read current Alarm counter in RTC registers */
;;;536        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;537    
;;;538        /* Set again alarm to match with new time if enabled */
;;;539        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;540        {
;;;541          if(counter_alarm < counter_time)
;;;542          {
;;;543            /* Add 1 day to alarm counter*/
;;;544            counter_alarm += (uint32_t)(24U * 3600U);
;;;545            
;;;546            /* Write new Alarm counter in RTC registers */
;;;547            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;548            {
;;;549              /* Set RTC state */
;;;550              hrtc->State = HAL_RTC_STATE_ERROR;
;;;551              
;;;552              /* Process Unlocked */ 
;;;553              __HAL_UNLOCK(hrtc);
;;;554              
;;;555              return HAL_ERROR;
;;;556            }
;;;557          }
;;;558        }
;;;559        
;;;560        hrtc->State = HAL_RTC_STATE_READY;
;;;561      
;;;562       __HAL_UNLOCK(hrtc); 
;;;563         
;;;564       return HAL_OK;
;;;565      }
;;;566    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.94|
00005e  2001              MOVS     r0,#1                 ;487
000060  e7fb              B        |L16.90|
                  |L16.98|
000062  2002              MOVS     r0,#2                 ;494
000064  e7f9              B        |L16.90|
                  |L16.102|
000066  7829              LDRB     r1,[r5,#0]            ;504
000068  f44f6061          MOV      r0,#0xe10             ;504
00006c  4341              MULS     r1,r0,r1              ;504
00006e  7868              LDRB     r0,[r5,#1]            ;504
000070  ebc01000          RSB      r0,r0,r0,LSL #4       ;504
000074  eb010080          ADD      r0,r1,r0,LSL #2       ;504
000078  78a9              LDRB     r1,[r5,#2]            ;504
00007a  1845              ADDS     r5,r0,r1              ;504
00007c  e7e1              B        |L16.66|
                  |L16.126|
00007e  6820              LDR      r0,[r4,#0]            ;533
000080  6841              LDR      r1,[r0,#4]            ;533
000082  f0210105          BIC      r1,r1,#5              ;533
000086  6041              STR      r1,[r0,#4]            ;533
000088  4620              MOV      r0,r4                 ;536
00008a  f7fffffe          BL       RTC_ReadAlarmCounter
00008e  1c41              ADDS     r1,r0,#1              ;539
000090  d00c              BEQ      |L16.172|
000092  42a8              CMP      r0,r5                 ;541
000094  d20a              BCS      |L16.172|
000096  4907              LDR      r1,|L16.180|
000098  4401              ADD      r1,r1,r0              ;544
00009a  4620              MOV      r0,r4                 ;547
00009c  f7fffffe          BL       RTC_WriteAlarmCounter
0000a0  b120              CBZ      r0,|L16.172|
0000a2  f8848011          STRB     r8,[r4,#0x11]         ;550
0000a6  7427              STRB     r7,[r4,#0x10]         ;553
0000a8  2001              MOVS     r0,#1                 ;555
0000aa  e7d6              B        |L16.90|
                  |L16.172|
0000ac  7466              STRB     r6,[r4,#0x11]         ;560
0000ae  7427              STRB     r7,[r4,#0x10]         ;562
0000b0  2000              MOVS     r0,#0                 ;564
0000b2  e7d2              B        |L16.90|
;;;567    
                          ENDP

                  |L16.180|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_WaitForSynchro||, CODE, READONLY, ALIGN=1

                  HAL_RTC_WaitForSynchro PROC
;;;1312     */
;;;1313   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1314   {
000002  4604              MOV      r4,r0
;;;1315     uint32_t tickstart = 0U;
;;;1316     
;;;1317     /* Check input parameters */
;;;1318     if(hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d00a              BEQ      |L17.30|
;;;1319     {
;;;1320        return HAL_ERROR;
;;;1321     }
;;;1322     
;;;1323     /* Clear RSF flag */
;;;1324     CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
000008  6820              LDR      r0,[r4,#0]
00000a  6841              LDR      r1,[r0,#4]
00000c  f0210108          BIC      r1,r1,#8
000010  6041              STR      r1,[r0,#4]
;;;1325     
;;;1326     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;1327     
;;;1328     /* Wait the registers to be synchronised */
;;;1329     while((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
;;;1330     {
;;;1331       if((HAL_GetTick() - tickstart ) >  RTC_TIMEOUT_VALUE)
000018  f44f767a          MOV      r6,#0x3e8
00001c  e008              B        |L17.48|
                  |L17.30|
00001e  2001              MOVS     r0,#1                 ;1320
;;;1332       {       
;;;1333         return HAL_TIMEOUT;
;;;1334       } 
;;;1335     }
;;;1336     
;;;1337     return HAL_OK;
;;;1338   }
000020  bd70              POP      {r4-r6,pc}
                  |L17.34|
000022  f7fffffe          BL       HAL_GetTick
000026  1b40              SUBS     r0,r0,r5              ;1331
000028  42b0              CMP      r0,r6                 ;1331
00002a  d901              BLS      |L17.48|
00002c  2003              MOVS     r0,#3                 ;1333
00002e  bd70              POP      {r4-r6,pc}
                  |L17.48|
000030  6820              LDR      r0,[r4,#0]            ;1329
000032  6840              LDR      r0,[r0,#4]            ;1329
000034  0700              LSLS     r0,r0,#28             ;1329
000036  d5f4              BPL      |L17.34|
000038  2000              MOVS     r0,#0                 ;1337
00003a  bd70              POP      {r4-r6,pc}
;;;1339   
                          ENDP


                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;1540     */
;;;1541   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;1542   {
;;;1543     uint32_t tmp = 0U;
;;;1544     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10U;
000002  eb010181          ADD      r1,r1,r1,LSL #2
000006  0049              LSLS     r1,r1,#1
;;;1545     return (tmp + (Value & (uint8_t)0x0F));
000008  f000000f          AND      r0,r0,#0xf
00000c  4408              ADD      r0,r0,r1
00000e  b2c0              UXTB     r0,r0
;;;1546   }
000010  4770              BX       lr
;;;1547   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;1522     */
;;;1523   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;1524   {
000002  e002              B        |L19.10|
                  |L19.4|
;;;1525     uint32_t bcdhigh = 0U;
;;;1526     
;;;1527     while(Value >= 10U)
;;;1528     {
;;;1529       bcdhigh++;
000004  1c49              ADDS     r1,r1,#1
;;;1530       Value -= 10U;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c0              UXTB     r0,r0
                  |L19.10|
00000a  280a              CMP      r0,#0xa               ;1527
00000c  d2fa              BCS      |L19.4|
;;;1531     }
;;;1532     
;;;1533     return  ((uint8_t)(bcdhigh << 4U) | Value);
00000e  0709              LSLS     r1,r1,#28
000010  ea406011          ORR      r0,r0,r1,LSR #24
;;;1534   }
000014  4770              BX       lr
;;;1535   
                          ENDP


                          AREA ||i.RTC_DateUpdate||, CODE, READONLY, ALIGN=1

                  RTC_DateUpdate PROC
;;;1554     */
;;;1555   static void RTC_DateUpdate(RTC_HandleTypeDef* hrtc, uint32_t DayElapsed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1556   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1557     uint32_t year = 0U, month = 0U, day = 0U;
;;;1558     uint32_t loop = 0U;
000008  2700              MOVS     r7,#0
;;;1559   
;;;1560     /* Get the current year*/
;;;1561     year = hrtc->DateToUpdate.Year;
00000a  7bf5              LDRB     r5,[r6,#0xf]
;;;1562   
;;;1563     /* Get the current month and day */
;;;1564     month = hrtc->DateToUpdate.Month;
00000c  7b74              LDRB     r4,[r6,#0xd]
;;;1565     day = hrtc->DateToUpdate.Date;
00000e  7bb2              LDRB     r2,[r6,#0xe]
000010  e040              B        |L20.148|
                  |L20.18|
;;;1566   
;;;1567     for (loop = 0U; loop < DayElapsed; loop++)
;;;1568     {
;;;1569       if((month == 1U) || (month == 3U) || (month == 5U) || (month == 7U) || \
000012  2c01              CMP      r4,#1
000014  d016              BEQ      |L20.68|
000016  2c03              CMP      r4,#3
000018  d014              BEQ      |L20.68|
00001a  2c05              CMP      r4,#5
00001c  d012              BEQ      |L20.68|
00001e  2c07              CMP      r4,#7
000020  d010              BEQ      |L20.68|
;;;1570          (month == 8U) || (month == 10U) || (month == 12U))
000022  2c08              CMP      r4,#8
000024  d00e              BEQ      |L20.68|
000026  2c0a              CMP      r4,#0xa
000028  d00c              BEQ      |L20.68|
00002a  2c0c              CMP      r4,#0xc
00002c  d00a              BEQ      |L20.68|
;;;1571       {
;;;1572         if(day < 31U)
;;;1573         {
;;;1574           day++;
;;;1575         }
;;;1576         /* Date structure member: day = 31 */
;;;1577         else
;;;1578         {
;;;1579           if(month != 12U)
;;;1580           {
;;;1581             month++;
;;;1582             day = 1U;
;;;1583           }
;;;1584           /* Date structure member: day = 31 & month =12 */
;;;1585           else
;;;1586           {
;;;1587             month = 1U;
;;;1588             day = 1U;
;;;1589             year++;
;;;1590           }
;;;1591         }
;;;1592       }
;;;1593       else if((month == 4U) || (month == 6U) || (month == 9U) || (month == 11U))
00002e  2c04              CMP      r4,#4
000030  d015              BEQ      |L20.94|
000032  2c06              CMP      r4,#6
000034  d013              BEQ      |L20.94|
000036  2c09              CMP      r4,#9
000038  d011              BEQ      |L20.94|
00003a  2c0b              CMP      r4,#0xb
00003c  d00f              BEQ      |L20.94|
;;;1594       {
;;;1595         if(day < 30U)
;;;1596         {
;;;1597           day++;
;;;1598         }
;;;1599         /* Date structure member: day = 30 */
;;;1600         else
;;;1601         {
;;;1602           month++;
;;;1603           day = 1U;
;;;1604         }
;;;1605       }
;;;1606       else if(month == 2U)
00003e  2c02              CMP      r4,#2
000040  d014              BEQ      |L20.108|
000042  e026              B        |L20.146|
                  |L20.68|
000044  2a1f              CMP      r2,#0x1f              ;1572
000046  d201              BCS      |L20.76|
000048  1c52              ADDS     r2,r2,#1              ;1574
00004a  e022              B        |L20.146|
                  |L20.76|
00004c  2c0c              CMP      r4,#0xc               ;1579
00004e  d002              BEQ      |L20.86|
000050  1c64              ADDS     r4,r4,#1              ;1581
000052  2201              MOVS     r2,#1                 ;1582
000054  e01d              B        |L20.146|
                  |L20.86|
000056  2401              MOVS     r4,#1                 ;1587
000058  2201              MOVS     r2,#1                 ;1588
00005a  1c6d              ADDS     r5,r5,#1              ;1589
00005c  e019              B        |L20.146|
                  |L20.94|
00005e  2a1e              CMP      r2,#0x1e              ;1595
000060  d201              BCS      |L20.102|
000062  1c52              ADDS     r2,r2,#1              ;1597
000064  e015              B        |L20.146|
                  |L20.102|
000066  1c64              ADDS     r4,r4,#1              ;1602
000068  2201              MOVS     r2,#1                 ;1603
00006a  e012              B        |L20.146|
                  |L20.108|
;;;1607       {
;;;1608         if(day < 28U)
00006c  2a1c              CMP      r2,#0x1c
00006e  d202              BCS      |L20.118|
;;;1609         {
;;;1610           day++;
000070  f1020201          ADD      r2,r2,#1
000074  e00d              B        |L20.146|
                  |L20.118|
;;;1611         }
;;;1612         else if(day == 28U)
000076  d108              BNE      |L20.138|
;;;1613         {
;;;1614           /* Leap year */
;;;1615           if(RTC_IsLeapYear(year))
000078  b2a8              UXTH     r0,r5
00007a  f7fffffe          BL       RTC_IsLeapYear
00007e  b108              CBZ      r0,|L20.132|
;;;1616           {
;;;1617             day++;
000080  221d              MOVS     r2,#0x1d
000082  e006              B        |L20.146|
                  |L20.132|
;;;1618           }
;;;1619           else
;;;1620           {
;;;1621             month++;
000084  2403              MOVS     r4,#3
;;;1622             day = 1U;
000086  2201              MOVS     r2,#1
000088  e003              B        |L20.146|
                  |L20.138|
;;;1623           }
;;;1624         }
;;;1625         else if(day == 29U)
00008a  2a1d              CMP      r2,#0x1d
00008c  d101              BNE      |L20.146|
;;;1626         {
;;;1627           month++;
00008e  2403              MOVS     r4,#3
;;;1628           day = 1U;
000090  2201              MOVS     r2,#1
                  |L20.146|
000092  1c7f              ADDS     r7,r7,#1              ;1567
                  |L20.148|
000094  4547              CMP      r7,r8                 ;1567
000096  d3bc              BCC      |L20.18|
;;;1629         }
;;;1630       }
;;;1631     }
;;;1632   
;;;1633     /* Update year */
;;;1634     hrtc->DateToUpdate.Year = year;
000098  73f5              STRB     r5,[r6,#0xf]
;;;1635   
;;;1636     /* Update day and month */
;;;1637     hrtc->DateToUpdate.Month = month;
00009a  b2e1              UXTB     r1,r4
00009c  7371              STRB     r1,[r6,#0xd]
;;;1638     hrtc->DateToUpdate.Date = day;
00009e  b2d2              UXTB     r2,r2
0000a0  73b2              STRB     r2,[r6,#0xe]
;;;1639   
;;;1640     /* Update day of the week */
;;;1641     hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(year, month, day);
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       RTC_WeekDayNum
0000a8  7330              STRB     r0,[r6,#0xc]
;;;1642   }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;1643   
                          ENDP


                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=1

                  RTC_EnterInitMode PROC
;;;1470     */
;;;1471   static HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1472   {
000002  4605              MOV      r5,r0
;;;1473     uint32_t tickstart = 0U;
;;;1474     
;;;1475     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4604              MOV      r4,r0
;;;1476     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1477     while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
;;;1478     {
;;;1479       if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
00000a  f44f767a          MOV      r6,#0x3e8
00000e  e006              B        |L21.30|
                  |L21.16|
000010  f7fffffe          BL       HAL_GetTick
000014  1b00              SUBS     r0,r0,r4
000016  42b0              CMP      r0,r6
000018  d901              BLS      |L21.30|
;;;1480       {       
;;;1481         return HAL_TIMEOUT;
00001a  2003              MOVS     r0,#3
;;;1482       } 
;;;1483     }
;;;1484   
;;;1485     /* Disable the write protection for RTC registers */
;;;1486     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1487     
;;;1488     
;;;1489     return HAL_OK;  
;;;1490   }
00001c  bd70              POP      {r4-r6,pc}
                  |L21.30|
00001e  6828              LDR      r0,[r5,#0]            ;1477
000020  6840              LDR      r0,[r0,#4]            ;1477
000022  0680              LSLS     r0,r0,#26             ;1477
000024  d5f4              BPL      |L21.16|
000026  6828              LDR      r0,[r5,#0]            ;1486
000028  6841              LDR      r1,[r0,#4]            ;1486
00002a  f0410110          ORR      r1,r1,#0x10           ;1486
00002e  6041              STR      r1,[r0,#4]            ;1486
000030  2000              MOVS     r0,#0                 ;1489
000032  bd70              POP      {r4-r6,pc}
;;;1491   
                          ENDP


                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=1

                  RTC_ExitInitMode PROC
;;;1497     */
;;;1498   static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1499   {
000002  4605              MOV      r5,r0
;;;1500     uint32_t tickstart = 0U;
;;;1501     
;;;1502     /* Disable the write protection for RTC registers */
;;;1503     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000004  6828              LDR      r0,[r5,#0]
000006  6841              LDR      r1,[r0,#4]
000008  f0210110          BIC      r1,r1,#0x10
00000c  6041              STR      r1,[r0,#4]
;;;1504     
;;;1505     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4604              MOV      r4,r0
;;;1506     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1507     while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
;;;1508     {
;;;1509       if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
000014  f44f767a          MOV      r6,#0x3e8
000018  e006              B        |L22.40|
                  |L22.26|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b00              SUBS     r0,r0,r4
000020  42b0              CMP      r0,r6
000022  d901              BLS      |L22.40|
;;;1510       {       
;;;1511         return HAL_TIMEOUT;
000024  2003              MOVS     r0,#3
;;;1512       } 
;;;1513     }
;;;1514     
;;;1515     return HAL_OK;  
;;;1516   }
000026  bd70              POP      {r4-r6,pc}
                  |L22.40|
000028  6828              LDR      r0,[r5,#0]            ;1507
00002a  6840              LDR      r0,[r0,#4]            ;1507
00002c  0680              LSLS     r0,r0,#26             ;1507
00002e  d5f4              BPL      |L22.26|
000030  2000              MOVS     r0,#0                 ;1515
000032  bd70              POP      {r4-r6,pc}
;;;1517   
                          ENDP


                          AREA ||i.RTC_IsLeapYear||, CODE, READONLY, ALIGN=1

                  RTC_IsLeapYear PROC
;;;1649     */
;;;1650   static uint8_t RTC_IsLeapYear(uint16_t nYear)
000000  0781              LSLS     r1,r0,#30
;;;1651   {
000002  d001              BEQ      |L23.8|
;;;1652     if((nYear % 4U) != 0U) 
;;;1653     {
;;;1654       return 0U;
000004  2000              MOVS     r0,#0
;;;1655     }
;;;1656     
;;;1657     if((nYear % 100U) != 0U) 
;;;1658     {
;;;1659       return 1U;
;;;1660     }
;;;1661     
;;;1662     if((nYear % 400U) == 0U)
;;;1663     {
;;;1664       return 1U;
;;;1665     }
;;;1666     else
;;;1667     {
;;;1668       return 0U;
;;;1669     }
;;;1670   }
000006  4770              BX       lr
                  |L23.8|
000008  2164              MOVS     r1,#0x64              ;1657
00000a  fbb0f2f1          UDIV     r2,r0,r1              ;1657
00000e  fb010112          MLS      r1,r1,r2,r0           ;1657
000012  b109              CBZ      r1,|L23.24|
000014  2001              MOVS     r0,#1                 ;1659
000016  4770              BX       lr
                  |L23.24|
000018  f44f71c8          MOV      r1,#0x190             ;1662
00001c  fbb0f2f1          UDIV     r2,r0,r1              ;1662
000020  fb010012          MLS      r0,r1,r2,r0           ;1662
000024  b108              CBZ      r0,|L23.42|
000026  2000              MOVS     r0,#0                 ;1668
000028  4770              BX       lr
                  |L23.42|
00002a  2001              MOVS     r0,#1                 ;1664
00002c  4770              BX       lr
;;;1671   
                          ENDP


                          AREA ||i.RTC_ReadAlarmCounter||, CODE, READONLY, ALIGN=1

                  RTC_ReadAlarmCounter PROC
;;;1421     */
;;;1422   static uint32_t RTC_ReadAlarmCounter(RTC_HandleTypeDef* hrtc)
000000  6800              LDR      r0,[r0,#0]
;;;1423   {
;;;1424     uint16_t high1 = 0U, low = 0U;
;;;1425   
;;;1426     high1 = READ_REG(hrtc->Instance->ALRH & RTC_CNTH_RTC_CNT);
000002  6a01              LDR      r1,[r0,#0x20]
;;;1427     low   = READ_REG(hrtc->Instance->ALRL & RTC_CNTL_RTC_CNT);
000004  6a40              LDR      r0,[r0,#0x24]
000006  b280              UXTH     r0,r0
;;;1428   
;;;1429     return (((uint32_t) high1 << 16U) | low);
000008  ea404001          ORR      r0,r0,r1,LSL #16
;;;1430   }
00000c  4770              BX       lr
;;;1431   
                          ENDP


                          AREA ||i.RTC_ReadTimeCounter||, CODE, READONLY, ALIGN=1

                  RTC_ReadTimeCounter PROC
;;;1359     */
;;;1360   static uint32_t RTC_ReadTimeCounter(RTC_HandleTypeDef* hrtc)
000000  6800              LDR      r0,[r0,#0]
;;;1361   {
;;;1362     uint16_t high1 = 0U, high2 = 0U, low = 0U;
;;;1363     uint32_t timecounter = 0U;
;;;1364   
;;;1365     high1 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
000002  6981              LDR      r1,[r0,#0x18]
000004  b289              UXTH     r1,r1
;;;1366     low   = READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT);
000006  69c2              LDR      r2,[r0,#0x1c]
000008  b293              UXTH     r3,r2
;;;1367     high2 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
00000a  6982              LDR      r2,[r0,#0x18]
00000c  b292              UXTH     r2,r2
;;;1368   
;;;1369     if (high1 != high2)
00000e  4291              CMP      r1,r2
000010  d003              BEQ      |L25.26|
;;;1370     { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
;;;1371          read again CNTL register then return the counter value */
;;;1372       timecounter = (((uint32_t) high2 << 16U) | READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT));
000012  69c0              LDR      r0,[r0,#0x1c]
000014  f362401f          BFI      r0,r2,#16,#16
;;;1373     }
;;;1374     else
;;;1375     { /* No counter roll over during reading of CNTL and CNTH registers, counter 
;;;1376          value is equal to first value of CNTL and CNTH */
;;;1377       timecounter = (((uint32_t) high1 << 16U) | low);
;;;1378     }
;;;1379   
;;;1380     return timecounter;
;;;1381   }
000018  4770              BX       lr
                  |L25.26|
00001a  ea434001          ORR      r0,r3,r1,LSL #16      ;1377
00001e  4770              BX       lr
;;;1382   
                          ENDP


                          AREA ||i.RTC_WeekDayNum||, CODE, READONLY, ALIGN=1

                  RTC_WeekDayNum PROC
;;;1686     */
;;;1687   static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1688   {
;;;1689     uint32_t year = 0U, weekday = 0U;
;;;1690   
;;;1691     year = 2000U + nYear;
000002  f50060fa          ADD      r0,r0,#0x7d0
;;;1692     
;;;1693     if(nMonth < 3U)
;;;1694     {
;;;1695       /*D = { [(23 x month)/9] + day + 4 + year + [(year-1)/4] - [(year-1)/100] + [(year-1)/400] } mod 7*/
;;;1696       weekday = (((23U * nMonth)/9U) + nDay + 4U + year + ((year-1U)/4U) - ((year-1U)/100U) + ((year-1U)/400U)) % 7U;
000006  2764              MOVS     r7,#0x64
000008  ebc103c1          RSB      r3,r1,r1,LSL #3
00000c  2509              MOVS     r5,#9
00000e  00be              LSLS     r6,r7,#2
000010  2407              MOVS     r4,#7
000012  eb031301          ADD      r3,r3,r1,LSL #4
000016  2903              CMP      r1,#3                 ;1693
000018  d212              BCS      |L26.64|
00001a  fbb3f1f5          UDIV     r1,r3,r5
00001e  4411              ADD      r1,r1,r2
000020  4401              ADD      r1,r1,r0
000022  1e40              SUBS     r0,r0,#1
000024  fbb0f2f7          UDIV     r2,r0,r7
000028  eb010190          ADD      r1,r1,r0,LSR #2
00002c  fbb0f0f6          UDIV     r0,r0,r6
000030  1a89              SUBS     r1,r1,r2
000032  4408              ADD      r0,r0,r1
000034  1d00              ADDS     r0,r0,#4
000036  fbb0f1f4          UDIV     r1,r0,r4
00003a  fb040011          MLS      r0,r4,r1,r0
00003e  e010              B        |L26.98|
                  |L26.64|
;;;1697     }
;;;1698     else
;;;1699     {
;;;1700       /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
;;;1701       weekday = (((23U * nMonth)/9U) + nDay + 4U + year + (year/4U) - (year/100U) + (year/400U) - 2U ) % 7U; 
000040  fbb3f1f5          UDIV     r1,r3,r5
000044  4411              ADD      r1,r1,r2
000046  fbb0f2f7          UDIV     r2,r0,r7
00004a  4401              ADD      r1,r1,r0
00004c  eb010190          ADD      r1,r1,r0,LSR #2
000050  fbb0f0f6          UDIV     r0,r0,r6
000054  1a89              SUBS     r1,r1,r2
000056  4408              ADD      r0,r0,r1
000058  1c80              ADDS     r0,r0,#2
00005a  fbb0f1f4          UDIV     r1,r0,r4
00005e  fb040011          MLS      r0,r4,r1,r0
                  |L26.98|
;;;1702     }
;;;1703   
;;;1704     return (uint8_t)weekday;
000062  b2c0              UXTB     r0,r0
;;;1705   }
000064  bdf0              POP      {r4-r7,pc}
;;;1706   
                          ENDP


                          AREA ||i.RTC_WriteAlarmCounter||, CODE, READONLY, ALIGN=1

                  RTC_WriteAlarmCounter PROC
;;;1438     */
;;;1439   static HAL_StatusTypeDef RTC_WriteAlarmCounter(RTC_HandleTypeDef* hrtc, uint32_t AlarmCounter)
000000  b570              PUSH     {r4-r6,lr}
;;;1440   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1441     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;1442     
;;;1443     /* Set Initialization mode */
;;;1444     if(RTC_EnterInitMode(hrtc) != HAL_OK)
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       RTC_EnterInitMode
00000e  b108              CBZ      r0,|L27.20|
;;;1445     {
;;;1446       status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e00a              B        |L27.42|
                  |L27.20|
;;;1447     } 
;;;1448     else
;;;1449     {
;;;1450       /* Set RTC COUNTER MSB word */
;;;1451       WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16U));
000014  6829              LDR      r1,[r5,#0]
000016  0c30              LSRS     r0,r6,#16
000018  6208              STR      r0,[r1,#0x20]
;;;1452       /* Set RTC COUNTER LSB word */
;;;1453       WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
00001a  6829              LDR      r1,[r5,#0]
00001c  b2b0              UXTH     r0,r6
00001e  6248              STR      r0,[r1,#0x24]
;;;1454       
;;;1455       /* Wait for synchro */
;;;1456       if(RTC_ExitInitMode(hrtc) != HAL_OK)
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       RTC_ExitInitMode
000026  b100              CBZ      r0,|L27.42|
;;;1457       {       
;;;1458         status = HAL_ERROR;
000028  2401              MOVS     r4,#1
                  |L27.42|
;;;1459       }
;;;1460     }
;;;1461   
;;;1462     return status;
00002a  4620              MOV      r0,r4
;;;1463   }
00002c  bd70              POP      {r4-r6,pc}
;;;1464   
                          ENDP


                          AREA ||i.RTC_WriteTimeCounter||, CODE, READONLY, ALIGN=1

                  RTC_WriteTimeCounter PROC
;;;1389     */
;;;1390   static HAL_StatusTypeDef RTC_WriteTimeCounter(RTC_HandleTypeDef* hrtc, uint32_t TimeCounter)
000000  b570              PUSH     {r4-r6,lr}
;;;1391   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1392     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;1393     
;;;1394     /* Set Initialization mode */
;;;1395     if(RTC_EnterInitMode(hrtc) != HAL_OK)
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       RTC_EnterInitMode
00000e  b108              CBZ      r0,|L28.20|
;;;1396     {
;;;1397       status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e00a              B        |L28.42|
                  |L28.20|
;;;1398     } 
;;;1399     else
;;;1400     {
;;;1401       /* Set RTC COUNTER MSB word */
;;;1402       WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16U));
000014  6829              LDR      r1,[r5,#0]
000016  0c30              LSRS     r0,r6,#16
000018  6188              STR      r0,[r1,#0x18]
;;;1403       /* Set RTC COUNTER LSB word */
;;;1404       WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
00001a  6829              LDR      r1,[r5,#0]
00001c  b2b0              UXTH     r0,r6
00001e  61c8              STR      r0,[r1,#0x1c]
;;;1405       
;;;1406       /* Wait for synchro */
;;;1407       if(RTC_ExitInitMode(hrtc) != HAL_OK)
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       RTC_ExitInitMode
000026  b100              CBZ      r0,|L28.42|
;;;1408       {       
;;;1409         status = HAL_ERROR;
000028  2401              MOVS     r4,#1
                  |L28.42|
;;;1410       }
;;;1411     }
;;;1412   
;;;1413     return status;
00002a  4620              MOV      r0,r4
;;;1414   }
00002c  bd70              POP      {r4-r6,pc}
;;;1415   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH|
#line 456
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX|
#line 643
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
