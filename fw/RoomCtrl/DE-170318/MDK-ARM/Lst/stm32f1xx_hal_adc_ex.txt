; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_adc_ex.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_adc_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_adc_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc_ex.c]
                          THUMB

                          AREA ||i.HAL_ADCEx_Calibration_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_Calibration_Start PROC
;;;143      */
;;;144    HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;145    {
000002  4604              MOV      r4,r0
;;;146      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;147      uint32_t tickstart;
;;;148      __IO uint32_t wait_loop_index = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;149      
;;;150      /* Check the parameters */
;;;151      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;152    
;;;153      /* Process locked */
;;;154      __HAL_LOCK(hadc);
000008  f8940024          LDRB     r0,[r4,#0x24]
00000c  2801              CMP      r0,#1
00000e  d009              BEQ      |L1.36|
000010  2001              MOVS     r0,#1
000012  f8840024          STRB     r0,[r4,#0x24]
;;;155        
;;;156      /* 1. Calibration prerequisite:                                             */
;;;157      /*    - ADC must be disabled for at least two ADC clock cycles in disable   */
;;;158      /*      mode before ADC enable                                              */
;;;159      /* Stop potential conversion on going, on regular and injected groups       */
;;;160      /* Disable ADC peripheral */
;;;161      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       ADC_ConversionStop_Disable
00001c  4607              MOV      r7,r0
;;;162      
;;;163      /* Check if ADC is effectively disabled */
;;;164      if (tmp_hal_status == HAL_OK)
00001e  0038              MOVS     r0,r7
000020  d002              BEQ      |L1.40|
000022  e058              B        |L1.214|
                  |L1.36|
000024  2002              MOVS     r0,#2                 ;154
;;;165      {
;;;166        /* Set ADC state */
;;;167        ADC_STATE_CLR_SET(hadc->State,
;;;168                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;169                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;170        
;;;171        /* Hardware prerequisite: delay before starting the calibration.          */
;;;172        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles.  */
;;;173        /*  - Wait for the expected ADC clock cycles delay */
;;;174        wait_loop_index = ((SystemCoreClock
;;;175                            / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;176                           * ADC_PRECALIBRATION_DELAY_ADCCLOCKCYCLES        );
;;;177    
;;;178        while(wait_loop_index != 0U)
;;;179        {
;;;180          wait_loop_index--;
;;;181        }
;;;182        
;;;183        /* 2. Enable the ADC peripheral */
;;;184        ADC_Enable(hadc);
;;;185        
;;;186        /* 3. Resets ADC calibration registers */  
;;;187        SET_BIT(hadc->Instance->CR2, ADC_CR2_RSTCAL);
;;;188        
;;;189        tickstart = HAL_GetTick();  
;;;190    
;;;191        /* Wait for calibration reset completion */
;;;192        while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_RSTCAL))
;;;193        {
;;;194          if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
;;;195          {
;;;196            /* Update ADC state machine to error */
;;;197            ADC_STATE_CLR_SET(hadc->State,
;;;198                              HAL_ADC_STATE_BUSY_INTERNAL,
;;;199                              HAL_ADC_STATE_ERROR_INTERNAL);
;;;200            
;;;201            /* Process unlocked */
;;;202            __HAL_UNLOCK(hadc);
;;;203            
;;;204            return HAL_ERROR;
;;;205          }
;;;206        }
;;;207        
;;;208        
;;;209        /* 4. Start ADC calibration */
;;;210        SET_BIT(hadc->Instance->CR2, ADC_CR2_CAL);
;;;211        
;;;212        tickstart = HAL_GetTick();  
;;;213    
;;;214        /* Wait for calibration completion */
;;;215        while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_CAL))
;;;216        {
;;;217          if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
;;;218          {
;;;219            /* Update ADC state machine to error */
;;;220            ADC_STATE_CLR_SET(hadc->State,
;;;221                              HAL_ADC_STATE_BUSY_INTERNAL,
;;;222                              HAL_ADC_STATE_ERROR_INTERNAL);
;;;223            
;;;224            /* Process unlocked */
;;;225            __HAL_UNLOCK(hadc);
;;;226            
;;;227            return HAL_ERROR;
;;;228          }
;;;229        }
;;;230        
;;;231        /* Set ADC state */
;;;232        ADC_STATE_CLR_SET(hadc->State,
;;;233                          HAL_ADC_STATE_BUSY_INTERNAL,
;;;234                          HAL_ADC_STATE_READY);
;;;235      }
;;;236      
;;;237      /* Process unlocked */
;;;238      __HAL_UNLOCK(hadc);
;;;239      
;;;240      /* Return function status */
;;;241      return tmp_hal_status;
;;;242    }
000026  bdf8              POP      {r3-r7,pc}
                  |L1.40|
000028  6aa0              LDR      r0,[r4,#0x28]         ;167
00002a  f4205088          BIC      r0,r0,#0x1100         ;167
00002e  f0400002          ORR      r0,r0,#2              ;167
000032  62a0              STR      r0,[r4,#0x28]         ;167
000034  2002              MOVS     r0,#2                 ;174
000036  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
00003a  4929              LDR      r1,|L1.224|
00003c  6809              LDR      r1,[r1,#0]            ;174  ; SystemCoreClock
00003e  fbb1f0f0          UDIV     r0,r1,r0              ;174
000042  0040              LSLS     r0,r0,#1              ;174
000044  9000              STR      r0,[sp,#0]            ;174
000046  e002              B        |L1.78|
                  |L1.72|
000048  9800              LDR      r0,[sp,#0]            ;180
00004a  1e40              SUBS     r0,r0,#1              ;180
00004c  9000              STR      r0,[sp,#0]            ;180
                  |L1.78|
00004e  9800              LDR      r0,[sp,#0]            ;178
000050  2800              CMP      r0,#0                 ;178
000052  d1f9              BNE      |L1.72|
000054  4620              MOV      r0,r4                 ;184
000056  f7fffffe          BL       ADC_Enable
00005a  6820              LDR      r0,[r4,#0]            ;187
00005c  6881              LDR      r1,[r0,#8]            ;187
00005e  f0410108          ORR      r1,r1,#8              ;187
000062  6081              STR      r1,[r0,#8]            ;187
000064  f7fffffe          BL       HAL_GetTick
000068  4605              MOV      r5,r0                 ;189
00006a  e00e              B        |L1.138|
                  |L1.108|
00006c  f7fffffe          BL       HAL_GetTick
000070  1b40              SUBS     r0,r0,r5              ;194
000072  280a              CMP      r0,#0xa               ;194
000074  d909              BLS      |L1.138|
000076  6aa0              LDR      r0,[r4,#0x28]         ;197
000078  f0200002          BIC      r0,r0,#2              ;197
00007c  f0400010          ORR      r0,r0,#0x10           ;197
000080  62a0              STR      r0,[r4,#0x28]         ;197
000082  f8846024          STRB     r6,[r4,#0x24]         ;202
000086  2001              MOVS     r0,#1                 ;204
000088  bdf8              POP      {r3-r7,pc}
                  |L1.138|
00008a  6820              LDR      r0,[r4,#0]            ;192
00008c  6880              LDR      r0,[r0,#8]            ;192
00008e  0700              LSLS     r0,r0,#28             ;192
000090  d4ec              BMI      |L1.108|
000092  6820              LDR      r0,[r4,#0]            ;210
000094  6881              LDR      r1,[r0,#8]            ;210
000096  f0410104          ORR      r1,r1,#4              ;210
00009a  6081              STR      r1,[r0,#8]            ;210
00009c  f7fffffe          BL       HAL_GetTick
0000a0  4605              MOV      r5,r0                 ;212
0000a2  e00e              B        |L1.194|
                  |L1.164|
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  1b40              SUBS     r0,r0,r5              ;217
0000aa  280a              CMP      r0,#0xa               ;217
0000ac  d909              BLS      |L1.194|
0000ae  6aa0              LDR      r0,[r4,#0x28]         ;220
0000b0  f0200002          BIC      r0,r0,#2              ;220
0000b4  f0400010          ORR      r0,r0,#0x10           ;220
0000b8  62a0              STR      r0,[r4,#0x28]         ;220
0000ba  f8846024          STRB     r6,[r4,#0x24]         ;225
0000be  2001              MOVS     r0,#1                 ;227
0000c0  bdf8              POP      {r3-r7,pc}
                  |L1.194|
0000c2  6820              LDR      r0,[r4,#0]            ;215
0000c4  6880              LDR      r0,[r0,#8]            ;215
0000c6  0740              LSLS     r0,r0,#29             ;215
0000c8  d4ec              BMI      |L1.164|
0000ca  6aa0              LDR      r0,[r4,#0x28]         ;232
0000cc  f0200002          BIC      r0,r0,#2              ;232
0000d0  f0400001          ORR      r0,r0,#1              ;232
0000d4  62a0              STR      r0,[r4,#0x28]         ;232
                  |L1.214|
0000d6  f8846024          STRB     r6,[r4,#0x24]         ;238
0000da  4638              MOV      r0,r7                 ;241
0000dc  bdf8              POP      {r3-r7,pc}
;;;243    
                          ENDP

0000de  0000              DCW      0x0000
                  |L1.224|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_ADCEx_InjectedConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedConfigChannel PROC
;;;1013     */
;;;1014   HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1015   {
;;;1016     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000002  2200              MOVS     r2,#0
;;;1017     __IO uint32_t wait_loop_index = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;1018     
;;;1019     /* Check the parameters */
;;;1020     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1021     assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
;;;1022     assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
;;;1023     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
;;;1024     assert_param(IS_ADC_EXTTRIGINJEC(sConfigInjected->ExternalTrigInjecConv));
;;;1025     assert_param(IS_ADC_RANGE(sConfigInjected->InjectedOffset));
;;;1026     
;;;1027     if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
000008  6883              LDR      r3,[r0,#8]
;;;1028     {
;;;1029       assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
;;;1030       assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
;;;1031       assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
;;;1032     }
;;;1033     
;;;1034     /* Process locked */
;;;1035     __HAL_LOCK(hadc);
00000a  f8904024          LDRB     r4,[r0,#0x24]
00000e  2c01              CMP      r4,#1
000010  d01e              BEQ      |L2.80|
000012  2401              MOVS     r4,#1
000014  f8804024          STRB     r4,[r0,#0x24]
000018  b1e3              CBZ      r3,|L2.84|
;;;1036     
;;;1037     /* Configuration of injected group sequencer:                               */
;;;1038     /* - if scan mode is disabled, injected channels sequence length is set to  */
;;;1039     /*   0x00: 1 channel converted (channel on regular rank 1)                  */
;;;1040     /*   Parameter "InjectedNbrOfConversion" is discarded.                      */
;;;1041     /*   Note: Scan mode is present by hardware on this device and, if          */
;;;1042     /*   disabled, discards automatically nb of conversions. Anyway, nb of      */
;;;1043     /*   conversions is forced to 0x00 for alignment over all STM32 devices.    */
;;;1044     /* - if scan mode is enabled, injected channels sequence length is set to   */
;;;1045     /*   parameter "InjectedNbrOfConversion".                                   */
;;;1046     if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
;;;1047     {
;;;1048       if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
;;;1049       {
;;;1050         /* Clear the old SQx bits for all injected ranks */
;;;1051         MODIFY_REG(hadc->Instance->JSQR                             ,
;;;1052                    ADC_JSQR_JL   |
;;;1053                    ADC_JSQR_JSQ4 |
;;;1054                    ADC_JSQR_JSQ3 |
;;;1055                    ADC_JSQR_JSQ2 |
;;;1056                    ADC_JSQR_JSQ1                                    ,
;;;1057                    ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,
;;;1058                                     ADC_INJECTED_RANK_1,
;;;1059                                     0x01U));
;;;1060       }
;;;1061       /* If another injected rank than rank1 was intended to be set, and could  */
;;;1062       /* not due to ScanConvMode disabled, error is reported.                   */
;;;1063       else
;;;1064       {
;;;1065         /* Update ADC state machine to error */
;;;1066         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1067         
;;;1068         tmp_hal_status = HAL_ERROR;
;;;1069       }
;;;1070     }
;;;1071     else
;;;1072     {
;;;1073       /* Since injected channels rank conv. order depends on total number of   */
;;;1074       /* injected conversions, selected rank must be below or equal to total   */
;;;1075       /* number of injected conversions to be updated.                         */
;;;1076       if (sConfigInjected->InjectedRank <= sConfigInjected->InjectedNbrOfConversion)
00001a  684c              LDR      r4,[r1,#4]
00001c  690b              LDR      r3,[r1,#0x10]
;;;1077       {
;;;1078         /* Clear the old SQx bits for the selected rank */
;;;1079         /* Set the SQx bits for the selected rank */
;;;1080         MODIFY_REG(hadc->Instance->JSQR                                         ,
00001e  261f              MOVS     r6,#0x1f
000020  429c              CMP      r4,r3                 ;1076
000022  d829              BHI      |L2.120|
000024  1b1c              SUBS     r4,r3,r4
000026  f1c40403          RSB      r4,r4,#3
00002a  eb040484          ADD      r4,r4,r4,LSL #2
00002e  40a6              LSLS     r6,r6,r4
000030  f4461c40          ORR      r12,r6,#0x300000
000034  6806              LDR      r6,[r0,#0]
000036  6bb7              LDR      r7,[r6,#0x38]
000038  ea27070c          BIC      r7,r7,r12
00003c  f8d1c000          LDR      r12,[r1,#0]
000040  fa0cfc04          LSL      r12,r12,r4
000044  1e5b              SUBS     r3,r3,#1
000046  ea4c5303          ORR      r3,r12,r3,LSL #20
00004a  431f              ORRS     r7,r7,r3
00004c  63b7              STR      r7,[r6,#0x38]
00004e  e01f              B        |L2.144|
                  |L2.80|
000050  2002              MOVS     r0,#2                 ;1035
;;;1081                    
;;;1082                    ADC_JSQR_JL                                               |
;;;1083                    ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
;;;1084                                     sConfigInjected->InjectedRank,         
;;;1085                                     sConfigInjected->InjectedNbrOfConversion)   ,
;;;1086                    
;;;1087                    ADC_JSQR_JL_SHIFT(sConfigInjected->InjectedNbrOfConversion) |
;;;1088                    ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,      
;;;1089                                     sConfigInjected->InjectedRank,         
;;;1090                                     sConfigInjected->InjectedNbrOfConversion)    );
;;;1091       }
;;;1092       else
;;;1093       {
;;;1094         /* Clear the old SQx bits for the selected rank */
;;;1095         MODIFY_REG(hadc->Instance->JSQR                                       ,
;;;1096                    
;;;1097                    ADC_JSQR_JL                                               |
;;;1098                    ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
;;;1099                                     sConfigInjected->InjectedRank,         
;;;1100                                     sConfigInjected->InjectedNbrOfConversion) ,
;;;1101                    
;;;1102                    0x00000000U);
;;;1103       }
;;;1104     } 
;;;1105       
;;;1106     /* Configuration of injected group                                          */
;;;1107     /* Parameters update conditioned to ADC state:                              */
;;;1108     /* Parameters that can be updated only when ADC is disabled:                */
;;;1109     /*  - external trigger to start conversion                                  */
;;;1110     /* Parameters update not conditioned to ADC state:                          */
;;;1111     /*  - Automatic injected conversion                                         */
;;;1112     /*  - Injected discontinuous mode                                           */
;;;1113     /* Note: In case of ADC already enabled, caution to not launch an unwanted  */
;;;1114     /*       conversion while modifying register CR2 by writing 1 to bit ADON.  */
;;;1115     if (ADC_IS_ENABLE(hadc) == RESET)
;;;1116     {    
;;;1117       MODIFY_REG(hadc->Instance->CR2                                           ,
;;;1118                  ADC_CR2_JEXTSEL |
;;;1119                  ADC_CR2_ADON                                                  ,
;;;1120                  ADC_CFGR_JEXTSEL(hadc, sConfigInjected->ExternalTrigInjecConv) );
;;;1121     }
;;;1122     
;;;1123     
;;;1124     /* Configuration of injected group                                          */
;;;1125     /*  - Automatic injected conversion                                         */
;;;1126     /*  - Injected discontinuous mode                                           */
;;;1127     
;;;1128       /* Automatic injected conversion can be enabled if injected group         */
;;;1129       /* external triggers are disabled.                                        */
;;;1130       if (sConfigInjected->AutoInjectedConv == ENABLE)
;;;1131       {
;;;1132         if (sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
;;;1133         {
;;;1134           SET_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;1135         }
;;;1136         else
;;;1137         {
;;;1138           /* Update ADC state machine to error */
;;;1139           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1140           
;;;1141           tmp_hal_status = HAL_ERROR;
;;;1142         }
;;;1143       }
;;;1144       
;;;1145       /* Injected discontinuous can be enabled only if auto-injected mode is    */
;;;1146       /* disabled.                                                              */  
;;;1147       if (sConfigInjected->InjectedDiscontinuousConvMode == ENABLE)
;;;1148       {
;;;1149         if (sConfigInjected->AutoInjectedConv == DISABLE)
;;;1150         {
;;;1151           SET_BIT(hadc->Instance->CR1, ADC_CR1_JDISCEN);
;;;1152         } 
;;;1153         else
;;;1154         {
;;;1155           /* Update ADC state machine to error */
;;;1156           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1157           
;;;1158           tmp_hal_status = HAL_ERROR;
;;;1159         }
;;;1160       }
;;;1161   
;;;1162   
;;;1163     /* InjectedChannel sampling time configuration */
;;;1164     /* For channels 10 to 17 */
;;;1165     if (sConfigInjected->InjectedChannel >= ADC_CHANNEL_10)
;;;1166     {
;;;1167       MODIFY_REG(hadc->Instance->SMPR1                                                             ,
;;;1168                  ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel)                      ,
;;;1169                  ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
;;;1170     }
;;;1171     else /* For channels 0 to 9 */
;;;1172     {
;;;1173       MODIFY_REG(hadc->Instance->SMPR2                                                             ,
;;;1174                  ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel)                       ,
;;;1175                  ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
;;;1176     }
;;;1177     
;;;1178     /* If ADC1 InjectedChannel_16 or InjectedChannel_17 is selected, enable Temperature sensor  */
;;;1179     /* and VREFINT measurement path.                                            */
;;;1180     if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1181         (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
;;;1182     {
;;;1183       SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1184     }
;;;1185     
;;;1186     
;;;1187     /* Configure the offset: offset enable/disable, InjectedChannel, offset value */
;;;1188     switch(sConfigInjected->InjectedRank)
;;;1189     {
;;;1190       case 1:
;;;1191         /* Set injected channel 1 offset */
;;;1192         MODIFY_REG(hadc->Instance->JOFR1,
;;;1193                    ADC_JOFR1_JOFFSET1,
;;;1194                    sConfigInjected->InjectedOffset);
;;;1195         break;
;;;1196       case 2:
;;;1197         /* Set injected channel 2 offset */
;;;1198         MODIFY_REG(hadc->Instance->JOFR2,
;;;1199                    ADC_JOFR2_JOFFSET2,
;;;1200                    sConfigInjected->InjectedOffset);
;;;1201         break;
;;;1202       case 3:
;;;1203         /* Set injected channel 3 offset */
;;;1204         MODIFY_REG(hadc->Instance->JOFR3,
;;;1205                    ADC_JOFR3_JOFFSET3,
;;;1206                    sConfigInjected->InjectedOffset);
;;;1207         break;
;;;1208       case 4:
;;;1209       default:
;;;1210         MODIFY_REG(hadc->Instance->JOFR4,
;;;1211                    ADC_JOFR4_JOFFSET4,
;;;1212                    sConfigInjected->InjectedOffset);
;;;1213         break;
;;;1214     }
;;;1215     
;;;1216     /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
;;;1217     /* and VREFINT measurement path.                                            */
;;;1218     if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1219         (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
;;;1220     {
;;;1221       /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
;;;1222       /* measurement channels (VrefInt/TempSensor). If these channels are       */
;;;1223       /* intended to be set on other ADC instances, an error is reported.       */
;;;1224       if (hadc->Instance == ADC1)
;;;1225       {
;;;1226         if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
;;;1227         {
;;;1228           SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1229           
;;;1230           if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR))
;;;1231           {
;;;1232             /* Delay for temperature sensor stabilization time */
;;;1233             /* Compute number of CPU cycles to wait for */
;;;1234             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1235             while(wait_loop_index != 0U)
;;;1236             {
;;;1237               wait_loop_index--;
;;;1238             }
;;;1239           }
;;;1240         }
;;;1241       }
;;;1242       else
;;;1243       {
;;;1244         /* Update ADC state machine to error */
;;;1245         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1246         
;;;1247         tmp_hal_status = HAL_ERROR;
;;;1248       }
;;;1249     }
;;;1250     
;;;1251     /* Process unlocked */
;;;1252     __HAL_UNLOCK(hadc);
;;;1253     
;;;1254     /* Return function status */
;;;1255     return tmp_hal_status;
;;;1256   }
000052  bdf8              POP      {r3-r7,pc}
                  |L2.84|
000054  684b              LDR      r3,[r1,#4]            ;1048
000056  2b01              CMP      r3,#1                 ;1048
000058  d005              BEQ      |L2.102|
00005a  6a82              LDR      r2,[r0,#0x28]         ;1066
00005c  f0420220          ORR      r2,r2,#0x20           ;1066
000060  6282              STR      r2,[r0,#0x28]         ;1066
000062  2201              MOVS     r2,#1                 ;1068
000064  e014              B        |L2.144|
                  |L2.102|
000066  6803              LDR      r3,[r0,#0]            ;1051
000068  6b9c              LDR      r4,[r3,#0x38]         ;1051
00006a  680e              LDR      r6,[r1,#0]            ;1051
00006c  f36f0415          BFC      r4,#0,#22             ;1051
000070  ea4434c6          ORR      r4,r4,r6,LSL #15      ;1051
000074  639c              STR      r4,[r3,#0x38]         ;1051
000076  e00b              B        |L2.144|
                  |L2.120|
000078  1b1b              SUBS     r3,r3,r4              ;1095
00007a  f1c30303          RSB      r3,r3,#3              ;1095
00007e  eb030383          ADD      r3,r3,r3,LSL #2       ;1095
000082  409e              LSLS     r6,r6,r3              ;1095
000084  6803              LDR      r3,[r0,#0]            ;1095
000086  f4461640          ORR      r6,r6,#0x300000       ;1095
00008a  6b9c              LDR      r4,[r3,#0x38]         ;1095
00008c  43b4              BICS     r4,r4,r6              ;1095
00008e  639c              STR      r4,[r3,#0x38]         ;1095
                  |L2.144|
000090  6803              LDR      r3,[r0,#0]            ;1115
000092  689c              LDR      r4,[r3,#8]            ;1115
000094  43e4              MVNS     r4,r4                 ;1115
000096  07e4              LSLS     r4,r4,#31             ;1115
000098  d006              BEQ      |L2.168|
00009a  689c              LDR      r4,[r3,#8]            ;1117
00009c  f2470601          MOV      r6,#0x7001            ;1117
0000a0  43b4              BICS     r4,r4,r6              ;1117
0000a2  69ce              LDR      r6,[r1,#0x1c]         ;1117
0000a4  4334              ORRS     r4,r4,r6              ;1117
0000a6  609c              STR      r4,[r3,#8]            ;1117
                  |L2.168|
0000a8  698b              LDR      r3,[r1,#0x18]         ;1130
0000aa  2b01              CMP      r3,#1                 ;1130
0000ac  d108              BNE      |L2.192|
0000ae  69cb              LDR      r3,[r1,#0x1c]         ;1132
0000b0  f5b34fe0          CMP      r3,#0x7000            ;1132
0000b4  d008              BEQ      |L2.200|
0000b6  6a82              LDR      r2,[r0,#0x28]         ;1139
0000b8  f0420220          ORR      r2,r2,#0x20           ;1139
0000bc  6282              STR      r2,[r0,#0x28]         ;1139
0000be  2201              MOVS     r2,#1                 ;1141
                  |L2.192|
0000c0  694b              LDR      r3,[r1,#0x14]         ;1147
0000c2  2b01              CMP      r3,#1                 ;1147
0000c4  d006              BEQ      |L2.212|
0000c6  e00c              B        |L2.226|
                  |L2.200|
0000c8  6803              LDR      r3,[r0,#0]            ;1134
0000ca  685c              LDR      r4,[r3,#4]            ;1134
0000cc  f4446480          ORR      r4,r4,#0x400          ;1134
0000d0  605c              STR      r4,[r3,#4]            ;1134
0000d2  e7f5              B        |L2.192|
                  |L2.212|
0000d4  698b              LDR      r3,[r1,#0x18]         ;1149
0000d6  b1a3              CBZ      r3,|L2.258|
0000d8  6a82              LDR      r2,[r0,#0x28]         ;1156
0000da  f0420220          ORR      r2,r2,#0x20           ;1156
0000de  6282              STR      r2,[r0,#0x28]         ;1156
0000e0  2201              MOVS     r2,#1                 ;1158
                  |L2.226|
0000e2  680b              LDR      r3,[r1,#0]            ;1165
0000e4  2607              MOVS     r6,#7                 ;1167
0000e6  2b0a              CMP      r3,#0xa               ;1165
0000e8  d311              BCC      |L2.270|
0000ea  6804              LDR      r4,[r0,#0]            ;1167
0000ec  68e7              LDR      r7,[r4,#0xc]          ;1167
0000ee  3b0a              SUBS     r3,r3,#0xa            ;1167
0000f0  eb030343          ADD      r3,r3,r3,LSL #1       ;1167
0000f4  409e              LSLS     r6,r6,r3              ;1167
0000f6  43b7              BICS     r7,r7,r6              ;1167
0000f8  688e              LDR      r6,[r1,#8]            ;1167
0000fa  409e              LSLS     r6,r6,r3              ;1167
0000fc  4337              ORRS     r7,r7,r6              ;1167
0000fe  60e7              STR      r7,[r4,#0xc]          ;1167
000100  e00f              B        |L2.290|
                  |L2.258|
000102  6803              LDR      r3,[r0,#0]            ;1151
000104  685c              LDR      r4,[r3,#4]            ;1151
000106  f4445480          ORR      r4,r4,#0x1000         ;1151
00010a  605c              STR      r4,[r3,#4]            ;1151
00010c  e7e9              B        |L2.226|
                  |L2.270|
00010e  6804              LDR      r4,[r0,#0]            ;1173
000110  6927              LDR      r7,[r4,#0x10]         ;1173
000112  eb030343          ADD      r3,r3,r3,LSL #1       ;1173
000116  409e              LSLS     r6,r6,r3              ;1173
000118  43b7              BICS     r7,r7,r6              ;1173
00011a  688e              LDR      r6,[r1,#8]            ;1173
00011c  409e              LSLS     r6,r6,r3              ;1173
00011e  4337              ORRS     r7,r7,r6              ;1173
000120  6127              STR      r7,[r4,#0x10]         ;1173
                  |L2.290|
000122  680b              LDR      r3,[r1,#0]            ;1180
000124  2b10              CMP      r3,#0x10              ;1180
000126  d001              BEQ      |L2.300|
000128  2b11              CMP      r3,#0x11              ;1181
00012a  d104              BNE      |L2.310|
                  |L2.300|
00012c  6803              LDR      r3,[r0,#0]            ;1183
00012e  689c              LDR      r4,[r3,#8]            ;1183
000130  f4440400          ORR      r4,r4,#0x800000       ;1183
000134  609c              STR      r4,[r3,#8]            ;1183
                  |L2.310|
000136  684b              LDR      r3,[r1,#4]            ;1188
000138  2b01              CMP      r3,#1                 ;1188
00013a  d010              BEQ      |L2.350|
00013c  2b02              CMP      r3,#2                 ;1188
00013e  d016              BEQ      |L2.366|
000140  2b03              CMP      r3,#3                 ;1188
000142  d01c              BEQ      |L2.382|
000144  6803              LDR      r3,[r0,#0]            ;1210
000146  6a1c              LDR      r4,[r3,#0x20]         ;1210
000148  68ce              LDR      r6,[r1,#0xc]          ;1210
00014a  f36f040b          BFC      r4,#0,#12             ;1210
00014e  4334              ORRS     r4,r4,r6              ;1210
000150  621c              STR      r4,[r3,#0x20]         ;1210
                  |L2.338|
000152  680b              LDR      r3,[r1,#0]            ;1218
000154  2b10              CMP      r3,#0x10              ;1218
000156  d01a              BEQ      |L2.398|
000158  2b11              CMP      r3,#0x11              ;1219
00015a  d018              BEQ      |L2.398|
00015c  e03b              B        |L2.470|
                  |L2.350|
00015e  6803              LDR      r3,[r0,#0]            ;1192
000160  695c              LDR      r4,[r3,#0x14]         ;1192
000162  68ce              LDR      r6,[r1,#0xc]          ;1192
000164  f36f040b          BFC      r4,#0,#12             ;1192
000168  4334              ORRS     r4,r4,r6              ;1192
00016a  615c              STR      r4,[r3,#0x14]         ;1192
00016c  e7f1              B        |L2.338|
                  |L2.366|
00016e  6803              LDR      r3,[r0,#0]            ;1198
000170  699c              LDR      r4,[r3,#0x18]         ;1198
000172  68ce              LDR      r6,[r1,#0xc]          ;1198
000174  f36f040b          BFC      r4,#0,#12             ;1198
000178  4334              ORRS     r4,r4,r6              ;1198
00017a  619c              STR      r4,[r3,#0x18]         ;1198
00017c  e7e9              B        |L2.338|
                  |L2.382|
00017e  6803              LDR      r3,[r0,#0]            ;1204
000180  69dc              LDR      r4,[r3,#0x1c]         ;1204
000182  68ce              LDR      r6,[r1,#0xc]          ;1204
000184  f36f040b          BFC      r4,#0,#12             ;1204
000188  4334              ORRS     r4,r4,r6              ;1204
00018a  61dc              STR      r4,[r3,#0x1c]         ;1204
00018c  e7e1              B        |L2.338|
                  |L2.398|
00018e  4c14              LDR      r4,|L2.480|
000190  6803              LDR      r3,[r0,#0]            ;1224
000192  42a3              CMP      r3,r4                 ;1224
000194  d11a              BNE      |L2.460|
000196  689c              LDR      r4,[r3,#8]            ;1226
000198  0224              LSLS     r4,r4,#8              ;1226
00019a  d41c              BMI      |L2.470|
00019c  689c              LDR      r4,[r3,#8]            ;1228
00019e  f4440400          ORR      r4,r4,#0x800000       ;1228
0001a2  609c              STR      r4,[r3,#8]            ;1228
0001a4  6809              LDR      r1,[r1,#0]            ;1230
0001a6  2910              CMP      r1,#0x10              ;1230
0001a8  d115              BNE      |L2.470|
0001aa  490e              LDR      r1,|L2.484|
0001ac  4b0e              LDR      r3,|L2.488|
0001ae  6809              LDR      r1,[r1,#0]            ;1234  ; SystemCoreClock
0001b0  fbb1f1f3          UDIV     r1,r1,r3              ;1234
0001b4  eb010181          ADD      r1,r1,r1,LSL #2       ;1234
0001b8  0049              LSLS     r1,r1,#1              ;1234
0001ba  9100              STR      r1,[sp,#0]            ;1234
0001bc  e002              B        |L2.452|
                  |L2.446|
0001be  9900              LDR      r1,[sp,#0]            ;1237
0001c0  1e49              SUBS     r1,r1,#1              ;1237
0001c2  9100              STR      r1,[sp,#0]            ;1237
                  |L2.452|
0001c4  9900              LDR      r1,[sp,#0]            ;1235
0001c6  2900              CMP      r1,#0                 ;1235
0001c8  d1f9              BNE      |L2.446|
0001ca  e004              B        |L2.470|
                  |L2.460|
0001cc  6a81              LDR      r1,[r0,#0x28]         ;1245
0001ce  f0410120          ORR      r1,r1,#0x20           ;1245
0001d2  6281              STR      r1,[r0,#0x28]         ;1245
0001d4  2201              MOVS     r2,#1                 ;1247
                  |L2.470|
0001d6  f8805024          STRB     r5,[r0,#0x24]         ;1252
0001da  4610              MOV      r0,r2                 ;1255
0001dc  bdf8              POP      {r3-r7,pc}
;;;1257   
                          ENDP

0001de  0000              DCW      0x0000
                  |L2.480|
                          DCD      0x40012400
                  |L2.484|
                          DCD      SystemCoreClock
                  |L2.488|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADCEx_InjectedConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedConvCpltCallback PROC
;;;971      */
;;;972    __WEAK void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;973    {
;;;974      /* Prevent unused argument(s) compilation warning */
;;;975      UNUSED(hadc);
;;;976      /* NOTE : This function Should not be modified, when the callback is needed,
;;;977                the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
;;;978      */
;;;979    }
;;;980    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedGetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedGetValue PROC
;;;902      */
;;;903    uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
000000  6800              LDR      r0,[r0,#0]
;;;904    {
;;;905      uint32_t tmp_jdr = 0U;
;;;906      
;;;907      /* Check the parameters */
;;;908      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;909      assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
;;;910      
;;;911      /* Get ADC converted value */ 
;;;912      switch(InjectedRank)
000002  2902              CMP      r1,#2
000004  d009              BEQ      |L4.26|
000006  2903              CMP      r1,#3
000008  d005              BEQ      |L4.22|
00000a  2904              CMP      r1,#4
00000c  d001              BEQ      |L4.18|
;;;913      {  
;;;914        case ADC_INJECTED_RANK_4: 
;;;915          tmp_jdr = hadc->Instance->JDR4;
;;;916          break;
;;;917        case ADC_INJECTED_RANK_3: 
;;;918          tmp_jdr = hadc->Instance->JDR3;
;;;919          break;
;;;920        case ADC_INJECTED_RANK_2: 
;;;921          tmp_jdr = hadc->Instance->JDR2;
;;;922          break;
;;;923        case ADC_INJECTED_RANK_1:
;;;924        default:
;;;925          tmp_jdr = hadc->Instance->JDR1;
00000e  6bc0              LDR      r0,[r0,#0x3c]
;;;926          break;
;;;927      }
;;;928      
;;;929      /* Return ADC converted value */ 
;;;930      return tmp_jdr;
;;;931    }
000010  4770              BX       lr
                  |L4.18|
000012  6c80              LDR      r0,[r0,#0x48]         ;915
000014  4770              BX       lr
                  |L4.22|
000016  6c40              LDR      r0,[r0,#0x44]         ;918
000018  4770              BX       lr
                  |L4.26|
00001a  6c00              LDR      r0,[r0,#0x40]         ;921
00001c  4770              BX       lr
;;;932    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedPollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedPollForConversion PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;403    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;404      uint32_t tickstart;
;;;405    
;;;406      /* Variables for polling in case of scan mode enabled and polling for each  */
;;;407      /* conversion.                                                              */
;;;408      __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
000008  2700              MOVS     r7,#0
00000a  9700              STR      r7,[sp,#0]
;;;409      uint32_t Conversion_Timeout_CPU_cycles_max = 0U;
;;;410      
;;;411      /* Check the parameters */
;;;412      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;413    
;;;414      /* Get timeout */
;;;415      tickstart = HAL_GetTick();  
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;416         
;;;417      /* Polling for end of conversion: differentiation if single/sequence        */
;;;418      /* conversion.                                                              */
;;;419      /* For injected group, flag JEOC is set only at the end of the sequence,    */
;;;420      /* not for each conversion within the sequence.                             */
;;;421      /*  - If single conversion for injected group (scan mode disabled or        */
;;;422      /*    InjectedNbrOfConversion ==1), flag JEOC is used to determine the      */
;;;423      /*    conversion completion.                                                */
;;;424      /*  - If sequence conversion for injected group (scan mode enabled and      */
;;;425      /*    InjectedNbrOfConversion >=2), flag JEOC is set only at the end of the */
;;;426      /*    sequence.                                                             */
;;;427      /*    To poll for each conversion, the maximum conversion time is computed  */
;;;428      /*    from ADC conversion time (selected sampling time + conversion time of */
;;;429      /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
;;;430      /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
;;;431      /*    As flag JEOC is not set after each conversion, no timeout status can  */
;;;432      /*    be set.                                                               */
;;;433      if ((hadc->Instance->JSQR & ADC_JSQR_JL) == RESET)
000012  6820              LDR      r0,[r4,#0]
000014  6b80              LDR      r0,[r0,#0x38]
000016  f4101f40          TST      r0,#0x300000
00001a  d02e              BEQ      |L5.122|
;;;434      {
;;;435        /* Wait until End of Conversion flag is raised */
;;;436        while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
;;;437        {
;;;438          /* Check if timeout is disabled (set to infinite wait) */
;;;439          if(Timeout != HAL_MAX_DELAY)
;;;440          {
;;;441            if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;442            {
;;;443              /* Update ADC state machine to timeout */
;;;444              SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;445              
;;;446              /* Process unlocked */
;;;447              __HAL_UNLOCK(hadc);
;;;448              
;;;449              return HAL_TIMEOUT;
;;;450            }
;;;451          }
;;;452        }
;;;453      }
;;;454      else
;;;455      {
;;;456        /* Replace polling by wait for maximum conversion time */
;;;457        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
;;;458        /*    and ADC maximum conversion cycles on all channels.                  */
;;;459        /*  - Wait for the expected ADC clock cycles delay                        */
;;;460        Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000022  4940              LDR      r1,|L5.292|
000024  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000026  fbb1f8f0          UDIV     r8,r1,r0
00002a  6820              LDR      r0,[r4,#0]
00002c  6902              LDR      r2,[r0,#0x10]
00002e  493e              LDR      r1,|L5.296|
000030  420a              TST      r2,r1
;;;461                                              / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;462                                             * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
000032  ea4f0161          ASR      r1,r1,#1
000036  ea4f13a1          ASR      r3,r1,#6
00003a  d123              BNE      |L5.132|
00003c  68c2              LDR      r2,[r0,#0xc]
00003e  ea4f1c61          ASR      r12,r1,#5
000042  ea120f0c          TST      r2,r12
000046  d11d              BNE      |L5.132|
000048  6902              LDR      r2,[r0,#0x10]
00004a  420a              TST      r2,r1
00004c  d129              BNE      |L5.162|
00004e  68c0              LDR      r0,[r0,#0xc]
000050  4218              TST      r0,r3
000052  d126              BNE      |L5.162|
000054  2014              MOVS     r0,#0x14
000056  e027              B        |L5.168|
                  |L5.88|
000058  1c68              ADDS     r0,r5,#1              ;439
00005a  d00e              BEQ      |L5.122|
00005c  b125              CBZ      r5,|L5.104|
00005e  f7fffffe          BL       HAL_GetTick
000062  1b80              SUBS     r0,r0,r6              ;441
000064  42a8              CMP      r0,r5                 ;441
000066  d908              BLS      |L5.122|
                  |L5.104|
000068  6aa0              LDR      r0,[r4,#0x28]         ;444
00006a  f0400004          ORR      r0,r0,#4              ;444
00006e  62a0              STR      r0,[r4,#0x28]         ;444
000070  f8847024          STRB     r7,[r4,#0x24]         ;447
000074  2003              MOVS     r0,#3                 ;449
                  |L5.118|
;;;463        
;;;464        while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;465        {
;;;466          /* Check if timeout is disabled (set to infinite wait) */
;;;467          if(Timeout != HAL_MAX_DELAY)
;;;468          {
;;;469            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;470            {
;;;471              /* Update ADC state machine to timeout */
;;;472              SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;473    
;;;474              /* Process unlocked */
;;;475              __HAL_UNLOCK(hadc);
;;;476              
;;;477              return HAL_TIMEOUT;
;;;478            }
;;;479          }
;;;480          Conversion_Timeout_CPU_cycles ++;
;;;481        }
;;;482      }
;;;483    
;;;484      /* Clear injected group conversion flag */
;;;485      /* Note: On STM32F1 ADC, clear regular conversion flag raised               */
;;;486      /* simultaneously.                                                          */
;;;487      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC | ADC_FLAG_EOC);
;;;488      
;;;489      /* Update ADC state machine */
;;;490      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
;;;491      
;;;492      /* Determine whether any further conversion upcoming on group injected      */
;;;493      /* by external trigger or by automatic injected conversion                  */
;;;494      /* from group regular.                                                      */
;;;495      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
;;;496         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
;;;497         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
;;;498          (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
;;;499      {
;;;500        /* Set ADC state */
;;;501        CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
;;;502        
;;;503        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;504        {
;;;505          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;506        }
;;;507      }
;;;508      
;;;509      /* Return ADC state */
;;;510      return HAL_OK;
;;;511    }
000076  e8bd83f8          POP      {r3-r9,pc}
                  |L5.122|
00007a  6820              LDR      r0,[r4,#0]            ;436
00007c  6800              LDR      r0,[r0,#0]            ;436
00007e  0740              LSLS     r0,r0,#29             ;436
000080  d5ea              BPL      |L5.88|
000082  e02a              B        |L5.218|
                  |L5.132|
000084  6902              LDR      r2,[r0,#0x10]         ;462
000086  420a              TST      r2,r1                 ;462
000088  d102              BNE      |L5.144|
00008a  68c1              LDR      r1,[r0,#0xc]          ;462
00008c  4219              TST      r1,r3                 ;462
00008e  d006              BEQ      |L5.158|
                  |L5.144|
000090  6902              LDR      r2,[r0,#0x10]         ;462
000092  4926              LDR      r1,|L5.300|
000094  420a              TST      r2,r1                 ;462
000096  d106              BNE      |L5.166|
000098  68c0              LDR      r0,[r0,#0xc]          ;462
00009a  4208              TST      r0,r1                 ;462
00009c  d103              BNE      |L5.166|
                  |L5.158|
00009e  2054              MOVS     r0,#0x54              ;462
0000a0  e002              B        |L5.168|
                  |L5.162|
0000a2  2029              MOVS     r0,#0x29              ;462
0000a4  e000              B        |L5.168|
                  |L5.166|
0000a6  20fc              MOVS     r0,#0xfc              ;462
                  |L5.168|
0000a8  fb08f800          MUL      r8,r8,r0              ;462
0000ac  e012              B        |L5.212|
                  |L5.174|
0000ae  1c68              ADDS     r0,r5,#1              ;467
0000b0  d00d              BEQ      |L5.206|
0000b2  b125              CBZ      r5,|L5.190|
0000b4  f7fffffe          BL       HAL_GetTick
0000b8  1b80              SUBS     r0,r0,r6              ;469
0000ba  42a8              CMP      r0,r5                 ;469
0000bc  d907              BLS      |L5.206|
                  |L5.190|
0000be  6aa0              LDR      r0,[r4,#0x28]         ;472
0000c0  f0400004          ORR      r0,r0,#4              ;472
0000c4  62a0              STR      r0,[r4,#0x28]         ;472
0000c6  f8847024          STRB     r7,[r4,#0x24]         ;475
0000ca  2003              MOVS     r0,#3                 ;477
0000cc  e7d3              B        |L5.118|
                  |L5.206|
0000ce  9800              LDR      r0,[sp,#0]            ;480
0000d0  1c40              ADDS     r0,r0,#1              ;480
0000d2  9000              STR      r0,[sp,#0]            ;480
                  |L5.212|
0000d4  9800              LDR      r0,[sp,#0]            ;464
0000d6  4540              CMP      r0,r8                 ;464
0000d8  d3e9              BCC      |L5.174|
                  |L5.218|
0000da  6821              LDR      r1,[r4,#0]            ;487
0000dc  f06f000e          MVN      r0,#0xe               ;487
0000e0  6008              STR      r0,[r1,#0]            ;487
0000e2  6aa0              LDR      r0,[r4,#0x28]         ;490
0000e4  f4405000          ORR      r0,r0,#0x2000         ;490
0000e8  62a0              STR      r0,[r4,#0x28]         ;490
0000ea  6820              LDR      r0,[r4,#0]            ;495
0000ec  6881              LDR      r1,[r0,#8]            ;495
0000ee  f3c13102          UBFX     r1,r1,#12,#3          ;495
0000f2  2907              CMP      r1,#7                 ;495
0000f4  d009              BEQ      |L5.266|
0000f6  6841              LDR      r1,[r0,#4]            ;496
0000f8  0549              LSLS     r1,r1,#21             ;496
0000fa  d411              BMI      |L5.288|
0000fc  6880              LDR      r0,[r0,#8]            ;497
0000fe  f3c04042          UBFX     r0,r0,#17,#3          ;497
000102  2807              CMP      r0,#7                 ;497
000104  d10c              BNE      |L5.288|
000106  68e0              LDR      r0,[r4,#0xc]          ;498
000108  b950              CBNZ     r0,|L5.288|
                  |L5.266|
00010a  6aa0              LDR      r0,[r4,#0x28]         ;501
00010c  f4205080          BIC      r0,r0,#0x1000         ;501
000110  62a0              STR      r0,[r4,#0x28]         ;501
000112  6aa0              LDR      r0,[r4,#0x28]         ;503
000114  05c0              LSLS     r0,r0,#23             ;503
000116  d403              BMI      |L5.288|
000118  6aa0              LDR      r0,[r4,#0x28]         ;505
00011a  f0400001          ORR      r0,r0,#1              ;505
00011e  62a0              STR      r0,[r4,#0x28]         ;505
                  |L5.288|
000120  2000              MOVS     r0,#0                 ;510
000122  e7a8              B        |L5.118|
;;;512    
                          ENDP

                  |L5.292|
                          DCD      SystemCoreClock
                  |L5.296|
                          DCD      0x24924924
                  |L5.300|
                          DCD      0x00249249

                          AREA ||i.HAL_ADCEx_InjectedStart||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart PROC
;;;249      */
;;;250    HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;253      
;;;254      /* Check the parameters */
;;;255      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;256      
;;;257      /* Process locked */
;;;258      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L6.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;259        
;;;260      /* Enable the ADC peripheral */
;;;261      tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;262      
;;;263      /* Start conversion if ADC is effectively enabled */
;;;264      if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L6.42|
;;;265      {
;;;266        /* Set ADC state                                                          */
;;;267        /* - Clear state bitfield related to injected group conversion results    */
;;;268        /* - Set state bitfield related to injected operation                     */
;;;269        ADC_STATE_CLR_SET(hadc->State,
;;;270                          HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;271                          HAL_ADC_STATE_INJ_BUSY);
;;;272        
;;;273        /* Case of independent mode or multimode (for devices with several ADCs): */
;;;274        /* Set multimode state.                                                   */
;;;275        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;276        {
;;;277          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;278        }
;;;279        else
;;;280        {
;;;281          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;282        }
;;;283        
;;;284        /* Check if a regular conversion is ongoing */
;;;285        /* Note: On this device, there is no ADC error code fields related to     */
;;;286        /*       conversions on group injected only. In case of conversion on     */
;;;287        /*       going on group regular, no error code is reset.                  */
;;;288        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;289        {
;;;290          /* Reset ADC all error code fields */
;;;291          ADC_CLEAR_ERRORCODE(hadc);
;;;292        }
;;;293        
;;;294        /* Process unlocked */
;;;295        /* Unlock before starting ADC conversions: in case of potential           */
;;;296        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;297        __HAL_UNLOCK(hadc);
;;;298        
;;;299        /* Clear injected group conversion flag */
;;;300        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;301        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
;;;302            
;;;303        /* Enable conversion of injected group.                                   */
;;;304        /* If software start has been selected, conversion starts immediately.    */
;;;305        /* If external trigger has been selected, conversion will start at next   */
;;;306        /* trigger event.                                                         */
;;;307        /* If automatic injected conversion is enabled, conversion will start     */
;;;308        /* after next regular group conversion.                                   */
;;;309        /* Case of multimode enabled (for devices with several ADCs): if ADC is   */
;;;310        /* slave, ADC is enabled only (conversion is not started). If ADC is      */
;;;311        /* master, ADC is enabled and conversion is started.                      */
;;;312        if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
;;;313        {
;;;314          if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
;;;315              ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;316          {
;;;317            /* Start ADC conversion on injected group with SW start */
;;;318            SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
;;;319          }
;;;320          else
;;;321          {
;;;322            /* Start ADC conversion on injected group with external trigger */
;;;323            SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
;;;324          }
;;;325        }
;;;326      }
;;;327      else
;;;328      {
;;;329        /* Process unlocked */
;;;330        __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L6.34|
;;;331      }
;;;332      
;;;333      /* Return function status */
;;;334      return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;335    }
000024  bd70              POP      {r4-r6,pc}
                  |L6.38|
000026  2002              MOVS     r0,#2                 ;258
000028  bd70              POP      {r4-r6,pc}
                  |L6.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;269
00002c  f2420301          MOV      r3,#0x2001            ;269
000030  4398              BICS     r0,r0,r3              ;269
000032  f4405080          ORR      r0,r0,#0x1000         ;269
000036  62a0              STR      r0,[r4,#0x28]         ;269
000038  4b1a              LDR      r3,|L6.164|
00003a  6820              LDR      r0,[r4,#0]            ;275
00003c  4d1a              LDR      r5,|L6.168|
00003e  4298              CMP      r0,r3                 ;275
000040  d11a              BNE      |L6.120|
000042  682e              LDR      r6,[r5,#0]            ;275
000044  f4162f70          TST      r6,#0xf0000           ;275
000048  d016              BEQ      |L6.120|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;281
00004c  f4461680          ORR      r6,r6,#0x100000       ;281
000050  62a6              STR      r6,[r4,#0x28]         ;281
                  |L6.82|
000052  6aa6              LDR      r6,[r4,#0x28]         ;288
000054  05f6              LSLS     r6,r6,#23             ;288
000056  d400              BMI      |L6.90|
000058  62e2              STR      r2,[r4,#0x2c]         ;291
                  |L6.90|
00005a  f8842024          STRB     r2,[r4,#0x24]         ;297
00005e  f06f0204          MVN      r2,#4                 ;301
000062  6002              STR      r2,[r0,#0]            ;301
000064  6820              LDR      r0,[r4,#0]            ;312
000066  6842              LDR      r2,[r0,#4]            ;312
000068  0552              LSLS     r2,r2,#21             ;312
00006a  d4da              BMI      |L6.34|
00006c  6882              LDR      r2,[r0,#8]            ;314
00006e  f3c23202          UBFX     r2,r2,#12,#3          ;314
000072  2a07              CMP      r2,#7                 ;314
000074  d005              BEQ      |L6.130|
000076  e00a              B        |L6.142|
                  |L6.120|
000078  6aa6              LDR      r6,[r4,#0x28]         ;277
00007a  f4261680          BIC      r6,r6,#0x100000       ;277
00007e  62a6              STR      r6,[r4,#0x28]         ;277
000080  e7e7              B        |L6.82|
                  |L6.130|
000082  4298              CMP      r0,r3                 ;315
000084  d108              BNE      |L6.152|
000086  682a              LDR      r2,[r5,#0]            ;315
000088  f4122f70          TST      r2,#0xf0000           ;315
00008c  d004              BEQ      |L6.152|
                  |L6.142|
00008e  6882              LDR      r2,[r0,#8]            ;323
000090  f4424200          ORR      r2,r2,#0x8000         ;323
000094  6082              STR      r2,[r0,#8]            ;323
000096  e7c4              B        |L6.34|
                  |L6.152|
000098  6882              LDR      r2,[r0,#8]            ;318
00009a  f4421202          ORR      r2,r2,#0x208000       ;318
00009e  6082              STR      r2,[r0,#8]            ;318
0000a0  e7bf              B        |L6.34|
;;;336    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      0x40012800
                  |L6.168|
                          DCD      0x40012404

                          AREA ||i.HAL_ADCEx_InjectedStart_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart_IT PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;523      
;;;524      /* Check the parameters */
;;;525      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;526      
;;;527      /* Process locked */
;;;528      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L7.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;529        
;;;530      /* Enable the ADC peripheral */
;;;531      tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;532      
;;;533      /* Start conversion if ADC is effectively enabled */
;;;534      if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L7.42|
;;;535      {
;;;536        /* Set ADC state                                                          */
;;;537        /* - Clear state bitfield related to injected group conversion results    */
;;;538        /* - Set state bitfield related to injected operation                     */
;;;539        ADC_STATE_CLR_SET(hadc->State,
;;;540                          HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;541                          HAL_ADC_STATE_INJ_BUSY);
;;;542        
;;;543        /* Case of independent mode or multimode (for devices with several ADCs): */
;;;544        /* Set multimode state.                                                   */
;;;545        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;546        {
;;;547          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;548        }
;;;549        else
;;;550        {
;;;551          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;552        }
;;;553        
;;;554        /* Check if a regular conversion is ongoing */
;;;555        /* Note: On this device, there is no ADC error code fields related to     */
;;;556        /*       conversions on group injected only. In case of conversion on     */
;;;557        /*       going on group regular, no error code is reset.                  */
;;;558        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;559        {
;;;560          /* Reset ADC all error code fields */
;;;561          ADC_CLEAR_ERRORCODE(hadc);
;;;562        }
;;;563        
;;;564        /* Process unlocked */
;;;565        /* Unlock before starting ADC conversions: in case of potential           */
;;;566        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;567        __HAL_UNLOCK(hadc);
;;;568        
;;;569        /* Clear injected group conversion flag */
;;;570        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;571        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
;;;572        
;;;573        /* Enable end of conversion interrupt for injected channels */
;;;574        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;575        
;;;576        /* Start conversion of injected group if software start has been selected */
;;;577        /* and if automatic injected conversion is disabled.                      */
;;;578        /* If external trigger has been selected, conversion will start at next   */
;;;579        /* trigger event.                                                         */
;;;580        /* If automatic injected conversion is enabled, conversion will start     */
;;;581        /* after next regular group conversion.                                   */
;;;582        if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
;;;583        {
;;;584          if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
;;;585              ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;586          {
;;;587            /* Start ADC conversion on injected group with SW start */
;;;588            SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
;;;589          }
;;;590          else
;;;591          {
;;;592            /* Start ADC conversion on injected group with external trigger */
;;;593            SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
;;;594          }
;;;595        }
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Process unlocked */
;;;600        __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L7.34|
;;;601      }
;;;602      
;;;603      /* Return function status */
;;;604      return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;605    }
000024  bd70              POP      {r4-r6,pc}
                  |L7.38|
000026  2002              MOVS     r0,#2                 ;528
000028  bd70              POP      {r4-r6,pc}
                  |L7.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;539
00002c  f2420301          MOV      r3,#0x2001            ;539
000030  4398              BICS     r0,r0,r3              ;539
000032  f4405080          ORR      r0,r0,#0x1000         ;539
000036  62a0              STR      r0,[r4,#0x28]         ;539
000038  4b1c              LDR      r3,|L7.172|
00003a  6820              LDR      r0,[r4,#0]            ;545
00003c  4d1c              LDR      r5,|L7.176|
00003e  4298              CMP      r0,r3                 ;545
000040  d11f              BNE      |L7.130|
000042  682e              LDR      r6,[r5,#0]            ;545
000044  f4162f70          TST      r6,#0xf0000           ;545
000048  d01b              BEQ      |L7.130|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;551
00004c  f4461680          ORR      r6,r6,#0x100000       ;551
000050  62a6              STR      r6,[r4,#0x28]         ;551
                  |L7.82|
000052  6aa6              LDR      r6,[r4,#0x28]         ;558
000054  05f6              LSLS     r6,r6,#23             ;558
000056  d400              BMI      |L7.90|
000058  62e2              STR      r2,[r4,#0x2c]         ;561
                  |L7.90|
00005a  f8842024          STRB     r2,[r4,#0x24]         ;567
00005e  f06f0204          MVN      r2,#4                 ;571
000062  6002              STR      r2,[r0,#0]            ;571
000064  6820              LDR      r0,[r4,#0]            ;574
000066  6842              LDR      r2,[r0,#4]            ;574
000068  f0420280          ORR      r2,r2,#0x80           ;574
00006c  6042              STR      r2,[r0,#4]            ;574
00006e  6820              LDR      r0,[r4,#0]            ;582
000070  6842              LDR      r2,[r0,#4]            ;582
000072  0552              LSLS     r2,r2,#21             ;582
000074  d4d5              BMI      |L7.34|
000076  6882              LDR      r2,[r0,#8]            ;584
000078  f3c23202          UBFX     r2,r2,#12,#3          ;584
00007c  2a07              CMP      r2,#7                 ;584
00007e  d005              BEQ      |L7.140|
000080  e00a              B        |L7.152|
                  |L7.130|
000082  6aa6              LDR      r6,[r4,#0x28]         ;547
000084  f4261680          BIC      r6,r6,#0x100000       ;547
000088  62a6              STR      r6,[r4,#0x28]         ;547
00008a  e7e2              B        |L7.82|
                  |L7.140|
00008c  4298              CMP      r0,r3                 ;585
00008e  d108              BNE      |L7.162|
000090  682a              LDR      r2,[r5,#0]            ;585
000092  f4122f70          TST      r2,#0xf0000           ;585
000096  d004              BEQ      |L7.162|
                  |L7.152|
000098  6882              LDR      r2,[r0,#8]            ;593
00009a  f4424200          ORR      r2,r2,#0x8000         ;593
00009e  6082              STR      r2,[r0,#8]            ;593
0000a0  e7bf              B        |L7.34|
                  |L7.162|
0000a2  6882              LDR      r2,[r0,#8]            ;588
0000a4  f4421202          ORR      r2,r2,#0x208000       ;588
0000a8  6082              STR      r2,[r0,#8]            ;588
0000aa  e7ba              B        |L7.34|
;;;606    
                          ENDP

                  |L7.172|
                          DCD      0x40012800
                  |L7.176|
                          DCD      0x40012404

                          AREA ||i.HAL_ADCEx_InjectedStop||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop PROC
;;;348      */
;;;349    HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;350    {
000002  4604              MOV      r4,r0
;;;351      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;352      
;;;353      /* Check the parameters */
;;;354      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;355    
;;;356      /* Process locked */
;;;357      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00e              BEQ      |L8.42|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;358        
;;;359      /* Stop potential conversion and disable ADC peripheral                     */
;;;360      /* Conditioned to:                                                          */
;;;361      /* - No conversion on the other group (regular group) is intended to        */
;;;362      /*   continue (injected and regular groups stop conversion and ADC disable  */
;;;363      /*   are common)                                                            */
;;;364      /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
;;;365      if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
000012  6aa0              LDR      r0,[r4,#0x28]
000014  05c0              LSLS     r0,r0,#23
000016  d411              BMI      |L8.60|
;;;366         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  0540              LSLS     r0,r0,#21
00001e  d40d              BMI      |L8.60|
;;;367      {
;;;368        /* Stop potential conversion on going, on regular and injected groups */
;;;369        /* Disable ADC peripheral */
;;;370        tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ADC_ConversionStop_Disable
;;;371        
;;;372        /* Check if ADC is effectively disabled */
;;;373        if (tmp_hal_status == HAL_OK)
000026  b110              CBZ      r0,|L8.46|
000028  e00d              B        |L8.70|
                  |L8.42|
00002a  2002              MOVS     r0,#2                 ;357
;;;374        {
;;;375          /* Set ADC state */
;;;376          ADC_STATE_CLR_SET(hadc->State,
;;;377                            HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;378                            HAL_ADC_STATE_READY);
;;;379        }
;;;380      }
;;;381      else
;;;382      {
;;;383        /* Update ADC state machine to error */
;;;384        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;385          
;;;386        tmp_hal_status = HAL_ERROR;
;;;387      }
;;;388      
;;;389      /* Process unlocked */
;;;390      __HAL_UNLOCK(hadc);
;;;391      
;;;392      /* Return function status */
;;;393      return tmp_hal_status;
;;;394    }
00002c  bd10              POP      {r4,pc}
                  |L8.46|
00002e  6aa1              LDR      r1,[r4,#0x28]         ;376
000030  f4215188          BIC      r1,r1,#0x1100         ;376
000034  f0410101          ORR      r1,r1,#1              ;376
000038  62a1              STR      r1,[r4,#0x28]         ;376
00003a  e004              B        |L8.70|
                  |L8.60|
00003c  6aa0              LDR      r0,[r4,#0x28]         ;384
00003e  f0400020          ORR      r0,r0,#0x20           ;384
000042  62a0              STR      r0,[r4,#0x28]         ;384
000044  2001              MOVS     r0,#1                 ;386
                  |L8.70|
000046  2100              MOVS     r1,#0                 ;390
000048  f8841024          STRB     r1,[r4,#0x24]         ;390
00004c  bd10              POP      {r4,pc}
;;;395    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop_IT PROC
;;;618      */
;;;619    HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;620    {
000002  4604              MOV      r4,r0
;;;621      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;622      
;;;623      /* Check the parameters */
;;;624      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;625    
;;;626      /* Process locked */
;;;627      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00e              BEQ      |L9.42|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;628        
;;;629      /* Stop potential conversion and disable ADC peripheral                     */
;;;630      /* Conditioned to:                                                          */
;;;631      /* - No conversion on the other group (regular group) is intended to        */
;;;632      /*   continue (injected and regular groups stop conversion and ADC disable  */
;;;633      /*   are common)                                                            */
;;;634      /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
;;;635      if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
000012  6aa0              LDR      r0,[r4,#0x28]
000014  05c0              LSLS     r0,r0,#23
000016  d416              BMI      |L9.70|
;;;636         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  0540              LSLS     r0,r0,#21
00001e  d412              BMI      |L9.70|
;;;637      {
;;;638        /* Stop potential conversion on going, on regular and injected groups */
;;;639        /* Disable ADC peripheral */
;;;640        tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ADC_ConversionStop_Disable
;;;641        
;;;642        /* Check if ADC is effectively disabled */
;;;643        if (tmp_hal_status == HAL_OK)
000026  b110              CBZ      r0,|L9.46|
000028  e012              B        |L9.80|
                  |L9.42|
00002a  2002              MOVS     r0,#2                 ;627
;;;644        {
;;;645          /* Disable ADC end of conversion interrupt for injected channels */
;;;646          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;647          
;;;648          /* Set ADC state */
;;;649          ADC_STATE_CLR_SET(hadc->State,
;;;650                            HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;651                            HAL_ADC_STATE_READY);
;;;652        }
;;;653      }
;;;654      else
;;;655      {
;;;656        /* Update ADC state machine to error */
;;;657        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;658          
;;;659        tmp_hal_status = HAL_ERROR;
;;;660      }
;;;661      
;;;662      /* Process unlocked */
;;;663      __HAL_UNLOCK(hadc);
;;;664      
;;;665      /* Return function status */
;;;666      return tmp_hal_status;
;;;667    }
00002c  bd10              POP      {r4,pc}
                  |L9.46|
00002e  6821              LDR      r1,[r4,#0]            ;646
000030  684a              LDR      r2,[r1,#4]            ;646
000032  f0220280          BIC      r2,r2,#0x80           ;646
000036  604a              STR      r2,[r1,#4]            ;646
000038  6aa1              LDR      r1,[r4,#0x28]         ;649
00003a  f4215188          BIC      r1,r1,#0x1100         ;649
00003e  f0410101          ORR      r1,r1,#1              ;649
000042  62a1              STR      r1,[r4,#0x28]         ;649
000044  e004              B        |L9.80|
                  |L9.70|
000046  6aa0              LDR      r0,[r4,#0x28]         ;657
000048  f0400020          ORR      r0,r0,#0x20           ;657
00004c  62a0              STR      r0,[r4,#0x28]         ;657
00004e  2001              MOVS     r0,#1                 ;659
                  |L9.80|
000050  2100              MOVS     r1,#0                 ;663
000052  f8841024          STRB     r1,[r4,#0x24]         ;663
000056  bd10              POP      {r4,pc}
;;;668    
                          ENDP


                          AREA ||i.HAL_ADCEx_MultiModeConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeConfigChannel PROC
;;;1274     */
;;;1275   HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
000000  b510              PUSH     {r4,lr}
;;;1276   {
000002  b08c              SUB      sp,sp,#0x30
;;;1277     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2300              MOVS     r3,#0
;;;1278     ADC_HandleTypeDef tmphadcSlave;
;;;1279     
;;;1280     /* Check the parameters */
;;;1281     assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;1282     assert_param(IS_ADC_MODE(multimode->Mode));
;;;1283     
;;;1284     /* Process locked */
;;;1285     __HAL_LOCK(hadc);
000006  f8902024          LDRB     r2,[r0,#0x24]
00000a  2a01              CMP      r2,#1
00000c  d018              BEQ      |L10.64|
00000e  2201              MOVS     r2,#1
000010  f8802024          STRB     r2,[r0,#0x24]
;;;1286     
;;;1287     /* Set a temporary handle of the ADC slave associated to the ADC master     */
;;;1288     ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
000014  4a11              LDR      r2,|L10.92|
000016  9200              STR      r2,[sp,#0]
;;;1289     
;;;1290     /* Parameters update conditioned to ADC state:                              */
;;;1291     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1292     /* conversion on going on regular group:                                    */
;;;1293     /*  - ADC master and ADC slave DMA configuration                            */
;;;1294     /* Parameters that can be updated only when ADC is disabled:                */
;;;1295     /*  - Multimode mode selection                                              */
;;;1296     /* To optimize code, all multimode settings can be set when both ADCs of    */
;;;1297     /* the common group are in state: disabled.                                 */
;;;1298     if ((ADC_IS_ENABLE(hadc) == RESET)                     &&
000018  6802              LDR      r2,[r0,#0]
00001a  6894              LDR      r4,[r2,#8]
00001c  43e4              MVNS     r4,r4
00001e  07e4              LSLS     r4,r4,#31
000020  d011              BEQ      |L10.70|
;;;1299         (ADC_IS_ENABLE(&tmphadcSlave) == RESET)            &&
000022  9c00              LDR      r4,[sp,#0]
000024  68a4              LDR      r4,[r4,#8]
000026  43e4              MVNS     r4,r4
000028  07e4              LSLS     r4,r4,#31
00002a  d00c              BEQ      |L10.70|
;;;1300         (IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance))   )
00002c  4c0c              LDR      r4,|L10.96|
00002e  42a2              CMP      r2,r4
000030  d109              BNE      |L10.70|
;;;1301     {
;;;1302       MODIFY_REG(hadc->Instance->CR1,
000032  6854              LDR      r4,[r2,#4]
000034  6809              LDR      r1,[r1,#0]
000036  f4242470          BIC      r4,r4,#0xf0000
00003a  430c              ORRS     r4,r4,r1
00003c  6054              STR      r4,[r2,#4]
00003e  e007              B        |L10.80|
                  |L10.64|
000040  2002              MOVS     r0,#2                 ;1285
                  |L10.66|
;;;1303                  ADC_CR1_DUALMOD    ,
;;;1304                  multimode->Mode     );
;;;1305     }
;;;1306     /* If one of the ADC sharing the same common group is enabled, no update    */
;;;1307     /* could be done on neither of the multimode structure parameters.          */
;;;1308     else
;;;1309     {
;;;1310       /* Update ADC state machine to error */
;;;1311       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1312       
;;;1313       tmp_hal_status = HAL_ERROR;
;;;1314     }
;;;1315       
;;;1316       
;;;1317     /* Process unlocked */
;;;1318     __HAL_UNLOCK(hadc);
;;;1319     
;;;1320     /* Return function status */
;;;1321     return tmp_hal_status;
;;;1322   } 
000042  b00c              ADD      sp,sp,#0x30
000044  bd10              POP      {r4,pc}
                  |L10.70|
000046  6a81              LDR      r1,[r0,#0x28]         ;1311
000048  f0410120          ORR      r1,r1,#0x20           ;1311
00004c  6281              STR      r1,[r0,#0x28]         ;1311
00004e  2301              MOVS     r3,#1                 ;1313
                  |L10.80|
000050  2100              MOVS     r1,#0                 ;1318
000052  f8801024          STRB     r1,[r0,#0x24]         ;1318
000056  4618              MOV      r0,r3                 ;1321
000058  e7f3              B        |L10.66|
;;;1323   #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      0x40012800
                  |L10.96|
                          DCD      0x40012400

                          AREA ||i.HAL_ADCEx_MultiModeGetValue||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeGetValue PROC
;;;939      */
;;;940    uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
000000  6800              LDR      r0,[r0,#0]
;;;941    {
;;;942      uint32_t tmpDR = 0U;
;;;943      
;;;944      /* Check the parameters */
;;;945      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;946      
;;;947      /* Check the parameters */
;;;948      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;949    
;;;950      /* Note: EOC flag is not cleared here by software because automatically     */
;;;951      /*       cleared by hardware when reading register DR.                      */
;;;952      
;;;953      /* On STM32F1 devices, ADC1 data register DR contains ADC2 conversions      */
;;;954      /* only if ADC1 DMA mode is enabled.                                        */
;;;955      tmpDR = hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;956    
;;;957      if (HAL_IS_BIT_CLR(ADC1->CR2, ADC_CR2_DMA))
000004  4904              LDR      r1,|L11.24|
000006  6809              LDR      r1,[r1,#0]
000008  05c9              LSLS     r1,r1,#23
00000a  d403              BMI      |L11.20|
;;;958      {
;;;959        tmpDR |= (ADC2->DR << 16U);
00000c  4903              LDR      r1,|L11.28|
00000e  6809              LDR      r1,[r1,#0]
000010  ea404001          ORR      r0,r0,r1,LSL #16
                  |L11.20|
;;;960      }
;;;961        
;;;962      /* Return ADC converted value */ 
;;;963      return tmpDR;
;;;964    }
000014  4770              BX       lr
;;;965    #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40012408
                  |L11.28|
                          DCD      0x4001284c

                          AREA ||i.HAL_ADCEx_MultiModeStart_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStart_DMA PROC
;;;687      */
;;;688    HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;689    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
;;;690      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;691      ADC_HandleTypeDef tmphadcSlave;
;;;692    
;;;693      /* Check the parameters */
;;;694      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;695      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;696      
;;;697      /* Process locked */
;;;698      __HAL_LOCK(hadc);
00000c  f8940024          LDRB     r0,[r4,#0x24]
000010  2801              CMP      r0,#1
000012  d014              BEQ      |L12.62|
000014  2001              MOVS     r0,#1
000016  f8840024          STRB     r0,[r4,#0x24]
;;;699    
;;;700      /* Set a temporary handle of the ADC slave associated to the ADC master     */
;;;701      ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
00001a  482f              LDR      r0,|L12.216|
00001c  9000              STR      r0,[sp,#0]
;;;702      
;;;703      /* On STM32F1 devices, ADC slave regular group must be configured with      */
;;;704      /* conversion trigger ADC_SOFTWARE_START.                                   */
;;;705      /* Note: External trigger of ADC slave must be enabled, it is already done  */
;;;706      /*       into function "HAL_ADC_Init()".                                    */
;;;707      if(!ADC_IS_SOFTWARE_START_REGULAR(&tmphadcSlave))  
00001e  6880              LDR      r0,[r0,#8]
000020  2600              MOVS     r6,#0
000022  f3c04042          UBFX     r0,r0,#17,#3
000026  2807              CMP      r0,#7
000028  d00b              BEQ      |L12.66|
;;;708      {
;;;709        /* Update ADC state machine to error */
;;;710        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00002a  6aa0              LDR      r0,[r4,#0x28]
00002c  f0400020          ORR      r0,r0,#0x20
000030  62a0              STR      r0,[r4,#0x28]
;;;711        
;;;712        /* Process unlocked */
;;;713        __HAL_UNLOCK(hadc);
000032  f8846024          STRB     r6,[r4,#0x24]
;;;714        
;;;715        return HAL_ERROR;
000036  2001              MOVS     r0,#1
                  |L12.56|
;;;716      }
;;;717      
;;;718      /* Enable the ADC peripherals: master and slave (in case if not already     */
;;;719      /* enabled previously)                                                      */
;;;720      tmp_hal_status = ADC_Enable(hadc);
;;;721      if (tmp_hal_status == HAL_OK)
;;;722      {
;;;723        tmp_hal_status = ADC_Enable(&tmphadcSlave);
;;;724      }
;;;725      
;;;726      /* Start conversion if all ADCs of multimode are effectively enabled */
;;;727      if (tmp_hal_status == HAL_OK)
;;;728      {
;;;729        /* Set ADC state (ADC master)                                             */
;;;730        /* - Clear state bitfield related to regular group conversion results     */
;;;731        /* - Set state bitfield related to regular operation                      */
;;;732        ADC_STATE_CLR_SET(hadc->State,
;;;733                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_MULTIMODE_SLAVE,
;;;734                          HAL_ADC_STATE_REG_BUSY);
;;;735          
;;;736        /* If conversions on group regular are also triggering group injected,    */
;;;737        /* update ADC state.                                                      */
;;;738        if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;739        {
;;;740          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;741        }
;;;742        
;;;743        /* Process unlocked */
;;;744        /* Unlock before starting ADC conversions: in case of potential           */
;;;745        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;746        __HAL_UNLOCK(hadc);
;;;747        
;;;748        /* Set ADC error code to none */
;;;749        ADC_CLEAR_ERRORCODE(hadc);
;;;750        
;;;751        
;;;752        /* Set the DMA transfer complete callback */
;;;753        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;754           
;;;755        /* Set the DMA half transfer complete callback */
;;;756        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;757        
;;;758        /* Set the DMA error callback */
;;;759        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;760    
;;;761        
;;;762        /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
;;;763        /* start (in case of SW start):                                           */
;;;764        
;;;765        /* Clear regular group conversion flag and overrun flag */
;;;766        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;767        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;768        
;;;769        /* Enable ADC DMA mode of ADC master */
;;;770        SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;771        
;;;772        /* Start the DMA channel */
;;;773        HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;774        
;;;775        /* Start conversion of regular group if software start has been selected. */
;;;776        /* If external trigger has been selected, conversion will start at next   */
;;;777        /* trigger event.                                                         */
;;;778        /* Note: Alternate trigger for single conversion could be to force an     */
;;;779        /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
;;;780        if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
;;;781        {
;;;782          /* Start ADC conversion on regular group with SW start */
;;;783          SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;784        }
;;;785        else
;;;786        {
;;;787          /* Start ADC conversion on regular group with external trigger */
;;;788          SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;789        }
;;;790      }
;;;791      else
;;;792      {
;;;793        /* Process unlocked */
;;;794        __HAL_UNLOCK(hadc);
;;;795      }
;;;796      
;;;797      /* Return function status */
;;;798      return tmp_hal_status;
;;;799    }
000038  b00c              ADD      sp,sp,#0x30
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L12.62|
00003e  2002              MOVS     r0,#2                 ;698
000040  e7fa              B        |L12.56|
                  |L12.66|
000042  4620              MOV      r0,r4                 ;720
000044  f7fffffe          BL       ADC_Enable
000048  4605              MOV      r5,r0                 ;720
00004a  0028              MOVS     r0,r5                 ;721
00004c  d103              BNE      |L12.86|
00004e  4668              MOV      r0,sp                 ;723
000050  f7fffffe          BL       ADC_Enable
000054  4605              MOV      r5,r0                 ;723
                  |L12.86|
000056  b11d              CBZ      r5,|L12.96|
000058  f8846024          STRB     r6,[r4,#0x24]         ;794
                  |L12.92|
00005c  4628              MOV      r0,r5                 ;798
00005e  e7eb              B        |L12.56|
                  |L12.96|
000060  6aa0              LDR      r0,[r4,#0x28]         ;732
000062  491e              LDR      r1,|L12.220|
000064  4008              ANDS     r0,r0,r1              ;732
000066  f4407080          ORR      r0,r0,#0x100          ;732
00006a  62a0              STR      r0,[r4,#0x28]         ;732
00006c  6820              LDR      r0,[r4,#0]            ;738
00006e  6840              LDR      r0,[r0,#4]            ;738
000070  0540              LSLS     r0,r0,#21             ;738
000072  d505              BPL      |L12.128|
000074  6aa0              LDR      r0,[r4,#0x28]         ;740
000076  f4205000          BIC      r0,r0,#0x2000         ;740
00007a  f4405080          ORR      r0,r0,#0x1000         ;740
00007e  62a0              STR      r0,[r4,#0x28]         ;740
                  |L12.128|
000080  f8846024          STRB     r6,[r4,#0x24]         ;746
000084  62e6              STR      r6,[r4,#0x2c]         ;749
000086  6a21              LDR      r1,[r4,#0x20]         ;753
000088  4815              LDR      r0,|L12.224|
00008a  6288              STR      r0,[r1,#0x28]         ;753
00008c  6a21              LDR      r1,[r4,#0x20]         ;756
00008e  4815              LDR      r0,|L12.228|
000090  62c8              STR      r0,[r1,#0x2c]         ;756
000092  6a21              LDR      r1,[r4,#0x20]         ;759
000094  4814              LDR      r0,|L12.232|
000096  6308              STR      r0,[r1,#0x30]         ;759
000098  6821              LDR      r1,[r4,#0]            ;767
00009a  f06f0002          MVN      r0,#2                 ;767
00009e  6008              STR      r0,[r1,#0]            ;767
0000a0  6820              LDR      r0,[r4,#0]            ;770
0000a2  6881              LDR      r1,[r0,#8]            ;770
0000a4  f4417180          ORR      r1,r1,#0x100          ;770
0000a8  6081              STR      r1,[r0,#8]            ;770
0000aa  6821              LDR      r1,[r4,#0]            ;773
0000ac  4643              MOV      r3,r8                 ;773
0000ae  314c              ADDS     r1,r1,#0x4c           ;773
0000b0  463a              MOV      r2,r7                 ;773
0000b2  6a20              LDR      r0,[r4,#0x20]         ;773
0000b4  f7fffffe          BL       HAL_DMA_Start_IT
0000b8  6820              LDR      r0,[r4,#0]            ;780
0000ba  6881              LDR      r1,[r0,#8]            ;780
0000bc  f3c14142          UBFX     r1,r1,#17,#3          ;780
0000c0  2907              CMP      r1,#7                 ;780
0000c2  d004              BEQ      |L12.206|
0000c4  6881              LDR      r1,[r0,#8]            ;788
0000c6  f4411180          ORR      r1,r1,#0x100000       ;788
0000ca  6081              STR      r1,[r0,#8]            ;788
0000cc  e7c6              B        |L12.92|
                  |L12.206|
0000ce  6881              LDR      r1,[r0,#8]            ;783
0000d0  f44101a0          ORR      r1,r1,#0x500000       ;783
0000d4  6081              STR      r1,[r0,#8]            ;783
0000d6  e7c1              B        |L12.92|
;;;800    
                          ENDP

                  |L12.216|
                          DCD      0x40012800
                  |L12.220|
                          DCD      0xffeffdfe
                  |L12.224|
                          DCD      ADC_DMAConvCplt
                  |L12.228|
                          DCD      ADC_DMAHalfConvCplt
                  |L12.232|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADCEx_MultiModeStop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStop_DMA PROC
;;;813      */
;;;814    HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
000000  b530              PUSH     {r4,r5,lr}
;;;815    {
000002  b08d              SUB      sp,sp,#0x34
000004  4604              MOV      r4,r0
;;;816      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;817      ADC_HandleTypeDef tmphadcSlave;
;;;818      
;;;819      /* Check the parameters */
;;;820      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;821      
;;;822      /* Process locked */
;;;823      __HAL_LOCK(hadc);
000006  f8940024          LDRB     r0,[r4,#0x24]
00000a  2801              CMP      r0,#1
00000c  d008              BEQ      |L13.32|
00000e  2001              MOVS     r0,#1
000010  f8840024          STRB     r0,[r4,#0x24]
;;;824      
;;;825     
;;;826      /* Stop potential conversion on going, on regular and injected groups */
;;;827      /* Disable ADC master peripheral */
;;;828      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ADC_ConversionStop_Disable
;;;829      
;;;830      /* Check if ADC is effectively disabled */
;;;831      if(tmp_hal_status == HAL_OK)
00001a  2500              MOVS     r5,#0
00001c  b118              CBZ      r0,|L13.38|
00001e  e023              B        |L13.104|
                  |L13.32|
000020  2002              MOVS     r0,#2                 ;823
                  |L13.34|
;;;832      {
;;;833        /* Set a temporary handle of the ADC slave associated to the ADC master   */
;;;834        ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
;;;835    
;;;836        /* Disable ADC slave peripheral */
;;;837        tmp_hal_status = ADC_ConversionStop_Disable(&tmphadcSlave);
;;;838    
;;;839        /* Check if ADC is effectively disabled */
;;;840        if(tmp_hal_status != HAL_OK)
;;;841        {
;;;842          /* Update ADC state machine to error */
;;;843          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;844    
;;;845          /* Process unlocked */
;;;846          __HAL_UNLOCK(hadc);
;;;847    
;;;848          return HAL_ERROR;
;;;849        }
;;;850    
;;;851        /* Disable ADC DMA mode */
;;;852        CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;853        
;;;854        /* Reset configuration of ADC DMA continuous request for dual mode */
;;;855        CLEAR_BIT(hadc->Instance->CR1, ADC_CR1_DUALMOD);
;;;856            
;;;857        /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;858        /* while DMA transfer is on going)                                        */
;;;859        tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;860    
;;;861        /* Change ADC state (ADC master) */
;;;862        ADC_STATE_CLR_SET(hadc->State,
;;;863                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;864                          HAL_ADC_STATE_READY);
;;;865      }
;;;866      
;;;867      /* Process unlocked */
;;;868      __HAL_UNLOCK(hadc);
;;;869      
;;;870      /* Return function status */
;;;871      return tmp_hal_status;
;;;872    }
000022  b00d              ADD      sp,sp,#0x34
000024  bd30              POP      {r4,r5,pc}
                  |L13.38|
000026  4812              LDR      r0,|L13.112|
000028  9001              STR      r0,[sp,#4]            ;834
00002a  a801              ADD      r0,sp,#4              ;837
00002c  f7fffffe          BL       ADC_ConversionStop_Disable
000030  b138              CBZ      r0,|L13.66|
000032  6aa0              LDR      r0,[r4,#0x28]         ;843
000034  f0400010          ORR      r0,r0,#0x10           ;843
000038  62a0              STR      r0,[r4,#0x28]         ;843
00003a  f8845024          STRB     r5,[r4,#0x24]         ;846
00003e  2001              MOVS     r0,#1                 ;848
000040  e7ef              B        |L13.34|
                  |L13.66|
000042  6820              LDR      r0,[r4,#0]            ;852
000044  6881              LDR      r1,[r0,#8]            ;852
000046  f4217180          BIC      r1,r1,#0x100          ;852
00004a  6081              STR      r1,[r0,#8]            ;852
00004c  6820              LDR      r0,[r4,#0]            ;855
00004e  6841              LDR      r1,[r0,#4]            ;855
000050  f4212170          BIC      r1,r1,#0xf0000        ;855
000054  6041              STR      r1,[r0,#4]            ;855
000056  6a20              LDR      r0,[r4,#0x20]         ;859
000058  f7fffffe          BL       HAL_DMA_Abort
00005c  6aa1              LDR      r1,[r4,#0x28]         ;862
00005e  f4215188          BIC      r1,r1,#0x1100         ;862
000062  f0410101          ORR      r1,r1,#1              ;862
000066  62a1              STR      r1,[r4,#0x28]         ;862
                  |L13.104|
000068  f8845024          STRB     r5,[r4,#0x24]         ;868
00006c  e7d9              B        |L13.34|
;;;873    #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

00006e  0000              DCW      0x0000
                  |L13.112|
                          DCD      0x40012800

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_adc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REVSH|
#line 456
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____RRX|
#line 643
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
