; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_spi.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_spi.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_spi.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;1634   */
;;;1635   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;1636   {
000002  4604              MOV      r4,r0
;;;1637     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  482a              LDR      r0,|L1.176|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;1638   
;;;1639     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;1640     if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000016  6820              LDR      r0,[r4,#0]
000018  6841              LDR      r1,[r0,#4]
00001a  0609              LSLS     r1,r1,#24
00001c  d501              BPL      |L1.34|
;;;1641     {
;;;1642       hspi->TxISR = SPI_AbortTx_ISR;
00001e  4925              LDR      r1,|L1.180|
000020  6461              STR      r1,[r4,#0x44]
                  |L1.34|
;;;1643     }
;;;1644   
;;;1645     if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000022  6841              LDR      r1,[r0,#4]
000024  0649              LSLS     r1,r1,#25
000026  d501              BPL      |L1.44|
;;;1646     {
;;;1647       hspi->RxISR = SPI_AbortRx_ISR;
000028  4923              LDR      r1,|L1.184|
00002a  6421              STR      r1,[r4,#0x40]
                  |L1.44|
;;;1648     }
;;;1649   
;;;1650     /* Clear ERRIE interrupts in case of DMA Mode */
;;;1651     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
00002c  6841              LDR      r1,[r0,#4]
00002e  f0210120          BIC      r1,r1,#0x20
000032  6041              STR      r1,[r0,#4]
;;;1652   
;;;1653     /* Disable the SPI DMA Tx or SPI DMA Rx request if enabled */
;;;1654     if ((HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN)))
000034  6820              LDR      r0,[r4,#0]
000036  6841              LDR      r1,[r0,#4]
000038  f04f0500          MOV      r5,#0
00003c  0789              LSLS     r1,r1,#30
00003e  d402              BMI      |L1.70|
000040  6840              LDR      r0,[r0,#4]
000042  07c0              LSLS     r0,r0,#31
000044  d027              BEQ      |L1.150|
                  |L1.70|
;;;1655     {
;;;1656       /* Abort the SPI DMA Tx channel : use blocking DMA Abort API (no callback) */  
;;;1657       if(hspi->hdmatx != NULL)
000046  6ca0              LDR      r0,[r4,#0x48]
000048  b1a8              CBZ      r0,|L1.118|
;;;1658       {
;;;1659         /* Set the SPI DMA Abort callback :
;;;1660         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;1661         hspi->hdmatx->XferAbortCallback = NULL;
00004a  6345              STR      r5,[r0,#0x34]
;;;1662         
;;;1663         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;1664         HAL_DMA_Abort(hspi->hdmatx);
00004c  6ca0              LDR      r0,[r4,#0x48]
00004e  f7fffffe          BL       HAL_DMA_Abort
;;;1665   
;;;1666         /* Disable Tx DMA Request */
;;;1667         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
000052  6820              LDR      r0,[r4,#0]
000054  6841              LDR      r1,[r0,#4]
000056  f0210102          BIC      r1,r1,#2
00005a  6041              STR      r1,[r0,#4]
                  |L1.92|
;;;1668   
;;;1669         /* Wait until TXE flag is set */
;;;1670         do
;;;1671         {
;;;1672           if(count-- == 0U)
00005c  9801              LDR      r0,[sp,#4]
00005e  1e41              SUBS     r1,r0,#1
000060  9101              STR      r1,[sp,#4]
000062  d204              BCS      |L1.110|
;;;1673           {
;;;1674             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000064  6d60              LDR      r0,[r4,#0x54]
000066  f0400020          ORR      r0,r0,#0x20
00006a  6560              STR      r0,[r4,#0x54]
;;;1675             break;
00006c  e003              B        |L1.118|
                  |L1.110|
;;;1676           }
;;;1677         }
;;;1678         while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);       
00006e  6820              LDR      r0,[r4,#0]
000070  6880              LDR      r0,[r0,#8]
000072  0780              LSLS     r0,r0,#30
000074  d5f2              BPL      |L1.92|
                  |L1.118|
;;;1679       }
;;;1680       /* Abort the SPI DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1681       if(hspi->hdmarx != NULL)
000076  6ce0              LDR      r0,[r4,#0x4c]
000078  b168              CBZ      r0,|L1.150|
;;;1682       {
;;;1683         /* Set the SPI DMA Abort callback :
;;;1684         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;1685         hspi->hdmarx->XferAbortCallback = NULL;
00007a  6345              STR      r5,[r0,#0x34]
;;;1686         
;;;1687         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;1688         HAL_DMA_Abort(hspi->hdmarx);
00007c  6ce0              LDR      r0,[r4,#0x4c]
00007e  f7fffffe          BL       HAL_DMA_Abort
;;;1689   
;;;1690         /* Disable peripheral */
;;;1691         __HAL_SPI_DISABLE(hspi); 
000082  6820              LDR      r0,[r4,#0]
000084  6801              LDR      r1,[r0,#0]
000086  f0210140          BIC      r1,r1,#0x40
00008a  6001              STR      r1,[r0,#0]
;;;1692   
;;;1693         /* Disable Rx DMA Request */
;;;1694         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
00008c  6820              LDR      r0,[r4,#0]
00008e  6841              LDR      r1,[r0,#4]
000090  f0210101          BIC      r1,r1,#1
000094  6041              STR      r1,[r0,#4]
                  |L1.150|
;;;1695         
;;;1696       }
;;;1697     }
;;;1698     /* Reset Tx and Rx transfer counters */
;;;1699     hspi->RxXferCount = 0U;
000096  87e5              STRH     r5,[r4,#0x3e]
;;;1700     hspi->TxXferCount = 0U;
000098  86e5              STRH     r5,[r4,#0x36]
;;;1701   
;;;1702     /* Reset errorCode */
;;;1703     hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00009a  6565              STR      r5,[r4,#0x54]
;;;1704   
;;;1705     /* Clear the Error flags in the SR register */
;;;1706     __HAL_SPI_CLEAR_OVRFLAG(hspi);
00009c  6820              LDR      r0,[r4,#0]
00009e  68c1              LDR      r1,[r0,#0xc]
0000a0  6880              LDR      r0,[r0,#8]
0000a2  9000              STR      r0,[sp,#0]
;;;1707   
;;;1708     /* Restore hspi->state to ready */
;;;1709     hspi->State = HAL_SPI_STATE_READY;
0000a4  2001              MOVS     r0,#1
0000a6  f8840051          STRB     r0,[r4,#0x51]
;;;1710   
;;;1711     return HAL_OK;
0000aa  2000              MOVS     r0,#0
;;;1712   }
0000ac  bd7c              POP      {r2-r6,pc}
;;;1713   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L1.176|
                          DCD      SystemCoreClock
                  |L1.180|
                          DCD      SPI_AbortTx_ISR
                  |L1.184|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2142     */
;;;2143   __WEAK void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2144   {
;;;2145     /* Prevent unused argument(s) compilation warning */
;;;2146     UNUSED(hspi);
;;;2147   
;;;2148     /* NOTE : This function should not be modified, when the callback is needed,
;;;2149               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2150      */
;;;2151   }
;;;2152   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;1730   */
;;;1731   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1732   {
000002  4604              MOV      r4,r0
;;;1733     uint32_t abortcplt;
;;;1734   
;;;1735     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;1736     if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000004  6820              LDR      r0,[r4,#0]
000006  6841              LDR      r1,[r0,#4]
000008  0609              LSLS     r1,r1,#24
00000a  d501              BPL      |L3.16|
;;;1737     {
;;;1738       hspi->TxISR = SPI_AbortTx_ISR;
00000c  4932              LDR      r1,|L3.216|
00000e  6461              STR      r1,[r4,#0x44]
                  |L3.16|
;;;1739     }
;;;1740   
;;;1741     if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000010  6841              LDR      r1,[r0,#4]
000012  0649              LSLS     r1,r1,#25
000014  d501              BPL      |L3.26|
;;;1742     {
;;;1743       hspi->RxISR = SPI_AbortRx_ISR;
000016  4931              LDR      r1,|L3.220|
000018  6421              STR      r1,[r4,#0x40]
                  |L3.26|
;;;1744     }
;;;1745   
;;;1746     /* Clear ERRIE interrupts in case of DMA Mode */
;;;1747     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
00001a  6841              LDR      r1,[r0,#4]
00001c  f0210120          BIC      r1,r1,#0x20
000020  6041              STR      r1,[r0,#4]
;;;1748   
;;;1749     abortcplt = 1U;
000022  2501              MOVS     r5,#1
;;;1750     
;;;1751     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;1752        before any call to DMA Abort functions */  
;;;1753     /* DMA Tx Handle is valid */
;;;1754     if(hspi->hdmatx != NULL)
000024  6ca0              LDR      r0,[r4,#0x48]
000026  2600              MOVS     r6,#0
000028  b138              CBZ      r0,|L3.58|
;;;1755     {
;;;1756       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1757          Otherwise, set it to NULL */
;;;1758       if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
00002a  6821              LDR      r1,[r4,#0]
00002c  6849              LDR      r1,[r1,#4]
00002e  0789              LSLS     r1,r1,#30
000030  d502              BPL      |L3.56|
;;;1759       {
;;;1760         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
000032  492b              LDR      r1,|L3.224|
000034  6341              STR      r1,[r0,#0x34]
000036  e000              B        |L3.58|
                  |L3.56|
;;;1761       }
;;;1762       else
;;;1763       {
;;;1764         hspi->hdmatx->XferAbortCallback = NULL;
000038  6346              STR      r6,[r0,#0x34]
                  |L3.58|
;;;1765       }
;;;1766     }  
;;;1767     /* DMA Rx Handle is valid */
;;;1768     if(hspi->hdmarx != NULL)
00003a  6ce0              LDR      r0,[r4,#0x4c]
00003c  b138              CBZ      r0,|L3.78|
;;;1769     {
;;;1770       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1771          Otherwise, set it to NULL */
;;;1772       if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
00003e  6821              LDR      r1,[r4,#0]
000040  6849              LDR      r1,[r1,#4]
000042  07c9              LSLS     r1,r1,#31
000044  d002              BEQ      |L3.76|
;;;1773       {
;;;1774         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
000046  4927              LDR      r1,|L3.228|
000048  6341              STR      r1,[r0,#0x34]
00004a  e000              B        |L3.78|
                  |L3.76|
;;;1775       }
;;;1776       else
;;;1777       {
;;;1778         hspi->hdmarx->XferAbortCallback = NULL;
00004c  6346              STR      r6,[r0,#0x34]
                  |L3.78|
;;;1779       }
;;;1780     }
;;;1781   
;;;1782     /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
;;;1783     if((HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN)) && (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN)))
00004e  6820              LDR      r0,[r4,#0]
000050  6841              LDR      r1,[r0,#4]
000052  0789              LSLS     r1,r1,#30
000054  d515              BPL      |L3.130|
000056  6840              LDR      r0,[r0,#4]
000058  07c0              LSLS     r0,r0,#31
00005a  d012              BEQ      |L3.130|
;;;1784     {
;;;1785       /* Abort the SPI DMA Tx channel */
;;;1786       if(hspi->hdmatx != NULL)
00005c  6ca0              LDR      r0,[r4,#0x48]
00005e  b130              CBZ      r0,|L3.110|
;;;1787       {
;;;1788         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;1789         if(HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
000060  f7fffffe          BL       HAL_DMA_Abort_IT
000064  b110              CBZ      r0,|L3.108|
;;;1790         {
;;;1791           hspi->hdmatx->XferAbortCallback = NULL;
000066  6ca0              LDR      r0,[r4,#0x48]
000068  6346              STR      r6,[r0,#0x34]
00006a  e000              B        |L3.110|
                  |L3.108|
;;;1792         }
;;;1793         else
;;;1794         {
;;;1795           abortcplt = 0U;
00006c  2500              MOVS     r5,#0
                  |L3.110|
;;;1796         }
;;;1797       }
;;;1798       /* Abort the SPI DMA Rx channel */
;;;1799       if(hspi->hdmarx != NULL)
00006e  6ce0              LDR      r0,[r4,#0x4c]
000070  b138              CBZ      r0,|L3.130|
;;;1800       {
;;;1801         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;1802         if(HAL_DMA_Abort_IT(hspi->hdmarx)!=  HAL_OK)
000072  f7fffffe          BL       HAL_DMA_Abort_IT
000076  b118              CBZ      r0,|L3.128|
;;;1803         {
;;;1804           hspi->hdmarx->XferAbortCallback = NULL;
000078  6ce0              LDR      r0,[r4,#0x4c]
00007a  6346              STR      r6,[r0,#0x34]
;;;1805           abortcplt = 1U;
00007c  2501              MOVS     r5,#1
00007e  e000              B        |L3.130|
                  |L3.128|
;;;1806         }
;;;1807         else
;;;1808         {
;;;1809           abortcplt = 0U;
000080  2500              MOVS     r5,#0
                  |L3.130|
;;;1810         }
;;;1811       }
;;;1812     }
;;;1813   
;;;1814     /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
;;;1815     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000082  6820              LDR      r0,[r4,#0]
000084  6840              LDR      r0,[r0,#4]
000086  0780              LSLS     r0,r0,#30
000088  d508              BPL      |L3.156|
;;;1816     {
;;;1817       /* Abort the SPI DMA Tx channel */
;;;1818       if(hspi->hdmatx != NULL)
00008a  6ca0              LDR      r0,[r4,#0x48]
00008c  b130              CBZ      r0,|L3.156|
;;;1819       {
;;;1820         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;1821         if(HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
00008e  f7fffffe          BL       HAL_DMA_Abort_IT
000092  b110              CBZ      r0,|L3.154|
;;;1822         {
;;;1823           hspi->hdmatx->XferAbortCallback = NULL;
000094  6ca0              LDR      r0,[r4,#0x48]
000096  6346              STR      r6,[r0,#0x34]
000098  e000              B        |L3.156|
                  |L3.154|
;;;1824         }
;;;1825         else
;;;1826         {
;;;1827           abortcplt = 0U;
00009a  2500              MOVS     r5,#0
                  |L3.156|
;;;1828         }
;;;1829       }
;;;1830     }
;;;1831     /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
;;;1832     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
00009c  6820              LDR      r0,[r4,#0]
00009e  6840              LDR      r0,[r0,#4]
0000a0  07c0              LSLS     r0,r0,#31
0000a2  d008              BEQ      |L3.182|
;;;1833     {
;;;1834       /* Abort the SPI DMA Rx channel */
;;;1835       if(hspi->hdmarx != NULL)
0000a4  6ce0              LDR      r0,[r4,#0x4c]
0000a6  b130              CBZ      r0,|L3.182|
;;;1836       {
;;;1837         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;1838         if(HAL_DMA_Abort_IT(hspi->hdmarx)!=  HAL_OK)
0000a8  f7fffffe          BL       HAL_DMA_Abort_IT
0000ac  b110              CBZ      r0,|L3.180|
;;;1839         {
;;;1840           hspi->hdmarx->XferAbortCallback = NULL;
0000ae  6ce0              LDR      r0,[r4,#0x4c]
0000b0  6346              STR      r6,[r0,#0x34]
0000b2  e000              B        |L3.182|
                  |L3.180|
;;;1841         }
;;;1842         else
;;;1843         {
;;;1844           abortcplt = 0U;
0000b4  2500              MOVS     r5,#0
                  |L3.182|
;;;1845         }
;;;1846       }
;;;1847     }
;;;1848   
;;;1849     if(abortcplt == 1U)
0000b6  2d01              CMP      r5,#1
0000b8  d10c              BNE      |L3.212|
;;;1850     {
;;;1851       /* Reset Tx and Rx transfer counters */
;;;1852       hspi->RxXferCount = 0U;
0000ba  87e6              STRH     r6,[r4,#0x3e]
;;;1853       hspi->TxXferCount = 0U;
0000bc  86e6              STRH     r6,[r4,#0x36]
;;;1854   
;;;1855       /* Reset errorCode */
;;;1856       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
0000be  6566              STR      r6,[r4,#0x54]
;;;1857   
;;;1858       /* Clear the Error flags in the SR register */
;;;1859       __HAL_SPI_CLEAR_OVRFLAG(hspi);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  68c1              LDR      r1,[r0,#0xc]
0000c4  6880              LDR      r0,[r0,#8]
0000c6  9000              STR      r0,[sp,#0]
;;;1860   
;;;1861       /* Restore hspi->State to Ready */
;;;1862       hspi->State = HAL_SPI_STATE_READY;
0000c8  2001              MOVS     r0,#1
0000ca  f8840051          STRB     r0,[r4,#0x51]
;;;1863   
;;;1864       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1865       HAL_SPI_AbortCpltCallback(hspi);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.212|
;;;1866     }
;;;1867     return HAL_OK;
0000d4  2000              MOVS     r0,#0
;;;1868   }
0000d6  bdf8              POP      {r3-r7,pc}
;;;1869   
                          ENDP

                  |L3.216|
                          DCD      SPI_AbortTx_ISR
                  |L3.220|
                          DCD      SPI_AbortRx_ISR
                  |L3.224|
                          DCD      SPI_DMATxAbortCallback
                  |L3.228|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;1875     */
;;;1876   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  f8901050          LDRB     r1,[r0,#0x50]
;;;1877   {
;;;1878     /* Process Locked */
;;;1879     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L4.34|
000008  2101              MOVS     r1,#1
00000a  f8801050          STRB     r1,[r0,#0x50]
;;;1880   
;;;1881     /* Disable the SPI DMA Tx & Rx requests */
;;;1882     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0220203          BIC      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;1883   
;;;1884     /* Process Unlocked */
;;;1885     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f8801050          STRB     r1,[r0,#0x50]
;;;1886   
;;;1887     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1888   }
000020  4770              BX       lr
                  |L4.34|
000022  2002              MOVS     r0,#2                 ;1879
000024  4770              BX       lr
;;;1889   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;1895     */
;;;1896   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  f8901050          LDRB     r1,[r0,#0x50]
;;;1897   {
;;;1898     /* Process Locked */
;;;1899     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L5.34|
000008  2101              MOVS     r1,#1
00000a  f8801050          STRB     r1,[r0,#0x50]
;;;1900   
;;;1901     /* Enable the SPI DMA Tx & Rx requests */
;;;1902     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0420203          ORR      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;1903   
;;;1904     /* Process Unlocked */
;;;1905     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f8801050          STRB     r1,[r0,#0x50]
;;;1906   
;;;1907     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1908   }
000020  4770              BX       lr
                  |L5.34|
000022  2002              MOVS     r0,#2                 ;1899
000024  4770              BX       lr
;;;1909   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;1915     */
;;;1916   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;1917   {
000002  4604              MOV      r4,r0
;;;1918     /* The Lock is not implemented on this API to allow the user application
;;;1919        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
;;;1920        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1921        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
;;;1922        */
;;;1923   
;;;1924     /* Abort the SPI DMA tx Stream */
;;;1925     if(hspi->hdmatx != NULL)
000004  6ca0              LDR      r0,[r4,#0x48]
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L6.14|
;;;1926     {
;;;1927       HAL_DMA_Abort(hspi->hdmatx);
00000a  f7fffffe          BL       HAL_DMA_Abort
                  |L6.14|
;;;1928     }
;;;1929     /* Abort the SPI DMA rx Stream */
;;;1930     if(hspi->hdmarx != NULL)
00000e  6ce0              LDR      r0,[r4,#0x4c]
000010  b108              CBZ      r0,|L6.22|
;;;1931     {
;;;1932       HAL_DMA_Abort(hspi->hdmarx);
000012  f7fffffe          BL       HAL_DMA_Abort
                  |L6.22|
;;;1933     }
;;;1934   
;;;1935     /* Disable the SPI DMA Tx & Rx requests */
;;;1936     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000016  6820              LDR      r0,[r4,#0]
000018  6841              LDR      r1,[r0,#4]
00001a  f0210103          BIC      r1,r1,#3
00001e  6041              STR      r1,[r0,#4]
;;;1937     hspi->State = HAL_SPI_STATE_READY;
000020  2001              MOVS     r0,#1
000022  f8840051          STRB     r0,[r4,#0x51]
;;;1938     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;1939   }
000028  bd10              POP      {r4,pc}
;;;1940   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DeInit PROC
;;;341      */
;;;342    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;343    {
000002  4604              MOV      r4,r0
;;;344      /* Check the SPI handle allocation */
;;;345      if(hspi == NULL)
000004  2c00              CMP      r4,#0
000006  d010              BEQ      |L7.42|
;;;346      {
;;;347        return HAL_ERROR;
;;;348      }
;;;349    
;;;350      /* Check SPI Instance parameter */
;;;351      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;352    
;;;353      hspi->State = HAL_SPI_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  f8840051          STRB     r0,[r4,#0x51]
;;;354    
;;;355      /* Disable the SPI Peripheral Clock */
;;;356      __HAL_SPI_DISABLE(hspi);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210140          BIC      r1,r1,#0x40
000016  6001              STR      r1,[r0,#0]
;;;357    
;;;358      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;359      HAL_SPI_MspDeInit(hspi);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_SPI_MspDeInit
;;;360    
;;;361      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3450              ADDS     r4,r4,#0x50
000022  6060              STR      r0,[r4,#4]
;;;362      hspi->State = HAL_SPI_STATE_RESET;
000024  7060              STRB     r0,[r4,#1]
;;;363    
;;;364      /* Release Lock */
;;;365      __HAL_UNLOCK(hspi);
000026  7020              STRB     r0,[r4,#0]
;;;366    
;;;367      return HAL_OK;
;;;368    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  2001              MOVS     r0,#1                 ;347
00002c  bd10              POP      {r4,pc}
;;;369    
                          ENDP


                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2125     */
;;;2126    __WEAK void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2127   {
;;;2128     /* Prevent unused argument(s) compilation warning */
;;;2129     UNUSED(hspi);
;;;2130     /* NOTE : This function should not be modified, when the callback is needed,
;;;2131               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2132      */
;;;2133     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2134               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2135     */
;;;2136   }
;;;2137   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2189     */
;;;2190   uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
000000  6d40              LDR      r0,[r0,#0x54]
;;;2191   {
;;;2192     /* Return SPI ErrorCode */
;;;2193     return hspi->ErrorCode;
;;;2194   }
000002  4770              BX       lr
;;;2195   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2177     */
;;;2178   HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
000000  f8900051          LDRB     r0,[r0,#0x51]
;;;2179   {
;;;2180     /* Return SPI handle state */
;;;2181     return hspi->State;
;;;2182   }
000004  4770              BX       lr
;;;2183   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;1946     */
;;;1947   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;1948   {
000002  4604              MOV      r4,r0
;;;1949     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6842              LDR      r2,[r0,#4]
;;;1950     uint32_t itflag   = hspi->Instance->SR;
000008  6881              LDR      r1,[r0,#8]
;;;1951   
;;;1952     /* SPI in mode Receiver ----------------------------------------------------*/
;;;1953     if(((itflag & SPI_FLAG_OVR) == RESET) &&
00000a  064b              LSLS     r3,r1,#25
00000c  d409              BMI      |L11.34|
;;;1954        ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
00000e  07cb              LSLS     r3,r1,#31
000010  d007              BEQ      |L11.34|
000012  0653              LSLS     r3,r2,#25
000014  d505              BPL      |L11.34|
;;;1955     {
;;;1956       hspi->RxISR(hspi);
000016  6c21              LDR      r1,[r4,#0x40]
000018  b001              ADD      sp,sp,#4
00001a  4620              MOV      r0,r4
00001c  e8bd4030          POP      {r4,r5,lr}
000020  4708              BX       r1
                  |L11.34|
;;;1957       return;
;;;1958     }
;;;1959   
;;;1960     /* SPI in mode Transmitter -------------------------------------------------*/
;;;1961     if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
000022  078b              LSLS     r3,r1,#30
000024  d507              BPL      |L11.54|
000026  0613              LSLS     r3,r2,#24
000028  d505              BPL      |L11.54|
;;;1962     {
;;;1963       hspi->TxISR(hspi);
00002a  6c61              LDR      r1,[r4,#0x44]
00002c  b001              ADD      sp,sp,#4
00002e  4620              MOV      r0,r4
000030  e8bd4030          POP      {r4,r5,lr}
000034  4708              BX       r1
                  |L11.54|
;;;1964       return;
;;;1965     }
;;;1966   
;;;1967     /* SPI in Error Treatment --------------------------------------------------*/
;;;1968     if(((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR)) != RESET) && ((itsource & SPI_IT_ERR) != RESET))
000036  f0110f60          TST      r1,#0x60
00003a  d043              BEQ      |L11.196|
00003c  0693              LSLS     r3,r2,#26
00003e  d541              BPL      |L11.196|
;;;1969     {
;;;1970       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;1971       if((itflag & SPI_FLAG_OVR) != RESET)
000040  064b              LSLS     r3,r1,#25
000042  d50a              BPL      |L11.90|
;;;1972       {
;;;1973         if(hspi->State != HAL_SPI_STATE_BUSY_TX)
000044  f8943051          LDRB     r3,[r4,#0x51]
000048  2b03              CMP      r3,#3
00004a  d038              BEQ      |L11.190|
;;;1974         {
;;;1975           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
00004c  6d63              LDR      r3,[r4,#0x54]
00004e  f0430304          ORR      r3,r3,#4
000052  6563              STR      r3,[r4,#0x54]
;;;1976           __HAL_SPI_CLEAR_OVRFLAG(hspi);
000054  68c3              LDR      r3,[r0,#0xc]
000056  6883              LDR      r3,[r0,#8]
000058  9300              STR      r3,[sp,#0]
                  |L11.90|
;;;1977         }
;;;1978         else
;;;1979         {
;;;1980           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1981           return;
;;;1982         }
;;;1983       }
;;;1984   
;;;1985       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;1986       if((itflag & SPI_FLAG_MODF) != RESET)
00005a  0689              LSLS     r1,r1,#26
00005c  d509              BPL      |L11.114|
;;;1987       {
;;;1988         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
00005e  6d61              LDR      r1,[r4,#0x54]
000060  f0410101          ORR      r1,r1,#1
000064  6561              STR      r1,[r4,#0x54]
;;;1989         __HAL_SPI_CLEAR_MODFFLAG(hspi);
000066  6881              LDR      r1,[r0,#8]
000068  9100              STR      r1,[sp,#0]
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210140          BIC      r1,r1,#0x40
000070  6001              STR      r1,[r0,#0]
                  |L11.114|
;;;1990       }
;;;1991   
;;;1992       if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000072  6d60              LDR      r0,[r4,#0x54]
000074  2800              CMP      r0,#0
000076  d025              BEQ      |L11.196|
;;;1993       {
;;;1994         /* Disable all interrupts */
;;;1995         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
000078  6820              LDR      r0,[r4,#0]
00007a  6841              LDR      r1,[r0,#4]
00007c  f02101e0          BIC      r1,r1,#0xe0
000080  6041              STR      r1,[r0,#4]
;;;1996   
;;;1997         hspi->State = HAL_SPI_STATE_READY;
000082  2001              MOVS     r0,#1
000084  f8840051          STRB     r0,[r4,#0x51]
;;;1998         /* Disable the SPI DMA requests if enabled */
;;;1999         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN))||(HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
000088  f0020002          AND      r0,r2,#2
00008c  f0020101          AND      r1,r2,#1
000090  4308              ORRS     r0,r0,r1
000092  d018              BEQ      |L11.198|
;;;2000         {
;;;2001           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
000094  6820              LDR      r0,[r4,#0]
000096  6841              LDR      r1,[r0,#4]
000098  f0210103          BIC      r1,r1,#3
00009c  6041              STR      r1,[r0,#4]
;;;2002   
;;;2003           /* Abort the SPI DMA Rx channel */
;;;2004           if(hspi->hdmarx != NULL)
;;;2005           {
;;;2006             /* Set the SPI DMA Abort callback :
;;;2007             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2008             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
00009e  4d0c              LDR      r5,|L11.208|
0000a0  6ce0              LDR      r0,[r4,#0x4c]         ;2004
0000a2  b118              CBZ      r0,|L11.172|
0000a4  6345              STR      r5,[r0,#0x34]
;;;2009             HAL_DMA_Abort_IT(hspi->hdmarx);
0000a6  6ce0              LDR      r0,[r4,#0x4c]
0000a8  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L11.172|
;;;2010           }
;;;2011           /* Abort the SPI DMA Tx channel */
;;;2012           if(hspi->hdmatx != NULL)
0000ac  6ca0              LDR      r0,[r4,#0x48]
0000ae  2800              CMP      r0,#0
0000b0  d008              BEQ      |L11.196|
;;;2013           {
;;;2014             /* Set the SPI DMA Abort callback :
;;;2015             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2016             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
0000b2  6345              STR      r5,[r0,#0x34]
;;;2017             HAL_DMA_Abort_IT(hspi->hdmatx);
0000b4  6ca0              LDR      r0,[r4,#0x48]
0000b6  e8bd4038          POP      {r3-r5,lr}
0000ba  f7ffbffe          B.W      HAL_DMA_Abort_IT
                  |L11.190|
0000be  68c1              LDR      r1,[r0,#0xc]          ;1980
0000c0  6880              LDR      r0,[r0,#8]            ;1980
0000c2  9000              STR      r0,[sp,#0]            ;1980
                  |L11.196|
;;;2018           }
;;;2019         }
;;;2020         else
;;;2021         {
;;;2022           /* Call user error callback */
;;;2023           HAL_SPI_ErrorCallback(hspi);
;;;2024         }
;;;2025       }
;;;2026       return;
;;;2027     }
;;;2028   }
0000c4  bd38              POP      {r3-r5,pc}
                  |L11.198|
0000c6  4620              MOV      r0,r4                 ;2023
0000c8  f7fffffe          BL       HAL_SPI_ErrorCallback
0000cc  bd38              POP      {r3-r5,pc}
;;;2029   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L11.208|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Init PROC
;;;262      */
;;;263    __WEAK HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
000002  4604              MOV      r4,r0
;;;265      /* Check the SPI handle allocation */
;;;266      if(hspi == NULL)
000004  2c00              CMP      r4,#0
000006  d005              BEQ      |L12.20|
;;;267      {
;;;268        return HAL_ERROR;
;;;269      }
;;;270    
;;;271      /* Check the parameters */
;;;272      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;273      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;274      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;275      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;276      assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;277      assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;278      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;279      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;280      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;281    
;;;282    #if (USE_SPI_CRC != 0U)
;;;283      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;284      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;285      {
;;;286        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;287      }
;;;288    #else
;;;289      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
000008  2500              MOVS     r5,#0
00000a  62a5              STR      r5,[r4,#0x28]
;;;290    #endif /* USE_SPI_CRC */
;;;291    
;;;292      if(hspi->State == HAL_SPI_STATE_RESET)
00000c  f8940051          LDRB     r0,[r4,#0x51]
000010  b110              CBZ      r0,|L12.24|
000012  e006              B        |L12.34|
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;268
;;;293      {
;;;294        /* Allocate lock resource and initialize it */
;;;295        hspi->Lock = HAL_UNLOCKED;
;;;296    
;;;297        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;298        HAL_SPI_MspInit(hspi);
;;;299      }
;;;300    
;;;301      hspi->State = HAL_SPI_STATE_BUSY;
;;;302    
;;;303      /* Disable the selected SPI peripheral */
;;;304      __HAL_SPI_DISABLE(hspi);
;;;305    
;;;306      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;307      /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
;;;308      Communication speed, First bit and CRC calculation state */
;;;309      WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
;;;310                                      hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
;;;311                                      hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );
;;;312    
;;;313      /* Configure : NSS management */
;;;314      WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
;;;315    
;;;316    #if (USE_SPI_CRC != 0U)
;;;317      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;318      /* Configure : CRC Polynomial */
;;;319      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;320      {
;;;321        WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
;;;322      }
;;;323    #endif /* USE_SPI_CRC */
;;;324    
;;;325    #if defined(SPI_I2SCFGR_I2SMOD)
;;;326      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;327      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;328    #endif /* SPI_I2SCFGR_I2SMOD */
;;;329    
;;;330      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;331      hspi->State     = HAL_SPI_STATE_READY;
;;;332    
;;;333      return HAL_OK;
;;;334    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  f8845050          STRB     r5,[r4,#0x50]         ;295
00001c  4620              MOV      r0,r4                 ;298
00001e  f7fffffe          BL       HAL_SPI_MspInit
                  |L12.34|
000022  2002              MOVS     r0,#2                 ;301
000024  f8840051          STRB     r0,[r4,#0x51]         ;301
000028  6820              LDR      r0,[r4,#0]            ;304
00002a  6801              LDR      r1,[r0,#0]            ;304
00002c  f0210140          BIC      r1,r1,#0x40           ;304
000030  6001              STR      r1,[r0,#0]            ;304
000032  e9d40101          LDRD     r0,r1,[r4,#4]         ;309
000036  4308              ORRS     r0,r0,r1              ;309
000038  e9d41203          LDRD     r1,r2,[r4,#0xc]       ;309
00003c  4311              ORRS     r1,r1,r2              ;309
00003e  4308              ORRS     r0,r0,r1              ;309
000040  6961              LDR      r1,[r4,#0x14]         ;309
000042  4308              ORRS     r0,r0,r1              ;309
000044  8b21              LDRH     r1,[r4,#0x18]         ;309
000046  f4017100          AND      r1,r1,#0x200          ;309
00004a  4308              ORRS     r0,r0,r1              ;309
00004c  69e1              LDR      r1,[r4,#0x1c]         ;309
00004e  4308              ORRS     r0,r0,r1              ;309
000050  6a21              LDR      r1,[r4,#0x20]         ;309
000052  4308              ORRS     r0,r0,r1              ;309
000054  6aa1              LDR      r1,[r4,#0x28]         ;309
000056  4308              ORRS     r0,r0,r1              ;309
000058  6821              LDR      r1,[r4,#0]            ;309
00005a  6008              STR      r0,[r1,#0]            ;309
00005c  69a0              LDR      r0,[r4,#0x18]         ;314
00005e  2104              MOVS     r1,#4                 ;314
000060  ea014010          AND      r0,r1,r0,LSR #16      ;314
000064  6a61              LDR      r1,[r4,#0x24]         ;314
000066  4308              ORRS     r0,r0,r1              ;314
000068  6821              LDR      r1,[r4,#0]            ;314
00006a  6048              STR      r0,[r1,#4]            ;314
00006c  6820              LDR      r0,[r4,#0]            ;327
00006e  69c1              LDR      r1,[r0,#0x1c]         ;327
000070  f4216100          BIC      r1,r1,#0x800          ;327
000074  61c1              STR      r1,[r0,#0x1c]         ;327
000076  6565              STR      r5,[r4,#0x54]         ;330
000078  2001              MOVS     r0,#1                 ;331
00007a  f8840051          STRB     r0,[r4,#0x51]         ;331
00007e  2000              MOVS     r0,#0                 ;333
000080  bd70              POP      {r4-r6,pc}
;;;335    
                          ENDP


                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;390      */
;;;391    __WEAK void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;392    {
;;;393      /* Prevent unused argument(s) compilation warning */
;;;394      UNUSED(hspi);
;;;395      /* NOTE : This function should not be modified, when the callback is needed,
;;;396                the HAL_SPI_MspDeInit should be implemented in the user file
;;;397      */
;;;398    }
;;;399    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;375      */
;;;376    __WEAK void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;377    {
;;;378      /* Prevent unused argument(s) compilation warning */
;;;379      UNUSED(hspi);
;;;380      /* NOTE : This function should not be modified, when the callback is needed,
;;;381                the HAL_SPI_MspInit should be implemented in the user file
;;;382      */
;;;383    }
;;;384    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;615      */
;;;616    HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;617    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;618    #if (USE_SPI_CRC != 0U)
;;;619      __IO uint16_t tmpreg = 0U;
;;;620    #endif /* USE_SPI_CRC */
;;;621      uint32_t tickstart = 0U;
;;;622      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  2700              MOVS     r7,#0
;;;623    
;;;624      if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
00000e  6860              LDR      r0,[r4,#4]
;;;625      {
;;;626         hspi->State = HAL_SPI_STATE_BUSY_RX;
000010  f04f0b04          MOV      r11,#4
000014  f5b07f82          CMP      r0,#0x104             ;624
000018  d101              BNE      |L15.30|
00001a  68a0              LDR      r0,[r4,#8]            ;624
00001c  b188              CBZ      r0,|L15.66|
                  |L15.30|
;;;627         /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;628        return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
;;;629      }
;;;630    
;;;631      /* Process Locked */
;;;632      __HAL_LOCK(hspi);
00001e  f8940050          LDRB     r0,[r4,#0x50]
000022  2801              CMP      r0,#1
000024  d018              BEQ      |L15.88|
000026  2001              MOVS     r0,#1
000028  f8840050          STRB     r0,[r4,#0x50]
;;;633    
;;;634      /* Init tickstart for timeout management*/
;;;635      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4680              MOV      r8,r0
;;;636    
;;;637      if(hspi->State != HAL_SPI_STATE_READY)
000032  f8940051          LDRB     r0,[r4,#0x51]
000036  f04f0900          MOV      r9,#0
00003a  2801              CMP      r0,#1
00003c  d00e              BEQ      |L15.92|
;;;638      {
;;;639        errorcode = HAL_BUSY;
00003e  2702              MOVS     r7,#2
;;;640        goto error;
000040  e07f              B        |L15.322|
                  |L15.66|
000042  f884b051          STRB     r11,[r4,#0x51]        ;626
000046  4653              MOV      r3,r10                ;628
000048  462a              MOV      r2,r5                 ;628
00004a  4629              MOV      r1,r5                 ;628
00004c  4620              MOV      r0,r4                 ;628
00004e  9600              STR      r6,[sp,#0]            ;628
000050  f7fffffe          BL       HAL_SPI_TransmitReceive
                  |L15.84|
;;;641      }
;;;642    
;;;643      if((pData == NULL ) || (Size == 0U))
;;;644      {
;;;645        errorcode = HAL_ERROR;
;;;646        goto error;
;;;647      }
;;;648    
;;;649      /* Set the transaction information */
;;;650      hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;651      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;652      hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;653      hspi->RxXferSize  = Size;
;;;654      hspi->RxXferCount = Size;
;;;655    
;;;656      /*Init field not used in handle to zero */
;;;657      hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;658      hspi->TxXferSize  = 0U;
;;;659      hspi->TxXferCount = 0U;
;;;660      hspi->RxISR       = NULL;
;;;661      hspi->TxISR       = NULL;
;;;662    
;;;663    #if (USE_SPI_CRC != 0U)
;;;664      /* Reset CRC Calculation */
;;;665      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;666      {
;;;667        SPI_RESET_CRC(hspi);
;;;668        /* this is done to handle the CRCNEXT before the latest data */
;;;669        hspi->RxXferCount--;
;;;670      }
;;;671    #endif /* USE_SPI_CRC */
;;;672    
;;;673      /* Configure communication direction: 1Line */
;;;674      if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;675      {
;;;676        SPI_1LINE_RX(hspi);
;;;677      }
;;;678    
;;;679      /* Check if the SPI is already enabled */
;;;680      if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;681      {
;;;682        /* Enable SPI peripheral */
;;;683        __HAL_SPI_ENABLE(hspi);
;;;684      }
;;;685    
;;;686        /* Receive data in 8 Bit mode */
;;;687      if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
;;;688      {
;;;689        /* Transfer loop */
;;;690        while(hspi->RxXferCount > 0U)
;;;691        {
;;;692          /* Check the RXNE flag */
;;;693          if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;694          {
;;;695            /* read the received data */
;;;696            (* (uint8_t *)pData)= *(__IO uint8_t *)&hspi->Instance->DR;
;;;697            pData += sizeof(uint8_t);
;;;698            hspi->RxXferCount--;
;;;699          }
;;;700          else
;;;701          {
;;;702            /* Timeout management */
;;;703            if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
;;;704            {
;;;705              errorcode = HAL_TIMEOUT;
;;;706              goto error;
;;;707            }
;;;708          }
;;;709        }
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Transfer loop */
;;;714        while(hspi->RxXferCount > 0U)
;;;715        {
;;;716          /* Check the RXNE flag */
;;;717          if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;718          {
;;;719            *((uint16_t*)pData) = hspi->Instance->DR;
;;;720            pData += sizeof(uint16_t);
;;;721            hspi->RxXferCount--;
;;;722          }
;;;723          else
;;;724          {
;;;725            /* Timeout management */
;;;726            if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
;;;727            {
;;;728              errorcode = HAL_TIMEOUT;
;;;729              goto error;
;;;730            }
;;;731          }
;;;732        }
;;;733      }
;;;734    
;;;735    #if (USE_SPI_CRC != 0U)
;;;736      /* Handle the CRC Transmission */
;;;737      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;738      {
;;;739        /* freeze the CRC before the latest data */
;;;740        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;741    
;;;742        /* Read the latest data */
;;;743        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;744        {
;;;745          /* the latest data has not been received */
;;;746          errorcode = HAL_TIMEOUT;
;;;747          goto error;
;;;748        }
;;;749    
;;;750        /* Receive last data in 16 Bit mode */
;;;751        if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;752        {
;;;753          *((uint16_t*)pData) = hspi->Instance->DR;
;;;754        }
;;;755        /* Receive last data in 8 Bit mode */
;;;756        else
;;;757        {
;;;758          (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;759        }
;;;760    
;;;761        /* Wait the CRC data */
;;;762        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;763        {
;;;764          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;765          errorcode = HAL_TIMEOUT;
;;;766          goto error;
;;;767        }
;;;768    
;;;769        /* Read CRC to Flush DR and RXNE flag */
;;;770        tmpreg = hspi->Instance->DR;
;;;771        /* To avoid GCC warning */
;;;772        UNUSED(tmpreg);
;;;773      }
;;;774    #endif /* USE_SPI_CRC */
;;;775    
;;;776      /* Check the end of the transaction */
;;;777      if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;778      {
;;;779        /* Disable SPI peripheral */
;;;780        __HAL_SPI_DISABLE(hspi);
;;;781      }
;;;782    
;;;783    #if (USE_SPI_CRC != 0U)
;;;784        /* Check if CRC error occurred */
;;;785        if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;786        {
;;;787          /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;788          if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;789          {
;;;790            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;791    
;;;792            /* Reset CRC Calculation */
;;;793            SPI_RESET_CRC(hspi);
;;;794          }
;;;795          else
;;;796          {
;;;797            __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;798          }
;;;799        }
;;;800    #endif /* USE_SPI_CRC */
;;;801    
;;;802      if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;803      {
;;;804        errorcode = HAL_ERROR;
;;;805      }
;;;806    
;;;807    error :
;;;808      hspi->State = HAL_SPI_STATE_READY;
;;;809      __HAL_UNLOCK(hspi);
;;;810      return errorcode;
;;;811    }
000054  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.88|
000058  2002              MOVS     r0,#2                 ;632
00005a  e7fb              B        |L15.84|
                  |L15.92|
00005c  b355              CBZ      r5,|L15.180|
00005e  f1ba0f00          CMP      r10,#0                ;643
000062  d027              BEQ      |L15.180|
000064  f884b051          STRB     r11,[r4,#0x51]        ;650
000068  f8c49054          STR      r9,[r4,#0x54]         ;651
00006c  63a5              STR      r5,[r4,#0x38]         ;652
00006e  f8a4a03c          STRH     r10,[r4,#0x3c]        ;653
000072  f8a4a03e          STRH     r10,[r4,#0x3e]        ;654
000076  f8c49030          STR      r9,[r4,#0x30]         ;657
00007a  f8a49034          STRH     r9,[r4,#0x34]         ;658
00007e  f8a49036          STRH     r9,[r4,#0x36]         ;659
000082  f8c49040          STR      r9,[r4,#0x40]         ;660
000086  f8c49044          STR      r9,[r4,#0x44]         ;661
00008a  68a0              LDR      r0,[r4,#8]            ;674
00008c  f44f4a00          MOV      r10,#0x8000           ;674
000090  4550              CMP      r0,r10                ;674
000092  d104              BNE      |L15.158|
000094  6820              LDR      r0,[r4,#0]            ;676
000096  6801              LDR      r1,[r0,#0]            ;676
000098  f4214180          BIC      r1,r1,#0x4000         ;676
00009c  6001              STR      r1,[r0,#0]            ;676
                  |L15.158|
00009e  6820              LDR      r0,[r4,#0]            ;680
0000a0  6801              LDR      r1,[r0,#0]            ;680
0000a2  0649              LSLS     r1,r1,#25             ;680
0000a4  d403              BMI      |L15.174|
0000a6  6801              LDR      r1,[r0,#0]            ;683
0000a8  f0410140          ORR      r1,r1,#0x40           ;683
0000ac  6001              STR      r1,[r0,#0]            ;683
                  |L15.174|
0000ae  68e0              LDR      r0,[r4,#0xc]          ;687
0000b0  b1c0              CBZ      r0,|L15.228|
0000b2  e031              B        |L15.280|
                  |L15.180|
0000b4  2701              MOVS     r7,#1                 ;645
0000b6  e044              B        |L15.322|
                  |L15.184|
0000b8  6820              LDR      r0,[r4,#0]            ;693
0000ba  6881              LDR      r1,[r0,#8]            ;693
0000bc  07c9              LSLS     r1,r1,#31             ;693
0000be  d006              BEQ      |L15.206|
0000c0  7b00              LDRB     r0,[r0,#0xc]          ;696
0000c2  f8050b01          STRB     r0,[r5],#1            ;696
0000c6  8fe0              LDRH     r0,[r4,#0x3e]         ;698
0000c8  1e40              SUBS     r0,r0,#1              ;698
0000ca  87e0              STRH     r0,[r4,#0x3e]         ;698
0000cc  e00a              B        |L15.228|
                  |L15.206|
0000ce  b13e              CBZ      r6,|L15.224|
0000d0  1c70              ADDS     r0,r6,#1              ;703
0000d2  d007              BEQ      |L15.228|
0000d4  f7fffffe          BL       HAL_GetTick
0000d8  eba00008          SUB      r0,r0,r8              ;703
0000dc  42b0              CMP      r0,r6                 ;703
0000de  d301              BCC      |L15.228|
                  |L15.224|
0000e0  2703              MOVS     r7,#3                 ;705
0000e2  e02e              B        |L15.322|
                  |L15.228|
0000e4  8fe0              LDRH     r0,[r4,#0x3e]         ;690
0000e6  2800              CMP      r0,#0                 ;690
0000e8  d1e6              BNE      |L15.184|
0000ea  e018              B        |L15.286|
                  |L15.236|
0000ec  6820              LDR      r0,[r4,#0]            ;717
0000ee  6881              LDR      r1,[r0,#8]            ;717
0000f0  07c9              LSLS     r1,r1,#31             ;717
0000f2  d006              BEQ      |L15.258|
0000f4  68c0              LDR      r0,[r0,#0xc]          ;719
0000f6  f8250b02          STRH     r0,[r5],#2            ;719
0000fa  8fe0              LDRH     r0,[r4,#0x3e]         ;721
0000fc  1e40              SUBS     r0,r0,#1              ;721
0000fe  87e0              STRH     r0,[r4,#0x3e]         ;721
000100  e00a              B        |L15.280|
                  |L15.258|
000102  b13e              CBZ      r6,|L15.276|
000104  1c70              ADDS     r0,r6,#1              ;726
000106  d007              BEQ      |L15.280|
000108  f7fffffe          BL       HAL_GetTick
00010c  eba00008          SUB      r0,r0,r8              ;726
000110  42b0              CMP      r0,r6                 ;726
000112  d301              BCC      |L15.280|
                  |L15.276|
000114  2703              MOVS     r7,#3                 ;728
000116  e014              B        |L15.322|
                  |L15.280|
000118  8fe0              LDRH     r0,[r4,#0x3e]         ;714
00011a  2800              CMP      r0,#0                 ;714
00011c  d1e6              BNE      |L15.236|
                  |L15.286|
00011e  6860              LDR      r0,[r4,#4]            ;777
000120  f5b07f82          CMP      r0,#0x104             ;777
000124  d10a              BNE      |L15.316|
000126  68a0              LDR      r0,[r4,#8]            ;777
000128  4550              CMP      r0,r10                ;777
00012a  d002              BEQ      |L15.306|
00012c  f5b06f80          CMP      r0,#0x400             ;777
000130  d104              BNE      |L15.316|
                  |L15.306|
000132  6820              LDR      r0,[r4,#0]            ;780
000134  6801              LDR      r1,[r0,#0]            ;780
000136  f0210140          BIC      r1,r1,#0x40           ;780
00013a  6001              STR      r1,[r0,#0]            ;780
                  |L15.316|
00013c  6d60              LDR      r0,[r4,#0x54]         ;802
00013e  b100              CBZ      r0,|L15.322|
000140  2701              MOVS     r7,#1                 ;804
                  |L15.322|
000142  2001              MOVS     r0,#1                 ;808
000144  f8840051          STRB     r0,[r4,#0x51]         ;808
000148  f8849050          STRB     r9,[r4,#0x50]         ;809
00014c  4638              MOV      r0,r7                 ;810
00014e  e781              B        |L15.84|
;;;812    
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1415     */
;;;1416   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1417   {
000004  4604              MOV      r4,r0
;;;1418     HAL_StatusTypeDef errorcode = HAL_OK;
000006  2600              MOVS     r6,#0
;;;1419   
;;;1420     if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
000008  68a0              LDR      r0,[r4,#8]
;;;1421     {
;;;1422        hspi->State = HAL_SPI_STATE_BUSY_RX;
00000a  2304              MOVS     r3,#4
00000c  2800              CMP      r0,#0                 ;1420
00000e  d103              BNE      |L16.24|
000010  6865              LDR      r5,[r4,#4]            ;1420
000012  f5b57f82          CMP      r5,#0x104             ;1420
000016  d00d              BEQ      |L16.52|
                  |L16.24|
;;;1423        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1424        return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
;;;1425     }
;;;1426   
;;;1427     /* Process Locked */
;;;1428     __HAL_LOCK(hspi);
000018  f8945050          LDRB     r5,[r4,#0x50]
00001c  2d01              CMP      r5,#1
00001e  d012              BEQ      |L16.70|
000020  2501              MOVS     r5,#1
000022  f8845050          STRB     r5,[r4,#0x50]
;;;1429   
;;;1430     if(hspi->State != HAL_SPI_STATE_READY)
000026  f8947051          LDRB     r7,[r4,#0x51]
00002a  2500              MOVS     r5,#0
00002c  2f01              CMP      r7,#1
00002e  d00d              BEQ      |L16.76|
;;;1431     {
;;;1432       errorcode = HAL_BUSY;
000030  2602              MOVS     r6,#2
;;;1433       goto error;
000032  e046              B        |L16.194|
                  |L16.52|
000034  f8843051          STRB     r3,[r4,#0x51]         ;1422
000038  4620              MOV      r0,r4                 ;1424
00003a  e8bd41f0          POP      {r4-r8,lr}            ;1424
00003e  4613              MOV      r3,r2                 ;1424
000040  460a              MOV      r2,r1                 ;1424
000042  f7ffbffe          B.W      HAL_SPI_TransmitReceive_DMA
                  |L16.70|
000046  2002              MOVS     r0,#2                 ;1428
                  |L16.72|
;;;1434     }
;;;1435   
;;;1436     if((pData == NULL) || (Size == 0U))
;;;1437     {
;;;1438       errorcode = HAL_ERROR;
;;;1439       goto error;
;;;1440     }
;;;1441   
;;;1442     /* Set the transaction information */
;;;1443     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1444     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1445     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1446     hspi->RxXferSize  = Size;
;;;1447     hspi->RxXferCount = Size;
;;;1448   
;;;1449     /*Init field not used in handle to zero */
;;;1450     hspi->RxISR       = NULL;
;;;1451     hspi->TxISR       = NULL;
;;;1452     hspi->TxXferSize  = 0U;
;;;1453     hspi->TxXferCount = 0U;
;;;1454   
;;;1455     /* Configure communication direction : 1Line */
;;;1456     if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1457     {
;;;1458       SPI_1LINE_RX(hspi);
;;;1459     }
;;;1460   
;;;1461   #if (USE_SPI_CRC != 0U)
;;;1462     /* Reset CRC Calculation */
;;;1463     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1464     {
;;;1465       SPI_RESET_CRC(hspi);
;;;1466     }
;;;1467   #endif /* USE_SPI_CRC */
;;;1468   
;;;1469     /* Set the SPI RxDMA Half transfer complete callback */
;;;1470     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1471   
;;;1472     /* Set the SPI Rx DMA transfer complete callback */
;;;1473     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;1474   
;;;1475     /* Set the DMA error callback */
;;;1476     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1477   
;;;1478    /* Set the DMA AbortCpltCallback */
;;;1479     hspi->hdmarx->XferAbortCallback = NULL;
;;;1480   
;;;1481     /* Enable the Rx DMA Stream */
;;;1482     HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
;;;1483   
;;;1484     /* Check if the SPI is already enabled */
;;;1485     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1486     {
;;;1487       /* Enable SPI peripheral */
;;;1488       __HAL_SPI_ENABLE(hspi);
;;;1489     }
;;;1490   
;;;1491     /* Enable the SPI Error Interrupt Bit */
;;;1492     SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
;;;1493   
;;;1494     /* Enable Rx DMA Request */
;;;1495     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1496   
;;;1497   error:
;;;1498     /* Process Unlocked */
;;;1499     __HAL_UNLOCK(hspi);
;;;1500     return errorcode;
;;;1501   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L16.76|
00004c  b171              CBZ      r1,|L16.108|
00004e  b16a              CBZ      r2,|L16.108|
000050  f8843051          STRB     r3,[r4,#0x51]         ;1443
000054  6565              STR      r5,[r4,#0x54]         ;1444
000056  63a1              STR      r1,[r4,#0x38]         ;1445
000058  87a2              STRH     r2,[r4,#0x3c]         ;1446
00005a  87e2              STRH     r2,[r4,#0x3e]         ;1447
00005c  6425              STR      r5,[r4,#0x40]         ;1450
00005e  6465              STR      r5,[r4,#0x44]         ;1451
000060  86a5              STRH     r5,[r4,#0x34]         ;1452
000062  86e5              STRH     r5,[r4,#0x36]         ;1453
000064  f5b04f00          CMP      r0,#0x8000            ;1456
000068  d002              BEQ      |L16.112|
00006a  e006              B        |L16.122|
                  |L16.108|
00006c  2601              MOVS     r6,#1                 ;1438
00006e  e028              B        |L16.194|
                  |L16.112|
000070  6820              LDR      r0,[r4,#0]            ;1458
000072  6801              LDR      r1,[r0,#0]            ;1458
000074  f4214180          BIC      r1,r1,#0x4000         ;1458
000078  6001              STR      r1,[r0,#0]            ;1458
                  |L16.122|
00007a  6ce1              LDR      r1,[r4,#0x4c]         ;1470
00007c  4813              LDR      r0,|L16.204|
00007e  62c8              STR      r0,[r1,#0x2c]         ;1470
000080  6ce1              LDR      r1,[r4,#0x4c]         ;1473
000082  4813              LDR      r0,|L16.208|
000084  6288              STR      r0,[r1,#0x28]         ;1473
000086  6ce1              LDR      r1,[r4,#0x4c]         ;1476
000088  4812              LDR      r0,|L16.212|
00008a  6308              STR      r0,[r1,#0x30]         ;1476
00008c  6ce0              LDR      r0,[r4,#0x4c]         ;1479
00008e  6345              STR      r5,[r0,#0x34]         ;1479
000090  8fe3              LDRH     r3,[r4,#0x3e]         ;1482
000092  6821              LDR      r1,[r4,#0]            ;1482
000094  6ba2              LDR      r2,[r4,#0x38]         ;1482
000096  310c              ADDS     r1,r1,#0xc            ;1482
000098  6ce0              LDR      r0,[r4,#0x4c]         ;1482
00009a  f7fffffe          BL       HAL_DMA_Start_IT
00009e  6820              LDR      r0,[r4,#0]            ;1485
0000a0  6801              LDR      r1,[r0,#0]            ;1485
0000a2  0649              LSLS     r1,r1,#25             ;1485
0000a4  d403              BMI      |L16.174|
0000a6  6801              LDR      r1,[r0,#0]            ;1488
0000a8  f0410140          ORR      r1,r1,#0x40           ;1488
0000ac  6001              STR      r1,[r0,#0]            ;1488
                  |L16.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1492
0000b0  6841              LDR      r1,[r0,#4]            ;1492
0000b2  f0410120          ORR      r1,r1,#0x20           ;1492
0000b6  6041              STR      r1,[r0,#4]            ;1492
0000b8  6820              LDR      r0,[r4,#0]            ;1495
0000ba  6841              LDR      r1,[r0,#4]            ;1495
0000bc  f0410101          ORR      r1,r1,#1              ;1495
0000c0  6041              STR      r1,[r0,#4]            ;1495
                  |L16.194|
0000c2  f8845050          STRB     r5,[r4,#0x50]         ;1499
0000c6  4630              MOV      r0,r6                 ;1500
0000c8  e7be              B        |L16.72|
;;;1502   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L16.204|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.208|
                          DCD      SPI_DMAReceiveCplt
                  |L16.212|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1144     */
;;;1145   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b4f0              PUSH     {r4-r7}
;;;1146   {
;;;1147     HAL_StatusTypeDef errorcode = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1148   
;;;1149     if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
000004  6885              LDR      r5,[r0,#8]
;;;1150     {
;;;1151        hspi->State = HAL_SPI_STATE_BUSY_RX;
000006  2604              MOVS     r6,#4
000008  2d00              CMP      r5,#0                 ;1149
00000a  d103              BNE      |L17.20|
00000c  6844              LDR      r4,[r0,#4]            ;1149
00000e  f5b47f82          CMP      r4,#0x104             ;1149
000012  d00d              BEQ      |L17.48|
                  |L17.20|
;;;1152        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1153        return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
;;;1154     }
;;;1155   
;;;1156     /* Process Locked */
;;;1157     __HAL_LOCK(hspi);
000014  f8904050          LDRB     r4,[r0,#0x50]
000018  2c01              CMP      r4,#1
00001a  d010              BEQ      |L17.62|
00001c  2401              MOVS     r4,#1
00001e  f8804050          STRB     r4,[r0,#0x50]
;;;1158   
;;;1159     if(hspi->State != HAL_SPI_STATE_READY)
000022  f8907051          LDRB     r7,[r0,#0x51]
000026  2400              MOVS     r4,#0
000028  2f01              CMP      r7,#1
00002a  d00b              BEQ      |L17.68|
;;;1160     {
;;;1161       errorcode = HAL_BUSY;
00002c  2302              MOVS     r3,#2
;;;1162       goto error;
00002e  e033              B        |L17.152|
                  |L17.48|
000030  f8806051          STRB     r6,[r0,#0x51]         ;1151
000034  bcf0              POP      {r4-r7}               ;1153
000036  4613              MOV      r3,r2                 ;1153
000038  460a              MOV      r2,r1                 ;1153
00003a  f7ffbffe          B.W      HAL_SPI_TransmitReceive_IT
                  |L17.62|
00003e  2002              MOVS     r0,#2                 ;1157
                  |L17.64|
;;;1163     }
;;;1164   
;;;1165     if((pData == NULL) || (Size == 0U))
;;;1166     {
;;;1167       errorcode = HAL_ERROR;
;;;1168       goto error;
;;;1169     }
;;;1170   
;;;1171     /* Set the transaction information */
;;;1172     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1173     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1174     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1175     hspi->RxXferSize  = Size;
;;;1176     hspi->RxXferCount = Size;
;;;1177   
;;;1178     /* Init field not used in handle to zero */
;;;1179     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1180     hspi->TxXferSize  = 0U;
;;;1181     hspi->TxXferCount = 0U;
;;;1182     hspi->TxISR       = NULL;
;;;1183   
;;;1184     /* Set the function for IT treatment */
;;;1185     if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
;;;1186     {
;;;1187       hspi->RxISR = SPI_RxISR_16BIT;
;;;1188     }
;;;1189     else
;;;1190     {
;;;1191       hspi->RxISR = SPI_RxISR_8BIT;
;;;1192     }
;;;1193   
;;;1194     /* Configure communication direction : 1Line */
;;;1195     if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1196     {
;;;1197       SPI_1LINE_RX(hspi);
;;;1198     }
;;;1199   
;;;1200   #if (USE_SPI_CRC != 0U)
;;;1201     /* Reset CRC Calculation */
;;;1202     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1203     {
;;;1204       SPI_RESET_CRC(hspi);
;;;1205     }
;;;1206   #endif /* USE_SPI_CRC */
;;;1207   
;;;1208     /* Enable TXE and ERR interrupt */
;;;1209     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1210   
;;;1211     /* Note : The SPI must be enabled after unlocking current process
;;;1212               to avoid the risk of SPI interrupt handle execution before current
;;;1213               process unlock */
;;;1214   
;;;1215     /* Check if the SPI is already enabled */
;;;1216     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1217     {
;;;1218       /* Enable SPI peripheral */
;;;1219       __HAL_SPI_ENABLE(hspi);
;;;1220     }
;;;1221   
;;;1222   error :
;;;1223     /* Process Unlocked */
;;;1224     __HAL_UNLOCK(hspi);
;;;1225     return errorcode;
;;;1226   }
000040  bcf0              POP      {r4-r7}
000042  4770              BX       lr
                  |L17.68|
000044  b179              CBZ      r1,|L17.102|
000046  b172              CBZ      r2,|L17.102|
000048  f8806051          STRB     r6,[r0,#0x51]         ;1172
00004c  6544              STR      r4,[r0,#0x54]         ;1173
00004e  6381              STR      r1,[r0,#0x38]         ;1174
000050  8782              STRH     r2,[r0,#0x3c]         ;1175
000052  87c2              STRH     r2,[r0,#0x3e]         ;1176
000054  6304              STR      r4,[r0,#0x30]         ;1179
000056  8684              STRH     r4,[r0,#0x34]         ;1180
000058  86c4              STRH     r4,[r0,#0x36]         ;1181
00005a  6444              STR      r4,[r0,#0x44]         ;1182
00005c  68c1              LDR      r1,[r0,#0xc]          ;1185
00005e  b121              CBZ      r1,|L17.106|
000060  490f              LDR      r1,|L17.160|
000062  6401              STR      r1,[r0,#0x40]         ;1187
000064  e003              B        |L17.110|
                  |L17.102|
000066  2301              MOVS     r3,#1                 ;1167
000068  e016              B        |L17.152|
                  |L17.106|
00006a  490e              LDR      r1,|L17.164|
00006c  6401              STR      r1,[r0,#0x40]         ;1191
                  |L17.110|
00006e  f5b54f00          CMP      r5,#0x8000            ;1195
000072  d104              BNE      |L17.126|
000074  6801              LDR      r1,[r0,#0]            ;1197
000076  680a              LDR      r2,[r1,#0]            ;1197
000078  f4224280          BIC      r2,r2,#0x4000         ;1197
00007c  600a              STR      r2,[r1,#0]            ;1197
                  |L17.126|
00007e  6801              LDR      r1,[r0,#0]            ;1209
000080  684a              LDR      r2,[r1,#4]            ;1209
000082  f0420260          ORR      r2,r2,#0x60           ;1209
000086  604a              STR      r2,[r1,#4]            ;1209
000088  6801              LDR      r1,[r0,#0]            ;1216
00008a  680a              LDR      r2,[r1,#0]            ;1216
00008c  0652              LSLS     r2,r2,#25             ;1216
00008e  d403              BMI      |L17.152|
000090  680a              LDR      r2,[r1,#0]            ;1219
000092  f0420240          ORR      r2,r2,#0x40           ;1219
000096  600a              STR      r2,[r1,#0]            ;1219
                  |L17.152|
000098  f8804050          STRB     r4,[r0,#0x50]         ;1224
00009c  4618              MOV      r0,r3                 ;1225
00009e  e7cf              B        |L17.64|
;;;1227   
                          ENDP

                  |L17.160|
                          DCD      SPI_RxISR_16BIT
                  |L17.164|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2050     */
;;;2051   __WEAK void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2052   {
;;;2053     /* Prevent unused argument(s) compilation warning */
;;;2054     UNUSED(hspi);
;;;2055     /* NOTE : This function should not be modified, when the callback is needed,
;;;2056               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2057     */
;;;2058   }
;;;2059   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2095     */
;;;2096   __WEAK void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2097   {
;;;2098     /* Prevent unused argument(s) compilation warning */
;;;2099     UNUSED(hspi);
;;;2100     /* NOTE : This function should not be modified, when the callback is needed,
;;;2101               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2102     */
;;;2103   }
;;;2104   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Transmit PROC
;;;445      */
;;;446    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;447    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4693              MOV      r11,r2
00000a  461e              MOV      r6,r3
;;;448      uint32_t tickstart = 0U;
;;;449      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  2700              MOVS     r7,#0
;;;450    
;;;451      /* Check Direction parameter */
;;;452      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;453    
;;;454      /* Process Locked */
;;;455      __HAL_LOCK(hspi);
00000e  f8940050          LDRB     r0,[r4,#0x50]
000012  2801              CMP      r0,#1
000014  d00d              BEQ      |L20.50|
000016  f04f0a01          MOV      r10,#1
00001a  f884a050          STRB     r10,[r4,#0x50]
;;;456    
;;;457      /* Init tickstart for timeout management*/
;;;458      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4680              MOV      r8,r0
;;;459    
;;;460      if(hspi->State != HAL_SPI_STATE_READY)
000024  f8940051          LDRB     r0,[r4,#0x51]
000028  46b9              MOV      r9,r7
00002a  2801              CMP      r0,#1
00002c  d004              BEQ      |L20.56|
;;;461      {
;;;462        errorcode = HAL_BUSY;
00002e  2702              MOVS     r7,#2
;;;463        goto error;
000030  e09e              B        |L20.368|
                  |L20.50|
000032  2002              MOVS     r0,#2                 ;455
                  |L20.52|
;;;464      }
;;;465    
;;;466      if((pData == NULL ) || (Size == 0U))
;;;467      {
;;;468        errorcode = HAL_ERROR;
;;;469        goto error;
;;;470      }
;;;471    
;;;472      /* Set the transaction information */
;;;473      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;474      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;475      hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;476      hspi->TxXferSize  = Size;
;;;477      hspi->TxXferCount = Size;
;;;478    
;;;479      /*Init field not used in handle to zero */
;;;480      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;481      hspi->RxXferSize  = 0U;
;;;482      hspi->RxXferCount = 0U;
;;;483      hspi->TxISR       = NULL;
;;;484      hspi->RxISR       = NULL;
;;;485    
;;;486      /* Configure communication direction : 1Line */
;;;487      if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;488      {
;;;489        SPI_1LINE_TX(hspi);
;;;490      }
;;;491    
;;;492    #if (USE_SPI_CRC != 0U)
;;;493      /* Reset CRC Calculation */
;;;494      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;495      {
;;;496        SPI_RESET_CRC(hspi);
;;;497      }
;;;498    #endif /* USE_SPI_CRC */
;;;499    
;;;500      /* Check if the SPI is already enabled */
;;;501      if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;502      {
;;;503        /* Enable SPI peripheral */
;;;504        __HAL_SPI_ENABLE(hspi);
;;;505      }
;;;506    
;;;507      /* Transmit data in 16 Bit mode */
;;;508      if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;509      {
;;;510        if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
;;;511        {
;;;512          hspi->Instance->DR = *((uint16_t *)pData);
;;;513          pData += sizeof(uint16_t);
;;;514          hspi->TxXferCount--;
;;;515        }
;;;516        /* Transmit data in 16 Bit mode */
;;;517        while (hspi->TxXferCount > 0U)
;;;518        {
;;;519          /* Wait until TXE flag is set to send data */
;;;520          if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;521          {
;;;522              hspi->Instance->DR = *((uint16_t *)pData);
;;;523              pData += sizeof(uint16_t);
;;;524              hspi->TxXferCount--;
;;;525          }
;;;526          else
;;;527          {
;;;528            /* Timeout management */
;;;529            if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
;;;530            {
;;;531              errorcode = HAL_TIMEOUT;
;;;532              goto error;
;;;533            }
;;;534          }
;;;535        }
;;;536      }
;;;537      /* Transmit data in 8 Bit mode */
;;;538      else
;;;539      {
;;;540        if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
;;;541        {
;;;542          *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
;;;543          pData += sizeof(uint8_t);
;;;544          hspi->TxXferCount--;
;;;545        }
;;;546        while (hspi->TxXferCount > 0U)
;;;547        {
;;;548          /* Wait until TXE flag is set to send data */
;;;549          if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;550          {
;;;551            *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
;;;552            pData += sizeof(uint8_t);
;;;553            hspi->TxXferCount--;
;;;554          }
;;;555          else
;;;556          {
;;;557            /* Timeout management */
;;;558            if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
;;;559            {
;;;560              errorcode = HAL_TIMEOUT;
;;;561              goto error;
;;;562            }
;;;563          }
;;;564        }
;;;565      }
;;;566    
;;;567      /* Wait until TXE flag */
;;;568      if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
;;;569      {
;;;570        errorcode = HAL_TIMEOUT;
;;;571        goto error;
;;;572      }
;;;573      
;;;574      /* Check Busy flag */
;;;575      if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
;;;576      {
;;;577        errorcode = HAL_ERROR;
;;;578        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;579        goto error;
;;;580      }
;;;581    
;;;582      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;583      if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;584      {
;;;585        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;586      }
;;;587    #if (USE_SPI_CRC != 0U)
;;;588      /* Enable CRC Transmission */
;;;589      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;590      {
;;;591         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;592      }
;;;593    #endif /* USE_SPI_CRC */
;;;594    
;;;595      if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;596      {
;;;597        errorcode = HAL_ERROR;
;;;598      }
;;;599    
;;;600    error:
;;;601      hspi->State = HAL_SPI_STATE_READY;
;;;602      /* Process Unlocked */
;;;603      __HAL_UNLOCK(hspi);
;;;604      return errorcode;
;;;605    }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.56|
000038  b1dd              CBZ      r5,|L20.114|
00003a  f1bb0f00          CMP      r11,#0                ;466
00003e  d018              BEQ      |L20.114|
000040  2003              MOVS     r0,#3                 ;473
000042  f8840051          STRB     r0,[r4,#0x51]         ;473
000046  f8c49054          STR      r9,[r4,#0x54]         ;474
00004a  6325              STR      r5,[r4,#0x30]         ;475
00004c  f8a4b034          STRH     r11,[r4,#0x34]        ;476
000050  f8a4b036          STRH     r11,[r4,#0x36]        ;477
000054  f8c49038          STR      r9,[r4,#0x38]         ;480
000058  f8a4903c          STRH     r9,[r4,#0x3c]         ;481
00005c  f8a4903e          STRH     r9,[r4,#0x3e]         ;482
000060  f8c49044          STR      r9,[r4,#0x44]         ;483
000064  f8c49040          STR      r9,[r4,#0x40]         ;484
000068  68a0              LDR      r0,[r4,#8]            ;487
00006a  f5b04f00          CMP      r0,#0x8000            ;487
00006e  d002              BEQ      |L20.118|
000070  e006              B        |L20.128|
                  |L20.114|
000072  2701              MOVS     r7,#1                 ;468
000074  e07c              B        |L20.368|
                  |L20.118|
000076  6820              LDR      r0,[r4,#0]            ;489
000078  6801              LDR      r1,[r0,#0]            ;489
00007a  f4414180          ORR      r1,r1,#0x4000         ;489
00007e  6001              STR      r1,[r0,#0]            ;489
                  |L20.128|
000080  6820              LDR      r0,[r4,#0]            ;501
000082  6801              LDR      r1,[r0,#0]            ;501
000084  0649              LSLS     r1,r1,#25             ;501
000086  d403              BMI      |L20.144|
000088  6801              LDR      r1,[r0,#0]            ;504
00008a  f0410140          ORR      r1,r1,#0x40           ;504
00008e  6001              STR      r1,[r0,#0]            ;504
                  |L20.144|
000090  68e0              LDR      r0,[r4,#0xc]          ;508
000092  f5b06f00          CMP      r0,#0x800             ;508
000096  d005              BEQ      |L20.164|
000098  6860              LDR      r0,[r4,#4]            ;540
00009a  b350              CBZ      r0,|L20.242|
00009c  8ee0              LDRH     r0,[r4,#0x36]         ;540
00009e  2801              CMP      r0,#1                 ;540
0000a0  d027              BEQ      |L20.242|
0000a2  e044              B        |L20.302|
                  |L20.164|
0000a4  6860              LDR      r0,[r4,#4]            ;510
0000a6  b110              CBZ      r0,|L20.174|
0000a8  8ee0              LDRH     r0,[r4,#0x36]         ;510
0000aa  2801              CMP      r0,#1                 ;510
0000ac  d11d              BNE      |L20.234|
                  |L20.174|
0000ae  6821              LDR      r1,[r4,#0]            ;512
0000b0  f8350b02          LDRH     r0,[r5],#2            ;512
0000b4  60c8              STR      r0,[r1,#0xc]          ;512
0000b6  8ee0              LDRH     r0,[r4,#0x36]         ;514
0000b8  1e40              SUBS     r0,r0,#1              ;514
0000ba  86e0              STRH     r0,[r4,#0x36]         ;514
0000bc  e015              B        |L20.234|
                  |L20.190|
0000be  6820              LDR      r0,[r4,#0]            ;520
0000c0  6881              LDR      r1,[r0,#8]            ;520
0000c2  0789              LSLS     r1,r1,#30             ;520
0000c4  d506              BPL      |L20.212|
0000c6  f8351b02          LDRH     r1,[r5],#2            ;522
0000ca  60c1              STR      r1,[r0,#0xc]          ;522
0000cc  8ee0              LDRH     r0,[r4,#0x36]         ;524
0000ce  1e40              SUBS     r0,r0,#1              ;524
0000d0  86e0              STRH     r0,[r4,#0x36]         ;524
0000d2  e00a              B        |L20.234|
                  |L20.212|
0000d4  b13e              CBZ      r6,|L20.230|
0000d6  1c70              ADDS     r0,r6,#1              ;529
0000d8  d007              BEQ      |L20.234|
0000da  f7fffffe          BL       HAL_GetTick
0000de  eba00008          SUB      r0,r0,r8              ;529
0000e2  42b0              CMP      r0,r6                 ;529
0000e4  d301              BCC      |L20.234|
                  |L20.230|
0000e6  2703              MOVS     r7,#3                 ;531
0000e8  e042              B        |L20.368|
                  |L20.234|
0000ea  8ee0              LDRH     r0,[r4,#0x36]         ;517
0000ec  2800              CMP      r0,#0                 ;517
0000ee  d1e6              BNE      |L20.190|
0000f0  e020              B        |L20.308|
                  |L20.242|
0000f2  6821              LDR      r1,[r4,#0]            ;542
0000f4  f8150b01          LDRB     r0,[r5],#1            ;542
0000f8  7308              STRB     r0,[r1,#0xc]          ;542
0000fa  8ee0              LDRH     r0,[r4,#0x36]         ;544
0000fc  1e40              SUBS     r0,r0,#1              ;544
0000fe  86e0              STRH     r0,[r4,#0x36]         ;544
000100  e015              B        |L20.302|
                  |L20.258|
000102  6820              LDR      r0,[r4,#0]            ;549
000104  6881              LDR      r1,[r0,#8]            ;549
000106  0789              LSLS     r1,r1,#30             ;549
000108  d506              BPL      |L20.280|
00010a  f8151b01          LDRB     r1,[r5],#1            ;551
00010e  7301              STRB     r1,[r0,#0xc]          ;551
000110  8ee0              LDRH     r0,[r4,#0x36]         ;553
000112  1e40              SUBS     r0,r0,#1              ;553
000114  86e0              STRH     r0,[r4,#0x36]         ;553
000116  e00a              B        |L20.302|
                  |L20.280|
000118  b13e              CBZ      r6,|L20.298|
00011a  1c70              ADDS     r0,r6,#1              ;558
00011c  d007              BEQ      |L20.302|
00011e  f7fffffe          BL       HAL_GetTick
000122  eba00008          SUB      r0,r0,r8              ;558
000126  42b0              CMP      r0,r6                 ;558
000128  d301              BCC      |L20.302|
                  |L20.298|
00012a  2703              MOVS     r7,#3                 ;560
00012c  e020              B        |L20.368|
                  |L20.302|
00012e  8ee0              LDRH     r0,[r4,#0x36]         ;546
000130  2800              CMP      r0,#0                 ;546
000132  d1e6              BNE      |L20.258|
                  |L20.308|
000134  4633              MOV      r3,r6                 ;568
000136  2201              MOVS     r2,#1                 ;568
000138  2102              MOVS     r1,#2                 ;568
00013a  4620              MOV      r0,r4                 ;568
00013c  f8cd8000          STR      r8,[sp,#0]            ;568
000140  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000144  b108              CBZ      r0,|L20.330|
000146  2703              MOVS     r7,#3                 ;570
000148  e012              B        |L20.368|
                  |L20.330|
00014a  4642              MOV      r2,r8                 ;575
00014c  4631              MOV      r1,r6                 ;575
00014e  4620              MOV      r0,r4                 ;575
000150  f7fffffe          BL       SPI_CheckFlag_BSY
000154  b118              CBZ      r0,|L20.350|
000156  2701              MOVS     r7,#1                 ;577
000158  2020              MOVS     r0,#0x20              ;578
00015a  6560              STR      r0,[r4,#0x54]         ;578
00015c  e008              B        |L20.368|
                  |L20.350|
00015e  68a0              LDR      r0,[r4,#8]            ;583
000160  b918              CBNZ     r0,|L20.362|
000162  6820              LDR      r0,[r4,#0]            ;585
000164  68c1              LDR      r1,[r0,#0xc]          ;585
000166  6880              LDR      r0,[r0,#8]            ;585
000168  9000              STR      r0,[sp,#0]            ;585
                  |L20.362|
00016a  6d60              LDR      r0,[r4,#0x54]         ;595
00016c  b100              CBZ      r0,|L20.368|
00016e  2701              MOVS     r7,#1                 ;597
                  |L20.368|
000170  f884a051          STRB     r10,[r4,#0x51]        ;601
000174  f8849050          STRB     r9,[r4,#0x50]         ;603
000178  4638              MOV      r0,r7                 ;604
00017a  e75b              B        |L20.52|
;;;606    
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TransmitReceive PROC
;;;822      */
;;;823    HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;824    {
000004  4604              MOV      r4,r0
000006  f8dd8028          LDR      r8,[sp,#0x28]
00000a  460d              MOV      r5,r1
00000c  4616              MOV      r6,r2
00000e  469b              MOV      r11,r3
;;;825      uint32_t tmp = 0U, tmp1 = 0U;
;;;826    #if (USE_SPI_CRC != 0U)
;;;827      __IO uint16_t tmpreg1 = 0U;
;;;828    #endif /* USE_SPI_CRC */
;;;829      uint32_t tickstart = 0U;
;;;830      /* Variable used to alternate Rx and Tx during transfer */
;;;831      uint32_t txallowed = 1U;
000010  2701              MOVS     r7,#1
;;;832      HAL_StatusTypeDef errorcode = HAL_OK;
000012  f04f0900          MOV      r9,#0
;;;833    
;;;834      /* Check Direction parameter */
;;;835      assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;836    
;;;837      /* Process Locked */
;;;838      __HAL_LOCK(hspi);
000016  f8940050          LDRB     r0,[r4,#0x50]
00001a  2801              CMP      r0,#1
00001c  d00e              BEQ      |L21.60|
00001e  2001              MOVS     r0,#1
000020  f8840050          STRB     r0,[r4,#0x50]
;;;839    
;;;840      /* Init tickstart for timeout management*/
;;;841      tickstart = HAL_GetTick();
000024  f7fffffe          BL       HAL_GetTick
000028  4682              MOV      r10,r0
;;;842      
;;;843      tmp  = hspi->State;
00002a  f8940051          LDRB     r0,[r4,#0x51]
;;;844      tmp1 = hspi->Init.Mode;
00002e  6861              LDR      r1,[r4,#4]
;;;845      
;;;846      if(!((tmp == HAL_SPI_STATE_READY) || \
000030  2801              CMP      r0,#1
000032  d00d              BEQ      |L21.80|
000034  f5b17f82          CMP      r1,#0x104
000038  d107              BNE      |L21.74|
00003a  e002              B        |L21.66|
                  |L21.60|
00003c  2002              MOVS     r0,#2                 ;838
                  |L21.62|
;;;847        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
;;;848      {
;;;849        errorcode = HAL_BUSY;
;;;850        goto error;
;;;851      }
;;;852    
;;;853      if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;854      {
;;;855        errorcode = HAL_ERROR;
;;;856        goto error;
;;;857      }
;;;858    
;;;859      /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;860      if(hspi->State == HAL_SPI_STATE_READY)
;;;861      {
;;;862        hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;863      }
;;;864    
;;;865      /* Set the transaction information */
;;;866      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;867      hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;868      hspi->RxXferCount = Size;
;;;869      hspi->RxXferSize  = Size;
;;;870      hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;871      hspi->TxXferCount = Size;
;;;872      hspi->TxXferSize  = Size;
;;;873    
;;;874      /*Init field not used in handle to zero */
;;;875      hspi->RxISR       = NULL;
;;;876      hspi->TxISR       = NULL;
;;;877    
;;;878    #if (USE_SPI_CRC != 0U)
;;;879      /* Reset CRC Calculation */
;;;880      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;881      {
;;;882        SPI_RESET_CRC(hspi);
;;;883      }
;;;884    #endif /* USE_SPI_CRC */
;;;885    
;;;886      /* Check if the SPI is already enabled */
;;;887      if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;888      {
;;;889        /* Enable SPI peripheral */
;;;890        __HAL_SPI_ENABLE(hspi);
;;;891      }
;;;892    
;;;893      /* Transmit and Receive data in 16 Bit mode */
;;;894      if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;895      {
;;;896        if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
;;;897        {
;;;898          hspi->Instance->DR = *((uint16_t *)pTxData);
;;;899          pTxData += sizeof(uint16_t);
;;;900          hspi->TxXferCount--;
;;;901        }
;;;902        while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;903        {
;;;904          /* Check TXE flag */
;;;905          if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
;;;906          {
;;;907            hspi->Instance->DR = *((uint16_t *)pTxData);
;;;908            pTxData += sizeof(uint16_t);
;;;909            hspi->TxXferCount--;
;;;910            /* Next Data is a reception (Rx). Tx not allowed */ 
;;;911            txallowed = 0U;
;;;912    
;;;913    #if (USE_SPI_CRC != 0U)
;;;914            /* Enable CRC Transmission */
;;;915            if((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;916            {
;;;917              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;918            }
;;;919    #endif /* USE_SPI_CRC */
;;;920          }
;;;921    
;;;922          /* Check RXNE flag */
;;;923          if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
;;;924          {
;;;925            *((uint16_t *)pRxData) = hspi->Instance->DR;
;;;926            pRxData += sizeof(uint16_t);
;;;927            hspi->RxXferCount--;
;;;928            /* Next Data is a Transmission (Tx). Tx is allowed */ 
;;;929            txallowed = 1U;
;;;930          }
;;;931          if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
;;;932          {
;;;933            errorcode = HAL_TIMEOUT;
;;;934            goto error;
;;;935          }
;;;936        }
;;;937      }
;;;938      /* Transmit and Receive data in 8 Bit mode */
;;;939      else
;;;940      {
;;;941        if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
;;;942        {
;;;943          *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
;;;944          pTxData += sizeof(uint8_t);
;;;945          hspi->TxXferCount--;
;;;946        }
;;;947        while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;948        {
;;;949          /* check TXE flag */
;;;950          if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
;;;951          {
;;;952            *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
;;;953            hspi->TxXferCount--;
;;;954            /* Next Data is a reception (Rx). Tx not allowed */ 
;;;955            txallowed = 0U;
;;;956    
;;;957    #if (USE_SPI_CRC != 0U)
;;;958            /* Enable CRC Transmission */
;;;959            if((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;960            {
;;;961              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;962            }
;;;963    #endif /* USE_SPI_CRC */
;;;964          }
;;;965    
;;;966          /* Wait until RXNE flag is reset */
;;;967          if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
;;;968          {
;;;969            (*(uint8_t *)pRxData++) = hspi->Instance->DR;
;;;970            hspi->RxXferCount--;
;;;971            /* Next Data is a Transmission (Tx). Tx is allowed */ 
;;;972            txallowed = 1U;
;;;973          }
;;;974          if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
;;;975          {
;;;976            errorcode = HAL_TIMEOUT;
;;;977            goto error;
;;;978          }
;;;979        }
;;;980      }
;;;981    
;;;982    #if (USE_SPI_CRC != 0U)
;;;983      /* Read CRC from DR to close CRC calculation process */
;;;984      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;985      {
;;;986        /* Wait until TXE flag */
;;;987        if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;988        {
;;;989          /* Error on the CRC reception */
;;;990          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;991          errorcode = HAL_TIMEOUT;
;;;992          goto error;
;;;993        }
;;;994        /* Read CRC */
;;;995        tmpreg1 = hspi->Instance->DR;
;;;996        /* To avoid GCC warning */
;;;997        UNUSED(tmpreg1);
;;;998      }
;;;999    
;;;1000     /* Check if CRC error occurred */
;;;1001     if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;1002     {
;;;1003       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;1004       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;1005       {
;;;1006         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1007   
;;;1008         /* Reset CRC Calculation */
;;;1009         SPI_RESET_CRC(hspi);
;;;1010   
;;;1011      	  errorcode = HAL_ERROR;
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1016       }
;;;1017     }
;;;1018   #endif /* USE_SPI_CRC */
;;;1019   
;;;1020     /* Wait until TXE flag */
;;;1021     if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
;;;1022     {
;;;1023       errorcode = HAL_TIMEOUT;
;;;1024       goto error;
;;;1025     }
;;;1026     
;;;1027     /* Check Busy flag */
;;;1028     if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
;;;1029     {
;;;1030       errorcode = HAL_ERROR;
;;;1031       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1032       goto error;
;;;1033     }
;;;1034   
;;;1035     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;1036     if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1037     {
;;;1038       __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1039     }
;;;1040     
;;;1041   error :
;;;1042     hspi->State = HAL_SPI_STATE_READY;
;;;1043     __HAL_UNLOCK(hspi);
;;;1044     return errorcode;
;;;1045   }
00003e  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.66|
000042  68a1              LDR      r1,[r4,#8]            ;846
000044  b909              CBNZ     r1,|L21.74|
000046  2804              CMP      r0,#4                 ;846
000048  d002              BEQ      |L21.80|
                  |L21.74|
00004a  f04f0902          MOV      r9,#2                 ;849
00004e  e0bd              B        |L21.460|
                  |L21.80|
000050  b145              CBZ      r5,|L21.100|
000052  b13e              CBZ      r6,|L21.100|
000054  f1bb0f00          CMP      r11,#0                ;853
000058  d004              BEQ      |L21.100|
00005a  f8940051          LDRB     r0,[r4,#0x51]         ;860
00005e  2801              CMP      r0,#1                 ;860
000060  d003              BEQ      |L21.106|
000062  e005              B        |L21.112|
                  |L21.100|
000064  f04f0901          MOV      r9,#1                 ;855
000068  e0b0              B        |L21.460|
                  |L21.106|
00006a  2005              MOVS     r0,#5                 ;862
00006c  f8840051          STRB     r0,[r4,#0x51]         ;862
                  |L21.112|
000070  2000              MOVS     r0,#0                 ;866
000072  6560              STR      r0,[r4,#0x54]         ;866
000074  63a6              STR      r6,[r4,#0x38]         ;867
000076  f8a4b03e          STRH     r11,[r4,#0x3e]        ;868
00007a  f8a4b03c          STRH     r11,[r4,#0x3c]        ;869
00007e  6325              STR      r5,[r4,#0x30]         ;870
000080  f8a4b036          STRH     r11,[r4,#0x36]        ;871
000084  f8a4b034          STRH     r11,[r4,#0x34]        ;872
000088  6420              STR      r0,[r4,#0x40]         ;875
00008a  6460              STR      r0,[r4,#0x44]         ;876
00008c  6820              LDR      r0,[r4,#0]            ;887
00008e  6801              LDR      r1,[r0,#0]            ;887
000090  0649              LSLS     r1,r1,#25             ;887
000092  d403              BMI      |L21.156|
000094  6801              LDR      r1,[r0,#0]            ;890
000096  f0410140          ORR      r1,r1,#0x40           ;890
00009a  6001              STR      r1,[r0,#0]            ;890
                  |L21.156|
00009c  68e0              LDR      r0,[r4,#0xc]          ;894
00009e  f5b06f00          CMP      r0,#0x800             ;894
0000a2  d005              BEQ      |L21.176|
0000a4  6860              LDR      r0,[r4,#4]            ;941
0000a6  b3b8              CBZ      r0,|L21.280|
0000a8  8ee0              LDRH     r0,[r4,#0x36]         ;941
0000aa  2801              CMP      r0,#1                 ;941
0000ac  d03c              BEQ      |L21.296|
0000ae  e06a              B        |L21.390|
                  |L21.176|
0000b0  6860              LDR      r0,[r4,#4]            ;896
0000b2  b110              CBZ      r0,|L21.186|
0000b4  8ee0              LDRH     r0,[r4,#0x36]         ;896
0000b6  2801              CMP      r0,#1                 ;896
0000b8  d12f              BNE      |L21.282|
                  |L21.186|
0000ba  6821              LDR      r1,[r4,#0]            ;898
0000bc  f8350b02          LDRH     r0,[r5],#2            ;898
0000c0  60c8              STR      r0,[r1,#0xc]          ;898
0000c2  8ee0              LDRH     r0,[r4,#0x36]         ;900
0000c4  1e40              SUBS     r0,r0,#1              ;900
0000c6  86e0              STRH     r0,[r4,#0x36]         ;900
0000c8  e027              B        |L21.282|
                  |L21.202|
0000ca  b167              CBZ      r7,|L21.230|
0000cc  8ee0              LDRH     r0,[r4,#0x36]         ;905
0000ce  b150              CBZ      r0,|L21.230|
0000d0  6820              LDR      r0,[r4,#0]            ;905
0000d2  6881              LDR      r1,[r0,#8]            ;905
0000d4  0789              LSLS     r1,r1,#30             ;905
0000d6  d506              BPL      |L21.230|
0000d8  f8351b02          LDRH     r1,[r5],#2            ;907
0000dc  60c1              STR      r1,[r0,#0xc]          ;907
0000de  8ee0              LDRH     r0,[r4,#0x36]         ;909
0000e0  1e40              SUBS     r0,r0,#1              ;909
0000e2  86e0              STRH     r0,[r4,#0x36]         ;909
0000e4  2700              MOVS     r7,#0                 ;911
                  |L21.230|
0000e6  8fe0              LDRH     r0,[r4,#0x3e]         ;923
0000e8  b150              CBZ      r0,|L21.256|
0000ea  6820              LDR      r0,[r4,#0]            ;923
0000ec  6881              LDR      r1,[r0,#8]            ;923
0000ee  07c9              LSLS     r1,r1,#31             ;923
0000f0  d006              BEQ      |L21.256|
0000f2  68c0              LDR      r0,[r0,#0xc]          ;925
0000f4  f8260b02          STRH     r0,[r6],#2            ;925
0000f8  8fe0              LDRH     r0,[r4,#0x3e]         ;927
0000fa  1e40              SUBS     r0,r0,#1              ;927
0000fc  87e0              STRH     r0,[r4,#0x3e]         ;927
0000fe  2701              MOVS     r7,#1                 ;929
                  |L21.256|
000100  f1b83fff          CMP      r8,#0xffffffff        ;931
000104  d009              BEQ      |L21.282|
000106  f7fffffe          BL       HAL_GetTick
00010a  eba0000a          SUB      r0,r0,r10             ;931
00010e  4540              CMP      r0,r8                 ;931
000110  d303              BCC      |L21.282|
000112  f04f0903          MOV      r9,#3                 ;933
000116  e059              B        |L21.460|
                  |L21.280|
000118  e006              B        |L21.296|
                  |L21.282|
00011a  8ee0              LDRH     r0,[r4,#0x36]         ;902
00011c  2800              CMP      r0,#0                 ;902
00011e  d1d4              BNE      |L21.202|
000120  8fe0              LDRH     r0,[r4,#0x3e]         ;902
000122  2800              CMP      r0,#0                 ;902
000124  d1d1              BNE      |L21.202|
000126  e034              B        |L21.402|
                  |L21.296|
000128  6821              LDR      r1,[r4,#0]            ;943
00012a  f8150b01          LDRB     r0,[r5],#1            ;943
00012e  7308              STRB     r0,[r1,#0xc]          ;943
000130  8ee0              LDRH     r0,[r4,#0x36]         ;945
000132  1e40              SUBS     r0,r0,#1              ;945
000134  86e0              STRH     r0,[r4,#0x36]         ;945
000136  e026              B        |L21.390|
                  |L21.312|
000138  b167              CBZ      r7,|L21.340|
00013a  8ee0              LDRH     r0,[r4,#0x36]         ;950
00013c  b150              CBZ      r0,|L21.340|
00013e  6820              LDR      r0,[r4,#0]            ;950
000140  6881              LDR      r1,[r0,#8]            ;950
000142  0789              LSLS     r1,r1,#30             ;950
000144  d506              BPL      |L21.340|
000146  f8151b01          LDRB     r1,[r5],#1            ;952
00014a  7301              STRB     r1,[r0,#0xc]          ;952
00014c  8ee0              LDRH     r0,[r4,#0x36]         ;953
00014e  1e40              SUBS     r0,r0,#1              ;953
000150  86e0              STRH     r0,[r4,#0x36]         ;953
000152  2700              MOVS     r7,#0                 ;955
                  |L21.340|
000154  8fe0              LDRH     r0,[r4,#0x3e]         ;967
000156  b150              CBZ      r0,|L21.366|
000158  6820              LDR      r0,[r4,#0]            ;967
00015a  6881              LDR      r1,[r0,#8]            ;967
00015c  07c9              LSLS     r1,r1,#31             ;967
00015e  d006              BEQ      |L21.366|
000160  68c0              LDR      r0,[r0,#0xc]          ;969
000162  f8060b01          STRB     r0,[r6],#1            ;969
000166  8fe0              LDRH     r0,[r4,#0x3e]         ;970
000168  1e40              SUBS     r0,r0,#1              ;970
00016a  87e0              STRH     r0,[r4,#0x3e]         ;970
00016c  2701              MOVS     r7,#1                 ;972
                  |L21.366|
00016e  f1b83fff          CMP      r8,#0xffffffff        ;974
000172  d008              BEQ      |L21.390|
000174  f7fffffe          BL       HAL_GetTick
000178  eba0000a          SUB      r0,r0,r10             ;974
00017c  4540              CMP      r0,r8                 ;974
00017e  d302              BCC      |L21.390|
000180  f04f0903          MOV      r9,#3                 ;976
000184  e022              B        |L21.460|
                  |L21.390|
000186  8ee0              LDRH     r0,[r4,#0x36]         ;947
000188  2800              CMP      r0,#0                 ;947
00018a  d1d5              BNE      |L21.312|
00018c  8fe0              LDRH     r0,[r4,#0x3e]         ;947
00018e  2800              CMP      r0,#0                 ;947
000190  d1d2              BNE      |L21.312|
                  |L21.402|
000192  4643              MOV      r3,r8                 ;1021
000194  2201              MOVS     r2,#1                 ;1021
000196  2102              MOVS     r1,#2                 ;1021
000198  4620              MOV      r0,r4                 ;1021
00019a  f8cda000          STR      r10,[sp,#0]           ;1021
00019e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0001a2  b110              CBZ      r0,|L21.426|
0001a4  f04f0903          MOV      r9,#3                 ;1023
0001a8  e010              B        |L21.460|
                  |L21.426|
0001aa  4652              MOV      r2,r10                ;1028
0001ac  4641              MOV      r1,r8                 ;1028
0001ae  4620              MOV      r0,r4                 ;1028
0001b0  f7fffffe          BL       SPI_CheckFlag_BSY
0001b4  b120              CBZ      r0,|L21.448|
0001b6  f04f0901          MOV      r9,#1                 ;1030
0001ba  2020              MOVS     r0,#0x20              ;1031
0001bc  6560              STR      r0,[r4,#0x54]         ;1031
0001be  e005              B        |L21.460|
                  |L21.448|
0001c0  68a0              LDR      r0,[r4,#8]            ;1036
0001c2  b918              CBNZ     r0,|L21.460|
0001c4  6820              LDR      r0,[r4,#0]            ;1038
0001c6  68c1              LDR      r1,[r0,#0xc]          ;1038
0001c8  6880              LDR      r0,[r0,#8]            ;1038
0001ca  9000              STR      r0,[sp,#0]            ;1038
                  |L21.460|
0001cc  2001              MOVS     r0,#1                 ;1042
0001ce  3450              ADDS     r4,r4,#0x50           ;1042
0001d0  7060              STRB     r0,[r4,#1]            ;1042
0001d2  2000              MOVS     r0,#0                 ;1043
0001d4  7020              STRB     r0,[r4,#0]            ;1043
0001d6  4648              MOV      r0,r9                 ;1044
0001d8  e731              B        |L21.62|
;;;1046   
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;1512     */
;;;1513   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1514   {
000004  4604              MOV      r4,r0
;;;1515     uint32_t tmp = 0U, tmp1 = 0U;
;;;1516     HAL_StatusTypeDef errorcode = HAL_OK;
000006  2600              MOVS     r6,#0
;;;1517   
;;;1518     /* Check Direction parameter */
;;;1519     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1520   
;;;1521     /* Process locked */
;;;1522     __HAL_LOCK(hspi);
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2801              CMP      r0,#1
00000e  d00c              BEQ      |L22.42|
000010  2001              MOVS     r0,#1
000012  f8840050          STRB     r0,[r4,#0x50]
;;;1523   
;;;1524     tmp  = hspi->State;
000016  f8940051          LDRB     r0,[r4,#0x51]
;;;1525     tmp1 = hspi->Init.Mode;
00001a  6867              LDR      r7,[r4,#4]
;;;1526     if(!((tmp == HAL_SPI_STATE_READY) ||
00001c  2500              MOVS     r5,#0
00001e  2801              CMP      r0,#1
000020  d00c              BEQ      |L22.60|
000022  f5b77f82          CMP      r7,#0x104
000026  d107              BNE      |L22.56|
000028  e002              B        |L22.48|
                  |L22.42|
00002a  2002              MOVS     r0,#2                 ;1522
                  |L22.44|
;;;1527         ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
;;;1528     {
;;;1529       errorcode = HAL_BUSY;
;;;1530       goto error;
;;;1531     }
;;;1532   
;;;1533     if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0U))
;;;1534     {
;;;1535       errorcode = HAL_ERROR;
;;;1536       goto error;
;;;1537     }
;;;1538   
;;;1539     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1540     if(hspi->State == HAL_SPI_STATE_READY)
;;;1541     {
;;;1542       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1543     }
;;;1544   
;;;1545     /* Set the transaction information */
;;;1546     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1547     hspi->pTxBuffPtr  = (uint8_t*)pTxData;
;;;1548     hspi->TxXferSize  = Size;
;;;1549     hspi->TxXferCount = Size;
;;;1550     hspi->pRxBuffPtr  = (uint8_t*)pRxData;
;;;1551     hspi->RxXferSize  = Size;
;;;1552     hspi->RxXferCount = Size;
;;;1553   
;;;1554     /* Init field not used in handle to zero */
;;;1555     hspi->RxISR       = NULL;
;;;1556     hspi->TxISR       = NULL;
;;;1557   
;;;1558   #if (USE_SPI_CRC != 0U)
;;;1559     /* Reset CRC Calculation */
;;;1560     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1561     {
;;;1562       SPI_RESET_CRC(hspi);
;;;1563     }
;;;1564   #endif /* USE_SPI_CRC */
;;;1565   
;;;1566     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;1567     if(hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;1568     {
;;;1569       /* Set the SPI Rx DMA Half transfer complete callback */
;;;1570       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1571       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;1576       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;1577       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;1578     }
;;;1579   
;;;1580     /* Set the DMA error callback */
;;;1581     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1582   
;;;1583     /* Set the DMA AbortCpltCallback */
;;;1584     hspi->hdmarx->XferAbortCallback = NULL;
;;;1585   
;;;1586     /* Enable the Rx DMA Stream */
;;;1587     HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
;;;1588   
;;;1589     /* Enable Rx DMA Request */
;;;1590     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1591   
;;;1592     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;1593     is performed in DMA reception complete callback  */
;;;1594     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;1595     hspi->hdmatx->XferCpltCallback     = NULL;
;;;1596     hspi->hdmatx->XferErrorCallback    = NULL;
;;;1597     hspi->hdmatx->XferAbortCallback    = NULL;
;;;1598   
;;;1599     /* Enable the Tx DMA Stream */
;;;1600     HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
;;;1601   
;;;1602     /* Check if the SPI is already enabled */
;;;1603     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1604     {
;;;1605       /* Enable SPI peripheral */
;;;1606       __HAL_SPI_ENABLE(hspi);
;;;1607     }
;;;1608     /* Enable the SPI Error Interrupt Bit */
;;;1609     SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
;;;1610   
;;;1611     /* Enable Tx DMA Request */
;;;1612     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1613   
;;;1614   error :
;;;1615     /* Process Unlocked */
;;;1616     __HAL_UNLOCK(hspi);
;;;1617     return errorcode;
;;;1618   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L22.48|
000030  68a7              LDR      r7,[r4,#8]            ;1526
000032  b90f              CBNZ     r7,|L22.56|
000034  2804              CMP      r0,#4                 ;1526
000036  d001              BEQ      |L22.60|
                  |L22.56|
000038  2602              MOVS     r6,#2                 ;1529
00003a  e051              B        |L22.224|
                  |L22.60|
00003c  b131              CBZ      r1,|L22.76|
00003e  b12a              CBZ      r2,|L22.76|
000040  b123              CBZ      r3,|L22.76|
000042  f8940051          LDRB     r0,[r4,#0x51]         ;1540
000046  2801              CMP      r0,#1                 ;1540
000048  d002              BEQ      |L22.80|
00004a  e004              B        |L22.86|
                  |L22.76|
00004c  2601              MOVS     r6,#1                 ;1535
00004e  e047              B        |L22.224|
                  |L22.80|
000050  2005              MOVS     r0,#5                 ;1542
000052  f8840051          STRB     r0,[r4,#0x51]         ;1542
                  |L22.86|
000056  6565              STR      r5,[r4,#0x54]         ;1546
000058  6321              STR      r1,[r4,#0x30]         ;1547
00005a  86a3              STRH     r3,[r4,#0x34]         ;1548
00005c  86e3              STRH     r3,[r4,#0x36]         ;1549
00005e  63a2              STR      r2,[r4,#0x38]         ;1550
000060  87a3              STRH     r3,[r4,#0x3c]         ;1551
000062  87e3              STRH     r3,[r4,#0x3e]         ;1552
000064  6425              STR      r5,[r4,#0x40]         ;1555
000066  6465              STR      r5,[r4,#0x44]         ;1556
000068  f8940051          LDRB     r0,[r4,#0x51]         ;1567
00006c  2804              CMP      r0,#4                 ;1567
00006e  d03b              BEQ      |L22.232|
000070  6ce1              LDR      r1,[r4,#0x4c]         ;1576
000072  4821              LDR      r0,|L22.248|
000074  62c8              STR      r0,[r1,#0x2c]         ;1576
000076  6ce1              LDR      r1,[r4,#0x4c]         ;1577
000078  4820              LDR      r0,|L22.252|
00007a  6288              STR      r0,[r1,#0x28]         ;1577
                  |L22.124|
00007c  6ce1              LDR      r1,[r4,#0x4c]         ;1581
00007e  4820              LDR      r0,|L22.256|
000080  6308              STR      r0,[r1,#0x30]         ;1581
000082  6ce0              LDR      r0,[r4,#0x4c]         ;1584
000084  6345              STR      r5,[r0,#0x34]         ;1584
000086  8fe3              LDRH     r3,[r4,#0x3e]         ;1587
000088  6821              LDR      r1,[r4,#0]            ;1587
00008a  6ba2              LDR      r2,[r4,#0x38]         ;1587
00008c  310c              ADDS     r1,r1,#0xc            ;1587
00008e  6ce0              LDR      r0,[r4,#0x4c]         ;1587
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  6820              LDR      r0,[r4,#0]            ;1590
000096  6841              LDR      r1,[r0,#4]            ;1590
000098  f0410101          ORR      r1,r1,#1              ;1590
00009c  6041              STR      r1,[r0,#4]            ;1590
00009e  6ca0              LDR      r0,[r4,#0x48]         ;1594
0000a0  62c5              STR      r5,[r0,#0x2c]         ;1594
0000a2  6ca0              LDR      r0,[r4,#0x48]         ;1595
0000a4  6285              STR      r5,[r0,#0x28]         ;1595
0000a6  6ca0              LDR      r0,[r4,#0x48]         ;1596
0000a8  6305              STR      r5,[r0,#0x30]         ;1596
0000aa  6ca0              LDR      r0,[r4,#0x48]         ;1597
0000ac  6345              STR      r5,[r0,#0x34]         ;1597
0000ae  8ee3              LDRH     r3,[r4,#0x36]         ;1600
0000b0  6822              LDR      r2,[r4,#0]            ;1600
0000b2  6b21              LDR      r1,[r4,#0x30]         ;1600
0000b4  320c              ADDS     r2,r2,#0xc            ;1600
0000b6  6ca0              LDR      r0,[r4,#0x48]         ;1600
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  6820              LDR      r0,[r4,#0]            ;1603
0000be  6801              LDR      r1,[r0,#0]            ;1603
0000c0  0649              LSLS     r1,r1,#25             ;1603
0000c2  d403              BMI      |L22.204|
0000c4  6801              LDR      r1,[r0,#0]            ;1606
0000c6  f0410140          ORR      r1,r1,#0x40           ;1606
0000ca  6001              STR      r1,[r0,#0]            ;1606
                  |L22.204|
0000cc  6820              LDR      r0,[r4,#0]            ;1609
0000ce  6841              LDR      r1,[r0,#4]            ;1609
0000d0  f0410120          ORR      r1,r1,#0x20           ;1609
0000d4  6041              STR      r1,[r0,#4]            ;1609
0000d6  6820              LDR      r0,[r4,#0]            ;1612
0000d8  6841              LDR      r1,[r0,#4]            ;1612
0000da  f0410102          ORR      r1,r1,#2              ;1612
0000de  6041              STR      r1,[r0,#4]            ;1612
                  |L22.224|
0000e0  f8845050          STRB     r5,[r4,#0x50]         ;1616
0000e4  4630              MOV      r0,r6                 ;1617
0000e6  e7a1              B        |L22.44|
                  |L22.232|
0000e8  6ce1              LDR      r1,[r4,#0x4c]         ;1570
0000ea  4806              LDR      r0,|L22.260|
0000ec  62c8              STR      r0,[r1,#0x2c]         ;1570
0000ee  6ce1              LDR      r1,[r4,#0x4c]         ;1571
0000f0  4805              LDR      r0,|L22.264|
0000f2  6288              STR      r0,[r1,#0x28]         ;1571
0000f4  e7c2              B        |L22.124|
;;;1619   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L22.248|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.252|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.256|
                          DCD      SPI_DMAError
                  |L22.260|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.264|
                          DCD      SPI_DMAReceiveCplt

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1236     */
;;;1237   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1238   {
;;;1239     uint32_t tmp = 0U, tmp1 = 0U;
;;;1240     HAL_StatusTypeDef errorcode = HAL_OK;
000002  2400              MOVS     r4,#0
;;;1241   
;;;1242     /* Check Direction parameter */
;;;1243     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1244   
;;;1245     /* Process locked */
;;;1246     __HAL_LOCK(hspi);
000004  f8905050          LDRB     r5,[r0,#0x50]
000008  2d01              CMP      r5,#1
00000a  d00c              BEQ      |L23.38|
00000c  2501              MOVS     r5,#1
00000e  f8805050          STRB     r5,[r0,#0x50]
;;;1247   
;;;1248     tmp  = hspi->State;
000012  f8905051          LDRB     r5,[r0,#0x51]
;;;1249     tmp1 = hspi->Init.Mode;
000016  6846              LDR      r6,[r0,#4]
;;;1250     
;;;1251     if(!((tmp == HAL_SPI_STATE_READY) || \
000018  2700              MOVS     r7,#0
00001a  2d01              CMP      r5,#1
00001c  d00b              BEQ      |L23.54|
00001e  f5b67f82          CMP      r6,#0x104
000022  d106              BNE      |L23.50|
000024  e001              B        |L23.42|
                  |L23.38|
000026  2002              MOVS     r0,#2                 ;1246
;;;1252       ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
;;;1253     {
;;;1254       errorcode = HAL_BUSY;
;;;1255       goto error;
;;;1256     }
;;;1257   
;;;1258     if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0U))
;;;1259     {
;;;1260       errorcode = HAL_ERROR;
;;;1261       goto error;
;;;1262     }
;;;1263   
;;;1264     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1265     if(hspi->State == HAL_SPI_STATE_READY)
;;;1266     {
;;;1267       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1268     }
;;;1269   
;;;1270     /* Set the transaction information */
;;;1271     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1272     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1273     hspi->TxXferSize  = Size;
;;;1274     hspi->TxXferCount = Size;
;;;1275     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1276     hspi->RxXferSize  = Size;
;;;1277     hspi->RxXferCount = Size;
;;;1278   
;;;1279     /* Set the function for IT treatment */
;;;1280     if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
;;;1281     {
;;;1282       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1283       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1284     }
;;;1285     else
;;;1286     {
;;;1287       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1288       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1289     }
;;;1290   
;;;1291   #if (USE_SPI_CRC != 0U)
;;;1292     /* Reset CRC Calculation */
;;;1293     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1294     {
;;;1295       SPI_RESET_CRC(hspi);
;;;1296     }
;;;1297   #endif /* USE_SPI_CRC */
;;;1298   
;;;1299     /* Enable TXE, RXNE and ERR interrupt */
;;;1300     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1301   
;;;1302     /* Check if the SPI is already enabled */
;;;1303     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1304     {
;;;1305       /* Enable SPI peripheral */
;;;1306       __HAL_SPI_ENABLE(hspi);
;;;1307     }
;;;1308   
;;;1309   error :
;;;1310     /* Process Unlocked */
;;;1311     __HAL_UNLOCK(hspi);
;;;1312     return errorcode;
;;;1313   }
000028  bdf0              POP      {r4-r7,pc}
                  |L23.42|
00002a  6886              LDR      r6,[r0,#8]            ;1251
00002c  b90e              CBNZ     r6,|L23.50|
00002e  2d04              CMP      r5,#4                 ;1251
000030  d001              BEQ      |L23.54|
                  |L23.50|
000032  2402              MOVS     r4,#2                 ;1254
000034  e02b              B        |L23.142|
                  |L23.54|
000036  b131              CBZ      r1,|L23.70|
000038  b12a              CBZ      r2,|L23.70|
00003a  b123              CBZ      r3,|L23.70|
00003c  f8905051          LDRB     r5,[r0,#0x51]         ;1265
000040  2d01              CMP      r5,#1                 ;1265
000042  d002              BEQ      |L23.74|
000044  e004              B        |L23.80|
                  |L23.70|
000046  2401              MOVS     r4,#1                 ;1260
000048  e021              B        |L23.142|
                  |L23.74|
00004a  2505              MOVS     r5,#5                 ;1267
00004c  f8805051          STRB     r5,[r0,#0x51]         ;1267
                  |L23.80|
000050  6547              STR      r7,[r0,#0x54]         ;1271
000052  6301              STR      r1,[r0,#0x30]         ;1272
000054  8683              STRH     r3,[r0,#0x34]         ;1273
000056  86c3              STRH     r3,[r0,#0x36]         ;1274
000058  6382              STR      r2,[r0,#0x38]         ;1275
00005a  8783              STRH     r3,[r0,#0x3c]         ;1276
00005c  87c3              STRH     r3,[r0,#0x3e]         ;1277
00005e  68c1              LDR      r1,[r0,#0xc]          ;1280
000060  b121              CBZ      r1,|L23.108|
000062  490d              LDR      r1,|L23.152|
000064  6401              STR      r1,[r0,#0x40]         ;1282
000066  490d              LDR      r1,|L23.156|
000068  6441              STR      r1,[r0,#0x44]         ;1283
00006a  e003              B        |L23.116|
                  |L23.108|
00006c  490c              LDR      r1,|L23.160|
00006e  6401              STR      r1,[r0,#0x40]         ;1287
000070  490c              LDR      r1,|L23.164|
000072  6441              STR      r1,[r0,#0x44]         ;1288
                  |L23.116|
000074  6801              LDR      r1,[r0,#0]            ;1300
000076  684a              LDR      r2,[r1,#4]            ;1300
000078  f04202e0          ORR      r2,r2,#0xe0           ;1300
00007c  604a              STR      r2,[r1,#4]            ;1300
00007e  6801              LDR      r1,[r0,#0]            ;1303
000080  680a              LDR      r2,[r1,#0]            ;1303
000082  0652              LSLS     r2,r2,#25             ;1303
000084  d403              BMI      |L23.142|
000086  680a              LDR      r2,[r1,#0]            ;1306
000088  f0420240          ORR      r2,r2,#0x40           ;1306
00008c  600a              STR      r2,[r1,#0]            ;1306
                  |L23.142|
00008e  f8807050          STRB     r7,[r0,#0x50]         ;1311
000092  4620              MOV      r0,r4                 ;1312
000094  bdf0              POP      {r4-r7,pc}
;;;1314   
                          ENDP

000096  0000              DCW      0x0000
                  |L23.152|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.156|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.160|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.164|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1322     */
;;;1323   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1324   {
000002  4604              MOV      r4,r0
;;;1325     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2600              MOVS     r6,#0
;;;1326   
;;;1327     /* Check Direction parameter */
;;;1328     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1329   
;;;1330     /* Process Locked */
;;;1331     __HAL_LOCK(hspi);
000006  f8940050          LDRB     r0,[r4,#0x50]
00000a  2801              CMP      r0,#1
00000c  d009              BEQ      |L24.34|
00000e  2001              MOVS     r0,#1
000010  f8840050          STRB     r0,[r4,#0x50]
;;;1332   
;;;1333     if(hspi->State != HAL_SPI_STATE_READY)
000014  f8940051          LDRB     r0,[r4,#0x51]
000018  2500              MOVS     r5,#0
00001a  2801              CMP      r0,#1
00001c  d003              BEQ      |L24.38|
;;;1334     {
;;;1335       errorcode = HAL_BUSY;
00001e  2602              MOVS     r6,#2
;;;1336       goto error;
000020  e03f              B        |L24.162|
                  |L24.34|
000022  2002              MOVS     r0,#2                 ;1331
;;;1337     }
;;;1338   
;;;1339     if((pData == NULL) || (Size == 0U))
;;;1340     {
;;;1341       errorcode = HAL_ERROR;
;;;1342       goto error;
;;;1343     }
;;;1344   
;;;1345     /* Set the transaction information */
;;;1346     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1347     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1348     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1349     hspi->TxXferSize  = Size;
;;;1350     hspi->TxXferCount = Size;
;;;1351   
;;;1352     /* Init field not used in handle to zero */
;;;1353     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1354     hspi->TxISR       = NULL;
;;;1355     hspi->RxISR       = NULL;
;;;1356     hspi->RxXferSize  = 0U;
;;;1357     hspi->RxXferCount = 0U;
;;;1358   
;;;1359     /* Configure communication direction : 1Line */
;;;1360     if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1361     {
;;;1362       SPI_1LINE_TX(hspi);
;;;1363     }
;;;1364   
;;;1365   #if (USE_SPI_CRC != 0U)
;;;1366     /* Reset CRC Calculation */
;;;1367     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1368     {
;;;1369       SPI_RESET_CRC(hspi);
;;;1370     }
;;;1371   #endif /* USE_SPI_CRC */
;;;1372   
;;;1373     /* Set the SPI TxDMA Half transfer complete callback */
;;;1374     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1375   
;;;1376     /* Set the SPI TxDMA transfer complete callback */
;;;1377     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1378   
;;;1379     /* Set the DMA error callback */
;;;1380     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1381   
;;;1382     /* Set the DMA AbortCpltCallback */
;;;1383     hspi->hdmatx->XferAbortCallback = NULL;
;;;1384   
;;;1385     /* Enable the Tx DMA Stream */
;;;1386     HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
;;;1387   
;;;1388     /* Check if the SPI is already enabled */
;;;1389     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1390     {
;;;1391       /* Enable SPI peripheral */
;;;1392       __HAL_SPI_ENABLE(hspi);
;;;1393     }
;;;1394   
;;;1395     /* Enable the SPI Error Interrupt Bit */
;;;1396     SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
;;;1397   
;;;1398     /* Enable Tx DMA Request */
;;;1399     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1400   
;;;1401   error :
;;;1402     /* Process Unlocked */
;;;1403     __HAL_UNLOCK(hspi);
;;;1404     return errorcode;
;;;1405   }
000024  bd70              POP      {r4-r6,pc}
                  |L24.38|
000026  b189              CBZ      r1,|L24.76|
000028  b182              CBZ      r2,|L24.76|
00002a  2003              MOVS     r0,#3                 ;1346
00002c  f8840051          STRB     r0,[r4,#0x51]         ;1346
000030  6565              STR      r5,[r4,#0x54]         ;1347
000032  6321              STR      r1,[r4,#0x30]         ;1348
000034  86a2              STRH     r2,[r4,#0x34]         ;1349
000036  86e2              STRH     r2,[r4,#0x36]         ;1350
000038  63a5              STR      r5,[r4,#0x38]         ;1353
00003a  6465              STR      r5,[r4,#0x44]         ;1354
00003c  6425              STR      r5,[r4,#0x40]         ;1355
00003e  87a5              STRH     r5,[r4,#0x3c]         ;1356
000040  87e5              STRH     r5,[r4,#0x3e]         ;1357
000042  68a0              LDR      r0,[r4,#8]            ;1360
000044  f5b04f00          CMP      r0,#0x8000            ;1360
000048  d002              BEQ      |L24.80|
00004a  e006              B        |L24.90|
                  |L24.76|
00004c  2601              MOVS     r6,#1                 ;1341
00004e  e028              B        |L24.162|
                  |L24.80|
000050  6820              LDR      r0,[r4,#0]            ;1362
000052  6801              LDR      r1,[r0,#0]            ;1362
000054  f4414180          ORR      r1,r1,#0x4000         ;1362
000058  6001              STR      r1,[r0,#0]            ;1362
                  |L24.90|
00005a  6ca1              LDR      r1,[r4,#0x48]         ;1374
00005c  4813              LDR      r0,|L24.172|
00005e  62c8              STR      r0,[r1,#0x2c]         ;1374
000060  6ca1              LDR      r1,[r4,#0x48]         ;1377
000062  4813              LDR      r0,|L24.176|
000064  6288              STR      r0,[r1,#0x28]         ;1377
000066  6ca1              LDR      r1,[r4,#0x48]         ;1380
000068  4812              LDR      r0,|L24.180|
00006a  6308              STR      r0,[r1,#0x30]         ;1380
00006c  6ca0              LDR      r0,[r4,#0x48]         ;1383
00006e  6345              STR      r5,[r0,#0x34]         ;1383
000070  8ee3              LDRH     r3,[r4,#0x36]         ;1386
000072  6822              LDR      r2,[r4,#0]            ;1386
000074  6b21              LDR      r1,[r4,#0x30]         ;1386
000076  320c              ADDS     r2,r2,#0xc            ;1386
000078  6ca0              LDR      r0,[r4,#0x48]         ;1386
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;1389
000080  6801              LDR      r1,[r0,#0]            ;1389
000082  0649              LSLS     r1,r1,#25             ;1389
000084  d403              BMI      |L24.142|
000086  6801              LDR      r1,[r0,#0]            ;1392
000088  f0410140          ORR      r1,r1,#0x40           ;1392
00008c  6001              STR      r1,[r0,#0]            ;1392
                  |L24.142|
00008e  6820              LDR      r0,[r4,#0]            ;1396
000090  6841              LDR      r1,[r0,#4]            ;1396
000092  f0410120          ORR      r1,r1,#0x20           ;1396
000096  6041              STR      r1,[r0,#4]            ;1396
000098  6820              LDR      r0,[r4,#0]            ;1399
00009a  6841              LDR      r1,[r0,#4]            ;1399
00009c  f0410102          ORR      r1,r1,#2              ;1399
0000a0  6041              STR      r1,[r0,#4]            ;1399
                  |L24.162|
0000a2  f8845050          STRB     r5,[r4,#0x50]         ;1403
0000a6  4630              MOV      r0,r6                 ;1404
0000a8  bd70              POP      {r4-r6,pc}
;;;1406   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L24.172|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.176|
                          DCD      SPI_DMATransmitCplt
                  |L24.180|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1054     */
;;;1055   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;1056   {
;;;1057     HAL_StatusTypeDef errorcode = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1058   
;;;1059     /* Check Direction parameter */
;;;1060     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1061   
;;;1062     /* Process Locked */
;;;1063     __HAL_LOCK(hspi);
000004  f8904050          LDRB     r4,[r0,#0x50]
000008  2c01              CMP      r4,#1
00000a  d00b              BEQ      |L25.36|
00000c  2401              MOVS     r4,#1
00000e  f8804050          STRB     r4,[r0,#0x50]
;;;1064   
;;;1065     if((pData == NULL) || (Size == 0U))
000012  2400              MOVS     r4,#0
000014  b141              CBZ      r1,|L25.40|
000016  b13a              CBZ      r2,|L25.40|
;;;1066     {
;;;1067       errorcode = HAL_ERROR;
;;;1068       goto error;
;;;1069     }
;;;1070   
;;;1071     if(hspi->State != HAL_SPI_STATE_READY)
000018  f8905051          LDRB     r5,[r0,#0x51]
00001c  2d01              CMP      r5,#1
00001e  d005              BEQ      |L25.44|
;;;1072     {
;;;1073       errorcode = HAL_BUSY;
000020  2302              MOVS     r3,#2
;;;1074       goto error;
000022  e02d              B        |L25.128|
                  |L25.36|
000024  2002              MOVS     r0,#2                 ;1063
;;;1075     }
;;;1076   
;;;1077     /* Set the transaction information */
;;;1078     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1079     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1080     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1081     hspi->TxXferSize  = Size;
;;;1082     hspi->TxXferCount = Size;
;;;1083   
;;;1084     /* Init field not used in handle to zero */
;;;1085     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1086     hspi->RxXferSize  = 0U;
;;;1087     hspi->RxXferCount = 0U;
;;;1088     hspi->RxISR       = NULL;
;;;1089   
;;;1090     /* Set the function for IT treatment */
;;;1091     if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
;;;1092     {
;;;1093       hspi->TxISR = SPI_TxISR_16BIT;
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       hspi->TxISR = SPI_TxISR_8BIT;
;;;1098     }
;;;1099   
;;;1100     /* Configure communication direction : 1Line */
;;;1101     if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1102     {
;;;1103       SPI_1LINE_TX(hspi);
;;;1104     }
;;;1105   
;;;1106   #if (USE_SPI_CRC != 0U)
;;;1107     /* Reset CRC Calculation */
;;;1108     if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1109     {
;;;1110       SPI_RESET_CRC(hspi);
;;;1111     }
;;;1112   #endif /* USE_SPI_CRC */
;;;1113   
;;;1114     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1115     {
;;;1116       /* Enable TXE interrupt */
;;;1117       __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
;;;1118     }
;;;1119     else
;;;1120     {
;;;1121       /* Enable TXE and ERR interrupt */
;;;1122       __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1123     }
;;;1124   
;;;1125     /* Check if the SPI is already enabled */
;;;1126     if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1127     {
;;;1128       /* Enable SPI peripheral */
;;;1129       __HAL_SPI_ENABLE(hspi);
;;;1130     }
;;;1131   
;;;1132   error :
;;;1133     __HAL_UNLOCK(hspi);
;;;1134     return errorcode;
;;;1135   }
000026  bd30              POP      {r4,r5,pc}
                  |L25.40|
000028  2301              MOVS     r3,#1                 ;1067
00002a  e029              B        |L25.128|
                  |L25.44|
00002c  2503              MOVS     r5,#3                 ;1078
00002e  f8805051          STRB     r5,[r0,#0x51]         ;1078
000032  6544              STR      r4,[r0,#0x54]         ;1079
000034  6301              STR      r1,[r0,#0x30]         ;1080
000036  8682              STRH     r2,[r0,#0x34]         ;1081
000038  86c2              STRH     r2,[r0,#0x36]         ;1082
00003a  6384              STR      r4,[r0,#0x38]         ;1085
00003c  8784              STRH     r4,[r0,#0x3c]         ;1086
00003e  87c4              STRH     r4,[r0,#0x3e]         ;1087
000040  6404              STR      r4,[r0,#0x40]         ;1088
000042  68c1              LDR      r1,[r0,#0xc]          ;1091
000044  b111              CBZ      r1,|L25.76|
000046  4913              LDR      r1,|L25.148|
000048  6441              STR      r1,[r0,#0x44]         ;1093
00004a  e001              B        |L25.80|
                  |L25.76|
00004c  4912              LDR      r1,|L25.152|
00004e  6441              STR      r1,[r0,#0x44]         ;1097
                  |L25.80|
000050  6881              LDR      r1,[r0,#8]            ;1101
000052  f5b14f00          CMP      r1,#0x8000            ;1101
000056  d104              BNE      |L25.98|
000058  6801              LDR      r1,[r0,#0]            ;1103
00005a  680a              LDR      r2,[r1,#0]            ;1103
00005c  f4424280          ORR      r2,r2,#0x4000         ;1103
000060  600a              STR      r2,[r1,#0]            ;1103
                  |L25.98|
000062  6881              LDR      r1,[r0,#8]            ;1114
000064  b181              CBZ      r1,|L25.136|
000066  6801              LDR      r1,[r0,#0]            ;1122
000068  684a              LDR      r2,[r1,#4]            ;1122
00006a  f04202a0          ORR      r2,r2,#0xa0           ;1122
00006e  604a              STR      r2,[r1,#4]            ;1122
                  |L25.112|
000070  6801              LDR      r1,[r0,#0]            ;1126
000072  680a              LDR      r2,[r1,#0]            ;1126
000074  0652              LSLS     r2,r2,#25             ;1126
000076  d403              BMI      |L25.128|
000078  680a              LDR      r2,[r1,#0]            ;1129
00007a  f0420240          ORR      r2,r2,#0x40           ;1129
00007e  600a              STR      r2,[r1,#0]            ;1129
                  |L25.128|
000080  f8804050          STRB     r4,[r0,#0x50]         ;1133
000084  4618              MOV      r0,r3                 ;1134
000086  bd30              POP      {r4,r5,pc}
                  |L25.136|
000088  6801              LDR      r1,[r0,#0]            ;1117
00008a  684a              LDR      r2,[r1,#4]            ;1117
00008c  f0420280          ORR      r2,r2,#0x80           ;1117
000090  604a              STR      r2,[r1,#4]            ;1117
000092  e7ed              B        |L25.112|
;;;1136   
                          ENDP

                  |L25.148|
                          DCD      SPI_TxISR_16BIT
                  |L25.152|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2035     */
;;;2036   __WEAK void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2037   {
;;;2038     /* Prevent unused argument(s) compilation warning */
;;;2039     UNUSED(hspi);
;;;2040     /* NOTE : This function should not be modified, when the callback is needed,
;;;2041               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2042     */
;;;2043   }
;;;2044   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2080     */
;;;2081   __WEAK void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2082   {
;;;2083     /* Prevent unused argument(s) compilation warning */
;;;2084     UNUSED(hspi);
;;;2085     /* NOTE : This function should not be modified, when the callback is needed,
;;;2086               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2087     */
;;;2088   }
;;;2089   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2065     */
;;;2066   __WEAK void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2067   {
;;;2068     /* Prevent unused argument(s) compilation warning */
;;;2069     UNUSED(hspi);
;;;2070     /* NOTE : This function should not be modified, when the callback is needed,
;;;2071               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2072     */
;;;2073   }
;;;2074   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2110     */
;;;2111   __WEAK void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2112   {
;;;2113     /* Prevent unused argument(s) compilation warning */
;;;2114     UNUSED(hspi);
;;;2115     /* NOTE : This function should not be modified, when the callback is needed,
;;;2116               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2117     */
;;;2118   }
;;;2119   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BIT PROC
;;;2673     */
;;;2674   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;2675   {
;;;2676     /* Receive data in 16 Bit mode */
;;;2677     *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
000002  68c9              LDR      r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  8011              STRH     r1,[r2,#0]
;;;2678     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;2679     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;2680   
;;;2681     if(hspi->RxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d109              BNE      |L30.46|
;;;2682     {
;;;2683   #if (USE_SPI_CRC != 0U)
;;;2684       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2685       {
;;;2686         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
;;;2687         return;
;;;2688       }
;;;2689   #endif /* USE_SPI_CRC */
;;;2690   
;;;2691       /* Disable RXNE interrupt */
;;;2692       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
00001a  6801              LDR      r1,[r0,#0]
00001c  684a              LDR      r2,[r1,#4]
00001e  f0220240          BIC      r2,r2,#0x40
000022  604a              STR      r2,[r1,#4]
;;;2693   
;;;2694       if(hspi->TxXferCount == 0U)
000024  8ec1              LDRH     r1,[r0,#0x36]
000026  2900              CMP      r1,#0
000028  d101              BNE      |L30.46|
;;;2695       {
;;;2696         SPI_CloseRxTx_ISR(hspi);
00002a  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L30.46|
;;;2697       }
;;;2698     }
;;;2699   }
00002e  4770              BX       lr
;;;2700   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BIT PROC
;;;2579     */
;;;2580   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;2581   {
;;;2582     /* Receive data in 8bit mode */
;;;2583     *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
000002  7b0b              LDRB     r3,[r1,#0xc]
000004  6b81              LDR      r1,[r0,#0x38]
000006  1c4a              ADDS     r2,r1,#1
000008  6382              STR      r2,[r0,#0x38]
00000a  700b              STRB     r3,[r1,#0]
;;;2584     hspi->RxXferCount--;
00000c  8fc1              LDRH     r1,[r0,#0x3e]
00000e  1e49              SUBS     r1,r1,#1
000010  87c1              STRH     r1,[r0,#0x3e]
;;;2585   
;;;2586     /* check end of the reception */
;;;2587     if(hspi->RxXferCount == 0U)
000012  8fc1              LDRH     r1,[r0,#0x3e]
000014  2900              CMP      r1,#0
000016  d109              BNE      |L31.44|
;;;2588     {
;;;2589   #if (USE_SPI_CRC != 0U)
;;;2590       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2591       {
;;;2592         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
;;;2593         return;
;;;2594       }
;;;2595   #endif /* USE_SPI_CRC */
;;;2596   
;;;2597       /* Disable RXNE interrupt */
;;;2598       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000018  6801              LDR      r1,[r0,#0]
00001a  684a              LDR      r2,[r1,#4]
00001c  f0220260          BIC      r2,r2,#0x60
000020  604a              STR      r2,[r1,#4]
;;;2599   
;;;2600       if(hspi->TxXferCount == 0U)
000022  8ec1              LDRH     r1,[r0,#0x36]
000024  2900              CMP      r1,#0
000026  d101              BNE      |L31.44|
;;;2601       {
;;;2602         SPI_CloseRxTx_ISR(hspi);
000028  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L31.44|
;;;2603       }
;;;2604     }
;;;2605   }
00002c  4770              BX       lr
;;;2606   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;2731     */
;;;2732   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;2733   {
;;;2734     /* Transmit data in 16 Bit mode */
;;;2735     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;2736     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c89              ADDS     r1,r1,#2
00000c  6301              STR      r1,[r0,#0x30]
;;;2737     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;2738   
;;;2739     /* Enable CRC Transmission */
;;;2740     if(hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d109              BNE      |L32.46|
;;;2741     {
;;;2742   #if (USE_SPI_CRC != 0U)
;;;2743       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2744       {
;;;2745         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2746         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;2747         return;
;;;2748       }
;;;2749   #endif /* USE_SPI_CRC */
;;;2750   
;;;2751       /* Disable TXE interrupt */
;;;2752       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00001a  6801              LDR      r1,[r0,#0]
00001c  684a              LDR      r2,[r1,#4]
00001e  f0220280          BIC      r2,r2,#0x80
000022  604a              STR      r2,[r1,#4]
;;;2753   
;;;2754       if(hspi->RxXferCount == 0U)
000024  8fc1              LDRH     r1,[r0,#0x3e]
000026  2900              CMP      r1,#0
000028  d101              BNE      |L32.46|
;;;2755       {
;;;2756         SPI_CloseRxTx_ISR(hspi);
00002a  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L32.46|
;;;2757       }
;;;2758     }
;;;2759   }
00002e  4770              BX       lr
;;;2760   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;2640     */
;;;2641   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;2642   {
;;;2643     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
000002  1c4a              ADDS     r2,r1,#1
000004  6302              STR      r2,[r0,#0x30]
000006  6802              LDR      r2,[r0,#0]
000008  7809              LDRB     r1,[r1,#0]
00000a  7311              STRB     r1,[r2,#0xc]
;;;2644     hspi->TxXferCount--;
00000c  8ec1              LDRH     r1,[r0,#0x36]
00000e  1e49              SUBS     r1,r1,#1
000010  86c1              STRH     r1,[r0,#0x36]
;;;2645   
;;;2646     /* check the end of the transmission */
;;;2647     if(hspi->TxXferCount == 0U)
000012  8ec1              LDRH     r1,[r0,#0x36]
000014  2900              CMP      r1,#0
000016  d109              BNE      |L33.44|
;;;2648     {
;;;2649   #if (USE_SPI_CRC != 0U)
;;;2650       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2651       {
;;;2652         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2653         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;2654         return;
;;;2655       }
;;;2656   #endif /* USE_SPI_CRC */
;;;2657   
;;;2658       /* Disable TXE interrupt */
;;;2659       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000018  6801              LDR      r1,[r0,#0]
00001a  684a              LDR      r2,[r1,#4]
00001c  f0220280          BIC      r2,r2,#0x80
000020  604a              STR      r2,[r1,#4]
;;;2660   
;;;2661       if(hspi->RxXferCount == 0U)
000022  8fc1              LDRH     r1,[r0,#0x3e]
000024  2900              CMP      r1,#0
000026  d101              BNE      |L33.44|
;;;2662       {
;;;2663         SPI_CloseRxTx_ISR(hspi);
000028  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L33.44|
;;;2664       }
;;;2665     }
;;;2666   }
00002c  4770              BX       lr
;;;2667   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;3194     */
;;;3195   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b50c              PUSH     {r2,r3,lr}
;;;3196   {
;;;3197     __IO uint32_t tmpreg = 0U;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;3198     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4911              LDR      r1,|L34.76|
000008  f64552c0          MOV      r2,#0x5dc0
00000c  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000e  fbb1f1f2          UDIV     r1,r1,r2
000012  2264              MOVS     r2,#0x64
000014  4351              MULS     r1,r2,r1
000016  9100              STR      r1,[sp,#0]
;;;3199   
;;;3200     /* Wait until TXE flag is set */
;;;3201     do
;;;3202     {
;;;3203       if(count-- == 0U)
;;;3204       {
;;;3205         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3206         break;
;;;3207       }
;;;3208     }
;;;3209     while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000018  6802              LDR      r2,[r0,#0]
                  |L34.26|
00001a  9900              LDR      r1,[sp,#0]            ;3203
00001c  1e4b              SUBS     r3,r1,#1              ;3203
00001e  9300              STR      r3,[sp,#0]            ;3203
000020  d204              BCS      |L34.44|
000022  6d41              LDR      r1,[r0,#0x54]         ;3205
000024  f0410120          ORR      r1,r1,#0x20           ;3205
000028  6541              STR      r1,[r0,#0x54]         ;3205
00002a  e002              B        |L34.50|
                  |L34.44|
00002c  6891              LDR      r1,[r2,#8]
00002e  0789              LSLS     r1,r1,#30
000030  d5f3              BPL      |L34.26|
                  |L34.50|
;;;3210   
;;;3211     /* Disable SPI Peripheral */
;;;3212     __HAL_SPI_DISABLE(hspi);    
000032  6811              LDR      r1,[r2,#0]
000034  f0210140          BIC      r1,r1,#0x40
000038  6011              STR      r1,[r2,#0]
;;;3213   
;;;3214     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3215     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
00003a  6801              LDR      r1,[r0,#0]
00003c  684a              LDR      r2,[r1,#4]
00003e  f02202e0          BIC      r2,r2,#0xe0
000042  604a              STR      r2,[r1,#4]
;;;3216   
;;;3217     /* Flush DR Register */
;;;3218     tmpreg = (*(__IO uint32_t *)&hspi->Instance->DR);
000044  6800              LDR      r0,[r0,#0]
000046  68c0              LDR      r0,[r0,#0xc]
000048  9001              STR      r0,[sp,#4]
;;;3219   
;;;3220     /* To avoid GCC warning */
;;;3221     UNUSED(tmpreg);
;;;3222   }
00004a  bd0c              POP      {r2,r3,pc}
;;;3223   
                          ENDP

                  |L34.76|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_AbortTx_ISR PROC
;;;3229     */
;;;3230   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3231   {
;;;3232     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3233     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
000002  684a              LDR      r2,[r1,#4]
000004  f02202e0          BIC      r2,r2,#0xe0
000008  604a              STR      r2,[r1,#4]
;;;3234   
;;;3235     /* Disable SPI Peripheral */
;;;3236     __HAL_SPI_DISABLE(hspi);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0210140          BIC      r1,r1,#0x40
000012  6001              STR      r1,[r0,#0]
;;;3237   }
000014  4770              BX       lr
;;;3238   
                          ENDP


                          AREA ||i.SPI_CheckFlag_BSY||, CODE, READONLY, ALIGN=1

                  SPI_CheckFlag_BSY PROC
;;;2977     */
;;;2978   static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b538              PUSH     {r3-r5,lr}
;;;2979   {
000002  4604              MOV      r4,r0
;;;2980     /* Control the BSY flag */
;;;2981     if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
000004  460b              MOV      r3,r1
000006  9200              STR      r2,[sp,#0]
000008  2200              MOVS     r2,#0
00000a  2180              MOVS     r1,#0x80
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000012  b128              CBZ      r0,|L36.32|
;;;2982     {
;;;2983       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000014  6d60              LDR      r0,[r4,#0x54]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6560              STR      r0,[r4,#0x54]
;;;2984       return HAL_TIMEOUT;
00001c  2003              MOVS     r0,#3
;;;2985     }
;;;2986     return HAL_OK;
;;;2987   }
00001e  bd38              POP      {r3-r5,pc}
                  |L36.32|
000020  2000              MOVS     r0,#0                 ;2986
000022  bd38              POP      {r3-r5,pc}
;;;2988   
                          ENDP


                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseRxTx_ISR PROC
;;;2994     */
;;;2995   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b51c              PUSH     {r2-r4,lr}
;;;2996   {
000002  4604              MOV      r4,r0
;;;2997     uint32_t tickstart = 0U;
;;;2998     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4822              LDR      r0,|L37.144|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;2999     /* Init tickstart for timeout managment*/
;;;3000     tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4602              MOV      r2,r0
;;;3001   
;;;3002     /* Disable ERR interrupt */
;;;3003     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001c  6820              LDR      r0,[r4,#0]
00001e  6841              LDR      r1,[r0,#4]
000020  f0210120          BIC      r1,r1,#0x20
000024  6041              STR      r1,[r0,#4]
                  |L37.38|
;;;3004   
;;;3005     /* Wait until TXE flag is set */
;;;3006     do
;;;3007     {
;;;3008       if(count-- == 0U)
000026  9801              LDR      r0,[sp,#4]
000028  1e41              SUBS     r1,r0,#1
00002a  9101              STR      r1,[sp,#4]
00002c  d204              BCS      |L37.56|
;;;3009       {
;;;3010         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00002e  6d60              LDR      r0,[r4,#0x54]
000030  f0400020          ORR      r0,r0,#0x20
000034  6560              STR      r0,[r4,#0x54]
;;;3011         break;
000036  e003              B        |L37.64|
                  |L37.56|
;;;3012       }
;;;3013     }
;;;3014     while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  0780              LSLS     r0,r0,#30
00003e  d5f2              BPL      |L37.38|
                  |L37.64|
;;;3015     
;;;3016     /* Check the end of the transaction */
;;;3017     if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart)!=HAL_OK)
000040  2164              MOVS     r1,#0x64
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       SPI_CheckFlag_BSY
000048  b118              CBZ      r0,|L37.82|
;;;3018     {
;;;3019       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00004a  6d60              LDR      r0,[r4,#0x54]
00004c  f0400020          ORR      r0,r0,#0x20
000050  6560              STR      r0,[r4,#0x54]
                  |L37.82|
;;;3020     }
;;;3021   
;;;3022     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3023     if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
000052  68a0              LDR      r0,[r4,#8]
000054  b918              CBNZ     r0,|L37.94|
;;;3024     {
;;;3025       __HAL_SPI_CLEAR_OVRFLAG(hspi);
000056  6820              LDR      r0,[r4,#0]
000058  68c1              LDR      r1,[r0,#0xc]
00005a  6880              LDR      r0,[r0,#8]
00005c  9000              STR      r0,[sp,#0]
                  |L37.94|
;;;3026     }
;;;3027   
;;;3028   #if (USE_SPI_CRC != 0U)
;;;3029     /* Check if CRC error occurred */
;;;3030     if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3031     {
;;;3032       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3033       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;3034       {
;;;3035         hspi->State = HAL_SPI_STATE_READY;
;;;3036         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3037   
;;;3038         /* Reset CRC Calculation */
;;;3039         SPI_RESET_CRC(hspi);
;;;3040   
;;;3041       HAL_SPI_ErrorCallback(hspi);
;;;3042       }
;;;3043       else
;;;3044       {
;;;3045         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3046       }
;;;3047     }
;;;3048     else
;;;3049     {
;;;3050   #endif /* USE_SPI_CRC */
;;;3051       if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
00005e  6d61              LDR      r1,[r4,#0x54]
;;;3052       {
;;;3053         if(hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;3054         {
;;;3055         	hspi->State = HAL_SPI_STATE_READY;
000060  2001              MOVS     r0,#1
000062  b129              CBZ      r1,|L37.112|
;;;3056           HAL_SPI_RxCpltCallback(hspi);
;;;3057         }
;;;3058         else
;;;3059         {
;;;3060         	hspi->State = HAL_SPI_STATE_READY;
;;;3061           HAL_SPI_TxRxCpltCallback(hspi);
;;;3062         }
;;;3063       }
;;;3064       else
;;;3065       {
;;;3066         hspi->State = HAL_SPI_STATE_READY;
000064  f8840051          STRB     r0,[r4,#0x51]
;;;3067         HAL_SPI_ErrorCallback(hspi);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3068       }
;;;3069   #if (USE_SPI_CRC != 0U)
;;;3070     }
;;;3071   #endif /* USE_SPI_CRC */
;;;3072   }
00006e  bd1c              POP      {r2-r4,pc}
                  |L37.112|
000070  f8941051          LDRB     r1,[r4,#0x51]         ;3053
000074  2904              CMP      r1,#4                 ;3053
000076  d005              BEQ      |L37.132|
000078  f8840051          STRB     r0,[r4,#0x51]         ;3060
00007c  4620              MOV      r0,r4                 ;3061
00007e  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
000082  bd1c              POP      {r2-r4,pc}
                  |L37.132|
000084  f8840051          STRB     r0,[r4,#0x51]         ;3055
000088  4620              MOV      r0,r4                 ;3056
00008a  f7fffffe          BL       HAL_SPI_RxCpltCallback
00008e  bd1c              POP      {r2-r4,pc}
;;;3073   
                          ENDP

                  |L37.144|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;3079     */
;;;3080   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b508              PUSH     {r3,lr}
;;;3081   {
;;;3082       /* Disable RXNE and ERR interrupt */
;;;3083       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000002  6801              LDR      r1,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  f0220260          BIC      r2,r2,#0x60
00000a  604a              STR      r2,[r1,#4]
;;;3084   
;;;3085       /* Check the end of the transaction */
;;;3086       if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
00000c  6841              LDR      r1,[r0,#4]
00000e  f5b17f82          CMP      r1,#0x104
000012  d10b              BNE      |L38.44|
000014  6881              LDR      r1,[r0,#8]
000016  f5b14f00          CMP      r1,#0x8000
00001a  d002              BEQ      |L38.34|
00001c  f5b16f80          CMP      r1,#0x400
000020  d104              BNE      |L38.44|
                  |L38.34|
;;;3087       {
;;;3088         /* Disable SPI peripheral */
;;;3089         __HAL_SPI_DISABLE(hspi);
000022  6801              LDR      r1,[r0,#0]
000024  680a              LDR      r2,[r1,#0]
000026  f0220240          BIC      r2,r2,#0x40
00002a  600a              STR      r2,[r1,#0]
                  |L38.44|
;;;3090       }
;;;3091   
;;;3092       /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3093       if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
00002c  6881              LDR      r1,[r0,#8]
00002e  b919              CBNZ     r1,|L38.56|
;;;3094       {
;;;3095         __HAL_SPI_CLEAR_OVRFLAG(hspi);
000030  6801              LDR      r1,[r0,#0]
000032  68ca              LDR      r2,[r1,#0xc]
000034  6889              LDR      r1,[r1,#8]
000036  9100              STR      r1,[sp,#0]
                  |L38.56|
;;;3096       }
;;;3097       hspi->State = HAL_SPI_STATE_READY;
000038  2101              MOVS     r1,#1
00003a  f8801051          STRB     r1,[r0,#0x51]
;;;3098   
;;;3099   #if (USE_SPI_CRC != 0U)
;;;3100       /* Check if CRC error occurred */
;;;3101       if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3102       {
;;;3103         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3104         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;3105         {
;;;3106           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3107   
;;;3108           /* Reset CRC Calculation */
;;;3109           SPI_RESET_CRC(hspi);
;;;3110   
;;;3111            HAL_SPI_ErrorCallback(hspi);
;;;3112         }
;;;3113         else
;;;3114         {
;;;3115           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3116         }
;;;3117       }
;;;3118       else
;;;3119       {
;;;3120   #endif /* USE_SPI_CRC */
;;;3121         if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
00003e  6d41              LDR      r1,[r0,#0x54]
000040  b111              CBZ      r1,|L38.72|
;;;3122         {
;;;3123           HAL_SPI_RxCpltCallback(hspi);
;;;3124         }
;;;3125         else
;;;3126         {
;;;3127           HAL_SPI_ErrorCallback(hspi);
000042  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3128         }
;;;3129   #if (USE_SPI_CRC != 0U)
;;;3130       }
;;;3131   #endif /* USE_SPI_CRC */
;;;3132   }
000046  bd08              POP      {r3,pc}
                  |L38.72|
000048  f7fffffe          BL       HAL_SPI_RxCpltCallback
00004c  bd08              POP      {r3,pc}
;;;3133   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseTx_ISR PROC
;;;3139     */
;;;3140   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b51c              PUSH     {r2-r4,lr}
;;;3141   {
000002  4604              MOV      r4,r0
;;;3142     uint32_t tickstart = 0U;
;;;3143     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  481c              LDR      r0,|L39.120|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;3144   
;;;3145     /* Init tickstart for timeout management*/
;;;3146     tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4602              MOV      r2,r0
;;;3147   
;;;3148     /* Wait until TXE flag is set */
;;;3149     do
;;;3150     {
;;;3151       if(count-- == 0U)
;;;3152       {
;;;3153         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3154         break;
;;;3155       }
;;;3156     }
;;;3157     while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
00001c  6821              LDR      r1,[r4,#0]
                  |L39.30|
00001e  9801              LDR      r0,[sp,#4]            ;3151
000020  1e43              SUBS     r3,r0,#1              ;3151
000022  9301              STR      r3,[sp,#4]            ;3151
000024  d204              BCS      |L39.48|
000026  6d60              LDR      r0,[r4,#0x54]         ;3153
000028  f0400020          ORR      r0,r0,#0x20           ;3153
00002c  6560              STR      r0,[r4,#0x54]         ;3153
00002e  e002              B        |L39.54|
                  |L39.48|
000030  6888              LDR      r0,[r1,#8]
000032  0780              LSLS     r0,r0,#30
000034  d5f3              BPL      |L39.30|
                  |L39.54|
;;;3158   
;;;3159     /* Disable TXE and ERR interrupt */
;;;3160     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
000036  6848              LDR      r0,[r1,#4]
000038  f02000a0          BIC      r0,r0,#0xa0
00003c  6048              STR      r0,[r1,#4]
;;;3161   
;;;3162     /* Check Busy flag */
;;;3163     if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00003e  2164              MOVS     r1,#0x64
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       SPI_CheckFlag_BSY
000046  b118              CBZ      r0,|L39.80|
;;;3164     {
;;;3165       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000048  6d60              LDR      r0,[r4,#0x54]
00004a  f0400020          ORR      r0,r0,#0x20
00004e  6560              STR      r0,[r4,#0x54]
                  |L39.80|
;;;3166     }
;;;3167   
;;;3168     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3169     if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
000050  68a0              LDR      r0,[r4,#8]
000052  b918              CBNZ     r0,|L39.92|
;;;3170     {
;;;3171       __HAL_SPI_CLEAR_OVRFLAG(hspi);
000054  6820              LDR      r0,[r4,#0]
000056  68c1              LDR      r1,[r0,#0xc]
000058  6880              LDR      r0,[r0,#8]
00005a  9000              STR      r0,[sp,#0]
                  |L39.92|
;;;3172     }
;;;3173   
;;;3174     hspi->State = HAL_SPI_STATE_READY;
00005c  2001              MOVS     r0,#1
00005e  f8840051          STRB     r0,[r4,#0x51]
;;;3175     if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000062  6d60              LDR      r0,[r4,#0x54]
000064  b118              CBZ      r0,|L39.110|
;;;3176     {
;;;3177       HAL_SPI_ErrorCallback(hspi);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3178     }
;;;3179     else
;;;3180     {
;;;3181       HAL_SPI_TxCpltCallback(hspi);
;;;3182     }
;;;3183   }
00006c  bd1c              POP      {r2-r4,pc}
                  |L39.110|
00006e  4620              MOV      r0,r4                 ;3181
000070  f7fffffe          BL       HAL_SPI_TxCpltCallback
000074  bd1c              POP      {r2-r4,pc}
;;;3184   
                          ENDP

000076  0000              DCW      0x0000
                  |L39.120|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;2466     */
;;;2467   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2468   {
;;;2469     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2470     hspi->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  87c1              STRH     r1,[r0,#0x3e]
;;;2471     hspi->TxXferCount = 0U;
000008  86c1              STRH     r1,[r0,#0x36]
;;;2472   
;;;2473     HAL_SPI_ErrorCallback(hspi);
00000a  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2474   }
00000e  bd10              POP      {r4,pc}
;;;2475   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;2448     */
;;;2449   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2450   {
;;;2451     SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2452   
;;;2453   /* Stop the disable DMA transfer on SPI side */
;;;2454     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000004  6801              LDR      r1,[r0,#0]
000006  684a              LDR      r2,[r1,#4]
000008  f0220203          BIC      r2,r2,#3
00000c  604a              STR      r2,[r1,#4]
;;;2455   
;;;2456     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
00000e  6d41              LDR      r1,[r0,#0x54]
000010  f0410110          ORR      r1,r1,#0x10
000014  6541              STR      r1,[r0,#0x54]
;;;2457     hspi->State = HAL_SPI_STATE_READY;
000016  2101              MOVS     r1,#1
000018  f8801051          STRB     r1,[r0,#0x51]
;;;2458     HAL_SPI_ErrorCallback(hspi);
00001c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2459   }
000020  bd10              POP      {r4,pc}
;;;2460   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;2422     */
;;;2423   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2424   {
;;;2425     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2426   
;;;2427     HAL_SPI_RxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;2428   }
000008  bd10              POP      {r4,pc}
;;;2429   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;2409     */
;;;2410   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2411   {
;;;2412     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2413   
;;;2414     HAL_SPI_TxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;2415   }
000008  bd10              POP      {r4,pc}
;;;2416   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;2435     */
;;;2436   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2437   {
;;;2438     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2439   
;;;2440     HAL_SPI_TxRxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;2441   }
000008  bd10              POP      {r4,pc}
;;;2442   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;2258     */
;;;2259   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2260   {
000002  4601              MOV      r1,r0
;;;2261     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2262   #if (USE_SPI_CRC != 0U)
;;;2263     uint32_t tickstart = 0U;
;;;2264     __IO uint16_t tmpreg = 0U;
;;;2265   
;;;2266     /* Init tickstart for timeout management*/
;;;2267     tickstart = HAL_GetTick();
;;;2268   #endif /* USE_SPI_CRC */
;;;2269    
;;;2270     if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d41e              BMI      |L45.76|
;;;2271     {
;;;2272   #if (USE_SPI_CRC != 0U)
;;;2273       /* CRC handling */
;;;2274       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2275       {
;;;2276         /* Wait until RXNE flag */
;;;2277         if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2278         {
;;;2279           /* Error on the CRC reception */
;;;2280           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2281         }
;;;2282         /* Read CRC */
;;;2283         tmpreg = hspi->Instance->DR;
;;;2284         /* To avoid GCC warning */
;;;2285         UNUSED(tmpreg);
;;;2286       }
;;;2287   #endif /* USE_SPI_CRC */
;;;2288   
;;;2289       /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;2290       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0220203          BIC      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;2291   
;;;2292       /* Check the end of the transaction */
;;;2293       if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000018  6841              LDR      r1,[r0,#4]
00001a  f5b17f82          CMP      r1,#0x104
00001e  d10b              BNE      |L45.56|
000020  6881              LDR      r1,[r0,#8]
000022  f5b14f00          CMP      r1,#0x8000
000026  d002              BEQ      |L45.46|
000028  f5b16f80          CMP      r1,#0x400
00002c  d104              BNE      |L45.56|
                  |L45.46|
;;;2294       {
;;;2295         /* Disable SPI peripheral */
;;;2296         __HAL_SPI_DISABLE(hspi);
00002e  6801              LDR      r1,[r0,#0]
000030  680a              LDR      r2,[r1,#0]
000032  f0220240          BIC      r2,r2,#0x40
000036  600a              STR      r2,[r1,#0]
                  |L45.56|
;;;2297       }
;;;2298   
;;;2299       hspi->RxXferCount = 0U;
000038  2100              MOVS     r1,#0
00003a  87c1              STRH     r1,[r0,#0x3e]
;;;2300       hspi->State = HAL_SPI_STATE_READY;
00003c  2101              MOVS     r1,#1
00003e  f8801051          STRB     r1,[r0,#0x51]
;;;2301   
;;;2302   #if (USE_SPI_CRC != 0U)
;;;2303       /* Check if CRC error occurred */
;;;2304       if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;2305       {
;;;2306         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2307         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;2308         {
;;;2309           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2310   
;;;2311           /* Reset CRC Calculation */
;;;2312           SPI_RESET_CRC(hspi);
;;;2313       }
;;;2314         else
;;;2315         {
;;;2316           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2317         }
;;;2318       }
;;;2319   #endif /* USE_SPI_CRC */
;;;2320   
;;;2321       if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000042  6d41              LDR      r1,[r0,#0x54]
000044  b111              CBZ      r1,|L45.76|
;;;2322       {
;;;2323         HAL_SPI_ErrorCallback(hspi);
000046  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2324         return;
;;;2325       }
;;;2326     }
;;;2327     HAL_SPI_RxCpltCallback(hspi);
;;;2328   }
00004a  bd10              POP      {r4,pc}
                  |L45.76|
00004c  f7fffffe          BL       HAL_SPI_RxCpltCallback
000050  bd10              POP      {r4,pc}
;;;2329   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;2535     */
;;;2536   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b508              PUSH     {r3,lr}
;;;2537   {
;;;2538     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2539   
;;;2540     /* Disable SPI Peripheral */
;;;2541     __HAL_SPI_DISABLE(hspi);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f0220240          BIC      r2,r2,#0x40
00000c  600a              STR      r2,[r1,#0]
;;;2542   
;;;2543     hspi->hdmarx->XferAbortCallback = NULL;
00000e  6cc1              LDR      r1,[r0,#0x4c]
000010  2200              MOVS     r2,#0
000012  634a              STR      r2,[r1,#0x34]
;;;2544   
;;;2545     /* Disable Rx DMA Request */
;;;2546     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000014  6801              LDR      r1,[r0,#0]
000016  684b              LDR      r3,[r1,#4]
000018  f0230301          BIC      r3,r3,#1
00001c  604b              STR      r3,[r1,#4]
;;;2547   
;;;2548     /* Check if an Abort process is still ongoing */
;;;2549     if(hspi->hdmatx != NULL)
00001e  6c81              LDR      r1,[r0,#0x48]
000020  2900              CMP      r1,#0
000022  d002              BEQ      |L46.42|
;;;2550     {
;;;2551       if(hspi->hdmatx->XferAbortCallback != NULL)
000024  6b49              LDR      r1,[r1,#0x34]
000026  2900              CMP      r1,#0
000028  d10b              BNE      |L46.66|
                  |L46.42|
;;;2552       {
;;;2553         return;
;;;2554       }
;;;2555     }
;;;2556   
;;;2557     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2558     hspi->RxXferCount = 0U;
00002a  87c2              STRH     r2,[r0,#0x3e]
;;;2559     hspi->TxXferCount = 0U;
00002c  86c2              STRH     r2,[r0,#0x36]
;;;2560   
;;;2561     /* Reset errorCode */
;;;2562     hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00002e  6542              STR      r2,[r0,#0x54]
;;;2563   
;;;2564     /* Clear the Error flags in the SR register */
;;;2565     __HAL_SPI_CLEAR_OVRFLAG(hspi);
000030  6801              LDR      r1,[r0,#0]
000032  68ca              LDR      r2,[r1,#0xc]
000034  6889              LDR      r1,[r1,#8]
000036  9100              STR      r1,[sp,#0]
;;;2566   
;;;2567     /* Restore hspi->State to Ready */
;;;2568     hspi->State  = HAL_SPI_STATE_READY;
000038  2101              MOVS     r1,#1
00003a  f8801051          STRB     r1,[r0,#0x51]
;;;2569   
;;;2570     /* Call user Abort complete callback */
;;;2571     HAL_SPI_AbortCpltCallback(hspi);
00003e  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L46.66|
;;;2572   }
000042  bd08              POP      {r3,pc}
;;;2573   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;2214     */
;;;2215   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b538              PUSH     {r3-r5,lr}
;;;2216   {
000002  4605              MOV      r5,r0
;;;2217     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2218     uint32_t tickstart = 0U;
;;;2219   
;;;2220     /* Init tickstart for timeout managment*/
;;;2221     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4602              MOV      r2,r0
;;;2222   
;;;2223     /* DMA Normal Mode */
;;;2224     if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  0680              LSLS     r0,r0,#26
000012  d41e              BMI      |L47.82|
;;;2225     {
;;;2226       /* Disable Tx DMA Request */
;;;2227       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000014  6820              LDR      r0,[r4,#0]
000016  6841              LDR      r1,[r0,#4]
000018  f0210102          BIC      r1,r1,#2
00001c  6041              STR      r1,[r0,#4]
;;;2228   
;;;2229       /* Check the end of the transaction */
;;;2230       if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00001e  2164              MOVS     r1,#0x64
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_CheckFlag_BSY
000026  b118              CBZ      r0,|L47.48|
;;;2231       {
;;;2232         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6560              STR      r0,[r4,#0x54]
                  |L47.48|
;;;2233       }
;;;2234   
;;;2235       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;2236       if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
000030  68a0              LDR      r0,[r4,#8]
000032  2100              MOVS     r1,#0
000034  b918              CBNZ     r0,|L47.62|
;;;2237       {
;;;2238         __HAL_SPI_CLEAR_OVRFLAG(hspi);
000036  6820              LDR      r0,[r4,#0]
000038  68c2              LDR      r2,[r0,#0xc]
00003a  6880              LDR      r0,[r0,#8]
00003c  9000              STR      r0,[sp,#0]
                  |L47.62|
;;;2239       }
;;;2240   
;;;2241       hspi->TxXferCount = 0U;
00003e  86e1              STRH     r1,[r4,#0x36]
;;;2242       hspi->State = HAL_SPI_STATE_READY;
000040  2001              MOVS     r0,#1
000042  f8840051          STRB     r0,[r4,#0x51]
;;;2243   
;;;2244       if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000046  6d60              LDR      r0,[r4,#0x54]
000048  b118              CBZ      r0,|L47.82|
;;;2245       {
;;;2246         HAL_SPI_ErrorCallback(hspi);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2247         return;
;;;2248       }
;;;2249     }
;;;2250     HAL_SPI_TxCpltCallback(hspi);
;;;2251   }
000050  bd38              POP      {r3-r5,pc}
                  |L47.82|
000052  4620              MOV      r0,r4                 ;2250
000054  f7fffffe          BL       HAL_SPI_TxCpltCallback
000058  bd38              POP      {r3-r5,pc}
;;;2252   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;2335     */
;;;2336   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2337   {
000002  4605              MOV      r5,r0
;;;2338     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2339     uint32_t tickstart = 0U;
;;;2340   #if (USE_SPI_CRC != 0U)
;;;2341     __IO int16_t tmpreg = 0U;
;;;2342   #endif /* USE_SPI_CRC */
;;;2343     /* Init tickstart for timeout management*/
;;;2344     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4602              MOV      r2,r0
;;;2345   
;;;2346     if((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  0680              LSLS     r0,r0,#26
000012  d419              BMI      |L48.72|
;;;2347     {
;;;2348   #if (USE_SPI_CRC != 0U)
;;;2349       /* CRC handling */
;;;2350       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2351       {
;;;2352         /* Wait the CRC data */
;;;2353         if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2354         {
;;;2355           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2356         }
;;;2357         /* Read CRC to Flush DR and RXNE flag */
;;;2358         tmpreg = hspi->Instance->DR;
;;;2359         /* To avoid GCC warning */
;;;2360         UNUSED(tmpreg);
;;;2361       }
;;;2362   #endif /* USE_SPI_CRC */
;;;2363       /* Check the end of the transaction */
;;;2364       if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_CheckFlag_BSY
00001c  b118              CBZ      r0,|L48.38|
;;;2365       {
;;;2366         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001e  6d60              LDR      r0,[r4,#0x54]
000020  f0400020          ORR      r0,r0,#0x20
000024  6560              STR      r0,[r4,#0x54]
                  |L48.38|
;;;2367       }
;;;2368   
;;;2369       /* Disable Rx/Tx DMA Request */
;;;2370       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000026  6820              LDR      r0,[r4,#0]
000028  6841              LDR      r1,[r0,#4]
00002a  f0210103          BIC      r1,r1,#3
00002e  6041              STR      r1,[r0,#4]
;;;2371   
;;;2372       hspi->TxXferCount = 0U;
000030  2000              MOVS     r0,#0
000032  86e0              STRH     r0,[r4,#0x36]
;;;2373       hspi->RxXferCount = 0U;
000034  87e0              STRH     r0,[r4,#0x3e]
;;;2374       hspi->State = HAL_SPI_STATE_READY;
000036  2001              MOVS     r0,#1
000038  f8840051          STRB     r0,[r4,#0x51]
;;;2375   
;;;2376   #if (USE_SPI_CRC != 0U)
;;;2377       /* Check if CRC error occurred */
;;;2378       if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;2379       {
;;;2380         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2381         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;2382         {
;;;2383           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2384   
;;;2385           /* Reset CRC Calculation */
;;;2386           SPI_RESET_CRC(hspi);
;;;2387       }
;;;2388         else
;;;2389         {
;;;2390           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2391         }
;;;2392       }
;;;2393   #endif /* USE_SPI_CRC */
;;;2394   
;;;2395       if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00003c  6d60              LDR      r0,[r4,#0x54]
00003e  b118              CBZ      r0,|L48.72|
;;;2396       {
;;;2397         HAL_SPI_ErrorCallback(hspi);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2398         return;
;;;2399       }
;;;2400     }
;;;2401     HAL_SPI_TxRxCpltCallback(hspi);
;;;2402   }
000046  bd70              POP      {r4-r6,pc}
                  |L48.72|
000048  4620              MOV      r0,r4                 ;2401
00004a  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
00004e  bd70              POP      {r4-r6,pc}
;;;2403   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=2

                  SPI_DMATxAbortCallback PROC
;;;2483     */
;;;2484   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b508              PUSH     {r3,lr}
;;;2485   {
;;;2486     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000002  4916              LDR      r1,|L49.92|
000004  f64552c0          MOV      r2,#0x5dc0
000008  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000a  fbb1f1f2          UDIV     r1,r1,r2
00000e  2264              MOVS     r2,#0x64
000010  4351              MULS     r1,r2,r1
000012  9100              STR      r1,[sp,#0]
;;;2487     SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000014  6a40              LDR      r0,[r0,#0x24]
;;;2488   
;;;2489     hspi->hdmatx->XferAbortCallback = NULL;
000016  2300              MOVS     r3,#0
000018  6c81              LDR      r1,[r0,#0x48]
00001a  634b              STR      r3,[r1,#0x34]
;;;2490   
;;;2491     /* Disable Tx DMA Request */
;;;2492     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN );
00001c  6801              LDR      r1,[r0,#0]
00001e  684a              LDR      r2,[r1,#4]
000020  f0220202          BIC      r2,r2,#2
000024  604a              STR      r2,[r1,#4]
                  |L49.38|
;;;2493   
;;;2494     /* Wait until TXE flag is set */
;;;2495     do
;;;2496     {
;;;2497       if(count-- == 0U)
000026  9900              LDR      r1,[sp,#0]
000028  1e4a              SUBS     r2,r1,#1
00002a  9200              STR      r2,[sp,#0]
00002c  d204              BCS      |L49.56|
;;;2498       {
;;;2499         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00002e  6d41              LDR      r1,[r0,#0x54]
000030  f0410120          ORR      r1,r1,#0x20
000034  6541              STR      r1,[r0,#0x54]
;;;2500         break;
000036  e003              B        |L49.64|
                  |L49.56|
;;;2501       }
;;;2502     }
;;;2503     while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000038  6801              LDR      r1,[r0,#0]
00003a  6889              LDR      r1,[r1,#8]
00003c  0789              LSLS     r1,r1,#30
00003e  d5f2              BPL      |L49.38|
                  |L49.64|
;;;2504   
;;;2505     /* Check if an Abort process is still ongoing */
;;;2506     if(hspi->hdmarx != NULL)
000040  6cc1              LDR      r1,[r0,#0x4c]
000042  b111              CBZ      r1,|L49.74|
;;;2507     {
;;;2508       if(hspi->hdmarx->XferAbortCallback != NULL)
000044  6b49              LDR      r1,[r1,#0x34]
000046  2900              CMP      r1,#0
000048  d107              BNE      |L49.90|
                  |L49.74|
;;;2509       {
;;;2510         return;
;;;2511       }
;;;2512     }
;;;2513     
;;;2514     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2515     hspi->RxXferCount = 0U;
00004a  87c3              STRH     r3,[r0,#0x3e]
;;;2516     hspi->TxXferCount = 0U;
00004c  86c3              STRH     r3,[r0,#0x36]
;;;2517   
;;;2518     /* Reset errorCode */
;;;2519     hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00004e  6543              STR      r3,[r0,#0x54]
;;;2520   
;;;2521     /* Restore hspi->State to Ready */
;;;2522     hspi->State  = HAL_SPI_STATE_READY;
000050  2101              MOVS     r1,#1
000052  f8801051          STRB     r1,[r0,#0x51]
;;;2523   
;;;2524     /* Call user Abort complete callback */
;;;2525     HAL_SPI_AbortCpltCallback(hspi);
000056  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L49.90|
;;;2526   }
00005a  bd08              POP      {r3,pc}
;;;2527   
                          ENDP

                  |L49.92|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_ISCRCErrorValid||, CODE, READONLY, ALIGN=1

                  SPI_ISCRCErrorValid PROC
;;;3245   */
;;;3246   __WEAK uint8_t SPI_ISCRCErrorValid(SPI_HandleTypeDef *hspi)
000000  2001              MOVS     r0,#1
;;;3247   {
;;;3248     /* Prevent unused argument(s) compilation warning */
;;;3249     UNUSED(hspi);
;;;3250     
;;;3251     return (SPI_VALID_CRC_ERROR);
;;;3252   }
000002  4770              BX       lr
;;;3253   /**
                          ENDP


                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BIT PROC
;;;2843     */
;;;2844   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;2845   {
;;;2846     *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
000002  68c9              LDR      r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  8011              STRH     r1,[r2,#0]
;;;2847     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;2848     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;2849   
;;;2850   #if (USE_SPI_CRC != 0U)
;;;2851     /* Enable CRC Transmission */
;;;2852     if((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;2853     {
;;;2854       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2855     }
;;;2856   #endif /* USE_SPI_CRC */
;;;2857   
;;;2858     if(hspi->RxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d101              BNE      |L51.30|
;;;2859     {
;;;2860   #if (USE_SPI_CRC != 0U)
;;;2861       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2862       {
;;;2863         hspi->RxISR = SPI_RxISR_16BITCRC;
;;;2864         return;
;;;2865       }
;;;2866   #endif /* USE_SPI_CRC */
;;;2867       SPI_CloseRx_ISR(hspi);
00001a  f7ffbffe          B.W      SPI_CloseRx_ISR
                  |L51.30|
;;;2868     }
;;;2869   }
00001e  4770              BX       lr
;;;2870   
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BIT PROC
;;;2787     */
;;;2788   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;2789   {
;;;2790     *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
000002  7b0b              LDRB     r3,[r1,#0xc]
000004  6b81              LDR      r1,[r0,#0x38]
000006  1c4a              ADDS     r2,r1,#1
000008  6382              STR      r2,[r0,#0x38]
00000a  700b              STRB     r3,[r1,#0]
;;;2791     hspi->RxXferCount--;
00000c  8fc1              LDRH     r1,[r0,#0x3e]
00000e  1e49              SUBS     r1,r1,#1
000010  87c1              STRH     r1,[r0,#0x3e]
;;;2792   
;;;2793   #if (USE_SPI_CRC != 0U)
;;;2794     /* Enable CRC Transmission */
;;;2795     if((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;2796     {
;;;2797       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2798     }
;;;2799   #endif /* USE_SPI_CRC */
;;;2800   
;;;2801     if(hspi->RxXferCount == 0U)
000012  8fc1              LDRH     r1,[r0,#0x3e]
000014  2900              CMP      r1,#0
000016  d101              BNE      |L52.28|
;;;2802     {
;;;2803   #if (USE_SPI_CRC != 0U)
;;;2804       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2805       {
;;;2806         hspi->RxISR =  SPI_RxISR_8BITCRC;
;;;2807         return;
;;;2808       }
;;;2809   #endif /* USE_SPI_CRC */
;;;2810       SPI_CloseRx_ISR(hspi);
000018  f7ffbffe          B.W      SPI_CloseRx_ISR
                  |L52.28|
;;;2811     }
;;;2812   }
00001c  4770              BX       lr
;;;2813   
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;2900     */
;;;2901   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;2902   {
;;;2903     /* Transmit data in 16 Bit mode */
;;;2904     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;2905     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c89              ADDS     r1,r1,#2
00000c  6301              STR      r1,[r0,#0x30]
;;;2906     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;2907   
;;;2908     if(hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d101              BNE      |L53.30|
;;;2909     {
;;;2910   #if (USE_SPI_CRC != 0U)
;;;2911       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2912       {
;;;2913         /* Enable CRC Transmission */
;;;2914         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2915       }
;;;2916   #endif /* USE_SPI_CRC */
;;;2917       SPI_CloseTx_ISR(hspi);
00001a  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L53.30|
;;;2918     }
;;;2919   }
00001e  4770              BX       lr
;;;2920   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;2876     */
;;;2877   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;2878   {
;;;2879     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
000002  1c4a              ADDS     r2,r1,#1
000004  6302              STR      r2,[r0,#0x30]
000006  6802              LDR      r2,[r0,#0]
000008  7809              LDRB     r1,[r1,#0]
00000a  7311              STRB     r1,[r2,#0xc]
;;;2880     hspi->TxXferCount--;
00000c  8ec1              LDRH     r1,[r0,#0x36]
00000e  1e49              SUBS     r1,r1,#1
000010  86c1              STRH     r1,[r0,#0x36]
;;;2881   
;;;2882     if(hspi->TxXferCount == 0U)
000012  8ec1              LDRH     r1,[r0,#0x36]
000014  2900              CMP      r1,#0
000016  d101              BNE      |L54.28|
;;;2883     {
;;;2884   #if (USE_SPI_CRC != 0U)
;;;2885       if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2886       {
;;;2887         /* Enable CRC Transmission */
;;;2888         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;2889       }
;;;2890   #endif /* USE_SPI_CRC */
;;;2891       SPI_CloseTx_ISR(hspi);
000018  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L54.28|
;;;2892     }
;;;2893   }
00001c  4770              BX       lr
;;;2894   
                          ENDP


                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=1

                  SPI_WaitFlagStateUntilTimeout PROC
;;;2930     */
;;;2931   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2932   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;2933     while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
;;;2934     {
;;;2935       if(Timeout != HAL_MAX_DELAY)
;;;2936       {
;;;2937         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
;;;2938         {
;;;2939           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;2940           on both master and slave sides in order to resynchronize the master
;;;2941           and slave for their respective CRC calculation */
;;;2942   
;;;2943           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;2944           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;2945   
;;;2946           if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;2947           {
;;;2948             /* Disable SPI peripheral */
;;;2949             __HAL_SPI_DISABLE(hspi);
;;;2950           }
;;;2951   
;;;2952           /* Reset CRC Calculation */
;;;2953           if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2954           {
;;;2955             SPI_RESET_CRC(hspi);
;;;2956           }
;;;2957   
;;;2958           hspi->State= HAL_SPI_STATE_READY;
;;;2959   
;;;2960           /* Process Unlocked */
;;;2961           __HAL_UNLOCK(hspi);
;;;2962   
;;;2963           return HAL_TIMEOUT;
000010  e034              B        |L55.124|
                  |L55.18|
000012  1c68              ADDS     r0,r5,#1              ;2935
000014  d032              BEQ      |L55.124|
000016  b12d              CBZ      r5,|L55.36|
000018  f7fffffe          BL       HAL_GetTick
00001c  eba00008          SUB      r0,r0,r8              ;2937
000020  42a8              CMP      r0,r5                 ;2937
000022  d32b              BCC      |L55.124|
                  |L55.36|
000024  6820              LDR      r0,[r4,#0]            ;2944
000026  6841              LDR      r1,[r0,#4]            ;2944
000028  f02101e0          BIC      r1,r1,#0xe0           ;2944
00002c  6041              STR      r1,[r0,#4]            ;2944
00002e  6860              LDR      r0,[r4,#4]            ;2946
000030  f5b07f82          CMP      r0,#0x104             ;2946
000034  d10b              BNE      |L55.78|
000036  68a0              LDR      r0,[r4,#8]            ;2946
000038  f5b04f00          CMP      r0,#0x8000            ;2946
00003c  d002              BEQ      |L55.68|
00003e  f5b06f80          CMP      r0,#0x400             ;2946
000042  d104              BNE      |L55.78|
                  |L55.68|
000044  6820              LDR      r0,[r4,#0]            ;2949
000046  6801              LDR      r1,[r0,#0]            ;2949
000048  f0210140          BIC      r1,r1,#0x40           ;2949
00004c  6001              STR      r1,[r0,#0]            ;2949
                  |L55.78|
00004e  6aa0              LDR      r0,[r4,#0x28]         ;2953
000050  f5b05f00          CMP      r0,#0x2000            ;2953
000054  d10a              BNE      |L55.108|
000056  6820              LDR      r0,[r4,#0]            ;2955
000058  6801              LDR      r1,[r0,#0]            ;2955
00005a  f64d72ff          MOV      r2,#0xdfff            ;2955
00005e  4011              ANDS     r1,r1,r2              ;2955
000060  6001              STR      r1,[r0,#0]            ;2955
000062  6820              LDR      r0,[r4,#0]            ;2955
000064  6801              LDR      r1,[r0,#0]            ;2955
000066  f4415100          ORR      r1,r1,#0x2000         ;2955
00006a  6001              STR      r1,[r0,#0]            ;2955
                  |L55.108|
00006c  2001              MOVS     r0,#1                 ;2958
00006e  3450              ADDS     r4,r4,#0x50           ;2958
000070  7060              STRB     r0,[r4,#1]            ;2958
000072  2000              MOVS     r0,#0                 ;2961
000074  7020              STRB     r0,[r4,#0]            ;2961
000076  2003              MOVS     r0,#3
                  |L55.120|
;;;2964         }
;;;2965       }
;;;2966     }
;;;2967   
;;;2968     return HAL_OK;
;;;2969   }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L55.124|
00007c  6820              LDR      r0,[r4,#0]            ;2933
00007e  6880              LDR      r0,[r0,#8]            ;2933
000080  ea360000          BICS     r0,r6,r0              ;2933
000084  d004              BEQ      |L55.144|
000086  2000              MOVS     r0,#0                 ;2933
                  |L55.136|
000088  42b8              CMP      r0,r7                 ;2933
00008a  d1c2              BNE      |L55.18|
00008c  2000              MOVS     r0,#0                 ;2968
00008e  e7f3              B        |L55.120|
                  |L55.144|
000090  2001              MOVS     r0,#1                 ;2933
000092  e7f9              B        |L55.136|
;;;2970   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5c481309____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_spi_c_5c481309____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5c481309____REVSH|
#line 456
|__asm___19_stm32f1xx_hal_spi_c_5c481309____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5c481309____RRX|
#line 643
|__asm___19_stm32f1xx_hal_spi_c_5c481309____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
