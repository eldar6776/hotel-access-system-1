; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_iwdg.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_iwdg.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_iwdg.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_iwdg.c]
                          THUMB

                          AREA ||i.HAL_IWDG_Init||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_Init PROC
;;;163      */
;;;164    HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166      uint32_t tickstart;
;;;167    
;;;168      /* Check the IWDG handle allocation */
;;;169      if(hiwdg == NULL)
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L1.44|
;;;170      {
;;;171        return HAL_ERROR;
;;;172      }
;;;173    
;;;174      /* Check the parameters */
;;;175      assert_param(IS_IWDG_ALL_INSTANCE(hiwdg->Instance));
;;;176      assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
;;;177      assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));
;;;178    
;;;179      /* Enable IWDG. LSI is turned on automaticaly */
;;;180      __HAL_IWDG_START(hiwdg);
000008  6821              LDR      r1,[r4,#0]
00000a  f64c40cc          MOV      r0,#0xcccc
00000e  6008              STR      r0,[r1,#0]
;;;181    
;;;182      /* Enable write access to IWDG_PR and IWDG_RLR registers by writing 0x5555 in KR */
;;;183      IWDG_ENABLE_WRITE_ACCESS(hiwdg);
000010  6821              LDR      r1,[r4,#0]
000012  f2455055          MOV      r0,#0x5555
000016  6008              STR      r0,[r1,#0]
;;;184    
;;;185      /* Write to IWDG registers the Prescaler & Reload values to work with */
;;;186      hiwdg->Instance->PR = hiwdg->Init.Prescaler;
000018  e9d41000          LDRD     r1,r0,[r4,#0]
00001c  6048              STR      r0,[r1,#4]
;;;187      hiwdg->Instance->RLR = hiwdg->Init.Reload;
00001e  6821              LDR      r1,[r4,#0]
000020  68a0              LDR      r0,[r4,#8]
000022  6088              STR      r0,[r1,#8]
;;;188    
;;;189      /* Check pending flag, if previous update not done, return timeout */
;;;190      tickstart = HAL_GetTick();
000024  f7fffffe          BL       HAL_GetTick
000028  4605              MOV      r5,r0
;;;191    
;;;192      /* Wait for register to be updated */
;;;193      while(hiwdg->Instance->SR != RESET)
00002a  e008              B        |L1.62|
                  |L1.44|
00002c  2001              MOVS     r0,#1                 ;171
;;;194      {
;;;195        if((HAL_GetTick() - tickstart ) > HAL_IWDG_DEFAULT_TIMEOUT)
;;;196        {
;;;197          return HAL_TIMEOUT;
;;;198        }
;;;199      }
;;;200    
;;;201      /* Reload IWDG counter with value defined in the reload register */
;;;202      __HAL_IWDG_RELOAD_COUNTER(hiwdg);
;;;203    
;;;204      /* Return function status */
;;;205      return HAL_OK;
;;;206    }
00002e  bd70              POP      {r4-r6,pc}
                  |L1.48|
000030  f7fffffe          BL       HAL_GetTick
000034  1b40              SUBS     r0,r0,r5              ;195
000036  2830              CMP      r0,#0x30              ;195
000038  d901              BLS      |L1.62|
00003a  2003              MOVS     r0,#3                 ;197
00003c  bd70              POP      {r4-r6,pc}
                  |L1.62|
00003e  6820              LDR      r0,[r4,#0]            ;193
000040  68c0              LDR      r0,[r0,#0xc]          ;193
000042  2800              CMP      r0,#0                 ;193
000044  d1f4              BNE      |L1.48|
000046  6821              LDR      r1,[r4,#0]            ;202
000048  f64a20aa          MOV      r0,#0xaaaa            ;202
00004c  6008              STR      r0,[r1,#0]            ;202
00004e  2000              MOVS     r0,#0                 ;205
000050  bd70              POP      {r4-r6,pc}
;;;207    
                          ENDP


                          AREA ||i.HAL_IWDG_Refresh||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_Refresh PROC
;;;231      */
;;;232    HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
000000  6800              LDR      r0,[r0,#0]
;;;233    {
;;;234      /* Reload IWDG counter with value defined in the reload register */
;;;235      __HAL_IWDG_RELOAD_COUNTER(hiwdg);
000002  f64a21aa          MOV      r1,#0xaaaa
000006  6001              STR      r1,[r0,#0]
;;;236    
;;;237      /* Return function status */
;;;238      return HAL_OK;
000008  2000              MOVS     r0,#0
;;;239    }
00000a  4770              BX       lr
;;;240    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_iwdg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REVSH|
#line 456
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____RRX|
#line 643
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
