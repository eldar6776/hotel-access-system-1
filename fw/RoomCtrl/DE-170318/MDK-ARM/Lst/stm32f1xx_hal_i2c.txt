; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_i2c.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_i2c.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_i2c.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;3743     */
;;;3744   __WEAK void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3745   {
;;;3746     /* Prevent unused argument(s) compilation warning */
;;;3747     UNUSED(hi2c);
;;;3748   
;;;3749     /* NOTE : This function should not be modified, when the callback is needed,
;;;3750               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;3751      */
;;;3752   }
;;;3753   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;3661     */
;;;3662   __WEAK void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;3663   {
;;;3664     /* Prevent unused argument(s) compilation warning */
;;;3665     UNUSED(hi2c);
;;;3666     UNUSED(TransferDirection);
;;;3667     UNUSED(AddrMatchCode);
;;;3668   
;;;3669     /* NOTE : This function should not be modified, when the callback is needed,
;;;3670               the HAL_I2C_AddrCallback can be implemented in the user file
;;;3671      */
;;;3672   }
;;;3673   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;452      */
;;;453    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  4604              MOV      r4,r0
;;;455      /* Check the I2C handle allocation */
;;;456      if(hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d012              BEQ      |L3.46|
;;;457      {
;;;458        return HAL_ERROR;
;;;459      }
;;;460    
;;;461      /* Check the parameters */
;;;462      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;463    
;;;464      hi2c->State = HAL_I2C_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f884003d          STRB     r0,[r4,#0x3d]
;;;465    
;;;466      /* Disable the I2C Peripheral Clock */
;;;467      __HAL_I2C_DISABLE(hi2c);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210101          BIC      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;468    
;;;469      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;470      HAL_I2C_MspDeInit(hi2c);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_I2C_MspDeInit
;;;471    
;;;472      hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3430              ADDS     r4,r4,#0x30
000022  6120              STR      r0,[r4,#0x10]
;;;473      hi2c->State         = HAL_I2C_STATE_RESET;
000024  7360              STRB     r0,[r4,#0xd]
;;;474      hi2c->PreviousState = I2C_STATE_NONE;
000026  6020              STR      r0,[r4,#0]
;;;475      hi2c->Mode          = HAL_I2C_MODE_NONE;
000028  73a0              STRB     r0,[r4,#0xe]
;;;476    
;;;477      /* Release Lock */
;;;478      __HAL_UNLOCK(hi2c);
00002a  7320              STRB     r0,[r4,#0xc]
;;;479    
;;;480      return HAL_OK;
;;;481    }
00002c  bd10              POP      {r4,pc}
                  |L3.46|
00002e  2001              MOVS     r0,#1                 ;458
000030  bd10              POP      {r4,pc}
;;;482    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;1925     */
;;;1926   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;1927   {
;;;1928     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;1929     uint32_t tmp;
;;;1930   
;;;1931     /* Disable Address listen mode only if a transfer is not ongoing */
;;;1932     if(hi2c->State == HAL_I2C_STATE_LISTEN)
000004  2928              CMP      r1,#0x28
000006  d001              BEQ      |L4.12|
;;;1933     {
;;;1934       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
;;;1935       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
;;;1936       hi2c->State = HAL_I2C_STATE_READY;
;;;1937       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1938   
;;;1939       /* Disable Address Acknowledge */
;;;1940       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1941   
;;;1942       /* Disable EVT and ERR interrupt */
;;;1943       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;1944     
;;;1945       return HAL_OK;
;;;1946     }
;;;1947     else
;;;1948     {
;;;1949       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1950     }
;;;1951   }
00000a  4770              BX       lr
                  |L4.12|
00000c  3020              ADDS     r0,r0,#0x20           ;1934
00000e  7f41              LDRB     r1,[r0,#0x1d]         ;1934
000010  f0010103          AND      r1,r1,#3              ;1934
000014  7f82              LDRB     r2,[r0,#0x1e]         ;1935
000016  430a              ORRS     r2,r2,r1              ;1935
000018  6102              STR      r2,[r0,#0x10]         ;1935
00001a  2120              MOVS     r1,#0x20              ;1936
00001c  7741              STRB     r1,[r0,#0x1d]         ;1936
00001e  2100              MOVS     r1,#0                 ;1937
000020  7781              STRB     r1,[r0,#0x1e]         ;1937
000022  f8501c20          LDR      r1,[r0,#-0x20]        ;1940
000026  680a              LDR      r2,[r1,#0]            ;1940
000028  f4226280          BIC      r2,r2,#0x400          ;1940
00002c  600a              STR      r2,[r1,#0]            ;1940
00002e  f8500c20          LDR      r0,[r0,#-0x20]        ;1943
000032  6841              LDR      r1,[r0,#4]            ;1943
000034  f4217140          BIC      r1,r1,#0x300          ;1943
000038  6041              STR      r1,[r0,#4]            ;1943
00003a  2000              MOVS     r0,#0                 ;1945
00003c  4770              BX       lr
;;;1952   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_I2C_ER_IRQHandler PROC
;;;3519     */
;;;3520   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;3521   {
000002  4604              MOV      r4,r0
;;;3522     uint32_t tmp1 = 0U, tmp2 = 0U, tmp3 = 0U, tmp4 = 0U;
;;;3523     uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
000004  6820              LDR      r0,[r4,#0]
000006  6945              LDR      r5,[r0,#0x14]
;;;3524     uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
000008  6846              LDR      r6,[r0,#4]
;;;3525   
;;;3526     /* I2C Bus error interrupt occurred ----------------------------------------*/
;;;3527     if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
00000a  4930              LDR      r1,|L5.204|
00000c  420d              TST      r5,r1
00000e  d00d              BEQ      |L5.44|
000010  05f1              LSLS     r1,r6,#23
000012  d50b              BPL      |L5.44|
;;;3528     {
;;;3529       hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
000014  6c21              LDR      r1,[r4,#0x40]
000016  f0410101          ORR      r1,r1,#1
00001a  6421              STR      r1,[r4,#0x40]
;;;3530   
;;;3531       /* Clear BERR flag */
;;;3532       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
00001c  f46f7180          MVN      r1,#0x100
000020  6141              STR      r1,[r0,#0x14]
;;;3533   
;;;3534       /* Workaround: Start cannot be generated after a misplaced Stop */
;;;3535       SET_BIT(hi2c->Instance->CR1, I2C_CR1_SWRST);
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  f4414100          ORR      r1,r1,#0x8000
00002a  6001              STR      r1,[r0,#0]
                  |L5.44|
;;;3536     }
;;;3537   
;;;3538     /* I2C Arbitration Loss error interrupt occurred ---------------------------*/
;;;3539     if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
00002c  f4153f81          TST      r5,#0x10200
000030  d009              BEQ      |L5.70|
000032  05f0              LSLS     r0,r6,#23
000034  d507              BPL      |L5.70|
;;;3540     {
;;;3541       hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
000036  6c20              LDR      r0,[r4,#0x40]
000038  f0400002          ORR      r0,r0,#2
00003c  6420              STR      r0,[r4,#0x40]
;;;3542   
;;;3543       /* Clear ARLO flag */
;;;3544       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00003e  6821              LDR      r1,[r4,#0]
000040  f46f7000          MVN      r0,#0x200
000044  6148              STR      r0,[r1,#0x14]
                  |L5.70|
;;;3545     }
;;;3546   
;;;3547     /* I2C Acknowledge failure error interrupt occurred ------------------------*/
;;;3548     if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
000046  f4153f82          TST      r5,#0x10400
00004a  d028              BEQ      |L5.158|
00004c  05f0              LSLS     r0,r6,#23
00004e  d526              BPL      |L5.158|
;;;3549     {
;;;3550       tmp1 = hi2c->Mode;
000050  f894203e          LDRB     r2,[r4,#0x3e]
;;;3551       tmp2 = hi2c->XferCount;
000054  8d61              LDRH     r1,[r4,#0x2a]
;;;3552       tmp3 = hi2c->State;
000056  f894003d          LDRB     r0,[r4,#0x3d]
;;;3553       tmp4 = hi2c->PreviousState;
00005a  6b23              LDR      r3,[r4,#0x30]
;;;3554       if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
00005c  2a20              CMP      r2,#0x20
00005e  d108              BNE      |L5.114|
000060  b939              CBNZ     r1,|L5.114|
;;;3555         ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
000062  2821              CMP      r0,#0x21
000064  d00e              BEQ      |L5.132|
000066  2829              CMP      r0,#0x29
000068  d00c              BEQ      |L5.132|
;;;3556         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
00006a  2828              CMP      r0,#0x28
00006c  d101              BNE      |L5.114|
00006e  2b21              CMP      r3,#0x21
000070  d008              BEQ      |L5.132|
                  |L5.114|
;;;3557       {
;;;3558         I2C_Slave_AF(hi2c);
;;;3559       }
;;;3560       else
;;;3561       {
;;;3562         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000072  6c20              LDR      r0,[r4,#0x40]
000074  f0400004          ORR      r0,r0,#4
000078  6420              STR      r0,[r4,#0x40]
;;;3563   
;;;3564         /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
;;;3565         if(hi2c->Mode == HAL_I2C_MODE_MASTER)
00007a  f894003e          LDRB     r0,[r4,#0x3e]
00007e  2810              CMP      r0,#0x10
000080  d004              BEQ      |L5.140|
000082  e008              B        |L5.150|
                  |L5.132|
000084  4620              MOV      r0,r4                 ;3558
000086  f7fffffe          BL       I2C_Slave_AF
00008a  e008              B        |L5.158|
                  |L5.140|
;;;3566         {
;;;3567           /* Generate Stop */
;;;3568           SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
00008c  6820              LDR      r0,[r4,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  f4417100          ORR      r1,r1,#0x200
000094  6001              STR      r1,[r0,#0]
                  |L5.150|
;;;3569         }
;;;3570   
;;;3571         /* Clear AF flag */
;;;3572         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000096  6821              LDR      r1,[r4,#0]
000098  f46f6080          MVN      r0,#0x400
00009c  6148              STR      r0,[r1,#0x14]
                  |L5.158|
;;;3573       }
;;;3574     }
;;;3575   
;;;3576     /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
;;;3577     if(((sr1itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
00009e  f4153f84          TST      r5,#0x10800
0000a2  d009              BEQ      |L5.184|
0000a4  05f0              LSLS     r0,r6,#23
0000a6  d507              BPL      |L5.184|
;;;3578     {
;;;3579       hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
0000a8  6c20              LDR      r0,[r4,#0x40]
0000aa  f0400008          ORR      r0,r0,#8
0000ae  6420              STR      r0,[r4,#0x40]
;;;3580       /* Clear OVR flag */
;;;3581       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
0000b0  6821              LDR      r1,[r4,#0]
0000b2  f46f6000          MVN      r0,#0x800
0000b6  6148              STR      r0,[r1,#0x14]
                  |L5.184|
;;;3582     }
;;;3583   
;;;3584     /* Call the Error Callback in case of Error detected -----------------------*/
;;;3585     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000b8  6c20              LDR      r0,[r4,#0x40]
0000ba  2800              CMP      r0,#0
0000bc  d004              BEQ      |L5.200|
;;;3586     {
;;;3587       I2C_ITError(hi2c);
0000be  4620              MOV      r0,r4
0000c0  e8bd4070          POP      {r4-r6,lr}
0000c4  f7ffbffe          B.W      I2C_ITError
                  |L5.200|
;;;3588     }
;;;3589   }
0000c8  bd70              POP      {r4-r6,pc}
;;;3590   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L5.204|
                          DCD      0x00010100

                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_I2C_EV_IRQHandler PROC
;;;3413     */
;;;3414   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3415   {
000004  4680              MOV      r8,r0
;;;3416     uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
000006  f8d80000          LDR      r0,[r8,#0]
00000a  6987              LDR      r7,[r0,#0x18]
;;;3417     uint32_t sr1itflags   = READ_REG(hi2c->Instance->SR1);
00000c  6944              LDR      r4,[r0,#0x14]
;;;3418     uint32_t itsources    = READ_REG(hi2c->Instance->CR2);
00000e  6845              LDR      r5,[r0,#4]
;;;3419   
;;;3420     uint32_t CurrentMode  = hi2c->Mode;
000010  f898003e          LDRB     r0,[r8,#0x3e]
;;;3421   
;;;3422     /* Master or Memory mode selected */
;;;3423     if((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
;;;3424     {
;;;3425       /* SB Set ----------------------------------------------------------------*/
;;;3426       if(((sr1itflags & I2C_FLAG_SB) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
;;;3427       {
;;;3428         I2C_Master_SB(hi2c);
;;;3429       }
;;;3430       /* ADD10 Set -------------------------------------------------------------*/
;;;3431       else if(((sr1itflags & I2C_FLAG_ADD10) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
;;;3432       {
;;;3433         I2C_Master_ADD10(hi2c);
;;;3434       }
;;;3435       /* ADDR Set --------------------------------------------------------------*/
;;;3436       else if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
000014  494c              LDR      r1,|L6.328|
;;;3437       {
;;;3438         I2C_Master_ADDR(hi2c);
;;;3439       }
;;;3440   
;;;3441       /* I2C in mode Transmitter -----------------------------------------------*/
;;;3442       if((sr2itflags & I2C_FLAG_TRA) != RESET)
;;;3443       {
;;;3444         /* TXE set and BTF reset -----------------------------------------------*/
;;;3445         if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
000016  f8dfa130          LDR      r10,|L6.328|
;;;3446         {
;;;3447           I2C_MasterTransmit_TXE(hi2c);
;;;3448         }
;;;3449         /* BTF set -------------------------------------------------------------*/
;;;3450         else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
;;;3451         {
;;;3452           I2C_MasterTransmit_BTF(hi2c);
;;;3453         }
;;;3454       }
;;;3455       /* I2C in mode Receiver --------------------------------------------------*/
;;;3456       else
;;;3457       {
;;;3458         /* RXNE set and BTF reset -----------------------------------------------*/
;;;3459         if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
00001a  f8dfb12c          LDR      r11,|L6.328|
00001e  f8df912c          LDR      r9,|L6.332|
000022  1c8e              ADDS     r6,r1,#2              ;3445
000024  f10a0a7e          ADD      r10,r10,#0x7e         ;3445
000028  f10b0b3e          ADD      r11,r11,#0x3e
00002c  2810              CMP      r0,#0x10              ;3423
00002e  d00a              BEQ      |L6.70|
000030  2840              CMP      r0,#0x40              ;3423
000032  d008              BEQ      |L6.70|
;;;3460         {
;;;3461           I2C_MasterReceive_RXNE(hi2c);
;;;3462         }
;;;3463         /* BTF set -------------------------------------------------------------*/
;;;3464         else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
;;;3465         {
;;;3466           I2C_MasterReceive_BTF(hi2c);
;;;3467         }
;;;3468       }
;;;3469     }
;;;3470     /* Slave mode selected */
;;;3471     else
;;;3472     {
;;;3473       /* ADDR set --------------------------------------------------------------*/
;;;3474       if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
000034  420c              TST      r4,r1
000036  d04d              BEQ      |L6.212|
000038  05a8              LSLS     r0,r5,#22
00003a  d54b              BPL      |L6.212|
;;;3475       {
;;;3476         I2C_Slave_ADDR(hi2c);
00003c  4640              MOV      r0,r8
00003e  e8bd5ff0          POP      {r4-r12,lr}
000042  f7ffbffe          B.W      I2C_Slave_ADDR
                  |L6.70|
000046  f0141f01          TST      r4,#0x10001           ;3426
00004a  d005              BEQ      |L6.88|
00004c  05a8              LSLS     r0,r5,#22             ;3426
00004e  d503              BPL      |L6.88|
000050  4640              MOV      r0,r8                 ;3428
000052  f7fffffe          BL       I2C_Master_SB
000056  e010              B        |L6.122|
                  |L6.88|
000058  483b              LDR      r0,|L6.328|
00005a  1d80              ADDS     r0,r0,#6              ;3431
00005c  4204              TST      r4,r0                 ;3431
00005e  d005              BEQ      |L6.108|
000060  05a8              LSLS     r0,r5,#22             ;3431
000062  d503              BPL      |L6.108|
000064  4640              MOV      r0,r8                 ;3433
000066  f7fffffe          BL       I2C_Master_ADD10
00006a  e006              B        |L6.122|
                  |L6.108|
00006c  420c              TST      r4,r1                 ;3436
00006e  d004              BEQ      |L6.122|
000070  05a8              LSLS     r0,r5,#22             ;3436
000072  d502              BPL      |L6.122|
000074  4640              MOV      r0,r8                 ;3438
000076  f7fffffe          BL       I2C_Master_ADDR
                  |L6.122|
00007a  ea170f09          TST      r7,r9                 ;3442
00007e  d014              BEQ      |L6.170|
000080  ea140f0a          TST      r4,r10                ;3445
000084  d008              BEQ      |L6.152|
000086  0568              LSLS     r0,r5,#21             ;3445
000088  d506              BPL      |L6.152|
00008a  4234              TST      r4,r6                 ;3445
00008c  d104              BNE      |L6.152|
00008e  4640              MOV      r0,r8                 ;3447
000090  e8bd5ff0          POP      {r4-r12,lr}           ;3447
000094  f7ffbffe          B.W      I2C_MasterTransmit_TXE
                  |L6.152|
000098  4234              TST      r4,r6                 ;3450
00009a  d053              BEQ      |L6.324|
00009c  05a8              LSLS     r0,r5,#22             ;3450
00009e  d551              BPL      |L6.324|
0000a0  4640              MOV      r0,r8                 ;3452
0000a2  e8bd5ff0          POP      {r4-r12,lr}           ;3452
0000a6  f7ffbffe          B.W      I2C_MasterTransmit_BTF
                  |L6.170|
0000aa  ea140f0b          TST      r4,r11                ;3459
0000ae  d008              BEQ      |L6.194|
0000b0  0568              LSLS     r0,r5,#21             ;3459
0000b2  d506              BPL      |L6.194|
0000b4  4234              TST      r4,r6                 ;3459
0000b6  d104              BNE      |L6.194|
0000b8  4640              MOV      r0,r8                 ;3461
0000ba  e8bd5ff0          POP      {r4-r12,lr}           ;3461
0000be  f7ffbffe          B.W      I2C_MasterReceive_RXNE
                  |L6.194|
0000c2  4234              TST      r4,r6                 ;3464
0000c4  d03e              BEQ      |L6.324|
0000c6  05a8              LSLS     r0,r5,#22             ;3464
0000c8  d53c              BPL      |L6.324|
0000ca  4640              MOV      r0,r8                 ;3466
0000cc  e8bd5ff0          POP      {r4-r12,lr}           ;3466
0000d0  f7ffbffe          B.W      I2C_MasterReceive_BTF
                  |L6.212|
;;;3477       }
;;;3478       /* STOPF set --------------------------------------------------------------*/
;;;3479       else if(((sr1itflags & I2C_FLAG_STOPF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
0000d4  481c              LDR      r0,|L6.328|
0000d6  300e              ADDS     r0,r0,#0xe
0000d8  4204              TST      r4,r0
0000da  d006              BEQ      |L6.234|
0000dc  05a8              LSLS     r0,r5,#22
0000de  d504              BPL      |L6.234|
;;;3480       {
;;;3481         I2C_Slave_STOPF(hi2c);
0000e0  4640              MOV      r0,r8
0000e2  e8bd5ff0          POP      {r4-r12,lr}
0000e6  f7ffbffe          B.W      I2C_Slave_STOPF
                  |L6.234|
;;;3482       }
;;;3483       /* I2C in mode Transmitter -----------------------------------------------*/
;;;3484       else if((sr2itflags & I2C_FLAG_TRA) != RESET)
0000ea  ea170f09          TST      r7,r9
0000ee  d014              BEQ      |L6.282|
;;;3485       {
;;;3486         /* TXE set and BTF reset -----------------------------------------------*/
;;;3487         if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
0000f0  ea140f0a          TST      r4,r10
0000f4  d008              BEQ      |L6.264|
0000f6  0568              LSLS     r0,r5,#21
0000f8  d506              BPL      |L6.264|
0000fa  4234              TST      r4,r6
0000fc  d104              BNE      |L6.264|
;;;3488         {
;;;3489           I2C_SlaveTransmit_TXE(hi2c);
0000fe  4640              MOV      r0,r8
000100  e8bd5ff0          POP      {r4-r12,lr}
000104  f7ffbffe          B.W      I2C_SlaveTransmit_TXE
                  |L6.264|
;;;3490         }
;;;3491         /* BTF set -------------------------------------------------------------*/
;;;3492         else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
000108  4234              TST      r4,r6
00010a  d01b              BEQ      |L6.324|
00010c  05a8              LSLS     r0,r5,#22
00010e  d519              BPL      |L6.324|
;;;3493         {
;;;3494           I2C_SlaveTransmit_BTF(hi2c);
000110  4640              MOV      r0,r8
000112  e8bd5ff0          POP      {r4-r12,lr}
000116  f7ffbffe          B.W      I2C_SlaveTransmit_BTF
                  |L6.282|
;;;3495         }
;;;3496       }
;;;3497       /* I2C in mode Receiver --------------------------------------------------*/
;;;3498       else
;;;3499       {
;;;3500         /* RXNE set and BTF reset ----------------------------------------------*/
;;;3501         if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
00011a  ea140f0b          TST      r4,r11
00011e  d008              BEQ      |L6.306|
000120  0568              LSLS     r0,r5,#21
000122  d506              BPL      |L6.306|
000124  4234              TST      r4,r6
000126  d104              BNE      |L6.306|
;;;3502         {
;;;3503           I2C_SlaveReceive_RXNE(hi2c);
000128  4640              MOV      r0,r8
00012a  e8bd5ff0          POP      {r4-r12,lr}
00012e  f7ffbffe          B.W      I2C_SlaveReceive_RXNE
                  |L6.306|
;;;3504         }
;;;3505         /* BTF set -------------------------------------------------------------*/
;;;3506         else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
000132  4234              TST      r4,r6
000134  d006              BEQ      |L6.324|
000136  05a8              LSLS     r0,r5,#22
000138  d504              BPL      |L6.324|
;;;3507         {
;;;3508           I2C_SlaveReceive_BTF(hi2c);
00013a  4640              MOV      r0,r8
00013c  e8bd5ff0          POP      {r4-r12,lr}
000140  f7ffbffe          B.W      I2C_SlaveReceive_BTF
                  |L6.324|
;;;3509         }
;;;3510       }
;;;3511     }
;;;3512   }
000144  e8bd9ff0          POP      {r4-r12,pc}
;;;3513   
                          ENDP

                  |L6.328|
                          DCD      0x00010002
                  |L6.332|
                          DCD      0x00100004

                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EnableListen_IT PROC
;;;1892     */
;;;1893   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;1894   {
;;;1895     if(hi2c->State == HAL_I2C_STATE_READY)
000004  2920              CMP      r1,#0x20
000006  d001              BEQ      |L7.12|
;;;1896     {
;;;1897       hi2c->State = HAL_I2C_STATE_LISTEN;
;;;1898       
;;;1899       /* Check if the I2C is already enabled */
;;;1900       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1901       {
;;;1902         /* Enable I2C peripheral */
;;;1903         __HAL_I2C_ENABLE(hi2c);
;;;1904       }
;;;1905   
;;;1906       /* Enable Address Acknowledge */
;;;1907       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1908   
;;;1909       /* Enable EVT and ERR interrupt */
;;;1910       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;1911   
;;;1912       return HAL_OK;
;;;1913     }
;;;1914     else
;;;1915     {
;;;1916       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1917     }
;;;1918   }
00000a  4770              BX       lr
                  |L7.12|
00000c  2128              MOVS     r1,#0x28              ;1897
00000e  f880103d          STRB     r1,[r0,#0x3d]         ;1897
000012  6801              LDR      r1,[r0,#0]            ;1900
000014  680a              LDR      r2,[r1,#0]            ;1900
000016  07d2              LSLS     r2,r2,#31             ;1900
000018  d103              BNE      |L7.34|
00001a  680a              LDR      r2,[r1,#0]            ;1903
00001c  f0420201          ORR      r2,r2,#1              ;1903
000020  600a              STR      r2,[r1,#0]            ;1903
                  |L7.34|
000022  6801              LDR      r1,[r0,#0]            ;1907
000024  680a              LDR      r2,[r1,#0]            ;1907
000026  f4426280          ORR      r2,r2,#0x400          ;1907
00002a  600a              STR      r2,[r1,#0]            ;1907
00002c  6800              LDR      r0,[r0,#0]            ;1910
00002e  6841              LDR      r1,[r0,#4]            ;1910
000030  f4417140          ORR      r1,r1,#0x300          ;1910
000034  6041              STR      r1,[r0,#4]            ;1910
000036  2000              MOVS     r0,#0                 ;1912
000038  4770              BX       lr
;;;1919   
                          ENDP


                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;3727     */
;;;3728   __WEAK void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3729   {
;;;3730     /* Prevent unused argument(s) compilation warning */
;;;3731     UNUSED(hi2c);
;;;3732   
;;;3733     /* NOTE : This function should not be modified, when the callback is needed,
;;;3734               the HAL_I2C_ErrorCallback can be implemented in the user file
;;;3735      */
;;;3736   }
;;;3737   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;3801     */
;;;3802   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  6c00              LDR      r0,[r0,#0x40]
;;;3803   {
;;;3804     return hi2c->ErrorCode;
;;;3805   }
000002  4770              BX       lr
;;;3806   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;3790     */
;;;3791   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  f890003e          LDRB     r0,[r0,#0x3e]
;;;3792   {
;;;3793     return hi2c->Mode;
;;;3794   }
000004  4770              BX       lr
;;;3795   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;3778     */
;;;3779   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;3780   {
;;;3781     /* Return I2C handle state */
;;;3782     return hi2c->State;
;;;3783   }
000004  4770              BX       lr
;;;3784   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;370      */
;;;371    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4604              MOV      r4,r0
;;;373      uint32_t freqrange = 0U;
;;;374      uint32_t pclk1 = 0U;
;;;375    
;;;376      /* Check the I2C handle allocation */
;;;377      if(hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L12.18|
;;;378      {
;;;379        return HAL_ERROR;
;;;380      }
;;;381    
;;;382      /* Check the parameters */
;;;383      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;384      assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
;;;385      assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
;;;386      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;387      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;388      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;389      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;390      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;391      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;392    
;;;393      if(hi2c->State == HAL_I2C_STATE_RESET)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L12.22|
000010  e006              B        |L12.32|
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;379
;;;394      {
;;;395        /* Allocate lock resource and initialize it */
;;;396        hi2c->Lock = HAL_UNLOCKED;
;;;397        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;398        HAL_I2C_MspInit(hi2c);
;;;399      }
;;;400    
;;;401      hi2c->State = HAL_I2C_STATE_BUSY;
;;;402    
;;;403      /* Disable the selected I2C peripheral */
;;;404      __HAL_I2C_DISABLE(hi2c);
;;;405    
;;;406      /* Get PCLK1 frequency */
;;;407      pclk1 = HAL_RCC_GetPCLK1Freq();
;;;408    
;;;409      /* Calculate frequency range */
;;;410      freqrange = I2C_FREQRANGE(pclk1);
;;;411    
;;;412      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;413      /* Configure I2Cx: Frequency range */
;;;414      hi2c->Instance->CR2 = freqrange;
;;;415    
;;;416      /*---------------------------- I2Cx TRISE Configuration --------------------*/
;;;417      /* Configure I2Cx: Rise Time */
;;;418      hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
;;;419    
;;;420      /*---------------------------- I2Cx CCR Configuration ----------------------*/
;;;421      /* Configure I2Cx: Speed */
;;;422      hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
;;;423    
;;;424      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;425      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;426      hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
;;;427    
;;;428      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;429      /* Configure I2Cx: Own Address1 and addressing mode */
;;;430      hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
;;;431    
;;;432      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;433      /* Configure I2Cx: Dual mode and Own Address2 */
;;;434      hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
;;;435    
;;;436      /* Enable the selected I2C peripheral */
;;;437      __HAL_I2C_ENABLE(hi2c);
;;;438    
;;;439      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;440      hi2c->State = HAL_I2C_STATE_READY;
;;;441      hi2c->PreviousState = I2C_STATE_NONE;
;;;442      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;443    
;;;444      return HAL_OK;
;;;445    }
000014  bd70              POP      {r4-r6,pc}
                  |L12.22|
000016  f884503c          STRB     r5,[r4,#0x3c]         ;396
00001a  4620              MOV      r0,r4                 ;398
00001c  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.32|
000020  2024              MOVS     r0,#0x24              ;401
000022  f884003d          STRB     r0,[r4,#0x3d]         ;401
000026  6820              LDR      r0,[r4,#0]            ;404
000028  6801              LDR      r1,[r0,#0]            ;404
00002a  f0210101          BIC      r1,r1,#1              ;404
00002e  6001              STR      r1,[r0,#0]            ;404
000030  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000034  4933              LDR      r1,|L12.260|
000036  fbb0f1f1          UDIV     r1,r0,r1              ;410
00003a  6822              LDR      r2,[r4,#0]            ;414
00003c  6051              STR      r1,[r2,#4]            ;414
00003e  4a32              LDR      r2,|L12.264|
000040  6863              LDR      r3,[r4,#4]            ;418
000042  4293              CMP      r3,r2                 ;418
000044  d801              BHI      |L12.74|
000046  1c49              ADDS     r1,r1,#1              ;418
000048  e007              B        |L12.90|
                  |L12.74|
00004a  f44f7396          MOV      r3,#0x12c             ;418
00004e  4359              MULS     r1,r3,r1              ;418
000050  f44f737a          MOV      r3,#0x3e8             ;418
000054  fbb1f1f3          UDIV     r1,r1,r3              ;418
000058  1c49              ADDS     r1,r1,#1              ;418
                  |L12.90|
00005a  6823              LDR      r3,[r4,#0]            ;418
00005c  6219              STR      r1,[r3,#0x20]         ;418
00005e  6861              LDR      r1,[r4,#4]            ;422
000060  4291              CMP      r1,r2                 ;422
000062  d80b              BHI      |L12.124|
000064  0049              LSLS     r1,r1,#1              ;422
000066  fbb0f2f1          UDIV     r2,r0,r1              ;422
00006a  f3c2020b          UBFX     r2,r2,#0,#12          ;422
00006e  2a04              CMP      r2,#4                 ;422
000070  d201              BCS      |L12.118|
000072  2004              MOVS     r0,#4                 ;422
000074  e019              B        |L12.170|
                  |L12.118|
000076  fbb0f0f1          UDIV     r0,r0,r1              ;422
00007a  e016              B        |L12.170|
                  |L12.124|
00007c  68a2              LDR      r2,[r4,#8]            ;422
00007e  b39a              CBZ      r2,|L12.232|
000080  eb0103c1          ADD      r3,r1,r1,LSL #3       ;422
000084  eb031301          ADD      r3,r3,r1,LSL #4       ;422
000088  fbb0f3f3          UDIV     r3,r0,r3              ;422
00008c  f4434380          ORR      r3,r3,#0x4000         ;422
                  |L12.144|
000090  051b              LSLS     r3,r3,#20             ;422
000092  d030              BEQ      |L12.246|
000094  b34a              CBZ      r2,|L12.234|
000096  eb0102c1          ADD      r2,r1,r1,LSL #3       ;422
00009a  eb021101          ADD      r1,r2,r1,LSL #4       ;422
00009e  fbb0f0f1          UDIV     r0,r0,r1              ;422
0000a2  f4404080          ORR      r0,r0,#0x4000         ;422
                  |L12.166|
0000a6  f4404000          ORR      r0,r0,#0x8000         ;422
                  |L12.170|
0000aa  6821              LDR      r1,[r4,#0]            ;422
0000ac  61c8              STR      r0,[r1,#0x1c]         ;422
0000ae  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;426
0000b2  4308              ORRS     r0,r0,r1              ;426
0000b4  6821              LDR      r1,[r4,#0]            ;426
0000b6  6008              STR      r0,[r1,#0]            ;426
0000b8  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;430
0000bc  4308              ORRS     r0,r0,r1              ;430
0000be  6821              LDR      r1,[r4,#0]            ;430
0000c0  6088              STR      r0,[r1,#8]            ;430
0000c2  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;434
0000c6  4308              ORRS     r0,r0,r1              ;434
0000c8  6821              LDR      r1,[r4,#0]            ;434
0000ca  60c8              STR      r0,[r1,#0xc]          ;434
0000cc  6820              LDR      r0,[r4,#0]            ;437
0000ce  6801              LDR      r1,[r0,#0]            ;437
0000d0  f0410101          ORR      r1,r1,#1              ;437
0000d4  6001              STR      r1,[r0,#0]            ;437
0000d6  6425              STR      r5,[r4,#0x40]         ;439
0000d8  2020              MOVS     r0,#0x20              ;440
0000da  f884003d          STRB     r0,[r4,#0x3d]         ;440
0000de  6325              STR      r5,[r4,#0x30]         ;441
0000e0  f884503e          STRB     r5,[r4,#0x3e]         ;442
0000e4  2000              MOVS     r0,#0                 ;444
0000e6  bd70              POP      {r4-r6,pc}
                  |L12.232|
0000e8  e000              B        |L12.236|
                  |L12.234|
0000ea  e006              B        |L12.250|
                  |L12.236|
0000ec  eb010341          ADD      r3,r1,r1,LSL #1       ;422
0000f0  fbb0f3f3          UDIV     r3,r0,r3              ;422
0000f4  e7cc              B        |L12.144|
                  |L12.246|
0000f6  2001              MOVS     r0,#1                 ;422
0000f8  e7d7              B        |L12.170|
                  |L12.250|
0000fa  eb010141          ADD      r1,r1,r1,LSL #1       ;422
0000fe  fbb0f0f1          UDIV     r0,r0,r1              ;422
000102  e7d0              B        |L12.166|
;;;446    
                          ENDP

                  |L12.260|
                          DCD      0x000f4240
                  |L12.264|
                          DCD      0x000186a0

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;3290     */
;;;3291   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3292   {
000004  b081              SUB      sp,sp,#4
000006  4604              MOV      r4,r0
000008  468b              MOV      r11,r1
00000a  461f              MOV      r7,r3
;;;3293     uint32_t tickstart = 0U, tmp1 = 0U, tmp2 = 0U, tmp3 = 0U, I2C_Trials = 1U;
00000c  2601              MOVS     r6,#1
;;;3294   
;;;3295     /* Get tick */
;;;3296     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;3297   
;;;3298     if(hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d003              BEQ      |L13.36|
;;;3299     {
;;;3300       /* Wait until BUSY flag is reset */
;;;3301       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3302       {
;;;3303         return HAL_BUSY;
;;;3304       }
;;;3305   
;;;3306       /* Process Locked */
;;;3307       __HAL_LOCK(hi2c);
;;;3308       
;;;3309       /* Check if the I2C is already enabled */
;;;3310       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3311       {
;;;3312         /* Enable I2C peripheral */
;;;3313         __HAL_I2C_ENABLE(hi2c);
;;;3314       }
;;;3315   
;;;3316       /* Disable Pos */
;;;3317       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;3318   
;;;3319       hi2c->State = HAL_I2C_STATE_BUSY;
;;;3320       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3321       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3322       
;;;3323       do
;;;3324       {
;;;3325         /* Generate Start */
;;;3326         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;3327   
;;;3328         /* Wait until SB flag is set */
;;;3329         if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
;;;3330         {
;;;3331           return HAL_TIMEOUT;
;;;3332         }
;;;3333   
;;;3334         /* Send slave address */
;;;3335         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;3336   
;;;3337         /* Wait until ADDR or AF flag are set */
;;;3338         /* Get tick */
;;;3339         tickstart = HAL_GetTick();
;;;3340   
;;;3341         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3342         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3343         tmp3 = hi2c->State;
;;;3344         while((tmp1 == RESET) && (tmp2 == RESET) && (tmp3 != HAL_I2C_STATE_TIMEOUT))
;;;3345         {
;;;3346           if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
;;;3347           {
;;;3348             hi2c->State = HAL_I2C_STATE_TIMEOUT;
;;;3349           }
;;;3350           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3351           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;3352           tmp3 = hi2c->State;
;;;3353         }
;;;3354   
;;;3355         hi2c->State = HAL_I2C_STATE_READY;
;;;3356   
;;;3357         /* Check if the ADDR flag has been set */
;;;3358         if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
;;;3359         {
;;;3360           /* Generate Stop */
;;;3361           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;3362   
;;;3363           /* Clear ADDR Flag */
;;;3364           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3365   
;;;3366           /* Wait until BUSY flag is reset */
;;;3367           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3368           {
;;;3369             return HAL_TIMEOUT;
;;;3370           }
;;;3371   
;;;3372           hi2c->State = HAL_I2C_STATE_READY;
;;;3373   
;;;3374           /* Process Unlocked */
;;;3375           __HAL_UNLOCK(hi2c);
;;;3376   
;;;3377           return HAL_OK;
;;;3378         }
;;;3379         else
;;;3380         {
;;;3381           /* Generate Stop */
;;;3382           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;3383   
;;;3384           /* Clear AF Flag */
;;;3385           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3386   
;;;3387           /* Wait until BUSY flag is reset */
;;;3388           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;3389           {
;;;3390             return HAL_TIMEOUT;
;;;3391           }
;;;3392         }
;;;3393       }while(I2C_Trials++ < Trials);
;;;3394   
;;;3395       hi2c->State = HAL_I2C_STATE_READY;
;;;3396   
;;;3397       /* Process Unlocked */
;;;3398       __HAL_UNLOCK(hi2c);
;;;3399   
;;;3400       return HAL_ERROR;
;;;3401     }
;;;3402     else
;;;3403     {
;;;3404       return HAL_BUSY;
00001c  2002              MOVS     r0,#2
                  |L13.30|
;;;3405     }
;;;3406   }
00001e  b005              ADD      sp,sp,#0x14
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.36|
000024  2319              MOVS     r3,#0x19              ;3301
000026  2201              MOVS     r2,#1                 ;3301
000028  494f              LDR      r1,|L13.360|
00002a  4620              MOV      r0,r4                 ;3301
00002c  9500              STR      r5,[sp,#0]            ;3301
00002e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000032  b108              CBZ      r0,|L13.56|
000034  2002              MOVS     r0,#2                 ;3303
000036  e7f2              B        |L13.30|
                  |L13.56|
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;3307
00003c  2801              CMP      r0,#1                 ;3307
00003e  d007              BEQ      |L13.80|
000040  2001              MOVS     r0,#1                 ;3307
000042  f884003c          STRB     r0,[r4,#0x3c]         ;3307
000046  6820              LDR      r0,[r4,#0]            ;3310
000048  6801              LDR      r1,[r0,#0]            ;3310
00004a  07c9              LSLS     r1,r1,#31             ;3310
00004c  d002              BEQ      |L13.84|
00004e  e005              B        |L13.92|
                  |L13.80|
000050  2002              MOVS     r0,#2                 ;3307
000052  e7e4              B        |L13.30|
                  |L13.84|
000054  6801              LDR      r1,[r0,#0]            ;3313
000056  f0410101          ORR      r1,r1,#1              ;3313
00005a  6001              STR      r1,[r0,#0]            ;3313
                  |L13.92|
00005c  6820              LDR      r0,[r4,#0]            ;3317
00005e  6801              LDR      r1,[r0,#0]            ;3317
000060  f4216100          BIC      r1,r1,#0x800          ;3317
000064  6001              STR      r1,[r0,#0]            ;3317
000066  2024              MOVS     r0,#0x24              ;3319
000068  f884003d          STRB     r0,[r4,#0x3d]         ;3319
00006c  f04f0a00          MOV      r10,#0                ;3320
000070  f8c4a040          STR      r10,[r4,#0x40]        ;3320
000074  483d              LDR      r0,|L13.364|
000076  62e0              STR      r0,[r4,#0x2c]         ;3321
000078  f04f0920          MOV      r9,#0x20              ;3355
                  |L13.124|
00007c  6820              LDR      r0,[r4,#0]            ;3326
00007e  6801              LDR      r1,[r0,#0]            ;3326
000080  f4417180          ORR      r1,r1,#0x100          ;3326
000084  6001              STR      r1,[r0,#0]            ;3326
000086  463b              MOV      r3,r7                 ;3329
000088  2200              MOVS     r2,#0                 ;3329
00008a  f04f1101          MOV      r1,#0x10001           ;3329
00008e  4620              MOV      r0,r4                 ;3329
000090  9500              STR      r5,[sp,#0]            ;3329
000092  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000096  b108              CBZ      r0,|L13.156|
000098  2003              MOVS     r0,#3                 ;3331
00009a  e7c0              B        |L13.30|
                  |L13.156|
00009c  6821              LDR      r1,[r4,#0]            ;3335
00009e  f00b00fe          AND      r0,r11,#0xfe          ;3335
0000a2  6108              STR      r0,[r1,#0x10]         ;3335
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  4605              MOV      r5,r0                 ;3339
0000aa  6820              LDR      r0,[r4,#0]            ;3341
0000ac  6941              LDR      r1,[r0,#0x14]         ;3341
0000ae  f3c10140          UBFX     r1,r1,#1,#1           ;3341
0000b2  6940              LDR      r0,[r0,#0x14]         ;3342
0000b4  f3c02080          UBFX     r0,r0,#10,#1          ;3342
0000b8  f894203d          LDRB     r2,[r4,#0x3d]         ;3343
0000bc  f04f08a0          MOV      r8,#0xa0              ;3348
0000c0  e010              B        |L13.228|
                  |L13.194|
0000c2  b127              CBZ      r7,|L13.206|
0000c4  f7fffffe          BL       HAL_GetTick
0000c8  1b40              SUBS     r0,r0,r5              ;3346
0000ca  42b8              CMP      r0,r7                 ;3346
0000cc  d901              BLS      |L13.210|
                  |L13.206|
0000ce  f884803d          STRB     r8,[r4,#0x3d]         ;3348
                  |L13.210|
0000d2  6820              LDR      r0,[r4,#0]            ;3350
0000d4  6941              LDR      r1,[r0,#0x14]         ;3350
0000d6  f3c10140          UBFX     r1,r1,#1,#1           ;3350
0000da  6940              LDR      r0,[r0,#0x14]         ;3351
0000dc  f3c02080          UBFX     r0,r0,#10,#1          ;3351
0000e0  f894203d          LDRB     r2,[r4,#0x3d]         ;3352
                  |L13.228|
0000e4  4301              ORRS     r1,r1,r0              ;3344
0000e6  d101              BNE      |L13.236|
0000e8  2aa0              CMP      r2,#0xa0              ;3344
0000ea  d1ea              BNE      |L13.194|
                  |L13.236|
0000ec  f884903d          STRB     r9,[r4,#0x3d]         ;3355
0000f0  6820              LDR      r0,[r4,#0]            ;3358
0000f2  6941              LDR      r1,[r0,#0x14]         ;3358
0000f4  43c9              MVNS     r1,r1                 ;3358
0000f6  0789              LSLS     r1,r1,#30             ;3358
0000f8  d418              BMI      |L13.300|
0000fa  6821              LDR      r1,[r4,#0]            ;3361
0000fc  6809              LDR      r1,[r1,#0]            ;3361
0000fe  f4417100          ORR      r1,r1,#0x200          ;3361
000102  6001              STR      r1,[r0,#0]            ;3361
000104  6820              LDR      r0,[r4,#0]            ;3364
000106  6941              LDR      r1,[r0,#0x14]         ;3364
000108  6980              LDR      r0,[r0,#0x18]         ;3364
00010a  9000              STR      r0,[sp,#0]            ;3364
00010c  2319              MOVS     r3,#0x19              ;3367
00010e  2201              MOVS     r2,#1                 ;3367
000110  4915              LDR      r1,|L13.360|
000112  4620              MOV      r0,r4                 ;3367
000114  9500              STR      r5,[sp,#0]            ;3367
000116  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00011a  b108              CBZ      r0,|L13.288|
00011c  2003              MOVS     r0,#3                 ;3369
00011e  e77e              B        |L13.30|
                  |L13.288|
000120  f884903d          STRB     r9,[r4,#0x3d]         ;3372
000124  f884a03c          STRB     r10,[r4,#0x3c]        ;3375
000128  2000              MOVS     r0,#0                 ;3377
00012a  e778              B        |L13.30|
                  |L13.300|
00012c  6801              LDR      r1,[r0,#0]            ;3382
00012e  f4417100          ORR      r1,r1,#0x200          ;3382
000132  6001              STR      r1,[r0,#0]            ;3382
000134  6821              LDR      r1,[r4,#0]            ;3385
000136  f46f6080          MVN      r0,#0x400             ;3385
00013a  6148              STR      r0,[r1,#0x14]         ;3385
00013c  2319              MOVS     r3,#0x19              ;3388
00013e  2201              MOVS     r2,#1                 ;3388
000140  4909              LDR      r1,|L13.360|
000142  4620              MOV      r0,r4                 ;3388
000144  9500              STR      r5,[sp,#0]            ;3388
000146  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00014a  b108              CBZ      r0,|L13.336|
00014c  2003              MOVS     r0,#3                 ;3390
00014e  e766              B        |L13.30|
                  |L13.336|
000150  4630              MOV      r0,r6                 ;3393
000152  9903              LDR      r1,[sp,#0xc]          ;3393
000154  1c76              ADDS     r6,r6,#1              ;3393
000156  4288              CMP      r0,r1                 ;3393
000158  d390              BCC      |L13.124|
00015a  f884903d          STRB     r9,[r4,#0x3d]         ;3395
00015e  f884a03c          STRB     r10,[r4,#0x3c]        ;3398
000162  2001              MOVS     r0,#1                 ;3400
000164  e75b              B        |L13.30|
;;;3407   
                          ENDP

000166  0000              DCW      0x0000
                  |L13.360|
                          DCD      0x00100002
                  |L13.364|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;3679     */
;;;3680   __WEAK void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3681   {
;;;3682     /* Prevent unused argument(s) compilation warning */
;;;3683     UNUSED(hi2c);
;;;3684   
;;;3685       /* NOTE : This function should not be modified, when the callback is needed,
;;;3686               the HAL_I2C_ListenCpltCallback can be implemented in the user file
;;;3687      */
;;;3688   }
;;;3689   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;3612     */
;;;3613   __WEAK void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3614   {
;;;3615     /* Prevent unused argument(s) compilation warning */
;;;3616     UNUSED(hi2c);
;;;3617   
;;;3618     /* NOTE : This function should not be modified, when the callback is needed,
;;;3619               the HAL_I2C_MasterRxCpltCallback can be implemented in the user file
;;;3620      */
;;;3621   }
;;;3622   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;3596     */
;;;3597   __WEAK void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3598   {
;;;3599     /* Prevent unused argument(s) compilation warning */
;;;3600     UNUSED(hi2c);
;;;3601   
;;;3602     /* NOTE : This function should not be modified, when the callback is needed,
;;;3603               the HAL_I2C_MasterTxCpltCallback can be implemented in the user file
;;;3604      */
;;;3605   }
;;;3606   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Master_Abort_IT PROC
;;;2197     */
;;;2198   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b510              PUSH     {r4,lr}
;;;2199   {
;;;2200     /* Prevent unused argument(s) compilation warning */
;;;2201     UNUSED(DevAddress);
;;;2202   
;;;2203     /* Abort Master transfer during Receive or Transmit process    */
;;;2204     if(hi2c->Mode == HAL_I2C_MODE_MASTER)
000002  f890103e          LDRB     r1,[r0,#0x3e]
000006  2910              CMP      r1,#0x10
000008  d001              BEQ      |L17.14|
;;;2205     {
;;;2206       /* Process Locked */
;;;2207       __HAL_LOCK(hi2c);
;;;2208   
;;;2209       hi2c->PreviousState = I2C_STATE_NONE;
;;;2210       hi2c->State = HAL_I2C_STATE_ABORT;
;;;2211   
;;;2212       /* Disable Acknowledge */
;;;2213       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;2214   
;;;2215       /* Generate Stop */
;;;2216       hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2217   
;;;2218       hi2c->XferCount = 0U;
;;;2219   
;;;2220       /* Disable EVT, BUF and ERR interrupt */
;;;2221       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2222   
;;;2223       /* Process Unlocked */
;;;2224       __HAL_UNLOCK(hi2c);
;;;2225   
;;;2226       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;2227       I2C_ITError(hi2c);
;;;2228   
;;;2229       return HAL_OK;
;;;2230     }
;;;2231     else
;;;2232     {
;;;2233       /* Wrong usage of abort function */
;;;2234       /* This function should be used only in case of abort monitored by master device */
;;;2235       return HAL_ERROR;
00000a  2001              MOVS     r0,#1
;;;2236     }
;;;2237   }
00000c  bd10              POP      {r4,pc}
                  |L17.14|
00000e  f890103c          LDRB     r1,[r0,#0x3c]         ;2207
000012  2901              CMP      r1,#1                 ;2207
000014  d01d              BEQ      |L17.82|
000016  2101              MOVS     r1,#1                 ;2207
000018  f880103c          STRB     r1,[r0,#0x3c]         ;2207
00001c  2200              MOVS     r2,#0                 ;2209
00001e  6302              STR      r2,[r0,#0x30]         ;2209
000020  2160              MOVS     r1,#0x60              ;2210
000022  f880103d          STRB     r1,[r0,#0x3d]         ;2210
000026  6801              LDR      r1,[r0,#0]            ;2213
000028  680b              LDR      r3,[r1,#0]            ;2213
00002a  f4236380          BIC      r3,r3,#0x400          ;2213
00002e  600b              STR      r3,[r1,#0]            ;2213
000030  6801              LDR      r1,[r0,#0]            ;2216
000032  680b              LDR      r3,[r1,#0]            ;2216
000034  f4437300          ORR      r3,r3,#0x200          ;2216
000038  600b              STR      r3,[r1,#0]            ;2216
00003a  8542              STRH     r2,[r0,#0x2a]         ;2218
00003c  6801              LDR      r1,[r0,#0]            ;2221
00003e  684b              LDR      r3,[r1,#4]            ;2221
000040  f42363e0          BIC      r3,r3,#0x700          ;2221
000044  604b              STR      r3,[r1,#4]            ;2221
000046  f880203c          STRB     r2,[r0,#0x3c]         ;2224
00004a  f7fffffe          BL       I2C_ITError
00004e  2000              MOVS     r0,#0                 ;2229
000050  bd10              POP      {r4,pc}
                  |L17.82|
000052  2002              MOVS     r0,#2                 ;2207
000054  bd10              POP      {r4,pc}
;;;2238   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;723      */
;;;724    HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;725    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;726      uint32_t tickstart = 0x00U;
;;;727    
;;;728      /* Init tickstart for timeout management*/
;;;729      tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
;;;730    
;;;731      if(hi2c->State == HAL_I2C_STATE_READY)
000016  f894003d          LDRB     r0,[r4,#0x3d]
00001a  2820              CMP      r0,#0x20
00001c  d002              BEQ      |L18.36|
;;;732      {
;;;733        /* Wait until BUSY flag is reset */
;;;734        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;735        {
;;;736          return HAL_BUSY;
;;;737        }
;;;738    
;;;739        /* Process Locked */
;;;740        __HAL_LOCK(hi2c);
;;;741    
;;;742        /* Check if the I2C is already enabled */
;;;743        if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;744        {
;;;745          /* Enable I2C peripheral */
;;;746          __HAL_I2C_ENABLE(hi2c);
;;;747        }
;;;748    
;;;749        /* Disable Pos */
;;;750        hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;751    
;;;752        hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;753        hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;754        hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;755    
;;;756        /* Prepare transfer parameters */
;;;757        hi2c->pBuffPtr    = pData;
;;;758        hi2c->XferCount   = Size;
;;;759        hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;760        hi2c->XferSize    = hi2c->XferCount;
;;;761    
;;;762        /* Send Slave Address */
;;;763        if(I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;764        {
;;;765          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;766          {
;;;767            /* Process Unlocked */
;;;768            __HAL_UNLOCK(hi2c);
;;;769            return HAL_ERROR;
;;;770          }
;;;771          else
;;;772          {
;;;773            /* Process Unlocked */
;;;774            __HAL_UNLOCK(hi2c);
;;;775            return HAL_TIMEOUT;
;;;776          }
;;;777        }
;;;778    
;;;779        if(hi2c->XferSize == 0U)
;;;780        {
;;;781          /* Clear ADDR flag */
;;;782          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;783    
;;;784          /* Generate Stop */
;;;785          hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;786        }
;;;787        else if(hi2c->XferSize == 1U)
;;;788        {
;;;789          /* Disable Acknowledge */
;;;790          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;791    
;;;792          /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;793          software sequence must complete before the current byte end of transfer */
;;;794          __disable_irq();
;;;795    
;;;796          /* Clear ADDR flag */
;;;797          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;798    
;;;799          /* Generate Stop */
;;;800          hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;801    
;;;802          /* Re-enable IRQs */
;;;803          __enable_irq(); 
;;;804        }
;;;805        else if(hi2c->XferSize == 2U)
;;;806        {
;;;807          /* Enable Pos */
;;;808          hi2c->Instance->CR1 |= I2C_CR1_POS;
;;;809    
;;;810          /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;811          software sequence must complete before the current byte end of transfer */
;;;812          __disable_irq();
;;;813    
;;;814          /* Clear ADDR flag */
;;;815          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;816    
;;;817          /* Disable Acknowledge */
;;;818          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;819    
;;;820          /* Re-enable IRQs */
;;;821          __enable_irq(); 
;;;822        }
;;;823        else
;;;824        {
;;;825          /* Enable Acknowledge */
;;;826          hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;827    
;;;828          /* Clear ADDR flag */
;;;829          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;830        }
;;;831    
;;;832        while(hi2c->XferSize > 0U)
;;;833        {
;;;834          if(hi2c->XferSize <= 3U)
;;;835          {
;;;836            /* One byte */
;;;837            if(hi2c->XferSize == 1U)
;;;838            {
;;;839              /* Wait until RXNE flag is set */
;;;840              if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
;;;841              {
;;;842                if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;843                {
;;;844                  return HAL_TIMEOUT;
;;;845                }
;;;846                else
;;;847                {
;;;848                  return HAL_ERROR;
;;;849                }
;;;850              }
;;;851    
;;;852              /* Read data from DR */
;;;853              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;854              hi2c->XferSize--;
;;;855              hi2c->XferCount--;
;;;856            }
;;;857            /* Two bytes */
;;;858            else if(hi2c->XferSize == 2U)
;;;859            {
;;;860              /* Wait until BTF flag is set */
;;;861              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;862              {
;;;863                return HAL_TIMEOUT;
;;;864              }
;;;865    
;;;866              /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;867                 software sequence must complete before the current byte end of transfer */
;;;868               __disable_irq();
;;;869    
;;;870              /* Generate Stop */
;;;871              hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;872    
;;;873              /* Read data from DR */
;;;874              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;875              hi2c->XferSize--;
;;;876              hi2c->XferCount--;
;;;877    
;;;878              /* Re-enable IRQs */
;;;879              __enable_irq();
;;;880    
;;;881              /* Read data from DR */
;;;882              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;883              hi2c->XferSize--;
;;;884              hi2c->XferCount--;
;;;885            }
;;;886            /* 3 Last bytes */
;;;887            else
;;;888            {
;;;889              /* Wait until BTF flag is set */
;;;890              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;891              {
;;;892                return HAL_TIMEOUT;
;;;893              }
;;;894    
;;;895              /* Disable Acknowledge */
;;;896              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;897    
;;;898              /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;899                 software sequence must complete before the current byte end of transfer */
;;;900              __disable_irq();
;;;901    
;;;902              /* Read data from DR */
;;;903              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;904              hi2c->XferSize--;
;;;905              hi2c->XferCount--;
;;;906    
;;;907              /* Wait until BTF flag is set */
;;;908              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;909              {
;;;910                return HAL_TIMEOUT;
;;;911              }
;;;912    
;;;913              /* Generate Stop */
;;;914              hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;915    
;;;916              /* Read data from DR */
;;;917              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;918              hi2c->XferSize--;
;;;919              hi2c->XferCount--;
;;;920    
;;;921              /* Re-enable IRQs */
;;;922              __enable_irq(); 
;;;923    
;;;924              /* Read data from DR */
;;;925              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;926              hi2c->XferSize--;
;;;927              hi2c->XferCount--;
;;;928            }
;;;929          }
;;;930          else
;;;931          {
;;;932            /* Wait until RXNE flag is set */
;;;933            if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
;;;934            {
;;;935              if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;936              {
;;;937                return HAL_TIMEOUT;
;;;938              }
;;;939              else
;;;940              {
;;;941                return HAL_ERROR;
;;;942              }
;;;943            }
;;;944    
;;;945            /* Read data from DR */
;;;946            (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;947            hi2c->XferSize--;
;;;948            hi2c->XferCount--;
;;;949    
;;;950            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;951            {
;;;952              /* Read data from DR */
;;;953              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;954              hi2c->XferSize--;
;;;955              hi2c->XferCount--;
;;;956            }
;;;957          }
;;;958        }
;;;959    
;;;960        hi2c->State = HAL_I2C_STATE_READY;
;;;961        hi2c->Mode = HAL_I2C_MODE_NONE;
;;;962    
;;;963        /* Process Unlocked */
;;;964        __HAL_UNLOCK(hi2c);
;;;965    
;;;966        return HAL_OK;
;;;967      }
;;;968      else
;;;969      {
;;;970        return HAL_BUSY;
00001e  2002              MOVS     r0,#2
                  |L18.32|
;;;971      }
;;;972    }
000020  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.36|
000024  2319              MOVS     r3,#0x19              ;734
000026  2201              MOVS     r2,#1                 ;734
000028  499f              LDR      r1,|L18.680|
00002a  4620              MOV      r0,r4                 ;734
00002c  9500              STR      r5,[sp,#0]            ;734
00002e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000032  b108              CBZ      r0,|L18.56|
000034  2002              MOVS     r0,#2                 ;736
000036  e7f3              B        |L18.32|
                  |L18.56|
000038  f894003c          LDRB     r0,[r4,#0x3c]         ;740
00003c  2801              CMP      r0,#1                 ;740
00003e  d007              BEQ      |L18.80|
000040  2001              MOVS     r0,#1                 ;740
000042  f884003c          STRB     r0,[r4,#0x3c]         ;740
000046  6820              LDR      r0,[r4,#0]            ;743
000048  6801              LDR      r1,[r0,#0]            ;743
00004a  07c9              LSLS     r1,r1,#31             ;743
00004c  d002              BEQ      |L18.84|
00004e  e005              B        |L18.92|
                  |L18.80|
000050  2002              MOVS     r0,#2                 ;740
000052  e7e5              B        |L18.32|
                  |L18.84|
000054  6801              LDR      r1,[r0,#0]            ;746
000056  f0410101          ORR      r1,r1,#1              ;746
00005a  6001              STR      r1,[r0,#0]            ;746
                  |L18.92|
00005c  6820              LDR      r0,[r4,#0]            ;750
00005e  6801              LDR      r1,[r0,#0]            ;750
000060  f4216100          BIC      r1,r1,#0x800          ;750
000064  6001              STR      r1,[r0,#0]            ;750
000066  2022              MOVS     r0,#0x22              ;752
000068  f884003d          STRB     r0,[r4,#0x3d]         ;752
00006c  2010              MOVS     r0,#0x10              ;753
00006e  f884003e          STRB     r0,[r4,#0x3e]         ;753
000072  2600              MOVS     r6,#0                 ;754
000074  6426              STR      r6,[r4,#0x40]         ;754
000076  6267              STR      r7,[r4,#0x24]         ;757
000078  f8a4902a          STRH     r9,[r4,#0x2a]         ;758
00007c  488b              LDR      r0,|L18.684|
00007e  62e0              STR      r0,[r4,#0x2c]         ;759
000080  8d60              LDRH     r0,[r4,#0x2a]         ;760
000082  8520              STRH     r0,[r4,#0x28]         ;760
000084  462b              MOV      r3,r5                 ;763
000086  4642              MOV      r2,r8                 ;763
000088  4651              MOV      r1,r10                ;763
00008a  4620              MOV      r0,r4                 ;763
00008c  f7fffffe          BL       I2C_MasterRequestRead
000090  b150              CBZ      r0,|L18.168|
000092  6c20              LDR      r0,[r4,#0x40]         ;765
000094  2804              CMP      r0,#4                 ;765
000096  d003              BEQ      |L18.160|
000098  f884603c          STRB     r6,[r4,#0x3c]         ;774
00009c  2003              MOVS     r0,#3                 ;775
00009e  e7bf              B        |L18.32|
                  |L18.160|
0000a0  f884603c          STRB     r6,[r4,#0x3c]         ;768
0000a4  2001              MOVS     r0,#1                 ;769
0000a6  e7bb              B        |L18.32|
                  |L18.168|
0000a8  8d20              LDRH     r0,[r4,#0x28]         ;779
0000aa  b170              CBZ      r0,|L18.202|
0000ac  2801              CMP      r0,#1                 ;787
0000ae  d015              BEQ      |L18.220|
0000b0  2802              CMP      r0,#2                 ;805
0000b2  d023              BEQ      |L18.252|
0000b4  6820              LDR      r0,[r4,#0]            ;826
0000b6  6801              LDR      r1,[r0,#0]            ;826
0000b8  f4416180          ORR      r1,r1,#0x400          ;826
0000bc  6001              STR      r1,[r0,#0]            ;826
0000be  6820              LDR      r0,[r4,#0]            ;829
0000c0  6941              LDR      r1,[r0,#0x14]         ;829
0000c2  6980              LDR      r0,[r0,#0x18]         ;829
0000c4  9000              STR      r0,[sp,#0]            ;829
                  |L18.198|
0000c6  4f7a              LDR      r7,|L18.688|
0000c8  e0e3              B        |L18.658|
                  |L18.202|
0000ca  6820              LDR      r0,[r4,#0]            ;782
0000cc  6941              LDR      r1,[r0,#0x14]         ;782
0000ce  6981              LDR      r1,[r0,#0x18]         ;782
0000d0  9100              STR      r1,[sp,#0]            ;782
0000d2  6801              LDR      r1,[r0,#0]            ;785
0000d4  f4417100          ORR      r1,r1,#0x200          ;785
0000d8  6001              STR      r1,[r0,#0]            ;785
0000da  e7f4              B        |L18.198|
                  |L18.220|
0000dc  6820              LDR      r0,[r4,#0]            ;790
0000de  6801              LDR      r1,[r0,#0]            ;790
0000e0  f4216180          BIC      r1,r1,#0x400          ;790
0000e4  6001              STR      r1,[r0,#0]            ;790
0000e6  b672              CPSID    i                     ;794
0000e8  6820              LDR      r0,[r4,#0]            ;797
0000ea  6941              LDR      r1,[r0,#0x14]         ;797
0000ec  6981              LDR      r1,[r0,#0x18]         ;797
0000ee  9100              STR      r1,[sp,#0]            ;797
0000f0  6801              LDR      r1,[r0,#0]            ;800
0000f2  f4417100          ORR      r1,r1,#0x200          ;800
0000f6  6001              STR      r1,[r0,#0]            ;800
0000f8  b662              CPSIE    i                     ;803
0000fa  e7e4              B        |L18.198|
                  |L18.252|
0000fc  6820              LDR      r0,[r4,#0]            ;808
0000fe  6801              LDR      r1,[r0,#0]            ;808
000100  f4416100          ORR      r1,r1,#0x800          ;808
000104  6001              STR      r1,[r0,#0]            ;808
000106  b672              CPSID    i                     ;812
000108  6820              LDR      r0,[r4,#0]            ;815
00010a  6941              LDR      r1,[r0,#0x14]         ;815
00010c  6981              LDR      r1,[r0,#0x18]         ;815
00010e  9100              STR      r1,[sp,#0]            ;815
000110  6801              LDR      r1,[r0,#0]            ;818
000112  f4216180          BIC      r1,r1,#0x400          ;818
000116  6001              STR      r1,[r0,#0]            ;818
000118  b662              CPSIE    i                     ;821
00011a  e7d4              B        |L18.198|
                  |L18.284|
00011c  2803              CMP      r0,#3                 ;834
00011e  d86f              BHI      |L18.512|
000120  2801              CMP      r0,#1                 ;837
000122  d00b              BEQ      |L18.316|
000124  2802              CMP      r0,#2                 ;858
000126  d023              BEQ      |L18.368|
000128  4643              MOV      r3,r8                 ;890
00012a  2200              MOVS     r2,#0                 ;890
00012c  4639              MOV      r1,r7                 ;890
00012e  4620              MOV      r0,r4                 ;890
000130  9500              STR      r5,[sp,#0]            ;890
000132  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000136  b3e8              CBZ      r0,|L18.436|
000138  2003              MOVS     r0,#3                 ;892
00013a  e771              B        |L18.32|
                  |L18.316|
00013c  462a              MOV      r2,r5                 ;840
00013e  4641              MOV      r1,r8                 ;840
000140  4620              MOV      r0,r4                 ;840
000142  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000146  b130              CBZ      r0,|L18.342|
000148  6c20              LDR      r0,[r4,#0x40]         ;842
00014a  2820              CMP      r0,#0x20              ;842
00014c  d001              BEQ      |L18.338|
00014e  2001              MOVS     r0,#1                 ;848
000150  e766              B        |L18.32|
                  |L18.338|
000152  2003              MOVS     r0,#3                 ;844
000154  e764              B        |L18.32|
                  |L18.342|
000156  6820              LDR      r0,[r4,#0]            ;853
000158  6901              LDR      r1,[r0,#0x10]         ;853
00015a  6a60              LDR      r0,[r4,#0x24]         ;853
00015c  1c42              ADDS     r2,r0,#1              ;853
00015e  6262              STR      r2,[r4,#0x24]         ;853
000160  7001              STRB     r1,[r0,#0]            ;853
000162  8d20              LDRH     r0,[r4,#0x28]         ;854
000164  1e40              SUBS     r0,r0,#1              ;854
000166  8520              STRH     r0,[r4,#0x28]         ;854
000168  8d60              LDRH     r0,[r4,#0x2a]         ;855
00016a  1e40              SUBS     r0,r0,#1              ;855
00016c  8560              STRH     r0,[r4,#0x2a]         ;855
00016e  e090              B        |L18.658|
                  |L18.368|
000170  4643              MOV      r3,r8                 ;861
000172  2200              MOVS     r2,#0                 ;861
000174  4639              MOV      r1,r7                 ;861
000176  4620              MOV      r0,r4                 ;861
000178  9500              STR      r5,[sp,#0]            ;861
00017a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00017e  b108              CBZ      r0,|L18.388|
000180  2003              MOVS     r0,#3                 ;863
000182  e74d              B        |L18.32|
                  |L18.388|
000184  b672              CPSID    i                     ;868
000186  6820              LDR      r0,[r4,#0]            ;871
000188  6801              LDR      r1,[r0,#0]            ;871
00018a  f4417100          ORR      r1,r1,#0x200          ;871
00018e  6001              STR      r1,[r0,#0]            ;871
000190  6820              LDR      r0,[r4,#0]            ;874
000192  6901              LDR      r1,[r0,#0x10]         ;874
000194  6a60              LDR      r0,[r4,#0x24]         ;874
000196  1c42              ADDS     r2,r0,#1              ;874
000198  6262              STR      r2,[r4,#0x24]         ;874
00019a  7001              STRB     r1,[r0,#0]            ;874
00019c  8d20              LDRH     r0,[r4,#0x28]         ;875
00019e  1e40              SUBS     r0,r0,#1              ;875
0001a0  8520              STRH     r0,[r4,#0x28]         ;875
0001a2  8d60              LDRH     r0,[r4,#0x2a]         ;876
0001a4  1e40              SUBS     r0,r0,#1              ;876
0001a6  8560              STRH     r0,[r4,#0x2a]         ;876
0001a8  b662              CPSIE    i                     ;879
0001aa  6820              LDR      r0,[r4,#0]            ;882
0001ac  6901              LDR      r1,[r0,#0x10]         ;882
0001ae  6a60              LDR      r0,[r4,#0x24]         ;882
0001b0  1c42              ADDS     r2,r0,#1              ;882
0001b2  e000              B        |L18.438|
                  |L18.436|
0001b4  e008              B        |L18.456|
                  |L18.438|
0001b6  6262              STR      r2,[r4,#0x24]         ;882
0001b8  7001              STRB     r1,[r0,#0]            ;882
0001ba  8d20              LDRH     r0,[r4,#0x28]         ;883
0001bc  1e40              SUBS     r0,r0,#1              ;883
0001be  8520              STRH     r0,[r4,#0x28]         ;883
0001c0  8d60              LDRH     r0,[r4,#0x2a]         ;884
0001c2  1e40              SUBS     r0,r0,#1              ;884
0001c4  8560              STRH     r0,[r4,#0x2a]         ;884
0001c6  e064              B        |L18.658|
                  |L18.456|
0001c8  6820              LDR      r0,[r4,#0]            ;896
0001ca  6801              LDR      r1,[r0,#0]            ;896
0001cc  f4216180          BIC      r1,r1,#0x400          ;896
0001d0  6001              STR      r1,[r0,#0]            ;896
0001d2  b672              CPSID    i                     ;900
0001d4  6820              LDR      r0,[r4,#0]            ;903
0001d6  6901              LDR      r1,[r0,#0x10]         ;903
0001d8  6a60              LDR      r0,[r4,#0x24]         ;903
0001da  1c42              ADDS     r2,r0,#1              ;903
0001dc  6262              STR      r2,[r4,#0x24]         ;903
0001de  7001              STRB     r1,[r0,#0]            ;903
0001e0  8d20              LDRH     r0,[r4,#0x28]         ;904
0001e2  1e40              SUBS     r0,r0,#1              ;904
0001e4  8520              STRH     r0,[r4,#0x28]         ;904
0001e6  8d60              LDRH     r0,[r4,#0x2a]         ;905
0001e8  1e40              SUBS     r0,r0,#1              ;905
0001ea  8560              STRH     r0,[r4,#0x2a]         ;905
0001ec  4643              MOV      r3,r8                 ;908
0001ee  2200              MOVS     r2,#0                 ;908
0001f0  4639              MOV      r1,r7                 ;908
0001f2  4620              MOV      r0,r4                 ;908
0001f4  9500              STR      r5,[sp,#0]            ;908
0001f6  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0001fa  b110              CBZ      r0,|L18.514|
0001fc  2003              MOVS     r0,#3                 ;910
0001fe  e70f              B        |L18.32|
                  |L18.512|
000200  e01e              B        |L18.576|
                  |L18.514|
000202  6820              LDR      r0,[r4,#0]            ;914
000204  6801              LDR      r1,[r0,#0]            ;914
000206  f4417100          ORR      r1,r1,#0x200          ;914
00020a  6001              STR      r1,[r0,#0]            ;914
00020c  6820              LDR      r0,[r4,#0]            ;917
00020e  6901              LDR      r1,[r0,#0x10]         ;917
000210  6a60              LDR      r0,[r4,#0x24]         ;917
000212  1c42              ADDS     r2,r0,#1              ;917
000214  6262              STR      r2,[r4,#0x24]         ;917
000216  7001              STRB     r1,[r0,#0]            ;917
000218  8d20              LDRH     r0,[r4,#0x28]         ;918
00021a  1e40              SUBS     r0,r0,#1              ;918
00021c  8520              STRH     r0,[r4,#0x28]         ;918
00021e  8d60              LDRH     r0,[r4,#0x2a]         ;919
000220  1e40              SUBS     r0,r0,#1              ;919
000222  8560              STRH     r0,[r4,#0x2a]         ;919
000224  b662              CPSIE    i                     ;922
000226  6820              LDR      r0,[r4,#0]            ;925
000228  6901              LDR      r1,[r0,#0x10]         ;925
00022a  6a60              LDR      r0,[r4,#0x24]         ;925
00022c  1c42              ADDS     r2,r0,#1              ;925
00022e  6262              STR      r2,[r4,#0x24]         ;925
000230  7001              STRB     r1,[r0,#0]            ;925
000232  8d20              LDRH     r0,[r4,#0x28]         ;926
000234  1e40              SUBS     r0,r0,#1              ;926
000236  8520              STRH     r0,[r4,#0x28]         ;926
000238  8d60              LDRH     r0,[r4,#0x2a]         ;927
00023a  1e40              SUBS     r0,r0,#1              ;927
00023c  8560              STRH     r0,[r4,#0x2a]         ;927
00023e  e028              B        |L18.658|
                  |L18.576|
000240  462a              MOV      r2,r5                 ;933
000242  4641              MOV      r1,r8                 ;933
000244  4620              MOV      r0,r4                 ;933
000246  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00024a  b130              CBZ      r0,|L18.602|
00024c  6c20              LDR      r0,[r4,#0x40]         ;935
00024e  2820              CMP      r0,#0x20              ;935
000250  d001              BEQ      |L18.598|
000252  2001              MOVS     r0,#1                 ;941
000254  e6e4              B        |L18.32|
                  |L18.598|
000256  2003              MOVS     r0,#3                 ;937
000258  e6e2              B        |L18.32|
                  |L18.602|
00025a  6820              LDR      r0,[r4,#0]            ;946
00025c  6901              LDR      r1,[r0,#0x10]         ;946
00025e  6a60              LDR      r0,[r4,#0x24]         ;946
000260  1c42              ADDS     r2,r0,#1              ;946
000262  6262              STR      r2,[r4,#0x24]         ;946
000264  7001              STRB     r1,[r0,#0]            ;946
000266  8d20              LDRH     r0,[r4,#0x28]         ;947
000268  1e40              SUBS     r0,r0,#1              ;947
00026a  8520              STRH     r0,[r4,#0x28]         ;947
00026c  8d60              LDRH     r0,[r4,#0x2a]         ;948
00026e  1e40              SUBS     r0,r0,#1              ;948
000270  8560              STRH     r0,[r4,#0x2a]         ;948
000272  6820              LDR      r0,[r4,#0]            ;950
000274  6941              LDR      r1,[r0,#0x14]         ;950
000276  43c9              MVNS     r1,r1                 ;950
000278  0749              LSLS     r1,r1,#29             ;950
00027a  d40a              BMI      |L18.658|
00027c  6901              LDR      r1,[r0,#0x10]         ;953
00027e  6a60              LDR      r0,[r4,#0x24]         ;953
000280  1c42              ADDS     r2,r0,#1              ;953
000282  6262              STR      r2,[r4,#0x24]         ;953
000284  7001              STRB     r1,[r0,#0]            ;953
000286  8d20              LDRH     r0,[r4,#0x28]         ;954
000288  1e40              SUBS     r0,r0,#1              ;954
00028a  8520              STRH     r0,[r4,#0x28]         ;954
00028c  8d60              LDRH     r0,[r4,#0x2a]         ;955
00028e  1e40              SUBS     r0,r0,#1              ;955
000290  8560              STRH     r0,[r4,#0x2a]         ;955
                  |L18.658|
000292  8d20              LDRH     r0,[r4,#0x28]         ;832
000294  2800              CMP      r0,#0                 ;832
000296  f47faf41          BNE      |L18.284|
00029a  2020              MOVS     r0,#0x20              ;960
00029c  343c              ADDS     r4,r4,#0x3c           ;960
00029e  7060              STRB     r0,[r4,#1]            ;960
0002a0  70a6              STRB     r6,[r4,#2]            ;961
0002a2  7026              STRB     r6,[r4,#0]            ;964
0002a4  2000              MOVS     r0,#0                 ;966
0002a6  e6bb              B        |L18.32|
;;;973    
                          ENDP

                  |L18.680|
                          DCD      0x00100002
                  |L18.684|
                          DCD      0xffff0000
                  |L18.688|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;2080     */
;;;2081   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2082   {
000002  4604              MOV      r4,r0
;;;2083     __IO uint32_t count = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;2084   
;;;2085     if(hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d001              BEQ      |L19.20|
;;;2086     {
;;;2087       /* Wait until BUSY flag is reset */
;;;2088       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;2089       do
;;;2090       {
;;;2091         if(count-- == 0U)
;;;2092         {
;;;2093           hi2c->PreviousState = I2C_STATE_NONE;
;;;2094           hi2c->State= HAL_I2C_STATE_READY;
;;;2095   
;;;2096           /* Process Unlocked */
;;;2097           __HAL_UNLOCK(hi2c);
;;;2098   
;;;2099           return HAL_TIMEOUT; 
;;;2100         }
;;;2101       }
;;;2102       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2103   
;;;2104       /* Process Locked */
;;;2105       __HAL_LOCK(hi2c);
;;;2106       
;;;2107       /* Check if the I2C is already enabled */
;;;2108       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2109       {
;;;2110         /* Enable I2C peripheral */
;;;2111         __HAL_I2C_ENABLE(hi2c);
;;;2112       }
;;;2113   
;;;2114       /* Disable Pos */
;;;2115       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2116       
;;;2117       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2118       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2119       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2120       
;;;2121       /* Prepare transfer parameters */
;;;2122       hi2c->pBuffPtr    = pData;
;;;2123       hi2c->XferCount   = Size;
;;;2124       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2125       hi2c->XferSize    = hi2c->XferCount;
;;;2126       hi2c->Devaddress  = DevAddress;
;;;2127       
;;;2128       if(hi2c->XferSize > 0U)
;;;2129       {
;;;2130         /* Set the I2C DMA transfer complete callback */
;;;2131         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2132   
;;;2133         /* Set the DMA error callback */
;;;2134         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2135   
;;;2136         /* Set the unused DMA callbacks to NULL */
;;;2137         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2138         hi2c->hdmarx->XferAbortCallback = NULL;
;;;2139   
;;;2140         /* Enable the DMA channel */
;;;2141         HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2142   
;;;2143         /* Enable Acknowledge */
;;;2144         hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2145   
;;;2146         /* Generate Start */
;;;2147         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2148   
;;;2149         /* Process Unlocked */
;;;2150         __HAL_UNLOCK(hi2c);
;;;2151   
;;;2152         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2153                   to avoid the risk of I2C interrupt handle execution before current
;;;2154                   process unlock */
;;;2155   
;;;2156         /* Enable EVT and ERR interrupt */
;;;2157         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2158   
;;;2159         /* Enable DMA Request */
;;;2160         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2161       }
;;;2162       else
;;;2163       {
;;;2164         /* Enable Acknowledge */
;;;2165         hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2166   
;;;2167         /* Generate Start */
;;;2168         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2169   
;;;2170         /* Process Unlocked */
;;;2171         __HAL_UNLOCK(hi2c);
;;;2172   
;;;2173         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2174         to avoid the risk of I2C interrupt handle execution before current
;;;2175         process unlock */
;;;2176   
;;;2177         /* Enable EVT, BUF and ERR interrupt */
;;;2178         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2179       }
;;;2180       
;;;2181       return HAL_OK;
;;;2182     }
;;;2183     else
;;;2184     {
;;;2185       return HAL_BUSY;
000010  2002              MOVS     r0,#2
;;;2186     }
;;;2187   }
000012  bdf8              POP      {r3-r7,pc}
                  |L19.20|
000014  483e              LDR      r0,|L19.272|
000016  f24615a8          MOV      r5,#0x61a8            ;2088
00001a  6800              LDR      r0,[r0,#0]            ;2088  ; SystemCoreClock
00001c  fbb0f0f5          UDIV     r0,r0,r5              ;2088
000020  eb0005c0          ADD      r5,r0,r0,LSL #3       ;2088
000024  eb051000          ADD      r0,r5,r0,LSL #4       ;2088
000028  9000              STR      r0,[sp,#0]            ;2088
                  |L19.42|
00002a  9800              LDR      r0,[sp,#0]            ;2091
00002c  1e45              SUBS     r5,r0,#1              ;2091
00002e  9500              STR      r5,[sp,#0]            ;2091
000030  d206              BCS      |L19.64|
000032  f8446f30          STR      r6,[r4,#0x30]!        ;2093
000036  2020              MOVS     r0,#0x20              ;2094
000038  7360              STRB     r0,[r4,#0xd]          ;2094
00003a  7326              STRB     r6,[r4,#0xc]          ;2097
00003c  2003              MOVS     r0,#3                 ;2099
00003e  bdf8              POP      {r3-r7,pc}
                  |L19.64|
000040  6820              LDR      r0,[r4,#0]            ;2102
000042  6980              LDR      r0,[r0,#0x18]         ;2102
000044  43c0              MVNS     r0,r0                 ;2102
000046  0780              LSLS     r0,r0,#30             ;2102
000048  d5ef              BPL      |L19.42|
00004a  f894003c          LDRB     r0,[r4,#0x3c]         ;2105
00004e  2801              CMP      r0,#1                 ;2105
000050  d007              BEQ      |L19.98|
000052  2001              MOVS     r0,#1                 ;2105
000054  f884003c          STRB     r0,[r4,#0x3c]         ;2105
000058  6820              LDR      r0,[r4,#0]            ;2108
00005a  6805              LDR      r5,[r0,#0]            ;2108
00005c  07ed              LSLS     r5,r5,#31             ;2108
00005e  d002              BEQ      |L19.102|
000060  e005              B        |L19.110|
                  |L19.98|
000062  2002              MOVS     r0,#2                 ;2105
000064  bdf8              POP      {r3-r7,pc}
                  |L19.102|
000066  6805              LDR      r5,[r0,#0]            ;2111
000068  f0450501          ORR      r5,r5,#1              ;2111
00006c  6005              STR      r5,[r0,#0]            ;2111
                  |L19.110|
00006e  6820              LDR      r0,[r4,#0]            ;2115
000070  6805              LDR      r5,[r0,#0]            ;2115
000072  f4256500          BIC      r5,r5,#0x800          ;2115
000076  6005              STR      r5,[r0,#0]            ;2115
000078  2022              MOVS     r0,#0x22              ;2117
00007a  f884003d          STRB     r0,[r4,#0x3d]         ;2117
00007e  2010              MOVS     r0,#0x10              ;2118
000080  f884003e          STRB     r0,[r4,#0x3e]         ;2118
000084  6426              STR      r6,[r4,#0x40]         ;2119
000086  6262              STR      r2,[r4,#0x24]         ;2122
000088  8563              STRH     r3,[r4,#0x2a]         ;2123
00008a  4822              LDR      r0,|L19.276|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2124
00008e  8d60              LDRH     r0,[r4,#0x2a]         ;2125
000090  8520              STRH     r0,[r4,#0x28]         ;2125
000092  6461              STR      r1,[r4,#0x44]         ;2126
000094  8d20              LDRH     r0,[r4,#0x28]         ;2128
000096  b338              CBZ      r0,|L19.232|
000098  6ba1              LDR      r1,[r4,#0x38]         ;2131
00009a  481f              LDR      r0,|L19.280|
00009c  6288              STR      r0,[r1,#0x28]         ;2131
00009e  6ba1              LDR      r1,[r4,#0x38]         ;2134
0000a0  481e              LDR      r0,|L19.284|
0000a2  6308              STR      r0,[r1,#0x30]         ;2134
0000a4  6ba0              LDR      r0,[r4,#0x38]         ;2137
0000a6  62c6              STR      r6,[r0,#0x2c]         ;2137
0000a8  6ba0              LDR      r0,[r4,#0x38]         ;2138
0000aa  6346              STR      r6,[r0,#0x34]         ;2138
0000ac  6821              LDR      r1,[r4,#0]            ;2141
0000ae  8d23              LDRH     r3,[r4,#0x28]         ;2141
0000b0  3110              ADDS     r1,r1,#0x10           ;2141
0000b2  6a62              LDR      r2,[r4,#0x24]         ;2141
0000b4  6ba0              LDR      r0,[r4,#0x38]         ;2141
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6820              LDR      r0,[r4,#0]            ;2144
0000bc  6801              LDR      r1,[r0,#0]            ;2144
0000be  f4416180          ORR      r1,r1,#0x400          ;2144
0000c2  6001              STR      r1,[r0,#0]            ;2144
0000c4  6820              LDR      r0,[r4,#0]            ;2147
0000c6  6801              LDR      r1,[r0,#0]            ;2147
0000c8  f4417180          ORR      r1,r1,#0x100          ;2147
0000cc  6001              STR      r1,[r0,#0]            ;2147
0000ce  f884603c          STRB     r6,[r4,#0x3c]         ;2150
0000d2  6820              LDR      r0,[r4,#0]            ;2157
0000d4  6841              LDR      r1,[r0,#4]            ;2157
0000d6  f4417140          ORR      r1,r1,#0x300          ;2157
0000da  6041              STR      r1,[r0,#4]            ;2157
0000dc  6820              LDR      r0,[r4,#0]            ;2160
0000de  6841              LDR      r1,[r0,#4]            ;2160
0000e0  f4416100          ORR      r1,r1,#0x800          ;2160
0000e4  6041              STR      r1,[r0,#4]            ;2160
0000e6  e010              B        |L19.266|
                  |L19.232|
0000e8  6820              LDR      r0,[r4,#0]            ;2165
0000ea  6801              LDR      r1,[r0,#0]            ;2165
0000ec  f4416180          ORR      r1,r1,#0x400          ;2165
0000f0  6001              STR      r1,[r0,#0]            ;2165
0000f2  6820              LDR      r0,[r4,#0]            ;2168
0000f4  6801              LDR      r1,[r0,#0]            ;2168
0000f6  f4417180          ORR      r1,r1,#0x100          ;2168
0000fa  6001              STR      r1,[r0,#0]            ;2168
0000fc  f884603c          STRB     r6,[r4,#0x3c]         ;2171
000100  6820              LDR      r0,[r4,#0]            ;2178
000102  6841              LDR      r1,[r0,#4]            ;2178
000104  f44161e0          ORR      r1,r1,#0x700          ;2178
000108  6041              STR      r1,[r0,#4]            ;2178
                  |L19.266|
00010a  2000              MOVS     r0,#0                 ;2181
00010c  bdf8              POP      {r3-r7,pc}
;;;2188   
                          ENDP

00010e  0000              DCW      0x0000
                  |L19.272|
                          DCD      SystemCoreClock
                  |L19.276|
                          DCD      0xffff0000
                  |L19.280|
                          DCD      I2C_DMAXferCplt
                  |L19.284|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1315     */
;;;1316   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b578              PUSH     {r3-r6,lr}
;;;1317   {
;;;1318     __IO uint32_t count = 0U;
000002  2600              MOVS     r6,#0
000004  9600              STR      r6,[sp,#0]
;;;1319   
;;;1320     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f890403d          LDRB     r4,[r0,#0x3d]
00000a  2c20              CMP      r4,#0x20
00000c  d001              BEQ      |L20.18|
;;;1321     {
;;;1322       /* Wait until BUSY flag is reset */
;;;1323       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1324       do
;;;1325       {
;;;1326         if(count-- == 0U)
;;;1327         {
;;;1328           hi2c->PreviousState = I2C_STATE_NONE;
;;;1329           hi2c->State= HAL_I2C_STATE_READY;
;;;1330   
;;;1331           /* Process Unlocked */
;;;1332           __HAL_UNLOCK(hi2c);
;;;1333   
;;;1334           return HAL_TIMEOUT; 
;;;1335         }
;;;1336       }
;;;1337       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1338   
;;;1339       /* Process Locked */
;;;1340       __HAL_LOCK(hi2c);
;;;1341       
;;;1342       /* Check if the I2C is already enabled */
;;;1343       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1344       {
;;;1345         /* Enable I2C peripheral */
;;;1346         __HAL_I2C_ENABLE(hi2c);
;;;1347       }
;;;1348   
;;;1349       /* Disable Pos */
;;;1350       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1351   
;;;1352       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1353       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1354       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1355   
;;;1356       /* Prepare transfer parameters */
;;;1357       hi2c->pBuffPtr    = pData;
;;;1358       hi2c->XferCount   = Size;
;;;1359       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1360       hi2c->XferSize    = hi2c->XferCount;
;;;1361       hi2c->Devaddress  = DevAddress;
;;;1362   
;;;1363       /* Enable Acknowledge */
;;;1364       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1365   
;;;1366       /* Generate Start */
;;;1367       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1368   
;;;1369       /* Process Unlocked */
;;;1370       __HAL_UNLOCK(hi2c);
;;;1371   
;;;1372       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1373       to avoid the risk of I2C interrupt handle execution before current
;;;1374       process unlock */
;;;1375   
;;;1376       /* Enable EVT, BUF and ERR interrupt */
;;;1377       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1378   
;;;1379       return HAL_OK;
;;;1380     }
;;;1381     else
;;;1382     {
;;;1383       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;1384     }
;;;1385   }
000010  bd78              POP      {r3-r6,pc}
                  |L20.18|
000012  4c29              LDR      r4,|L20.184|
000014  f24615a8          MOV      r5,#0x61a8            ;1323
000018  6824              LDR      r4,[r4,#0]            ;1323  ; SystemCoreClock
00001a  fbb4f4f5          UDIV     r4,r4,r5              ;1323
00001e  eb0405c4          ADD      r5,r4,r4,LSL #3       ;1323
000022  eb051404          ADD      r4,r5,r4,LSL #4       ;1323
000026  9400              STR      r4,[sp,#0]            ;1323
                  |L20.40|
000028  9c00              LDR      r4,[sp,#0]            ;1326
00002a  1e65              SUBS     r5,r4,#1              ;1326
00002c  9500              STR      r5,[sp,#0]            ;1326
00002e  d206              BCS      |L20.62|
000030  f8406f30          STR      r6,[r0,#0x30]!        ;1328
000034  2120              MOVS     r1,#0x20              ;1329
000036  7341              STRB     r1,[r0,#0xd]          ;1329
000038  7306              STRB     r6,[r0,#0xc]          ;1332
00003a  2003              MOVS     r0,#3                 ;1334
00003c  bd78              POP      {r3-r6,pc}
                  |L20.62|
00003e  6804              LDR      r4,[r0,#0]            ;1337
000040  69a4              LDR      r4,[r4,#0x18]         ;1337
000042  43e4              MVNS     r4,r4                 ;1337
000044  07a4              LSLS     r4,r4,#30             ;1337
000046  d5ef              BPL      |L20.40|
000048  f890403c          LDRB     r4,[r0,#0x3c]         ;1340
00004c  2c01              CMP      r4,#1                 ;1340
00004e  d007              BEQ      |L20.96|
000050  2401              MOVS     r4,#1                 ;1340
000052  f880403c          STRB     r4,[r0,#0x3c]         ;1340
000056  6804              LDR      r4,[r0,#0]            ;1343
000058  6825              LDR      r5,[r4,#0]            ;1343
00005a  07ed              LSLS     r5,r5,#31             ;1343
00005c  d002              BEQ      |L20.100|
00005e  e005              B        |L20.108|
                  |L20.96|
000060  2002              MOVS     r0,#2                 ;1340
000062  bd78              POP      {r3-r6,pc}
                  |L20.100|
000064  6825              LDR      r5,[r4,#0]            ;1346
000066  f0450501          ORR      r5,r5,#1              ;1346
00006a  6025              STR      r5,[r4,#0]            ;1346
                  |L20.108|
00006c  6804              LDR      r4,[r0,#0]            ;1350
00006e  6825              LDR      r5,[r4,#0]            ;1350
000070  f4256500          BIC      r5,r5,#0x800          ;1350
000074  6025              STR      r5,[r4,#0]            ;1350
000076  2422              MOVS     r4,#0x22              ;1352
000078  f880403d          STRB     r4,[r0,#0x3d]         ;1352
00007c  2410              MOVS     r4,#0x10              ;1353
00007e  f880403e          STRB     r4,[r0,#0x3e]         ;1353
000082  6406              STR      r6,[r0,#0x40]         ;1354
000084  6242              STR      r2,[r0,#0x24]         ;1357
000086  8543              STRH     r3,[r0,#0x2a]         ;1358
000088  4a0c              LDR      r2,|L20.188|
00008a  62c2              STR      r2,[r0,#0x2c]         ;1359
00008c  8d42              LDRH     r2,[r0,#0x2a]         ;1360
00008e  8502              STRH     r2,[r0,#0x28]         ;1360
000090  6441              STR      r1,[r0,#0x44]         ;1361
000092  6801              LDR      r1,[r0,#0]            ;1364
000094  680a              LDR      r2,[r1,#0]            ;1364
000096  f4426280          ORR      r2,r2,#0x400          ;1364
00009a  600a              STR      r2,[r1,#0]            ;1364
00009c  6801              LDR      r1,[r0,#0]            ;1367
00009e  680a              LDR      r2,[r1,#0]            ;1367
0000a0  f4427280          ORR      r2,r2,#0x100          ;1367
0000a4  600a              STR      r2,[r1,#0]            ;1367
0000a6  f880603c          STRB     r6,[r0,#0x3c]         ;1370
0000aa  6800              LDR      r0,[r0,#0]            ;1377
0000ac  6841              LDR      r1,[r0,#4]            ;1377
0000ae  f44161e0          ORR      r1,r1,#0x700          ;1377
0000b2  6041              STR      r1,[r0,#4]            ;1377
0000b4  2000              MOVS     r0,#0                 ;1379
0000b6  bd78              POP      {r3-r6,pc}
;;;1386   
                          ENDP

                  |L20.184|
                          DCD      SystemCoreClock
                  |L20.188|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Sequential_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Sequential_Receive_IT PROC
;;;1501     */
;;;1502   HAL_StatusTypeDef HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1503   {
000002  9c06              LDR      r4,[sp,#0x18]
;;;1504     __IO uint32_t count = 0U;
000004  2700              MOVS     r7,#0
000006  9700              STR      r7,[sp,#0]
;;;1505       
;;;1506     /* Check the parameters */
;;;1507     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;1508   
;;;1509     if(hi2c->State == HAL_I2C_STATE_READY)
000008  f890503d          LDRB     r5,[r0,#0x3d]
00000c  2d20              CMP      r5,#0x20
00000e  d001              BEQ      |L21.20|
;;;1510     {
;;;1511       /* Check Busy Flag only if FIRST call of Master interface */
;;;1512       if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
;;;1513       {
;;;1514         /* Wait until BUSY flag is reset */
;;;1515         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1516         do
;;;1517         {
;;;1518           if(count-- == 0U)
;;;1519           {
;;;1520             hi2c->PreviousState = I2C_STATE_NONE;
;;;1521             hi2c->State= HAL_I2C_STATE_READY;
;;;1522   
;;;1523             /* Process Unlocked */
;;;1524             __HAL_UNLOCK(hi2c);
;;;1525   
;;;1526             return HAL_TIMEOUT; 
;;;1527           }
;;;1528         }
;;;1529         while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1530       }
;;;1531   
;;;1532       /* Process Locked */
;;;1533       __HAL_LOCK(hi2c);
;;;1534   
;;;1535       /* Check if the I2C is already enabled */
;;;1536       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1537       {
;;;1538         /* Enable I2C peripheral */
;;;1539         __HAL_I2C_ENABLE(hi2c);
;;;1540       }
;;;1541   
;;;1542       /* Disable Pos */
;;;1543       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1544   
;;;1545       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1546       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1547       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1548   
;;;1549       /* Prepare transfer parameters */
;;;1550       hi2c->pBuffPtr = pData;
;;;1551       hi2c->XferCount = Size;
;;;1552       hi2c->XferOptions = XferOptions;
;;;1553       hi2c->XferSize    = hi2c->XferCount;
;;;1554       hi2c->Devaddress = DevAddress;
;;;1555       
;;;1556       if((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) || (hi2c->PreviousState == I2C_STATE_NONE))
;;;1557       {
;;;1558         /* Generate Start condition if first transfer */
;;;1559         if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME)  || (XferOptions == I2C_NO_OPTION_FRAME))
;;;1560         {
;;;1561           /* Enable Acknowledge */
;;;1562           hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1563           
;;;1564           /* Generate Start */
;;;1565           hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1566         }
;;;1567         else
;;;1568         {
;;;1569           /* Enable Acknowledge */
;;;1570           hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1571           
;;;1572           /* Generate ReStart */
;;;1573           hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1574         }
;;;1575       }
;;;1576   
;;;1577       /* Process Unlocked */
;;;1578       __HAL_UNLOCK(hi2c);
;;;1579   
;;;1580       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1581       to avoid the risk of I2C interrupt handle execution before current
;;;1582       process unlock */
;;;1583   
;;;1584       /* Enable EVT, BUF and ERR interrupt */
;;;1585       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1586   
;;;1587       return HAL_OK;
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       return HAL_BUSY;
000010  2002              MOVS     r0,#2
;;;1592     }
;;;1593   }
000012  bdf8              POP      {r3-r7,pc}
                  |L21.20|
000014  2c04              CMP      r4,#4                 ;1512
000016  d001              BEQ      |L21.28|
000018  2c01              CMP      r4,#1                 ;1512
00001a  d11a              BNE      |L21.82|
                  |L21.28|
00001c  4d34              LDR      r5,|L21.240|
00001e  f24616a8          MOV      r6,#0x61a8            ;1515
000022  682d              LDR      r5,[r5,#0]            ;1515  ; SystemCoreClock
000024  fbb5f5f6          UDIV     r5,r5,r6              ;1515
000028  eb0506c5          ADD      r6,r5,r5,LSL #3       ;1515
00002c  eb061505          ADD      r5,r6,r5,LSL #4       ;1515
000030  9500              STR      r5,[sp,#0]            ;1515
                  |L21.50|
000032  9d00              LDR      r5,[sp,#0]            ;1518
000034  1e6e              SUBS     r6,r5,#1              ;1518
000036  9600              STR      r6,[sp,#0]            ;1518
000038  d206              BCS      |L21.72|
00003a  f8407f30          STR      r7,[r0,#0x30]!        ;1520
00003e  2120              MOVS     r1,#0x20              ;1521
000040  7341              STRB     r1,[r0,#0xd]          ;1521
000042  7307              STRB     r7,[r0,#0xc]          ;1524
000044  2003              MOVS     r0,#3                 ;1526
000046  bdf8              POP      {r3-r7,pc}
                  |L21.72|
000048  6805              LDR      r5,[r0,#0]            ;1529
00004a  69ad              LDR      r5,[r5,#0x18]         ;1529
00004c  43ed              MVNS     r5,r5                 ;1529
00004e  07ad              LSLS     r5,r5,#30             ;1529
000050  d5ef              BPL      |L21.50|
                  |L21.82|
000052  f890503c          LDRB     r5,[r0,#0x3c]         ;1533
000056  2d01              CMP      r5,#1                 ;1533
000058  d007              BEQ      |L21.106|
00005a  2501              MOVS     r5,#1                 ;1533
00005c  f880503c          STRB     r5,[r0,#0x3c]         ;1533
000060  6805              LDR      r5,[r0,#0]            ;1536
000062  682e              LDR      r6,[r5,#0]            ;1536
000064  07f6              LSLS     r6,r6,#31             ;1536
000066  d002              BEQ      |L21.110|
000068  e005              B        |L21.118|
                  |L21.106|
00006a  2002              MOVS     r0,#2                 ;1533
00006c  bdf8              POP      {r3-r7,pc}
                  |L21.110|
00006e  682e              LDR      r6,[r5,#0]            ;1539
000070  f0460601          ORR      r6,r6,#1              ;1539
000074  602e              STR      r6,[r5,#0]            ;1539
                  |L21.118|
000076  6805              LDR      r5,[r0,#0]            ;1543
000078  682e              LDR      r6,[r5,#0]            ;1543
00007a  f4266600          BIC      r6,r6,#0x800          ;1543
00007e  602e              STR      r6,[r5,#0]            ;1543
000080  2522              MOVS     r5,#0x22              ;1545
000082  f880503d          STRB     r5,[r0,#0x3d]         ;1545
000086  2510              MOVS     r5,#0x10              ;1546
000088  f880503e          STRB     r5,[r0,#0x3e]         ;1546
00008c  6407              STR      r7,[r0,#0x40]         ;1547
00008e  6242              STR      r2,[r0,#0x24]         ;1550
000090  8543              STRH     r3,[r0,#0x2a]         ;1551
000092  62c4              STR      r4,[r0,#0x2c]         ;1552
000094  8d42              LDRH     r2,[r0,#0x2a]         ;1553
000096  8502              STRH     r2,[r0,#0x28]         ;1553
000098  6441              STR      r1,[r0,#0x44]         ;1554
00009a  6b01              LDR      r1,[r0,#0x30]         ;1556
00009c  2911              CMP      r1,#0x11              ;1556
00009e  d001              BEQ      |L21.164|
0000a0  6b01              LDR      r1,[r0,#0x30]         ;1556
0000a2  b981              CBNZ     r1,|L21.198|
                  |L21.164|
0000a4  2c04              CMP      r4,#4                 ;1559
0000a6  d017              BEQ      |L21.216|
0000a8  2c01              CMP      r4,#1                 ;1559
0000aa  d015              BEQ      |L21.216|
0000ac  f5143f80          CMN      r4,#0x10000           ;1559
0000b0  d012              BEQ      |L21.216|
0000b2  6801              LDR      r1,[r0,#0]            ;1570
0000b4  680a              LDR      r2,[r1,#0]            ;1570
0000b6  f4426280          ORR      r2,r2,#0x400          ;1570
0000ba  600a              STR      r2,[r1,#0]            ;1570
0000bc  6801              LDR      r1,[r0,#0]            ;1573
0000be  680a              LDR      r2,[r1,#0]            ;1573
0000c0  f4427280          ORR      r2,r2,#0x100          ;1573
0000c4  600a              STR      r2,[r1,#0]            ;1573
                  |L21.198|
0000c6  f880703c          STRB     r7,[r0,#0x3c]         ;1578
0000ca  6800              LDR      r0,[r0,#0]            ;1585
0000cc  6841              LDR      r1,[r0,#4]            ;1585
0000ce  f44161e0          ORR      r1,r1,#0x700          ;1585
0000d2  6041              STR      r1,[r0,#4]            ;1585
0000d4  2000              MOVS     r0,#0                 ;1587
0000d6  bdf8              POP      {r3-r7,pc}
                  |L21.216|
0000d8  6801              LDR      r1,[r0,#0]            ;1562
0000da  680a              LDR      r2,[r1,#0]            ;1562
0000dc  f4426280          ORR      r2,r2,#0x400          ;1562
0000e0  600a              STR      r2,[r1,#0]            ;1562
0000e2  6801              LDR      r1,[r0,#0]            ;1565
0000e4  680a              LDR      r2,[r1,#0]            ;1565
0000e6  f4427280          ORR      r2,r2,#0x100          ;1565
0000ea  600a              STR      r2,[r1,#0]            ;1565
0000ec  e7eb              B        |L21.198|
;;;1594   
                          ENDP

0000ee  0000              DCW      0x0000
                  |L21.240|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Sequential_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Sequential_Transmit_IT PROC
;;;1398     */
;;;1399   HAL_StatusTypeDef HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fc              PUSH     {r2-r7,lr}
;;;1400   {
000002  9d07              LDR      r5,[sp,#0x1c]
;;;1401     __IO uint32_t Prev_State = 0x00U;
000004  2700              MOVS     r7,#0
000006  9701              STR      r7,[sp,#4]
;;;1402     __IO uint32_t count      = 0x00U;
000008  9700              STR      r7,[sp,#0]
;;;1403     
;;;1404     /* Check the parameters */
;;;1405     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;1406   
;;;1407     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c20              CMP      r4,#0x20
000010  d001              BEQ      |L22.22|
;;;1408     {
;;;1409       /* Check Busy Flag only if FIRST call of Master interface */
;;;1410       if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
;;;1411       {
;;;1412         /* Wait until BUSY flag is reset */
;;;1413         count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1414         do
;;;1415         {
;;;1416           if(count-- == 0U)
;;;1417           {
;;;1418             hi2c->PreviousState = I2C_STATE_NONE;
;;;1419             hi2c->State= HAL_I2C_STATE_READY;
;;;1420             
;;;1421             /* Process Unlocked */
;;;1422             __HAL_UNLOCK(hi2c);
;;;1423             
;;;1424             return HAL_TIMEOUT; 
;;;1425           }
;;;1426         }
;;;1427         while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1428       }
;;;1429   
;;;1430       /* Process Locked */
;;;1431       __HAL_LOCK(hi2c);
;;;1432   
;;;1433       /* Check if the I2C is already enabled */
;;;1434       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1435       {
;;;1436         /* Enable I2C peripheral */
;;;1437         __HAL_I2C_ENABLE(hi2c);
;;;1438       }
;;;1439   
;;;1440       /* Disable Pos */
;;;1441       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1442   
;;;1443       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1444       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1445       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1446   
;;;1447       /* Prepare transfer parameters */
;;;1448       hi2c->pBuffPtr    = pData;
;;;1449       hi2c->XferCount   = Size;
;;;1450       hi2c->XferOptions = XferOptions;
;;;1451       hi2c->XferSize    = hi2c->XferCount;
;;;1452       hi2c->Devaddress  = DevAddress;
;;;1453   
;;;1454       Prev_State = hi2c->PreviousState;
;;;1455       
;;;1456       /* Generate Start */    
;;;1457       if((Prev_State == I2C_STATE_MASTER_BUSY_RX) || (Prev_State == I2C_STATE_NONE))
;;;1458       {
;;;1459         /* Generate Start condition if first transfer */
;;;1460         if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
;;;1461         {
;;;1462           /* Generate Start */
;;;1463           hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1464         }
;;;1465         else
;;;1466         {
;;;1467           /* Generate ReStart */
;;;1468           hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1469         }
;;;1470       }
;;;1471   
;;;1472       /* Process Unlocked */
;;;1473       __HAL_UNLOCK(hi2c);
;;;1474   
;;;1475       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1476       to avoid the risk of I2C interrupt handle execution before current
;;;1477       process unlock */
;;;1478   
;;;1479       /* Enable EVT, BUF and ERR interrupt */
;;;1480       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1481   
;;;1482       return HAL_OK;
;;;1483     }
;;;1484     else
;;;1485     {
;;;1486       return HAL_BUSY;
000012  2002              MOVS     r0,#2
;;;1487     }
;;;1488   }
000014  bdfc              POP      {r2-r7,pc}
                  |L22.22|
000016  2d04              CMP      r5,#4                 ;1410
000018  d001              BEQ      |L22.30|
00001a  2d01              CMP      r5,#1                 ;1410
00001c  d11a              BNE      |L22.84|
                  |L22.30|
00001e  4c2f              LDR      r4,|L22.220|
000020  f24616a8          MOV      r6,#0x61a8            ;1413
000024  6824              LDR      r4,[r4,#0]            ;1413  ; SystemCoreClock
000026  fbb4f4f6          UDIV     r4,r4,r6              ;1413
00002a  eb0406c4          ADD      r6,r4,r4,LSL #3       ;1413
00002e  eb061404          ADD      r4,r6,r4,LSL #4       ;1413
000032  9400              STR      r4,[sp,#0]            ;1413
                  |L22.52|
000034  9c00              LDR      r4,[sp,#0]            ;1416
000036  1e66              SUBS     r6,r4,#1              ;1416
000038  9600              STR      r6,[sp,#0]            ;1416
00003a  d206              BCS      |L22.74|
00003c  f8407f30          STR      r7,[r0,#0x30]!        ;1418
000040  2120              MOVS     r1,#0x20              ;1419
000042  7341              STRB     r1,[r0,#0xd]          ;1419
000044  7307              STRB     r7,[r0,#0xc]          ;1422
000046  2003              MOVS     r0,#3                 ;1424
000048  bdfc              POP      {r2-r7,pc}
                  |L22.74|
00004a  6804              LDR      r4,[r0,#0]            ;1427
00004c  69a4              LDR      r4,[r4,#0x18]         ;1427
00004e  43e4              MVNS     r4,r4                 ;1427
000050  07a4              LSLS     r4,r4,#30             ;1427
000052  d5ef              BPL      |L22.52|
                  |L22.84|
000054  f890403c          LDRB     r4,[r0,#0x3c]         ;1431
000058  2c01              CMP      r4,#1                 ;1431
00005a  d007              BEQ      |L22.108|
00005c  2401              MOVS     r4,#1                 ;1431
00005e  f880403c          STRB     r4,[r0,#0x3c]         ;1431
000062  6804              LDR      r4,[r0,#0]            ;1434
000064  6826              LDR      r6,[r4,#0]            ;1434
000066  07f6              LSLS     r6,r6,#31             ;1434
000068  d002              BEQ      |L22.112|
00006a  e005              B        |L22.120|
                  |L22.108|
00006c  2002              MOVS     r0,#2                 ;1431
00006e  bdfc              POP      {r2-r7,pc}
                  |L22.112|
000070  6826              LDR      r6,[r4,#0]            ;1437
000072  f0460601          ORR      r6,r6,#1              ;1437
000076  6026              STR      r6,[r4,#0]            ;1437
                  |L22.120|
000078  6804              LDR      r4,[r0,#0]            ;1441
00007a  6826              LDR      r6,[r4,#0]            ;1441
00007c  f4266600          BIC      r6,r6,#0x800          ;1441
000080  6026              STR      r6,[r4,#0]            ;1441
000082  2421              MOVS     r4,#0x21              ;1443
000084  f880403d          STRB     r4,[r0,#0x3d]         ;1443
000088  2410              MOVS     r4,#0x10              ;1444
00008a  f880403e          STRB     r4,[r0,#0x3e]         ;1444
00008e  6407              STR      r7,[r0,#0x40]         ;1445
000090  6242              STR      r2,[r0,#0x24]         ;1448
000092  8543              STRH     r3,[r0,#0x2a]         ;1449
000094  62c5              STR      r5,[r0,#0x2c]         ;1450
000096  8d42              LDRH     r2,[r0,#0x2a]         ;1451
000098  8502              STRH     r2,[r0,#0x28]         ;1451
00009a  6441              STR      r1,[r0,#0x44]         ;1452
00009c  6b01              LDR      r1,[r0,#0x30]         ;1454
00009e  9101              STR      r1,[sp,#4]            ;1454
0000a0  9901              LDR      r1,[sp,#4]            ;1457
0000a2  2912              CMP      r1,#0x12              ;1457
0000a4  d001              BEQ      |L22.170|
0000a6  9901              LDR      r1,[sp,#4]            ;1457
0000a8  b941              CBNZ     r1,|L22.188|
                  |L22.170|
0000aa  2d04              CMP      r5,#4                 ;1460
0000ac  d00f              BEQ      |L22.206|
0000ae  2d01              CMP      r5,#1                 ;1460
0000b0  d00d              BEQ      |L22.206|
0000b2  6801              LDR      r1,[r0,#0]            ;1468
0000b4  680a              LDR      r2,[r1,#0]            ;1468
0000b6  f4427280          ORR      r2,r2,#0x100          ;1468
0000ba  600a              STR      r2,[r1,#0]            ;1468
                  |L22.188|
0000bc  f880703c          STRB     r7,[r0,#0x3c]         ;1473
0000c0  6800              LDR      r0,[r0,#0]            ;1480
0000c2  6841              LDR      r1,[r0,#4]            ;1480
0000c4  f44161e0          ORR      r1,r1,#0x700          ;1480
0000c8  6041              STR      r1,[r0,#4]            ;1480
0000ca  2000              MOVS     r0,#0                 ;1482
0000cc  bdfc              POP      {r2-r7,pc}
                  |L22.206|
0000ce  6801              LDR      r1,[r0,#0]            ;1463
0000d0  680a              LDR      r2,[r1,#0]            ;1463
0000d2  f4427280          ORR      r2,r2,#0x100          ;1463
0000d6  600a              STR      r2,[r1,#0]            ;1463
0000d8  e7f0              B        |L22.188|
;;;1489   
                          ENDP

0000da  0000              DCW      0x0000
                  |L22.220|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;591      */
;;;592    HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;593    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
;;;594      uint32_t tickstart = 0x00U;
;;;595    
;;;596      /* Init tickstart for timeout management*/
;;;597      tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4605              MOV      r5,r0
;;;598    
;;;599      if(hi2c->State == HAL_I2C_STATE_READY)
000014  f894003d          LDRB     r0,[r4,#0x3d]
000018  2820              CMP      r0,#0x20
00001a  d002              BEQ      |L23.34|
;;;600      {
;;;601        /* Wait until BUSY flag is reset */
;;;602        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;603        {
;;;604          return HAL_BUSY;
;;;605        }
;;;606    
;;;607        /* Process Locked */
;;;608        __HAL_LOCK(hi2c);
;;;609    
;;;610        /* Check if the I2C is already enabled */
;;;611        if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;612        {
;;;613          /* Enable I2C peripheral */
;;;614          __HAL_I2C_ENABLE(hi2c);
;;;615        }
;;;616    
;;;617        /* Disable Pos */
;;;618        hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;619    
;;;620        hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;621        hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;622        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;623    
;;;624        /* Prepare transfer parameters */
;;;625        hi2c->pBuffPtr    = pData;
;;;626        hi2c->XferCount   = Size;
;;;627        hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;628        hi2c->XferSize    = hi2c->XferCount;
;;;629    
;;;630        /* Send Slave Address */
;;;631        if(I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
;;;632        {
;;;633          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;634          {
;;;635            /* Process Unlocked */
;;;636            __HAL_UNLOCK(hi2c);
;;;637            return HAL_ERROR;
;;;638          }
;;;639          else
;;;640          {
;;;641            /* Process Unlocked */
;;;642            __HAL_UNLOCK(hi2c);
;;;643            return HAL_TIMEOUT;
;;;644          }
;;;645        }
;;;646    
;;;647        /* Clear ADDR flag */
;;;648        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;649    
;;;650        while(hi2c->XferSize > 0U)
;;;651        {
;;;652          /* Wait until TXE flag is set */
;;;653          if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;654          {
;;;655            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;656            {
;;;657              /* Generate Stop */
;;;658              hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;659              return HAL_ERROR;
;;;660            }
;;;661            else
;;;662            {
;;;663              return HAL_TIMEOUT;
;;;664            }
;;;665          }
;;;666    
;;;667          /* Write data to DR */
;;;668          hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;669          hi2c->XferCount--;
;;;670          hi2c->XferSize--;
;;;671    
;;;672          if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;673          {
;;;674            /* Write data to DR */
;;;675            hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;676            hi2c->XferCount--;
;;;677            hi2c->XferSize--;
;;;678          }
;;;679          
;;;680          /* Wait until BTF flag is set */
;;;681          if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;682          {
;;;683            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;684            {
;;;685              /* Generate Stop */
;;;686              hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;687              return HAL_ERROR;
;;;688            }
;;;689            else
;;;690            {
;;;691              return HAL_TIMEOUT;
;;;692            }
;;;693          }
;;;694        }
;;;695    
;;;696        /* Generate Stop */
;;;697        hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;698    
;;;699        hi2c->State = HAL_I2C_STATE_READY;
;;;700        hi2c->Mode = HAL_I2C_MODE_NONE;
;;;701        
;;;702        /* Process Unlocked */
;;;703        __HAL_UNLOCK(hi2c);
;;;704    
;;;705        return HAL_OK;
;;;706      }
;;;707      else
;;;708      {
;;;709        return HAL_BUSY;
00001c  2002              MOVS     r0,#2
                  |L23.30|
;;;710      }
;;;711    }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.34|
000022  2319              MOVS     r3,#0x19              ;602
000024  2201              MOVS     r2,#1                 ;602
000026  494c              LDR      r1,|L23.344|
000028  4620              MOV      r0,r4                 ;602
00002a  9500              STR      r5,[sp,#0]            ;602
00002c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000030  b108              CBZ      r0,|L23.54|
000032  2002              MOVS     r0,#2                 ;604
000034  e7f3              B        |L23.30|
                  |L23.54|
000036  f894003c          LDRB     r0,[r4,#0x3c]         ;608
00003a  2801              CMP      r0,#1                 ;608
00003c  d007              BEQ      |L23.78|
00003e  2001              MOVS     r0,#1                 ;608
000040  f884003c          STRB     r0,[r4,#0x3c]         ;608
000044  6820              LDR      r0,[r4,#0]            ;611
000046  6801              LDR      r1,[r0,#0]            ;611
000048  07c9              LSLS     r1,r1,#31             ;611
00004a  d002              BEQ      |L23.82|
00004c  e005              B        |L23.90|
                  |L23.78|
00004e  2002              MOVS     r0,#2                 ;608
000050  e7e5              B        |L23.30|
                  |L23.82|
000052  6801              LDR      r1,[r0,#0]            ;614
000054  f0410101          ORR      r1,r1,#1              ;614
000058  6001              STR      r1,[r0,#0]            ;614
                  |L23.90|
00005a  6820              LDR      r0,[r4,#0]            ;618
00005c  6801              LDR      r1,[r0,#0]            ;618
00005e  f4216100          BIC      r1,r1,#0x800          ;618
000062  6001              STR      r1,[r0,#0]            ;618
000064  2021              MOVS     r0,#0x21              ;620
000066  f884003d          STRB     r0,[r4,#0x3d]         ;620
00006a  2010              MOVS     r0,#0x10              ;621
00006c  f884003e          STRB     r0,[r4,#0x3e]         ;621
000070  2600              MOVS     r6,#0                 ;622
000072  6426              STR      r6,[r4,#0x40]         ;622
000074  f8c48024          STR      r8,[r4,#0x24]         ;625
000078  f8a4902a          STRH     r9,[r4,#0x2a]         ;626
00007c  4837              LDR      r0,|L23.348|
00007e  62e0              STR      r0,[r4,#0x2c]         ;627
000080  8d60              LDRH     r0,[r4,#0x2a]         ;628
000082  8520              STRH     r0,[r4,#0x28]         ;628
000084  462b              MOV      r3,r5                 ;631
000086  463a              MOV      r2,r7                 ;631
000088  4651              MOV      r1,r10                ;631
00008a  4620              MOV      r0,r4                 ;631
00008c  f7fffffe          BL       I2C_MasterRequestWrite
000090  b150              CBZ      r0,|L23.168|
000092  6c20              LDR      r0,[r4,#0x40]         ;633
000094  2804              CMP      r0,#4                 ;633
000096  d003              BEQ      |L23.160|
000098  f884603c          STRB     r6,[r4,#0x3c]         ;642
00009c  2003              MOVS     r0,#3                 ;643
00009e  e7be              B        |L23.30|
                  |L23.160|
0000a0  f884603c          STRB     r6,[r4,#0x3c]         ;636
0000a4  2001              MOVS     r0,#1                 ;637
0000a6  e7ba              B        |L23.30|
                  |L23.168|
0000a8  6820              LDR      r0,[r4,#0]            ;648
0000aa  6941              LDR      r1,[r0,#0x14]         ;648
0000ac  6980              LDR      r0,[r0,#0x18]         ;648
0000ae  9000              STR      r0,[sp,#0]            ;648
0000b0  e041              B        |L23.310|
                  |L23.178|
0000b2  462a              MOV      r2,r5                 ;653
0000b4  4639              MOV      r1,r7                 ;653
0000b6  4620              MOV      r0,r4                 ;653
0000b8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000bc  b158              CBZ      r0,|L23.214|
0000be  6c20              LDR      r0,[r4,#0x40]         ;655
0000c0  2804              CMP      r0,#4                 ;655
0000c2  d001              BEQ      |L23.200|
0000c4  2003              MOVS     r0,#3                 ;663
0000c6  e7aa              B        |L23.30|
                  |L23.200|
0000c8  6820              LDR      r0,[r4,#0]            ;658
0000ca  6801              LDR      r1,[r0,#0]            ;658
0000cc  f4417100          ORR      r1,r1,#0x200          ;658
0000d0  6001              STR      r1,[r0,#0]            ;658
0000d2  2001              MOVS     r0,#1                 ;659
0000d4  e7a3              B        |L23.30|
                  |L23.214|
0000d6  6a60              LDR      r0,[r4,#0x24]         ;668
0000d8  1c41              ADDS     r1,r0,#1              ;668
0000da  6261              STR      r1,[r4,#0x24]         ;668
0000dc  6821              LDR      r1,[r4,#0]            ;668
0000de  7800              LDRB     r0,[r0,#0]            ;668
0000e0  6108              STR      r0,[r1,#0x10]         ;668
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;669
0000e4  1e40              SUBS     r0,r0,#1              ;669
0000e6  8560              STRH     r0,[r4,#0x2a]         ;669
0000e8  8d20              LDRH     r0,[r4,#0x28]         ;670
0000ea  1e40              SUBS     r0,r0,#1              ;670
0000ec  b280              UXTH     r0,r0                 ;670
0000ee  8520              STRH     r0,[r4,#0x28]         ;670
0000f0  6822              LDR      r2,[r4,#0]            ;672
0000f2  6951              LDR      r1,[r2,#0x14]         ;672
0000f4  43c9              MVNS     r1,r1                 ;672
0000f6  0749              LSLS     r1,r1,#29             ;672
0000f8  d40b              BMI      |L23.274|
0000fa  b150              CBZ      r0,|L23.274|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;675
0000fe  1c41              ADDS     r1,r0,#1              ;675
000100  6261              STR      r1,[r4,#0x24]         ;675
000102  7800              LDRB     r0,[r0,#0]            ;675
000104  6110              STR      r0,[r2,#0x10]         ;675
000106  8d60              LDRH     r0,[r4,#0x2a]         ;676
000108  1e40              SUBS     r0,r0,#1              ;676
00010a  8560              STRH     r0,[r4,#0x2a]         ;676
00010c  8d20              LDRH     r0,[r4,#0x28]         ;677
00010e  1e40              SUBS     r0,r0,#1              ;677
000110  8520              STRH     r0,[r4,#0x28]         ;677
                  |L23.274|
000112  462a              MOV      r2,r5                 ;681
000114  4639              MOV      r1,r7                 ;681
000116  4620              MOV      r0,r4                 ;681
000118  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
00011c  b158              CBZ      r0,|L23.310|
00011e  6c20              LDR      r0,[r4,#0x40]         ;683
000120  2804              CMP      r0,#4                 ;683
000122  d001              BEQ      |L23.296|
000124  2003              MOVS     r0,#3                 ;691
000126  e77a              B        |L23.30|
                  |L23.296|
000128  6820              LDR      r0,[r4,#0]            ;686
00012a  6801              LDR      r1,[r0,#0]            ;686
00012c  f4417100          ORR      r1,r1,#0x200          ;686
000130  6001              STR      r1,[r0,#0]            ;686
000132  2001              MOVS     r0,#1                 ;687
000134  e773              B        |L23.30|
                  |L23.310|
000136  8d20              LDRH     r0,[r4,#0x28]         ;650
000138  2800              CMP      r0,#0                 ;650
00013a  d1ba              BNE      |L23.178|
00013c  341f              ADDS     r4,r4,#0x1f           ;697
00013e  f8540c1f          LDR      r0,[r4,#-0x1f]        ;697
000142  6801              LDR      r1,[r0,#0]            ;697
000144  f4417100          ORR      r1,r1,#0x200          ;697
000148  6001              STR      r1,[r0,#0]            ;697
00014a  2020              MOVS     r0,#0x20              ;699
00014c  77a0              STRB     r0,[r4,#0x1e]         ;699
00014e  77e6              STRB     r6,[r4,#0x1f]         ;700
000150  7766              STRB     r6,[r4,#0x1d]         ;703
000152  2000              MOVS     r0,#0                 ;705
000154  e763              B        |L23.30|
;;;712    
                          ENDP

000156  0000              DCW      0x0000
                  |L23.344|
                          DCD      0x00100002
                  |L23.348|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1962     */
;;;1963   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1964   {
000002  4604              MOV      r4,r0
;;;1965     __IO uint32_t count = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;1966   
;;;1967     if(hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d001              BEQ      |L24.20|
;;;1968     {
;;;1969       /* Wait until BUSY flag is reset */
;;;1970       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1971       do
;;;1972       {
;;;1973         if(count-- == 0U)
;;;1974         {
;;;1975           hi2c->PreviousState = I2C_STATE_NONE;
;;;1976           hi2c->State= HAL_I2C_STATE_READY;
;;;1977   
;;;1978           /* Process Unlocked */
;;;1979           __HAL_UNLOCK(hi2c);
;;;1980   
;;;1981           return HAL_TIMEOUT; 
;;;1982         }
;;;1983       }
;;;1984       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1985   
;;;1986       /* Process Locked */
;;;1987       __HAL_LOCK(hi2c);
;;;1988   
;;;1989       /* Check if the I2C is already enabled */
;;;1990       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1991       {
;;;1992         /* Enable I2C peripheral */
;;;1993         __HAL_I2C_ENABLE(hi2c);
;;;1994       }
;;;1995   
;;;1996       /* Disable Pos */
;;;1997       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1998   
;;;1999       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2000       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2001       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2002   
;;;2003       /* Prepare transfer parameters */
;;;2004       hi2c->pBuffPtr    = pData;
;;;2005       hi2c->XferCount   = Size;
;;;2006       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2007       hi2c->XferSize    = hi2c->XferCount;
;;;2008       hi2c->Devaddress  = DevAddress;
;;;2009   
;;;2010       if(hi2c->XferSize > 0U)
;;;2011       {
;;;2012         /* Set the I2C DMA transfer complete callback */
;;;2013         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;2014   
;;;2015         /* Set the DMA error callback */      
;;;2016         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2017   
;;;2018         /* Set the unused DMA callbacks to NULL */
;;;2019         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2020         hi2c->hdmatx->XferAbortCallback = NULL;
;;;2021   
;;;2022         /* Enable the DMA channel */
;;;2023         HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2024   
;;;2025         /* Enable Acknowledge */
;;;2026         hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2027   
;;;2028         /* Generate Start */
;;;2029         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2030   
;;;2031         /* Process Unlocked */
;;;2032         __HAL_UNLOCK(hi2c);
;;;2033   
;;;2034         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2035         to avoid the risk of I2C interrupt handle execution before current
;;;2036         process unlock */
;;;2037   
;;;2038         /* Enable EVT and ERR interrupt */
;;;2039         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2040   
;;;2041         /* Enable DMA Request */
;;;2042         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2043       }
;;;2044       else
;;;2045       {
;;;2046         /* Enable Acknowledge */
;;;2047         hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2048   
;;;2049         /* Generate Start */
;;;2050         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2051   
;;;2052         /* Process Unlocked */
;;;2053         __HAL_UNLOCK(hi2c);
;;;2054   
;;;2055         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2056         to avoid the risk of I2C interrupt handle execution before current
;;;2057         process unlock */
;;;2058   
;;;2059        /* Enable EVT, BUF and ERR interrupt */
;;;2060       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2061       }
;;;2062   
;;;2063       return HAL_OK;
;;;2064     }
;;;2065     else
;;;2066     {
;;;2067       return HAL_BUSY;
000010  2002              MOVS     r0,#2
;;;2068     }
;;;2069   }
000012  bdf8              POP      {r3-r7,pc}
                  |L24.20|
000014  483e              LDR      r0,|L24.272|
000016  f24615a8          MOV      r5,#0x61a8            ;1970
00001a  6800              LDR      r0,[r0,#0]            ;1970  ; SystemCoreClock
00001c  fbb0f0f5          UDIV     r0,r0,r5              ;1970
000020  eb0005c0          ADD      r5,r0,r0,LSL #3       ;1970
000024  eb051000          ADD      r0,r5,r0,LSL #4       ;1970
000028  9000              STR      r0,[sp,#0]            ;1970
                  |L24.42|
00002a  9800              LDR      r0,[sp,#0]            ;1973
00002c  1e45              SUBS     r5,r0,#1              ;1973
00002e  9500              STR      r5,[sp,#0]            ;1973
000030  d206              BCS      |L24.64|
000032  f8446f30          STR      r6,[r4,#0x30]!        ;1975
000036  2020              MOVS     r0,#0x20              ;1976
000038  7360              STRB     r0,[r4,#0xd]          ;1976
00003a  7326              STRB     r6,[r4,#0xc]          ;1979
00003c  2003              MOVS     r0,#3                 ;1981
00003e  bdf8              POP      {r3-r7,pc}
                  |L24.64|
000040  6820              LDR      r0,[r4,#0]            ;1984
000042  6980              LDR      r0,[r0,#0x18]         ;1984
000044  43c0              MVNS     r0,r0                 ;1984
000046  0780              LSLS     r0,r0,#30             ;1984
000048  d5ef              BPL      |L24.42|
00004a  f894003c          LDRB     r0,[r4,#0x3c]         ;1987
00004e  2801              CMP      r0,#1                 ;1987
000050  d007              BEQ      |L24.98|
000052  2001              MOVS     r0,#1                 ;1987
000054  f884003c          STRB     r0,[r4,#0x3c]         ;1987
000058  6820              LDR      r0,[r4,#0]            ;1990
00005a  6805              LDR      r5,[r0,#0]            ;1990
00005c  07ed              LSLS     r5,r5,#31             ;1990
00005e  d002              BEQ      |L24.102|
000060  e005              B        |L24.110|
                  |L24.98|
000062  2002              MOVS     r0,#2                 ;1987
000064  bdf8              POP      {r3-r7,pc}
                  |L24.102|
000066  6805              LDR      r5,[r0,#0]            ;1993
000068  f0450501          ORR      r5,r5,#1              ;1993
00006c  6005              STR      r5,[r0,#0]            ;1993
                  |L24.110|
00006e  6820              LDR      r0,[r4,#0]            ;1997
000070  6805              LDR      r5,[r0,#0]            ;1997
000072  f4256500          BIC      r5,r5,#0x800          ;1997
000076  6005              STR      r5,[r0,#0]            ;1997
000078  2021              MOVS     r0,#0x21              ;1999
00007a  f884003d          STRB     r0,[r4,#0x3d]         ;1999
00007e  2010              MOVS     r0,#0x10              ;2000
000080  f884003e          STRB     r0,[r4,#0x3e]         ;2000
000084  6426              STR      r6,[r4,#0x40]         ;2001
000086  6262              STR      r2,[r4,#0x24]         ;2004
000088  8563              STRH     r3,[r4,#0x2a]         ;2005
00008a  4822              LDR      r0,|L24.276|
00008c  62e0              STR      r0,[r4,#0x2c]         ;2006
00008e  8d60              LDRH     r0,[r4,#0x2a]         ;2007
000090  8520              STRH     r0,[r4,#0x28]         ;2007
000092  6461              STR      r1,[r4,#0x44]         ;2008
000094  8d20              LDRH     r0,[r4,#0x28]         ;2010
000096  b338              CBZ      r0,|L24.232|
000098  6b61              LDR      r1,[r4,#0x34]         ;2013
00009a  481f              LDR      r0,|L24.280|
00009c  6288              STR      r0,[r1,#0x28]         ;2013
00009e  6b61              LDR      r1,[r4,#0x34]         ;2016
0000a0  481e              LDR      r0,|L24.284|
0000a2  6308              STR      r0,[r1,#0x30]         ;2016
0000a4  6b60              LDR      r0,[r4,#0x34]         ;2019
0000a6  62c6              STR      r6,[r0,#0x2c]         ;2019
0000a8  6b60              LDR      r0,[r4,#0x34]         ;2020
0000aa  6346              STR      r6,[r0,#0x34]         ;2020
0000ac  6822              LDR      r2,[r4,#0]            ;2023
0000ae  8d23              LDRH     r3,[r4,#0x28]         ;2023
0000b0  3210              ADDS     r2,r2,#0x10           ;2023
0000b2  6a61              LDR      r1,[r4,#0x24]         ;2023
0000b4  6b60              LDR      r0,[r4,#0x34]         ;2023
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6820              LDR      r0,[r4,#0]            ;2026
0000bc  6801              LDR      r1,[r0,#0]            ;2026
0000be  f4416180          ORR      r1,r1,#0x400          ;2026
0000c2  6001              STR      r1,[r0,#0]            ;2026
0000c4  6820              LDR      r0,[r4,#0]            ;2029
0000c6  6801              LDR      r1,[r0,#0]            ;2029
0000c8  f4417180          ORR      r1,r1,#0x100          ;2029
0000cc  6001              STR      r1,[r0,#0]            ;2029
0000ce  f884603c          STRB     r6,[r4,#0x3c]         ;2032
0000d2  6820              LDR      r0,[r4,#0]            ;2039
0000d4  6841              LDR      r1,[r0,#4]            ;2039
0000d6  f4417140          ORR      r1,r1,#0x300          ;2039
0000da  6041              STR      r1,[r0,#4]            ;2039
0000dc  6820              LDR      r0,[r4,#0]            ;2042
0000de  6841              LDR      r1,[r0,#4]            ;2042
0000e0  f4416100          ORR      r1,r1,#0x800          ;2042
0000e4  6041              STR      r1,[r0,#4]            ;2042
0000e6  e010              B        |L24.266|
                  |L24.232|
0000e8  6820              LDR      r0,[r4,#0]            ;2047
0000ea  6801              LDR      r1,[r0,#0]            ;2047
0000ec  f4416180          ORR      r1,r1,#0x400          ;2047
0000f0  6001              STR      r1,[r0,#0]            ;2047
0000f2  6820              LDR      r0,[r4,#0]            ;2050
0000f4  6801              LDR      r1,[r0,#0]            ;2050
0000f6  f4417180          ORR      r1,r1,#0x100          ;2050
0000fa  6001              STR      r1,[r0,#0]            ;2050
0000fc  f884603c          STRB     r6,[r4,#0x3c]         ;2053
000100  6820              LDR      r0,[r4,#0]            ;2060
000102  6841              LDR      r1,[r0,#4]            ;2060
000104  f44161e0          ORR      r1,r1,#0x700          ;2060
000108  6041              STR      r1,[r0,#4]            ;2060
                  |L24.266|
00010a  2000              MOVS     r0,#0                 ;2063
00010c  bdf8              POP      {r3-r7,pc}
;;;2070   
                          ENDP

00010e  0000              DCW      0x0000
                  |L24.272|
                          DCD      SystemCoreClock
                  |L24.276|
                          DCD      0xffff0000
                  |L24.280|
                          DCD      I2C_DMAXferCplt
                  |L24.284|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1238     */
;;;1239   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b578              PUSH     {r3-r6,lr}
;;;1240   {
;;;1241     __IO uint32_t count = 0U;
000002  2600              MOVS     r6,#0
000004  9600              STR      r6,[sp,#0]
;;;1242   
;;;1243     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f890403d          LDRB     r4,[r0,#0x3d]
00000a  2c20              CMP      r4,#0x20
00000c  d001              BEQ      |L25.18|
;;;1244     {
;;;1245       /* Wait until BUSY flag is reset */
;;;1246       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1247       do
;;;1248       {
;;;1249         if(count-- == 0U)
;;;1250         {
;;;1251           hi2c->PreviousState = I2C_STATE_NONE;
;;;1252           hi2c->State= HAL_I2C_STATE_READY;
;;;1253   
;;;1254           /* Process Unlocked */
;;;1255           __HAL_UNLOCK(hi2c);
;;;1256   
;;;1257           return HAL_TIMEOUT;
;;;1258         }
;;;1259       }
;;;1260       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1261   
;;;1262       /* Process Locked */
;;;1263       __HAL_LOCK(hi2c);
;;;1264       
;;;1265       /* Check if the I2C is already enabled */
;;;1266       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1267       {
;;;1268         /* Enable I2C peripheral */
;;;1269         __HAL_I2C_ENABLE(hi2c);
;;;1270       }
;;;1271   
;;;1272       /* Disable Pos */
;;;1273       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1274   
;;;1275       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1276       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;1277       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1278   
;;;1279       /* Prepare transfer parameters */
;;;1280       hi2c->pBuffPtr    = pData;
;;;1281       hi2c->XferCount   = Size;
;;;1282       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1283       hi2c->XferSize    = hi2c->XferCount;
;;;1284       hi2c->Devaddress  = DevAddress;
;;;1285   
;;;1286       /* Generate Start */
;;;1287       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;1288   
;;;1289       /* Process Unlocked */
;;;1290       __HAL_UNLOCK(hi2c);
;;;1291   
;;;1292       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1293                 to avoid the risk of I2C interrupt handle execution before current
;;;1294                 process unlock */
;;;1295       /* Enable EVT, BUF and ERR interrupt */
;;;1296       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1297   
;;;1298       return HAL_OK;
;;;1299     }
;;;1300     else
;;;1301     {
;;;1302       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;1303     }
;;;1304   }
000010  bd78              POP      {r3-r6,pc}
                  |L25.18|
000012  4c27              LDR      r4,|L25.176|
000014  f24615a8          MOV      r5,#0x61a8            ;1246
000018  6824              LDR      r4,[r4,#0]            ;1246  ; SystemCoreClock
00001a  fbb4f4f5          UDIV     r4,r4,r5              ;1246
00001e  eb0405c4          ADD      r5,r4,r4,LSL #3       ;1246
000022  eb051404          ADD      r4,r5,r4,LSL #4       ;1246
000026  9400              STR      r4,[sp,#0]            ;1246
                  |L25.40|
000028  9c00              LDR      r4,[sp,#0]            ;1249
00002a  1e65              SUBS     r5,r4,#1              ;1249
00002c  9500              STR      r5,[sp,#0]            ;1249
00002e  d206              BCS      |L25.62|
000030  f8406f30          STR      r6,[r0,#0x30]!        ;1251
000034  2120              MOVS     r1,#0x20              ;1252
000036  7341              STRB     r1,[r0,#0xd]          ;1252
000038  7306              STRB     r6,[r0,#0xc]          ;1255
00003a  2003              MOVS     r0,#3                 ;1257
00003c  bd78              POP      {r3-r6,pc}
                  |L25.62|
00003e  6804              LDR      r4,[r0,#0]            ;1260
000040  69a4              LDR      r4,[r4,#0x18]         ;1260
000042  43e4              MVNS     r4,r4                 ;1260
000044  07a4              LSLS     r4,r4,#30             ;1260
000046  d5ef              BPL      |L25.40|
000048  f890403c          LDRB     r4,[r0,#0x3c]         ;1263
00004c  2c01              CMP      r4,#1                 ;1263
00004e  d007              BEQ      |L25.96|
000050  2401              MOVS     r4,#1                 ;1263
000052  f880403c          STRB     r4,[r0,#0x3c]         ;1263
000056  6804              LDR      r4,[r0,#0]            ;1266
000058  6825              LDR      r5,[r4,#0]            ;1266
00005a  07ed              LSLS     r5,r5,#31             ;1266
00005c  d002              BEQ      |L25.100|
00005e  e005              B        |L25.108|
                  |L25.96|
000060  2002              MOVS     r0,#2                 ;1263
000062  bd78              POP      {r3-r6,pc}
                  |L25.100|
000064  6825              LDR      r5,[r4,#0]            ;1269
000066  f0450501          ORR      r5,r5,#1              ;1269
00006a  6025              STR      r5,[r4,#0]            ;1269
                  |L25.108|
00006c  6804              LDR      r4,[r0,#0]            ;1273
00006e  6825              LDR      r5,[r4,#0]            ;1273
000070  f4256500          BIC      r5,r5,#0x800          ;1273
000074  6025              STR      r5,[r4,#0]            ;1273
000076  2421              MOVS     r4,#0x21              ;1275
000078  f880403d          STRB     r4,[r0,#0x3d]         ;1275
00007c  2410              MOVS     r4,#0x10              ;1276
00007e  f880403e          STRB     r4,[r0,#0x3e]         ;1276
000082  6406              STR      r6,[r0,#0x40]         ;1277
000084  6242              STR      r2,[r0,#0x24]         ;1280
000086  8543              STRH     r3,[r0,#0x2a]         ;1281
000088  4a0a              LDR      r2,|L25.180|
00008a  62c2              STR      r2,[r0,#0x2c]         ;1282
00008c  8d42              LDRH     r2,[r0,#0x2a]         ;1283
00008e  8502              STRH     r2,[r0,#0x28]         ;1283
000090  6441              STR      r1,[r0,#0x44]         ;1284
000092  6801              LDR      r1,[r0,#0]            ;1287
000094  680a              LDR      r2,[r1,#0]            ;1287
000096  f4427280          ORR      r2,r2,#0x100          ;1287
00009a  600a              STR      r2,[r1,#0]            ;1287
00009c  f880603c          STRB     r6,[r0,#0x3c]         ;1290
0000a0  6800              LDR      r0,[r0,#0]            ;1296
0000a2  6841              LDR      r1,[r0,#4]            ;1296
0000a4  f44161e0          ORR      r1,r1,#0x700          ;1296
0000a8  6041              STR      r1,[r0,#4]            ;1296
0000aa  2000              MOVS     r0,#0                 ;1298
0000ac  bd78              POP      {r3-r6,pc}
;;;1305   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L25.176|
                          DCD      SystemCoreClock
                  |L25.180|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;3711     */
;;;3712   __WEAK void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3713   {
;;;3714     /* Prevent unused argument(s) compilation warning */
;;;3715     UNUSED(hi2c);
;;;3716   
;;;3717     /* NOTE : This function should not be modified, when the callback is needed,
;;;3718               the HAL_I2C_MemRxCpltCallback can be implemented in the user file
;;;3719      */
;;;3720   }
;;;3721   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;3695     */
;;;3696   __WEAK void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3697   {
;;;3698     /* Prevent unused argument(s) compilation warning */
;;;3699     UNUSED(hi2c);
;;;3700   
;;;3701     /* NOTE : This function should not be modified, when the callback is needed,
;;;3702               the HAL_I2C_MemTxCpltCallback can be implemented in the user file
;;;3703      */
;;;3704   }
;;;3705   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;2572     */
;;;2573   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2574   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  e9dd9811          LDRD     r9,r8,[sp,#0x44]
00000c  468a              MOV      r10,r1
00000e  4693              MOV      r11,r2
000010  9f10              LDR      r7,[sp,#0x40]
;;;2575     uint32_t tickstart = 0x00U;
;;;2576   
;;;2577     /* Init tickstart for timeout management*/
;;;2578     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2579     
;;;2580     /* Check the parameters */
;;;2581     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2582   
;;;2583     if(hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d003              BEQ      |L28.40|
;;;2584     {
;;;2585       /* Wait until BUSY flag is reset */
;;;2586       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;2587       {
;;;2588         return HAL_BUSY;
;;;2589       }
;;;2590   
;;;2591       /* Process Locked */
;;;2592       __HAL_LOCK(hi2c);
;;;2593       
;;;2594       /* Check if the I2C is already enabled */
;;;2595       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2596       {
;;;2597         /* Enable I2C peripheral */
;;;2598         __HAL_I2C_ENABLE(hi2c);
;;;2599       }
;;;2600   
;;;2601       /* Disable Pos */
;;;2602       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2603   
;;;2604       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2605       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2606       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2607   
;;;2608       /* Prepare transfer parameters */
;;;2609       hi2c->pBuffPtr    = pData;
;;;2610       hi2c->XferCount   = Size;
;;;2611       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2612       hi2c->XferSize    = hi2c->XferCount;
;;;2613   
;;;2614       /* Send Slave Address and Memory Address */
;;;2615       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2616       {
;;;2617         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2618         {
;;;2619           /* Process Unlocked */
;;;2620           __HAL_UNLOCK(hi2c);
;;;2621           return HAL_ERROR;
;;;2622         }
;;;2623         else
;;;2624         {
;;;2625           /* Process Unlocked */
;;;2626           __HAL_UNLOCK(hi2c);
;;;2627           return HAL_TIMEOUT;
;;;2628         }
;;;2629       }
;;;2630   
;;;2631       if(hi2c->XferSize == 0U)
;;;2632       {
;;;2633         /* Clear ADDR flag */
;;;2634         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2635         
;;;2636         /* Generate Stop */
;;;2637         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2638       }
;;;2639       else if(hi2c->XferSize == 1U)
;;;2640       {
;;;2641         /* Disable Acknowledge */
;;;2642         hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;2643   
;;;2644         /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;2645            software sequence must complete before the current byte end of transfer */
;;;2646         __disable_irq();
;;;2647   
;;;2648         /* Clear ADDR flag */
;;;2649         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2650   
;;;2651         /* Generate Stop */
;;;2652         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2653   
;;;2654         /* Re-enable IRQs */
;;;2655         __enable_irq();
;;;2656       }
;;;2657       else if(hi2c->XferSize == 2U)
;;;2658       {
;;;2659         /* Enable Pos */
;;;2660         hi2c->Instance->CR1 |= I2C_CR1_POS;
;;;2661   
;;;2662         /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;2663            software sequence must complete before the current byte end of transfer */
;;;2664         __disable_irq();
;;;2665   
;;;2666         /* Clear ADDR flag */
;;;2667         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2668         
;;;2669         /* Disable Acknowledge */
;;;2670         hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;2671         
;;;2672          /* Re-enable IRQs */
;;;2673          __enable_irq(); 
;;;2674       }
;;;2675       else
;;;2676       {
;;;2677         /* Enable Acknowledge */
;;;2678         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2679   
;;;2680         /* Clear ADDR flag */
;;;2681         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2682       }
;;;2683   
;;;2684       while(hi2c->XferSize > 0U)
;;;2685       {
;;;2686         if(hi2c->XferSize <= 3U)
;;;2687         {
;;;2688           /* One byte */
;;;2689           if(hi2c->XferSize== 1U)
;;;2690           {
;;;2691             /* Wait until RXNE flag is set */
;;;2692             if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
;;;2693             {
;;;2694               if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;2695               {
;;;2696                 return HAL_TIMEOUT;
;;;2697               }
;;;2698               else
;;;2699               {
;;;2700                 return HAL_ERROR;
;;;2701               }
;;;2702             }
;;;2703   
;;;2704             /* Read data from DR */
;;;2705             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2706             hi2c->XferSize--;
;;;2707             hi2c->XferCount--;
;;;2708           }
;;;2709           /* Two bytes */
;;;2710           else if(hi2c->XferSize == 2U)
;;;2711           {
;;;2712             /* Wait until BTF flag is set */
;;;2713             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2714             {
;;;2715               return HAL_TIMEOUT;
;;;2716             }
;;;2717   
;;;2718             /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;2719                software sequence must complete before the current byte end of transfer */
;;;2720              __disable_irq();
;;;2721   
;;;2722             /* Generate Stop */
;;;2723             hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2724   
;;;2725             /* Read data from DR */
;;;2726             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2727             hi2c->XferSize--;
;;;2728             hi2c->XferCount--;
;;;2729   
;;;2730             /* Re-enable IRQs */
;;;2731             __enable_irq();
;;;2732   
;;;2733             /* Read data from DR */
;;;2734             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2735             hi2c->XferSize--;
;;;2736             hi2c->XferCount--;
;;;2737           }
;;;2738           /* 3 Last bytes */
;;;2739           else
;;;2740           {
;;;2741             /* Wait until BTF flag is set */
;;;2742             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2743             {
;;;2744               return HAL_TIMEOUT;
;;;2745             }
;;;2746   
;;;2747             /* Disable Acknowledge */
;;;2748             hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;2749   
;;;2750             /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;2751                software sequence must complete before the current byte end of transfer */
;;;2752             __disable_irq();
;;;2753   
;;;2754             /* Read data from DR */
;;;2755             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2756             hi2c->XferSize--;
;;;2757             hi2c->XferCount--;
;;;2758   
;;;2759             /* Wait until BTF flag is set */
;;;2760             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
;;;2761             {
;;;2762               return HAL_TIMEOUT;
;;;2763             }
;;;2764   
;;;2765             /* Generate Stop */
;;;2766             hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2767   
;;;2768             /* Read data from DR */
;;;2769             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2770             hi2c->XferSize--;
;;;2771             hi2c->XferCount--;
;;;2772   
;;;2773             /* Re-enable IRQs */
;;;2774             __enable_irq();
;;;2775   
;;;2776             /* Read data from DR */
;;;2777             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2778             hi2c->XferSize--;
;;;2779             hi2c->XferCount--;
;;;2780           }
;;;2781         }
;;;2782         else
;;;2783         {
;;;2784           /* Wait until RXNE flag is set */
;;;2785           if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2786           {
;;;2787             if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;2788             {
;;;2789               return HAL_TIMEOUT;
;;;2790             }
;;;2791             else
;;;2792             {
;;;2793               return HAL_ERROR;
;;;2794             }
;;;2795           }
;;;2796   
;;;2797           /* Read data from DR */
;;;2798           (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2799           hi2c->XferSize--;
;;;2800           hi2c->XferCount--;
;;;2801   
;;;2802           if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;2803           {
;;;2804             /* Read data from DR */
;;;2805             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;2806             hi2c->XferSize--;
;;;2807             hi2c->XferCount--;
;;;2808           }
;;;2809         }
;;;2810       }
;;;2811   
;;;2812       hi2c->State = HAL_I2C_STATE_READY;
;;;2813       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2814       
;;;2815       /* Process Unlocked */
;;;2816       __HAL_UNLOCK(hi2c);
;;;2817   
;;;2818       return HAL_OK;
;;;2819     }
;;;2820     else
;;;2821     {
;;;2822       return HAL_BUSY;
000020  2002              MOVS     r0,#2
                  |L28.34|
;;;2823     }
;;;2824   }
000022  b007              ADD      sp,sp,#0x1c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.40|
000028  2319              MOVS     r3,#0x19              ;2586
00002a  2201              MOVS     r2,#1                 ;2586
00002c  49a0              LDR      r1,|L28.688|
00002e  4620              MOV      r0,r4                 ;2586
000030  9500              STR      r5,[sp,#0]            ;2586
000032  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000036  b108              CBZ      r0,|L28.60|
000038  2002              MOVS     r0,#2                 ;2588
00003a  e7f2              B        |L28.34|
                  |L28.60|
00003c  f894003c          LDRB     r0,[r4,#0x3c]         ;2592
000040  2801              CMP      r0,#1                 ;2592
000042  d007              BEQ      |L28.84|
000044  2001              MOVS     r0,#1                 ;2592
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2592
00004a  6820              LDR      r0,[r4,#0]            ;2595
00004c  6801              LDR      r1,[r0,#0]            ;2595
00004e  07c9              LSLS     r1,r1,#31             ;2595
000050  d002              BEQ      |L28.88|
000052  e005              B        |L28.96|
                  |L28.84|
000054  2002              MOVS     r0,#2                 ;2592
000056  e7e4              B        |L28.34|
                  |L28.88|
000058  6801              LDR      r1,[r0,#0]            ;2598
00005a  f0410101          ORR      r1,r1,#1              ;2598
00005e  6001              STR      r1,[r0,#0]            ;2598
                  |L28.96|
000060  6820              LDR      r0,[r4,#0]            ;2602
000062  6801              LDR      r1,[r0,#0]            ;2602
000064  f4216100          BIC      r1,r1,#0x800          ;2602
000068  6001              STR      r1,[r0,#0]            ;2602
00006a  2022              MOVS     r0,#0x22              ;2604
00006c  f884003d          STRB     r0,[r4,#0x3d]         ;2604
000070  2040              MOVS     r0,#0x40              ;2605
000072  f884003e          STRB     r0,[r4,#0x3e]         ;2605
000076  2600              MOVS     r6,#0                 ;2606
000078  6426              STR      r6,[r4,#0x40]         ;2606
00007a  6267              STR      r7,[r4,#0x24]         ;2609
00007c  f8a4902a          STRH     r9,[r4,#0x2a]         ;2610
000080  488c              LDR      r0,|L28.692|
000082  62e0              STR      r0,[r4,#0x2c]         ;2611
000084  8d60              LDRH     r0,[r4,#0x2a]         ;2612
000086  8520              STRH     r0,[r4,#0x28]         ;2612
000088  e9cd8500          STRD     r8,r5,[sp,#0]         ;2615
00008c  465a              MOV      r2,r11                ;2615
00008e  4651              MOV      r1,r10                ;2615
000090  4620              MOV      r0,r4                 ;2615
000092  9b06              LDR      r3,[sp,#0x18]         ;2615
000094  f7fffffe          BL       I2C_RequestMemoryRead
000098  b150              CBZ      r0,|L28.176|
00009a  6c20              LDR      r0,[r4,#0x40]         ;2617
00009c  2804              CMP      r0,#4                 ;2617
00009e  d003              BEQ      |L28.168|
0000a0  f884603c          STRB     r6,[r4,#0x3c]         ;2626
0000a4  2003              MOVS     r0,#3                 ;2627
0000a6  e7bc              B        |L28.34|
                  |L28.168|
0000a8  f884603c          STRB     r6,[r4,#0x3c]         ;2620
0000ac  2001              MOVS     r0,#1                 ;2621
0000ae  e7b8              B        |L28.34|
                  |L28.176|
0000b0  8d20              LDRH     r0,[r4,#0x28]         ;2631
0000b2  b170              CBZ      r0,|L28.210|
0000b4  2801              CMP      r0,#1                 ;2639
0000b6  d015              BEQ      |L28.228|
0000b8  2802              CMP      r0,#2                 ;2657
0000ba  d023              BEQ      |L28.260|
0000bc  6820              LDR      r0,[r4,#0]            ;2678
0000be  6801              LDR      r1,[r0,#0]            ;2678
0000c0  f4416180          ORR      r1,r1,#0x400          ;2678
0000c4  6001              STR      r1,[r0,#0]            ;2678
0000c6  6820              LDR      r0,[r4,#0]            ;2681
0000c8  6941              LDR      r1,[r0,#0x14]         ;2681
0000ca  6980              LDR      r0,[r0,#0x18]         ;2681
0000cc  9002              STR      r0,[sp,#8]            ;2681
                  |L28.206|
0000ce  4f7a              LDR      r7,|L28.696|
0000d0  e0e3              B        |L28.666|
                  |L28.210|
0000d2  6820              LDR      r0,[r4,#0]            ;2634
0000d4  6941              LDR      r1,[r0,#0x14]         ;2634
0000d6  6981              LDR      r1,[r0,#0x18]         ;2634
0000d8  9102              STR      r1,[sp,#8]            ;2634
0000da  6801              LDR      r1,[r0,#0]            ;2637
0000dc  f4417100          ORR      r1,r1,#0x200          ;2637
0000e0  6001              STR      r1,[r0,#0]            ;2637
0000e2  e7f4              B        |L28.206|
                  |L28.228|
0000e4  6820              LDR      r0,[r4,#0]            ;2642
0000e6  6801              LDR      r1,[r0,#0]            ;2642
0000e8  f4216180          BIC      r1,r1,#0x400          ;2642
0000ec  6001              STR      r1,[r0,#0]            ;2642
0000ee  b672              CPSID    i                     ;2646
0000f0  6820              LDR      r0,[r4,#0]            ;2649
0000f2  6941              LDR      r1,[r0,#0x14]         ;2649
0000f4  6981              LDR      r1,[r0,#0x18]         ;2649
0000f6  9102              STR      r1,[sp,#8]            ;2649
0000f8  6801              LDR      r1,[r0,#0]            ;2652
0000fa  f4417100          ORR      r1,r1,#0x200          ;2652
0000fe  6001              STR      r1,[r0,#0]            ;2652
000100  b662              CPSIE    i                     ;2655
000102  e7e4              B        |L28.206|
                  |L28.260|
000104  6820              LDR      r0,[r4,#0]            ;2660
000106  6801              LDR      r1,[r0,#0]            ;2660
000108  f4416100          ORR      r1,r1,#0x800          ;2660
00010c  6001              STR      r1,[r0,#0]            ;2660
00010e  b672              CPSID    i                     ;2664
000110  6820              LDR      r0,[r4,#0]            ;2667
000112  6941              LDR      r1,[r0,#0x14]         ;2667
000114  6981              LDR      r1,[r0,#0x18]         ;2667
000116  9102              STR      r1,[sp,#8]            ;2667
000118  6801              LDR      r1,[r0,#0]            ;2670
00011a  f4216180          BIC      r1,r1,#0x400          ;2670
00011e  6001              STR      r1,[r0,#0]            ;2670
000120  b662              CPSIE    i                     ;2673
000122  e7d4              B        |L28.206|
                  |L28.292|
000124  2803              CMP      r0,#3                 ;2686
000126  d86f              BHI      |L28.520|
000128  2801              CMP      r0,#1                 ;2689
00012a  d00b              BEQ      |L28.324|
00012c  2802              CMP      r0,#2                 ;2710
00012e  d023              BEQ      |L28.376|
000130  4643              MOV      r3,r8                 ;2742
000132  2200              MOVS     r2,#0                 ;2742
000134  4639              MOV      r1,r7                 ;2742
000136  4620              MOV      r0,r4                 ;2742
000138  9500              STR      r5,[sp,#0]            ;2742
00013a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00013e  b3e8              CBZ      r0,|L28.444|
000140  2003              MOVS     r0,#3                 ;2744
000142  e76e              B        |L28.34|
                  |L28.324|
000144  462a              MOV      r2,r5                 ;2692
000146  4641              MOV      r1,r8                 ;2692
000148  4620              MOV      r0,r4                 ;2692
00014a  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00014e  b130              CBZ      r0,|L28.350|
000150  6c20              LDR      r0,[r4,#0x40]         ;2694
000152  2820              CMP      r0,#0x20              ;2694
000154  d001              BEQ      |L28.346|
000156  2001              MOVS     r0,#1                 ;2700
000158  e763              B        |L28.34|
                  |L28.346|
00015a  2003              MOVS     r0,#3                 ;2696
00015c  e761              B        |L28.34|
                  |L28.350|
00015e  6820              LDR      r0,[r4,#0]            ;2705
000160  6901              LDR      r1,[r0,#0x10]         ;2705
000162  6a60              LDR      r0,[r4,#0x24]         ;2705
000164  1c42              ADDS     r2,r0,#1              ;2705
000166  6262              STR      r2,[r4,#0x24]         ;2705
000168  7001              STRB     r1,[r0,#0]            ;2705
00016a  8d20              LDRH     r0,[r4,#0x28]         ;2706
00016c  1e40              SUBS     r0,r0,#1              ;2706
00016e  8520              STRH     r0,[r4,#0x28]         ;2706
000170  8d60              LDRH     r0,[r4,#0x2a]         ;2707
000172  1e40              SUBS     r0,r0,#1              ;2707
000174  8560              STRH     r0,[r4,#0x2a]         ;2707
000176  e090              B        |L28.666|
                  |L28.376|
000178  4643              MOV      r3,r8                 ;2713
00017a  2200              MOVS     r2,#0                 ;2713
00017c  4639              MOV      r1,r7                 ;2713
00017e  4620              MOV      r0,r4                 ;2713
000180  9500              STR      r5,[sp,#0]            ;2713
000182  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000186  b108              CBZ      r0,|L28.396|
000188  2003              MOVS     r0,#3                 ;2715
00018a  e74a              B        |L28.34|
                  |L28.396|
00018c  b672              CPSID    i                     ;2720
00018e  6820              LDR      r0,[r4,#0]            ;2723
000190  6801              LDR      r1,[r0,#0]            ;2723
000192  f4417100          ORR      r1,r1,#0x200          ;2723
000196  6001              STR      r1,[r0,#0]            ;2723
000198  6820              LDR      r0,[r4,#0]            ;2726
00019a  6901              LDR      r1,[r0,#0x10]         ;2726
00019c  6a60              LDR      r0,[r4,#0x24]         ;2726
00019e  1c42              ADDS     r2,r0,#1              ;2726
0001a0  6262              STR      r2,[r4,#0x24]         ;2726
0001a2  7001              STRB     r1,[r0,#0]            ;2726
0001a4  8d20              LDRH     r0,[r4,#0x28]         ;2727
0001a6  1e40              SUBS     r0,r0,#1              ;2727
0001a8  8520              STRH     r0,[r4,#0x28]         ;2727
0001aa  8d60              LDRH     r0,[r4,#0x2a]         ;2728
0001ac  1e40              SUBS     r0,r0,#1              ;2728
0001ae  8560              STRH     r0,[r4,#0x2a]         ;2728
0001b0  b662              CPSIE    i                     ;2731
0001b2  6820              LDR      r0,[r4,#0]            ;2734
0001b4  6901              LDR      r1,[r0,#0x10]         ;2734
0001b6  6a60              LDR      r0,[r4,#0x24]         ;2734
0001b8  1c42              ADDS     r2,r0,#1              ;2734
0001ba  e000              B        |L28.446|
                  |L28.444|
0001bc  e008              B        |L28.464|
                  |L28.446|
0001be  6262              STR      r2,[r4,#0x24]         ;2734
0001c0  7001              STRB     r1,[r0,#0]            ;2734
0001c2  8d20              LDRH     r0,[r4,#0x28]         ;2735
0001c4  1e40              SUBS     r0,r0,#1              ;2735
0001c6  8520              STRH     r0,[r4,#0x28]         ;2735
0001c8  8d60              LDRH     r0,[r4,#0x2a]         ;2736
0001ca  1e40              SUBS     r0,r0,#1              ;2736
0001cc  8560              STRH     r0,[r4,#0x2a]         ;2736
0001ce  e064              B        |L28.666|
                  |L28.464|
0001d0  6820              LDR      r0,[r4,#0]            ;2748
0001d2  6801              LDR      r1,[r0,#0]            ;2748
0001d4  f4216180          BIC      r1,r1,#0x400          ;2748
0001d8  6001              STR      r1,[r0,#0]            ;2748
0001da  b672              CPSID    i                     ;2752
0001dc  6820              LDR      r0,[r4,#0]            ;2755
0001de  6901              LDR      r1,[r0,#0x10]         ;2755
0001e0  6a60              LDR      r0,[r4,#0x24]         ;2755
0001e2  1c42              ADDS     r2,r0,#1              ;2755
0001e4  6262              STR      r2,[r4,#0x24]         ;2755
0001e6  7001              STRB     r1,[r0,#0]            ;2755
0001e8  8d20              LDRH     r0,[r4,#0x28]         ;2756
0001ea  1e40              SUBS     r0,r0,#1              ;2756
0001ec  8520              STRH     r0,[r4,#0x28]         ;2756
0001ee  8d60              LDRH     r0,[r4,#0x2a]         ;2757
0001f0  1e40              SUBS     r0,r0,#1              ;2757
0001f2  8560              STRH     r0,[r4,#0x2a]         ;2757
0001f4  4643              MOV      r3,r8                 ;2760
0001f6  2200              MOVS     r2,#0                 ;2760
0001f8  4639              MOV      r1,r7                 ;2760
0001fa  4620              MOV      r0,r4                 ;2760
0001fc  9500              STR      r5,[sp,#0]            ;2760
0001fe  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000202  b110              CBZ      r0,|L28.522|
000204  2003              MOVS     r0,#3                 ;2762
000206  e70c              B        |L28.34|
                  |L28.520|
000208  e01e              B        |L28.584|
                  |L28.522|
00020a  6820              LDR      r0,[r4,#0]            ;2766
00020c  6801              LDR      r1,[r0,#0]            ;2766
00020e  f4417100          ORR      r1,r1,#0x200          ;2766
000212  6001              STR      r1,[r0,#0]            ;2766
000214  6820              LDR      r0,[r4,#0]            ;2769
000216  6901              LDR      r1,[r0,#0x10]         ;2769
000218  6a60              LDR      r0,[r4,#0x24]         ;2769
00021a  1c42              ADDS     r2,r0,#1              ;2769
00021c  6262              STR      r2,[r4,#0x24]         ;2769
00021e  7001              STRB     r1,[r0,#0]            ;2769
000220  8d20              LDRH     r0,[r4,#0x28]         ;2770
000222  1e40              SUBS     r0,r0,#1              ;2770
000224  8520              STRH     r0,[r4,#0x28]         ;2770
000226  8d60              LDRH     r0,[r4,#0x2a]         ;2771
000228  1e40              SUBS     r0,r0,#1              ;2771
00022a  8560              STRH     r0,[r4,#0x2a]         ;2771
00022c  b662              CPSIE    i                     ;2774
00022e  6820              LDR      r0,[r4,#0]            ;2777
000230  6901              LDR      r1,[r0,#0x10]         ;2777
000232  6a60              LDR      r0,[r4,#0x24]         ;2777
000234  1c42              ADDS     r2,r0,#1              ;2777
000236  6262              STR      r2,[r4,#0x24]         ;2777
000238  7001              STRB     r1,[r0,#0]            ;2777
00023a  8d20              LDRH     r0,[r4,#0x28]         ;2778
00023c  1e40              SUBS     r0,r0,#1              ;2778
00023e  8520              STRH     r0,[r4,#0x28]         ;2778
000240  8d60              LDRH     r0,[r4,#0x2a]         ;2779
000242  1e40              SUBS     r0,r0,#1              ;2779
000244  8560              STRH     r0,[r4,#0x2a]         ;2779
000246  e028              B        |L28.666|
                  |L28.584|
000248  462a              MOV      r2,r5                 ;2785
00024a  4641              MOV      r1,r8                 ;2785
00024c  4620              MOV      r0,r4                 ;2785
00024e  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000252  b130              CBZ      r0,|L28.610|
000254  6c20              LDR      r0,[r4,#0x40]         ;2787
000256  2820              CMP      r0,#0x20              ;2787
000258  d001              BEQ      |L28.606|
00025a  2001              MOVS     r0,#1                 ;2793
00025c  e6e1              B        |L28.34|
                  |L28.606|
00025e  2003              MOVS     r0,#3                 ;2789
000260  e6df              B        |L28.34|
                  |L28.610|
000262  6820              LDR      r0,[r4,#0]            ;2798
000264  6901              LDR      r1,[r0,#0x10]         ;2798
000266  6a60              LDR      r0,[r4,#0x24]         ;2798
000268  1c42              ADDS     r2,r0,#1              ;2798
00026a  6262              STR      r2,[r4,#0x24]         ;2798
00026c  7001              STRB     r1,[r0,#0]            ;2798
00026e  8d20              LDRH     r0,[r4,#0x28]         ;2799
000270  1e40              SUBS     r0,r0,#1              ;2799
000272  8520              STRH     r0,[r4,#0x28]         ;2799
000274  8d60              LDRH     r0,[r4,#0x2a]         ;2800
000276  1e40              SUBS     r0,r0,#1              ;2800
000278  8560              STRH     r0,[r4,#0x2a]         ;2800
00027a  6820              LDR      r0,[r4,#0]            ;2802
00027c  6941              LDR      r1,[r0,#0x14]         ;2802
00027e  43c9              MVNS     r1,r1                 ;2802
000280  0749              LSLS     r1,r1,#29             ;2802
000282  d40a              BMI      |L28.666|
000284  6901              LDR      r1,[r0,#0x10]         ;2805
000286  6a60              LDR      r0,[r4,#0x24]         ;2805
000288  1c42              ADDS     r2,r0,#1              ;2805
00028a  6262              STR      r2,[r4,#0x24]         ;2805
00028c  7001              STRB     r1,[r0,#0]            ;2805
00028e  8d20              LDRH     r0,[r4,#0x28]         ;2806
000290  1e40              SUBS     r0,r0,#1              ;2806
000292  8520              STRH     r0,[r4,#0x28]         ;2806
000294  8d60              LDRH     r0,[r4,#0x2a]         ;2807
000296  1e40              SUBS     r0,r0,#1              ;2807
000298  8560              STRH     r0,[r4,#0x2a]         ;2807
                  |L28.666|
00029a  8d20              LDRH     r0,[r4,#0x28]         ;2684
00029c  2800              CMP      r0,#0                 ;2684
00029e  f47faf41          BNE      |L28.292|
0002a2  2020              MOVS     r0,#0x20              ;2812
0002a4  343c              ADDS     r4,r4,#0x3c           ;2812
0002a6  7060              STRB     r0,[r4,#1]            ;2812
0002a8  70a6              STRB     r6,[r4,#2]            ;2813
0002aa  7026              STRB     r6,[r4,#0]            ;2816
0002ac  2000              MOVS     r0,#0                 ;2818
0002ae  e6b8              B        |L28.34|
;;;2825   
                          ENDP

                  |L28.688|
                          DCD      0x00100002
                  |L28.692|
                          DCD      0xffff0000
                  |L28.696|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;3131     */
;;;3132   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3133   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  e9dd9710          LDRD     r9,r7,[sp,#0x40]
00000c  468a              MOV      r10,r1
00000e  4693              MOV      r11,r2
;;;3134     uint32_t tickstart = 0x00U;
;;;3135     __IO uint32_t count = 0U;
000010  2600              MOVS     r6,#0
000012  9602              STR      r6,[sp,#8]
;;;3136   
;;;3137     /* Init tickstart for timeout management*/
;;;3138     tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4605              MOV      r5,r0
;;;3139   
;;;3140     /* Check the parameters */
;;;3141     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3142   
;;;3143     if(hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d003              BEQ      |L29.42|
;;;3144     {
;;;3145       /* Wait until BUSY flag is reset */
;;;3146       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;3147       do
;;;3148       {
;;;3149         if(count-- == 0U)
;;;3150         {
;;;3151           hi2c->PreviousState = I2C_STATE_NONE;
;;;3152           hi2c->State= HAL_I2C_STATE_READY;
;;;3153   
;;;3154           /* Process Unlocked */
;;;3155           __HAL_UNLOCK(hi2c);
;;;3156   
;;;3157           return HAL_TIMEOUT; 
;;;3158         }
;;;3159       }
;;;3160       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3161   
;;;3162       /* Process Locked */
;;;3163       __HAL_LOCK(hi2c);
;;;3164   
;;;3165       /* Check if the I2C is already enabled */
;;;3166       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3167       {
;;;3168         /* Enable I2C peripheral */
;;;3169         __HAL_I2C_ENABLE(hi2c);
;;;3170       }
;;;3171   
;;;3172       /* Disable Pos */
;;;3173       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;3174   
;;;3175       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;3176       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3177       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3178   
;;;3179       /* Prepare transfer parameters */
;;;3180       hi2c->pBuffPtr = pData;
;;;3181       hi2c->XferCount = Size;
;;;3182       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3183       hi2c->XferSize    = hi2c->XferCount;
;;;3184   
;;;3185       if(hi2c->XferSize > 0U)
;;;3186       {
;;;3187         /* Set the I2C DMA transfer complete callback */
;;;3188         hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;3189   
;;;3190         /* Set the DMA error callback */
;;;3191         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;3192   
;;;3193         /* Set the unused DMA callbacks to NULL */
;;;3194         hi2c->hdmarx->XferAbortCallback = NULL;
;;;3195   
;;;3196         /* Enable the DMA channel */
;;;3197         HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;3198   
;;;3199         /* Send Slave Address and Memory Address */
;;;3200         if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3201         {
;;;3202           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3203           {
;;;3204             /* Process Unlocked */
;;;3205             __HAL_UNLOCK(hi2c);
;;;3206             return HAL_ERROR;
;;;3207           }
;;;3208           else
;;;3209           {
;;;3210             /* Process Unlocked */
;;;3211             __HAL_UNLOCK(hi2c);
;;;3212             return HAL_TIMEOUT;
;;;3213           }
;;;3214         }
;;;3215   
;;;3216         if(Size == 1U)
;;;3217         {
;;;3218           /* Disable Acknowledge */
;;;3219           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;3220         }
;;;3221         else
;;;3222         {
;;;3223           /* Enable Last DMA bit */
;;;3224           hi2c->Instance->CR2 |= I2C_CR2_LAST;
;;;3225         }
;;;3226   
;;;3227         /* Clear ADDR flag */
;;;3228         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3229   
;;;3230         /* Process Unlocked */
;;;3231         __HAL_UNLOCK(hi2c);
;;;3232   
;;;3233         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3234                   to avoid the risk of I2C interrupt handle execution before current
;;;3235                   process unlock */
;;;3236         /* Enable ERR interrupt */
;;;3237         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3238         
;;;3239        /* Enable DMA Request */
;;;3240         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;3241       }
;;;3242       else
;;;3243       {
;;;3244         /* Send Slave Address and Memory Address */
;;;3245         if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3246         {
;;;3247           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3248           {
;;;3249             /* Process Unlocked */
;;;3250             __HAL_UNLOCK(hi2c);
;;;3251             return HAL_ERROR;
;;;3252           }
;;;3253           else
;;;3254           {
;;;3255             /* Process Unlocked */
;;;3256             __HAL_UNLOCK(hi2c);
;;;3257             return HAL_TIMEOUT;
;;;3258           }
;;;3259         }
;;;3260   
;;;3261         /* Clear ADDR flag */
;;;3262         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3263   
;;;3264         /* Generate Stop */
;;;3265         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;3266   
;;;3267         hi2c->State = HAL_I2C_STATE_READY;
;;;3268   
;;;3269         /* Process Unlocked */
;;;3270         __HAL_UNLOCK(hi2c);
;;;3271       }
;;;3272   
;;;3273       return HAL_OK;
;;;3274     }
;;;3275     else
;;;3276     {
;;;3277       return HAL_BUSY;
000022  2002              MOVS     r0,#2
                  |L29.36|
;;;3278     }
;;;3279   }
000024  b007              ADD      sp,sp,#0x1c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L29.42|
00002a  4854              LDR      r0,|L29.380|
00002c  f24611a8          MOV      r1,#0x61a8            ;3146
000030  6800              LDR      r0,[r0,#0]            ;3146  ; SystemCoreClock
000032  fbb0f0f1          UDIV     r0,r0,r1              ;3146
000036  eb0001c0          ADD      r1,r0,r0,LSL #3       ;3146
00003a  eb011000          ADD      r0,r1,r0,LSL #4       ;3146
00003e  9002              STR      r0,[sp,#8]            ;3146
000040  f04f0820          MOV      r8,#0x20              ;3152
                  |L29.68|
000044  9802              LDR      r0,[sp,#8]            ;3149
000046  1e41              SUBS     r1,r0,#1              ;3149
000048  9102              STR      r1,[sp,#8]            ;3149
00004a  d206              BCS      |L29.90|
00004c  6326              STR      r6,[r4,#0x30]         ;3151
00004e  f884803d          STRB     r8,[r4,#0x3d]         ;3152
000052  f884603c          STRB     r6,[r4,#0x3c]         ;3155
000056  2003              MOVS     r0,#3                 ;3157
000058  e7e4              B        |L29.36|
                  |L29.90|
00005a  6820              LDR      r0,[r4,#0]            ;3160
00005c  6980              LDR      r0,[r0,#0x18]         ;3160
00005e  43c0              MVNS     r0,r0                 ;3160
000060  0780              LSLS     r0,r0,#30             ;3160
000062  d5ef              BPL      |L29.68|
000064  f894003c          LDRB     r0,[r4,#0x3c]         ;3163
000068  2801              CMP      r0,#1                 ;3163
00006a  d007              BEQ      |L29.124|
00006c  2001              MOVS     r0,#1                 ;3163
00006e  f884003c          STRB     r0,[r4,#0x3c]         ;3163
000072  6820              LDR      r0,[r4,#0]            ;3166
000074  6801              LDR      r1,[r0,#0]            ;3166
000076  07c9              LSLS     r1,r1,#31             ;3166
000078  d002              BEQ      |L29.128|
00007a  e005              B        |L29.136|
                  |L29.124|
00007c  2002              MOVS     r0,#2                 ;3163
00007e  e7d1              B        |L29.36|
                  |L29.128|
000080  6801              LDR      r1,[r0,#0]            ;3169
000082  f0410101          ORR      r1,r1,#1              ;3169
000086  6001              STR      r1,[r0,#0]            ;3169
                  |L29.136|
000088  6820              LDR      r0,[r4,#0]            ;3173
00008a  6801              LDR      r1,[r0,#0]            ;3173
00008c  f4216100          BIC      r1,r1,#0x800          ;3173
000090  6001              STR      r1,[r0,#0]            ;3173
000092  2022              MOVS     r0,#0x22              ;3175
000094  f884003d          STRB     r0,[r4,#0x3d]         ;3175
000098  2040              MOVS     r0,#0x40              ;3176
00009a  f884003e          STRB     r0,[r4,#0x3e]         ;3176
00009e  6426              STR      r6,[r4,#0x40]         ;3177
0000a0  f8c49024          STR      r9,[r4,#0x24]         ;3180
0000a4  8567              STRH     r7,[r4,#0x2a]         ;3181
0000a6  4836              LDR      r0,|L29.384|
0000a8  62e0              STR      r0,[r4,#0x2c]         ;3182
0000aa  8d60              LDRH     r0,[r4,#0x2a]         ;3183
0000ac  8520              STRH     r0,[r4,#0x28]         ;3183
0000ae  8d20              LDRH     r0,[r4,#0x28]         ;3185
0000b0  f04f0923          MOV      r9,#0x23              ;3200
0000b4  b3c8              CBZ      r0,|L29.298|
0000b6  6ba1              LDR      r1,[r4,#0x38]         ;3188
0000b8  4832              LDR      r0,|L29.388|
0000ba  6288              STR      r0,[r1,#0x28]         ;3188
0000bc  6ba1              LDR      r1,[r4,#0x38]         ;3191
0000be  4832              LDR      r0,|L29.392|
0000c0  6308              STR      r0,[r1,#0x30]         ;3191
0000c2  6ba0              LDR      r0,[r4,#0x38]         ;3194
0000c4  6346              STR      r6,[r0,#0x34]         ;3194
0000c6  6821              LDR      r1,[r4,#0]            ;3197
0000c8  8d23              LDRH     r3,[r4,#0x28]         ;3197
0000ca  3110              ADDS     r1,r1,#0x10           ;3197
0000cc  6a62              LDR      r2,[r4,#0x24]         ;3197
0000ce  6ba0              LDR      r0,[r4,#0x38]         ;3197
0000d0  f7fffffe          BL       HAL_DMA_Start_IT
0000d4  e9cd9500          STRD     r9,r5,[sp,#0]         ;3200
0000d8  465a              MOV      r2,r11                ;3200
0000da  4651              MOV      r1,r10                ;3200
0000dc  4620              MOV      r0,r4                 ;3200
0000de  9b06              LDR      r3,[sp,#0x18]         ;3200
0000e0  f7fffffe          BL       I2C_RequestMemoryRead
0000e4  b150              CBZ      r0,|L29.252|
0000e6  6c20              LDR      r0,[r4,#0x40]         ;3202
0000e8  2804              CMP      r0,#4                 ;3202
0000ea  d003              BEQ      |L29.244|
0000ec  f884603c          STRB     r6,[r4,#0x3c]         ;3211
0000f0  2003              MOVS     r0,#3                 ;3212
0000f2  e797              B        |L29.36|
                  |L29.244|
0000f4  f884603c          STRB     r6,[r4,#0x3c]         ;3205
0000f8  2001              MOVS     r0,#1                 ;3206
0000fa  e793              B        |L29.36|
                  |L29.252|
0000fc  2f01              CMP      r7,#1                 ;3216
0000fe  d015              BEQ      |L29.300|
000100  6820              LDR      r0,[r4,#0]            ;3224
000102  6841              LDR      r1,[r0,#4]            ;3224
000104  f4415180          ORR      r1,r1,#0x1000         ;3224
000108  6041              STR      r1,[r0,#4]            ;3224
                  |L29.266|
00010a  6820              LDR      r0,[r4,#0]            ;3228
00010c  6941              LDR      r1,[r0,#0x14]         ;3228
00010e  6981              LDR      r1,[r0,#0x18]         ;3228
000110  9101              STR      r1,[sp,#4]            ;3228
000112  f884603c          STRB     r6,[r4,#0x3c]         ;3231
000116  6841              LDR      r1,[r0,#4]            ;3237
000118  f4417180          ORR      r1,r1,#0x100          ;3237
00011c  6041              STR      r1,[r0,#4]            ;3237
00011e  6820              LDR      r0,[r4,#0]            ;3240
000120  6841              LDR      r1,[r0,#4]            ;3240
000122  f4416100          ORR      r1,r1,#0x800          ;3240
000126  6041              STR      r1,[r0,#4]            ;3240
000128  e026              B        |L29.376|
                  |L29.298|
00012a  e005              B        |L29.312|
                  |L29.300|
00012c  6820              LDR      r0,[r4,#0]            ;3219
00012e  6801              LDR      r1,[r0,#0]            ;3219
000130  f4216180          BIC      r1,r1,#0x400          ;3219
000134  6001              STR      r1,[r0,#0]            ;3219
000136  e7e8              B        |L29.266|
                  |L29.312|
000138  e9cd9500          STRD     r9,r5,[sp,#0]         ;3245
00013c  465a              MOV      r2,r11                ;3245
00013e  4651              MOV      r1,r10                ;3245
000140  4620              MOV      r0,r4                 ;3245
000142  9b06              LDR      r3,[sp,#0x18]         ;3245
000144  f7fffffe          BL       I2C_RequestMemoryRead
000148  b150              CBZ      r0,|L29.352|
00014a  6c20              LDR      r0,[r4,#0x40]         ;3247
00014c  2804              CMP      r0,#4                 ;3247
00014e  d003              BEQ      |L29.344|
000150  f884603c          STRB     r6,[r4,#0x3c]         ;3256
000154  2003              MOVS     r0,#3                 ;3257
000156  e765              B        |L29.36|
                  |L29.344|
000158  f884603c          STRB     r6,[r4,#0x3c]         ;3250
00015c  2001              MOVS     r0,#1                 ;3251
00015e  e761              B        |L29.36|
                  |L29.352|
000160  6820              LDR      r0,[r4,#0]            ;3262
000162  6941              LDR      r1,[r0,#0x14]         ;3262
000164  6981              LDR      r1,[r0,#0x18]         ;3262
000166  9101              STR      r1,[sp,#4]            ;3262
000168  6801              LDR      r1,[r0,#0]            ;3265
00016a  f4417100          ORR      r1,r1,#0x200          ;3265
00016e  6001              STR      r1,[r0,#0]            ;3265
000170  f884803d          STRB     r8,[r4,#0x3d]         ;3267
000174  f884603c          STRB     r6,[r4,#0x3c]         ;3270
                  |L29.376|
000178  2000              MOVS     r0,#0                 ;3273
00017a  e753              B        |L29.36|
;;;3280   
                          ENDP

                  |L29.380|
                          DCD      SystemCoreClock
                  |L29.384|
                          DCD      0xffff0000
                  |L29.388|
                          DCD      I2C_DMAXferCplt
                  |L29.392|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2921     */
;;;2922   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2923   {
000002  e9ddc706          LDRD     r12,r7,[sp,#0x18]
;;;2924     __IO uint32_t count = 0U;
000006  2600              MOVS     r6,#0
000008  9600              STR      r6,[sp,#0]
;;;2925   
;;;2926     /* Check the parameters */
;;;2927     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2928   
;;;2929     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c20              CMP      r4,#0x20
000010  d001              BEQ      |L30.22|
;;;2930     {
;;;2931       /* Wait until BUSY flag is reset */
;;;2932       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;2933       do
;;;2934       {
;;;2935         if(count-- == 0U)
;;;2936         {
;;;2937           hi2c->PreviousState = I2C_STATE_NONE;
;;;2938           hi2c->State= HAL_I2C_STATE_READY;
;;;2939   
;;;2940           /* Process Unlocked */
;;;2941           __HAL_UNLOCK(hi2c);
;;;2942   
;;;2943           return HAL_TIMEOUT; 
;;;2944         }
;;;2945       }
;;;2946       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2947   
;;;2948       /* Process Locked */
;;;2949       __HAL_LOCK(hi2c);
;;;2950   
;;;2951       /* Check if the I2C is already enabled */
;;;2952       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2953       {
;;;2954         /* Enable I2C peripheral */
;;;2955         __HAL_I2C_ENABLE(hi2c);
;;;2956       }
;;;2957   
;;;2958       /* Disable Pos */
;;;2959       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2960   
;;;2961       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;2962       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2963       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2964   
;;;2965       /* Prepare transfer parameters */
;;;2966       hi2c->pBuffPtr = pData;
;;;2967       hi2c->XferSize = Size;
;;;2968       hi2c->XferCount = Size;
;;;2969       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2970       hi2c->Devaddress = DevAddress;
;;;2971       hi2c->Memaddress = MemAddress;
;;;2972       hi2c->MemaddSize = MemAddSize;
;;;2973       hi2c->EventCount = 0U;
;;;2974   
;;;2975       /* Enable Acknowledge */
;;;2976       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2977   
;;;2978       /* Generate Start */
;;;2979       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2980   
;;;2981       /* Process Unlocked */
;;;2982       __HAL_UNLOCK(hi2c);
;;;2983   
;;;2984       if(hi2c->XferSize > 0U)
;;;2985       {
;;;2986         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2987         to avoid the risk of I2C interrupt handle execution before current
;;;2988         process unlock */
;;;2989         
;;;2990         /* Enable EVT, BUF and ERR interrupt */
;;;2991         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2992       }
;;;2993       return HAL_OK;
;;;2994     }
;;;2995     else
;;;2996     {
;;;2997       return HAL_BUSY;
000012  2002              MOVS     r0,#2
;;;2998     }
;;;2999   }
000014  bdf8              POP      {r3-r7,pc}
                  |L30.22|
000016  4c2c              LDR      r4,|L30.200|
000018  f24615a8          MOV      r5,#0x61a8            ;2932
00001c  6824              LDR      r4,[r4,#0]            ;2932  ; SystemCoreClock
00001e  fbb4f4f5          UDIV     r4,r4,r5              ;2932
000022  eb0405c4          ADD      r5,r4,r4,LSL #3       ;2932
000026  eb051404          ADD      r4,r5,r4,LSL #4       ;2932
00002a  9400              STR      r4,[sp,#0]            ;2932
                  |L30.44|
00002c  9c00              LDR      r4,[sp,#0]            ;2935
00002e  1e65              SUBS     r5,r4,#1              ;2935
000030  9500              STR      r5,[sp,#0]            ;2935
000032  d206              BCS      |L30.66|
000034  f8406f30          STR      r6,[r0,#0x30]!        ;2937
000038  2120              MOVS     r1,#0x20              ;2938
00003a  7341              STRB     r1,[r0,#0xd]          ;2938
00003c  7306              STRB     r6,[r0,#0xc]          ;2941
00003e  2003              MOVS     r0,#3                 ;2943
000040  bdf8              POP      {r3-r7,pc}
                  |L30.66|
000042  6804              LDR      r4,[r0,#0]            ;2946
000044  69a4              LDR      r4,[r4,#0x18]         ;2946
000046  43e4              MVNS     r4,r4                 ;2946
000048  07a4              LSLS     r4,r4,#30             ;2946
00004a  d5ef              BPL      |L30.44|
00004c  f890403c          LDRB     r4,[r0,#0x3c]         ;2949
000050  2c01              CMP      r4,#1                 ;2949
000052  d007              BEQ      |L30.100|
000054  2401              MOVS     r4,#1                 ;2949
000056  f880403c          STRB     r4,[r0,#0x3c]         ;2949
00005a  6804              LDR      r4,[r0,#0]            ;2952
00005c  6825              LDR      r5,[r4,#0]            ;2952
00005e  07ed              LSLS     r5,r5,#31             ;2952
000060  d002              BEQ      |L30.104|
000062  e005              B        |L30.112|
                  |L30.100|
000064  2002              MOVS     r0,#2                 ;2949
000066  bdf8              POP      {r3-r7,pc}
                  |L30.104|
000068  6825              LDR      r5,[r4,#0]            ;2955
00006a  f0450501          ORR      r5,r5,#1              ;2955
00006e  6025              STR      r5,[r4,#0]            ;2955
                  |L30.112|
000070  6804              LDR      r4,[r0,#0]            ;2959
000072  6825              LDR      r5,[r4,#0]            ;2959
000074  f4256500          BIC      r5,r5,#0x800          ;2959
000078  6025              STR      r5,[r4,#0]            ;2959
00007a  2422              MOVS     r4,#0x22              ;2961
00007c  f880403d          STRB     r4,[r0,#0x3d]         ;2961
000080  2440              MOVS     r4,#0x40              ;2962
000082  f880403e          STRB     r4,[r0,#0x3e]         ;2962
000086  6406              STR      r6,[r0,#0x40]         ;2963
000088  f8c0c024          STR      r12,[r0,#0x24]        ;2966
00008c  8507              STRH     r7,[r0,#0x28]         ;2967
00008e  8547              STRH     r7,[r0,#0x2a]         ;2968
000090  4c0e              LDR      r4,|L30.204|
000092  62c4              STR      r4,[r0,#0x2c]         ;2969
000094  6441              STR      r1,[r0,#0x44]         ;2970
000096  6482              STR      r2,[r0,#0x48]         ;2971
000098  64c3              STR      r3,[r0,#0x4c]         ;2972
00009a  6506              STR      r6,[r0,#0x50]         ;2973
00009c  6801              LDR      r1,[r0,#0]            ;2976
00009e  680a              LDR      r2,[r1,#0]            ;2976
0000a0  f4426280          ORR      r2,r2,#0x400          ;2976
0000a4  600a              STR      r2,[r1,#0]            ;2976
0000a6  6801              LDR      r1,[r0,#0]            ;2979
0000a8  680a              LDR      r2,[r1,#0]            ;2979
0000aa  f4427280          ORR      r2,r2,#0x100          ;2979
0000ae  600a              STR      r2,[r1,#0]            ;2979
0000b0  f880603c          STRB     r6,[r0,#0x3c]         ;2982
0000b4  8d01              LDRH     r1,[r0,#0x28]         ;2984
0000b6  b121              CBZ      r1,|L30.194|
0000b8  6800              LDR      r0,[r0,#0]            ;2991
0000ba  6841              LDR      r1,[r0,#4]            ;2991
0000bc  f44161e0          ORR      r1,r1,#0x700          ;2991
0000c0  6041              STR      r1,[r0,#4]            ;2991
                  |L30.194|
0000c2  2000              MOVS     r0,#0                 ;2993
0000c4  bdf8              POP      {r3-r7,pc}
;;;3000   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L30.200|
                          DCD      SystemCoreClock
                  |L30.204|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;2439     */
;;;2440   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2441   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  e9dd8910          LDRD     r8,r9,[sp,#0x40]
00000c  468a              MOV      r10,r1
00000e  4693              MOV      r11,r2
000010  9f12              LDR      r7,[sp,#0x48]
;;;2442     uint32_t tickstart = 0x00U;
;;;2443   
;;;2444     /* Init tickstart for timeout management*/
;;;2445     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;2446     
;;;2447     /* Check the parameters */
;;;2448     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2449   
;;;2450     if(hi2c->State == HAL_I2C_STATE_READY)
000018  f894003d          LDRB     r0,[r4,#0x3d]
00001c  2820              CMP      r0,#0x20
00001e  d003              BEQ      |L31.40|
;;;2451     {
;;;2452       /* Wait until BUSY flag is reset */
;;;2453       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
;;;2454       {
;;;2455         return HAL_BUSY;
;;;2456       }
;;;2457   
;;;2458       /* Process Locked */
;;;2459       __HAL_LOCK(hi2c);
;;;2460       
;;;2461       /* Check if the I2C is already enabled */
;;;2462       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2463       {
;;;2464         /* Enable I2C peripheral */
;;;2465         __HAL_I2C_ENABLE(hi2c);
;;;2466       }
;;;2467   
;;;2468       /* Disable Pos */
;;;2469       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2470   
;;;2471       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2472       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;2473       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2474   
;;;2475       /* Prepare transfer parameters */
;;;2476       hi2c->pBuffPtr    = pData;
;;;2477       hi2c->XferCount   = Size;
;;;2478       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2479       hi2c->XferSize    = hi2c->XferCount;
;;;2480       
;;;2481       /* Send Slave Address and Memory Address */
;;;2482       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;2483       {
;;;2484         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2485         {
;;;2486           /* Process Unlocked */
;;;2487           __HAL_UNLOCK(hi2c);
;;;2488           return HAL_ERROR;
;;;2489         }
;;;2490         else
;;;2491         {
;;;2492           /* Process Unlocked */
;;;2493           __HAL_UNLOCK(hi2c);
;;;2494           return HAL_TIMEOUT;
;;;2495         }
;;;2496       }
;;;2497   
;;;2498       while(hi2c->XferSize > 0U)
;;;2499       {
;;;2500         /* Wait until TXE flag is set */
;;;2501         if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2502         {
;;;2503           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2504           {
;;;2505             /* Generate Stop */
;;;2506             hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2507             return HAL_ERROR;
;;;2508           }
;;;2509           else
;;;2510           {
;;;2511             return HAL_TIMEOUT;
;;;2512           }
;;;2513         }
;;;2514   
;;;2515         /* Write data to DR */
;;;2516         hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;2517         hi2c->XferSize--;
;;;2518         hi2c->XferCount--;
;;;2519   
;;;2520         if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;2521         {
;;;2522           /* Write data to DR */
;;;2523           hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;2524           hi2c->XferSize--;
;;;2525           hi2c->XferCount--;
;;;2526         }
;;;2527       }
;;;2528       
;;;2529       /* Wait until BTF flag is set */
;;;2530       if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;2531       {
;;;2532         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2533         {
;;;2534           /* Generate Stop */
;;;2535           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2536           return HAL_ERROR;
;;;2537         }
;;;2538         else
;;;2539         {
;;;2540           return HAL_TIMEOUT;
;;;2541         }
;;;2542       }
;;;2543   
;;;2544       /* Generate Stop */
;;;2545       hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;2546   
;;;2547       hi2c->State = HAL_I2C_STATE_READY;
;;;2548       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2549       
;;;2550       /* Process Unlocked */
;;;2551       __HAL_UNLOCK(hi2c);
;;;2552   
;;;2553       return HAL_OK;
;;;2554     }
;;;2555     else
;;;2556     {
;;;2557       return HAL_BUSY;
000020  2002              MOVS     r0,#2
                  |L31.34|
;;;2558     }
;;;2559   }
000022  b007              ADD      sp,sp,#0x1c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L31.40|
000028  2319              MOVS     r3,#0x19              ;2453
00002a  2201              MOVS     r2,#1                 ;2453
00002c  494a              LDR      r1,|L31.344|
00002e  4620              MOV      r0,r4                 ;2453
000030  9500              STR      r5,[sp,#0]            ;2453
000032  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000036  b108              CBZ      r0,|L31.60|
000038  2002              MOVS     r0,#2                 ;2455
00003a  e7f2              B        |L31.34|
                  |L31.60|
00003c  f894003c          LDRB     r0,[r4,#0x3c]         ;2459
000040  2801              CMP      r0,#1                 ;2459
000042  d007              BEQ      |L31.84|
000044  2001              MOVS     r0,#1                 ;2459
000046  f884003c          STRB     r0,[r4,#0x3c]         ;2459
00004a  6820              LDR      r0,[r4,#0]            ;2462
00004c  6801              LDR      r1,[r0,#0]            ;2462
00004e  07c9              LSLS     r1,r1,#31             ;2462
000050  d002              BEQ      |L31.88|
000052  e005              B        |L31.96|
                  |L31.84|
000054  2002              MOVS     r0,#2                 ;2459
000056  e7e4              B        |L31.34|
                  |L31.88|
000058  6801              LDR      r1,[r0,#0]            ;2465
00005a  f0410101          ORR      r1,r1,#1              ;2465
00005e  6001              STR      r1,[r0,#0]            ;2465
                  |L31.96|
000060  6820              LDR      r0,[r4,#0]            ;2469
000062  6801              LDR      r1,[r0,#0]            ;2469
000064  f4216100          BIC      r1,r1,#0x800          ;2469
000068  6001              STR      r1,[r0,#0]            ;2469
00006a  2021              MOVS     r0,#0x21              ;2471
00006c  f884003d          STRB     r0,[r4,#0x3d]         ;2471
000070  2040              MOVS     r0,#0x40              ;2472
000072  f884003e          STRB     r0,[r4,#0x3e]         ;2472
000076  2600              MOVS     r6,#0                 ;2473
000078  6426              STR      r6,[r4,#0x40]         ;2473
00007a  f8c48024          STR      r8,[r4,#0x24]         ;2476
00007e  f8a4902a          STRH     r9,[r4,#0x2a]         ;2477
000082  4836              LDR      r0,|L31.348|
000084  62e0              STR      r0,[r4,#0x2c]         ;2478
000086  8d60              LDRH     r0,[r4,#0x2a]         ;2479
000088  8520              STRH     r0,[r4,#0x28]         ;2479
00008a  e9cd7500          STRD     r7,r5,[sp,#0]         ;2482
00008e  465a              MOV      r2,r11                ;2482
000090  4651              MOV      r1,r10                ;2482
000092  4620              MOV      r0,r4                 ;2482
000094  9b06              LDR      r3,[sp,#0x18]         ;2482
000096  f7fffffe          BL       I2C_RequestMemoryWrite
00009a  b3d0              CBZ      r0,|L31.274|
00009c  6c20              LDR      r0,[r4,#0x40]         ;2484
00009e  2804              CMP      r0,#4                 ;2484
0000a0  d003              BEQ      |L31.170|
0000a2  f884603c          STRB     r6,[r4,#0x3c]         ;2493
0000a6  2003              MOVS     r0,#3                 ;2494
0000a8  e7bb              B        |L31.34|
                  |L31.170|
0000aa  f884603c          STRB     r6,[r4,#0x3c]         ;2487
0000ae  2001              MOVS     r0,#1                 ;2488
0000b0  e7b7              B        |L31.34|
                  |L31.178|
0000b2  462a              MOV      r2,r5                 ;2501
0000b4  4639              MOV      r1,r7                 ;2501
0000b6  4620              MOV      r0,r4                 ;2501
0000b8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000bc  b158              CBZ      r0,|L31.214|
0000be  6c20              LDR      r0,[r4,#0x40]         ;2503
0000c0  2804              CMP      r0,#4                 ;2503
0000c2  d001              BEQ      |L31.200|
0000c4  2003              MOVS     r0,#3                 ;2511
0000c6  e7ac              B        |L31.34|
                  |L31.200|
0000c8  6820              LDR      r0,[r4,#0]            ;2506
0000ca  6801              LDR      r1,[r0,#0]            ;2506
0000cc  f4417100          ORR      r1,r1,#0x200          ;2506
0000d0  6001              STR      r1,[r0,#0]            ;2506
0000d2  2001              MOVS     r0,#1                 ;2507
0000d4  e7a5              B        |L31.34|
                  |L31.214|
0000d6  6a60              LDR      r0,[r4,#0x24]         ;2516
0000d8  1c41              ADDS     r1,r0,#1              ;2516
0000da  6261              STR      r1,[r4,#0x24]         ;2516
0000dc  6821              LDR      r1,[r4,#0]            ;2516
0000de  7800              LDRB     r0,[r0,#0]            ;2516
0000e0  6108              STR      r0,[r1,#0x10]         ;2516
0000e2  8d20              LDRH     r0,[r4,#0x28]         ;2517
0000e4  1e40              SUBS     r0,r0,#1              ;2517
0000e6  b280              UXTH     r0,r0                 ;2517
0000e8  8520              STRH     r0,[r4,#0x28]         ;2517
0000ea  8d61              LDRH     r1,[r4,#0x2a]         ;2518
0000ec  1e49              SUBS     r1,r1,#1              ;2518
0000ee  8561              STRH     r1,[r4,#0x2a]         ;2518
0000f0  6823              LDR      r3,[r4,#0]            ;2520
0000f2  6959              LDR      r1,[r3,#0x14]         ;2520
0000f4  43c9              MVNS     r1,r1                 ;2520
0000f6  0749              LSLS     r1,r1,#29             ;2520
0000f8  d40b              BMI      |L31.274|
0000fa  b150              CBZ      r0,|L31.274|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;2523
0000fe  1c41              ADDS     r1,r0,#1              ;2523
000100  6261              STR      r1,[r4,#0x24]         ;2523
000102  7800              LDRB     r0,[r0,#0]            ;2523
000104  6118              STR      r0,[r3,#0x10]         ;2523
000106  8d20              LDRH     r0,[r4,#0x28]         ;2524
000108  1e40              SUBS     r0,r0,#1              ;2524
00010a  8520              STRH     r0,[r4,#0x28]         ;2524
00010c  8d60              LDRH     r0,[r4,#0x2a]         ;2525
00010e  1e40              SUBS     r0,r0,#1              ;2525
000110  8560              STRH     r0,[r4,#0x2a]         ;2525
                  |L31.274|
000112  8d20              LDRH     r0,[r4,#0x28]         ;2498
000114  2800              CMP      r0,#0                 ;2498
000116  d1cc              BNE      |L31.178|
000118  462a              MOV      r2,r5                 ;2530
00011a  4639              MOV      r1,r7                 ;2530
00011c  4620              MOV      r0,r4                 ;2530
00011e  f7fffffe          BL       I2C_WaitOnBTFFlagUntilTimeout
000122  b158              CBZ      r0,|L31.316|
000124  6c20              LDR      r0,[r4,#0x40]         ;2532
000126  2804              CMP      r0,#4                 ;2532
000128  d001              BEQ      |L31.302|
00012a  2003              MOVS     r0,#3                 ;2540
00012c  e779              B        |L31.34|
                  |L31.302|
00012e  6820              LDR      r0,[r4,#0]            ;2535
000130  6801              LDR      r1,[r0,#0]            ;2535
000132  f4417100          ORR      r1,r1,#0x200          ;2535
000136  6001              STR      r1,[r0,#0]            ;2535
000138  2001              MOVS     r0,#1                 ;2536
00013a  e772              B        |L31.34|
                  |L31.316|
00013c  341f              ADDS     r4,r4,#0x1f           ;2545
00013e  f8540c1f          LDR      r0,[r4,#-0x1f]        ;2545
000142  6801              LDR      r1,[r0,#0]            ;2545
000144  f4417100          ORR      r1,r1,#0x200          ;2545
000148  6001              STR      r1,[r0,#0]            ;2545
00014a  2020              MOVS     r0,#0x20              ;2547
00014c  77a0              STRB     r0,[r4,#0x1e]         ;2547
00014e  77e6              STRB     r6,[r4,#0x1f]         ;2548
000150  7766              STRB     r6,[r4,#0x1d]         ;2551
000152  2000              MOVS     r0,#0                 ;2553
000154  e765              B        |L31.34|
;;;2560   
                          ENDP

000156  0000              DCW      0x0000
                  |L31.344|
                          DCD      0x00100002
                  |L31.348|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;3011     */
;;;3012   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3013   {
000004  4604              MOV      r4,r0
000006  e9dd860c          LDRD     r8,r6,[sp,#0x30]
00000a  4689              MOV      r9,r1
00000c  4692              MOV      r10,r2
00000e  469b              MOV      r11,r3
;;;3014     __IO uint32_t count = 0U;
000010  2500              MOVS     r5,#0
000012  9502              STR      r5,[sp,#8]
;;;3015   
;;;3016     uint32_t tickstart = 0x00U;
;;;3017   
;;;3018     /* Init tickstart for timeout management*/
;;;3019     tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4607              MOV      r7,r0
;;;3020     
;;;3021     /* Check the parameters */
;;;3022     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;3023   
;;;3024     if(hi2c->State == HAL_I2C_STATE_READY)
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  2820              CMP      r0,#0x20
000020  d002              BEQ      |L32.40|
;;;3025     {
;;;3026       /* Wait until BUSY flag is reset */
;;;3027       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;3028       do
;;;3029       {
;;;3030         if(count-- == 0U)
;;;3031         {
;;;3032           hi2c->PreviousState = I2C_STATE_NONE;
;;;3033           hi2c->State= HAL_I2C_STATE_READY;
;;;3034   
;;;3035           /* Process Unlocked */
;;;3036           __HAL_UNLOCK(hi2c);
;;;3037   
;;;3038           return HAL_TIMEOUT; 
;;;3039         }
;;;3040       }
;;;3041       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;3042   
;;;3043       /* Process Locked */
;;;3044       __HAL_LOCK(hi2c);
;;;3045   
;;;3046       /* Check if the I2C is already enabled */
;;;3047       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;3048       {
;;;3049         /* Enable I2C peripheral */
;;;3050         __HAL_I2C_ENABLE(hi2c);
;;;3051       }
;;;3052   
;;;3053       /* Disable Pos */
;;;3054       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;3055   
;;;3056       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;3057       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;3058       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;3059   
;;;3060       /* Prepare transfer parameters */
;;;3061       hi2c->pBuffPtr = pData;
;;;3062       hi2c->XferSize = Size;
;;;3063       hi2c->XferCount = Size;
;;;3064       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;3065   
;;;3066       if(hi2c->XferSize > 0U)
;;;3067       {    
;;;3068         /* Set the I2C DMA transfer complete callback */
;;;3069         hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;3070   
;;;3071         /* Set the DMA error callback */
;;;3072         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;3073   
;;;3074         /* Set the unused DMA callbacks to NULL */
;;;3075         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;3076         hi2c->hdmatx->XferAbortCallback = NULL;
;;;3077   
;;;3078         /* Enable the DMA channel */
;;;3079         HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;3080   
;;;3081         /* Send Slave Address and Memory Address */
;;;3082         if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;3083         {
;;;3084           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3085           {
;;;3086             /* Process Unlocked */
;;;3087             __HAL_UNLOCK(hi2c);
;;;3088             return HAL_ERROR;
;;;3089           }
;;;3090           else
;;;3091           {
;;;3092             /* Process Unlocked */
;;;3093             __HAL_UNLOCK(hi2c);
;;;3094             return HAL_TIMEOUT;
;;;3095           }
;;;3096         }
;;;3097   
;;;3098         /* Clear ADDR flag */
;;;3099         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3100         
;;;3101         /* Process Unlocked */
;;;3102         __HAL_UNLOCK(hi2c);
;;;3103         
;;;3104         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;3105         to avoid the risk of I2C interrupt handle execution before current
;;;3106         process unlock */
;;;3107         /* Enable ERR interrupt */
;;;3108         __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
;;;3109   
;;;3110         /* Enable DMA Request */
;;;3111         hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;3112       }
;;;3113       return HAL_OK;
;;;3114     }
;;;3115     else
;;;3116     {
;;;3117       return HAL_BUSY;
000022  2002              MOVS     r0,#2
                  |L32.36|
;;;3118     }
;;;3119   }
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L32.40|
000028  483b              LDR      r0,|L32.280|
00002a  f24611a8          MOV      r1,#0x61a8            ;3027
00002e  6800              LDR      r0,[r0,#0]            ;3027  ; SystemCoreClock
000030  fbb0f0f1          UDIV     r0,r0,r1              ;3027
000034  eb0001c0          ADD      r1,r0,r0,LSL #3       ;3027
000038  eb011000          ADD      r0,r1,r0,LSL #4       ;3027
00003c  9002              STR      r0,[sp,#8]            ;3027
                  |L32.62|
00003e  9802              LDR      r0,[sp,#8]            ;3030
000040  1e41              SUBS     r1,r0,#1              ;3030
000042  9102              STR      r1,[sp,#8]            ;3030
000044  d206              BCS      |L32.84|
000046  f8445f30          STR      r5,[r4,#0x30]!        ;3032
00004a  2020              MOVS     r0,#0x20              ;3033
00004c  7360              STRB     r0,[r4,#0xd]          ;3033
00004e  7325              STRB     r5,[r4,#0xc]          ;3036
000050  2003              MOVS     r0,#3                 ;3038
000052  e7e7              B        |L32.36|
                  |L32.84|
000054  6820              LDR      r0,[r4,#0]            ;3041
000056  6980              LDR      r0,[r0,#0x18]         ;3041
000058  43c0              MVNS     r0,r0                 ;3041
00005a  0780              LSLS     r0,r0,#30             ;3041
00005c  d5ef              BPL      |L32.62|
00005e  f894003c          LDRB     r0,[r4,#0x3c]         ;3044
000062  2801              CMP      r0,#1                 ;3044
000064  d007              BEQ      |L32.118|
000066  2001              MOVS     r0,#1                 ;3044
000068  f884003c          STRB     r0,[r4,#0x3c]         ;3044
00006c  6820              LDR      r0,[r4,#0]            ;3047
00006e  6801              LDR      r1,[r0,#0]            ;3047
000070  07c9              LSLS     r1,r1,#31             ;3047
000072  d002              BEQ      |L32.122|
000074  e005              B        |L32.130|
                  |L32.118|
000076  2002              MOVS     r0,#2                 ;3044
000078  e7d4              B        |L32.36|
                  |L32.122|
00007a  6801              LDR      r1,[r0,#0]            ;3050
00007c  f0410101          ORR      r1,r1,#1              ;3050
000080  6001              STR      r1,[r0,#0]            ;3050
                  |L32.130|
000082  6820              LDR      r0,[r4,#0]            ;3054
000084  6801              LDR      r1,[r0,#0]            ;3054
000086  f4216100          BIC      r1,r1,#0x800          ;3054
00008a  6001              STR      r1,[r0,#0]            ;3054
00008c  2021              MOVS     r0,#0x21              ;3056
00008e  f884003d          STRB     r0,[r4,#0x3d]         ;3056
000092  2040              MOVS     r0,#0x40              ;3057
000094  f884003e          STRB     r0,[r4,#0x3e]         ;3057
000098  6425              STR      r5,[r4,#0x40]         ;3058
00009a  f8c48024          STR      r8,[r4,#0x24]         ;3061
00009e  8526              STRH     r6,[r4,#0x28]         ;3062
0000a0  8566              STRH     r6,[r4,#0x2a]         ;3063
0000a2  481e              LDR      r0,|L32.284|
0000a4  62e0              STR      r0,[r4,#0x2c]         ;3064
0000a6  b3a6              CBZ      r6,|L32.274|
0000a8  6b61              LDR      r1,[r4,#0x34]         ;3069
0000aa  481d              LDR      r0,|L32.288|
0000ac  6288              STR      r0,[r1,#0x28]         ;3069
0000ae  6b61              LDR      r1,[r4,#0x34]         ;3072
0000b0  481c              LDR      r0,|L32.292|
0000b2  6308              STR      r0,[r1,#0x30]         ;3072
0000b4  6b60              LDR      r0,[r4,#0x34]         ;3075
0000b6  62c5              STR      r5,[r0,#0x2c]         ;3075
0000b8  6b60              LDR      r0,[r4,#0x34]         ;3076
0000ba  6345              STR      r5,[r0,#0x34]         ;3076
0000bc  6822              LDR      r2,[r4,#0]            ;3079
0000be  8d23              LDRH     r3,[r4,#0x28]         ;3079
0000c0  3210              ADDS     r2,r2,#0x10           ;3079
0000c2  6a61              LDR      r1,[r4,#0x24]         ;3079
0000c4  6b60              LDR      r0,[r4,#0x34]         ;3079
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  2023              MOVS     r0,#0x23              ;3082
0000cc  e9cd0700          STRD     r0,r7,[sp,#0]         ;3082
0000d0  465b              MOV      r3,r11                ;3082
0000d2  4652              MOV      r2,r10                ;3082
0000d4  4649              MOV      r1,r9                 ;3082
0000d6  4620              MOV      r0,r4                 ;3082
0000d8  f7fffffe          BL       I2C_RequestMemoryWrite
0000dc  b150              CBZ      r0,|L32.244|
0000de  6c20              LDR      r0,[r4,#0x40]         ;3084
0000e0  2804              CMP      r0,#4                 ;3084
0000e2  d003              BEQ      |L32.236|
0000e4  f884503c          STRB     r5,[r4,#0x3c]         ;3093
0000e8  2003              MOVS     r0,#3                 ;3094
0000ea  e79b              B        |L32.36|
                  |L32.236|
0000ec  f884503c          STRB     r5,[r4,#0x3c]         ;3087
0000f0  2001              MOVS     r0,#1                 ;3088
0000f2  e797              B        |L32.36|
                  |L32.244|
0000f4  6820              LDR      r0,[r4,#0]            ;3099
0000f6  6941              LDR      r1,[r0,#0x14]         ;3099
0000f8  6981              LDR      r1,[r0,#0x18]         ;3099
0000fa  9101              STR      r1,[sp,#4]            ;3099
0000fc  f884503c          STRB     r5,[r4,#0x3c]         ;3102
000100  6841              LDR      r1,[r0,#4]            ;3108
000102  f4417180          ORR      r1,r1,#0x100          ;3108
000106  6041              STR      r1,[r0,#4]            ;3108
000108  6820              LDR      r0,[r4,#0]            ;3111
00010a  6841              LDR      r1,[r0,#4]            ;3111
00010c  f4416100          ORR      r1,r1,#0x800          ;3111
000110  6041              STR      r1,[r0,#4]            ;3111
                  |L32.274|
000112  2000              MOVS     r0,#0                 ;3113
000114  e786              B        |L32.36|
;;;3120   
                          ENDP

000116  0000              DCW      0x0000
                  |L32.280|
                          DCD      SystemCoreClock
                  |L32.284|
                          DCD      0xffff0000
                  |L32.288|
                          DCD      I2C_DMAXferCplt
                  |L32.292|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2836     */
;;;2837   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2838   {
000002  e9ddc706          LDRD     r12,r7,[sp,#0x18]
;;;2839     __IO uint32_t count = 0U;
000006  2600              MOVS     r6,#0
000008  9600              STR      r6,[sp,#0]
;;;2840   
;;;2841     /* Check the parameters */
;;;2842     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2843   
;;;2844     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f890403d          LDRB     r4,[r0,#0x3d]
00000e  2c20              CMP      r4,#0x20
000010  d001              BEQ      |L33.22|
;;;2845     {
;;;2846       /* Wait until BUSY flag is reset */
;;;2847       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;2848       do
;;;2849       {
;;;2850         if(count-- == 0U)
;;;2851         {
;;;2852           hi2c->PreviousState = I2C_STATE_NONE;
;;;2853           hi2c->State= HAL_I2C_STATE_READY;
;;;2854   
;;;2855           /* Process Unlocked */
;;;2856           __HAL_UNLOCK(hi2c);
;;;2857   
;;;2858           return HAL_TIMEOUT; 
;;;2859         }
;;;2860       }
;;;2861       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2862   
;;;2863       /* Process Locked */
;;;2864       __HAL_LOCK(hi2c);
;;;2865   
;;;2866       /* Check if the I2C is already enabled */
;;;2867       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2868       {
;;;2869         /* Enable I2C peripheral */
;;;2870         __HAL_I2C_ENABLE(hi2c);
;;;2871       }
;;;2872   
;;;2873       /* Disable Pos */
;;;2874       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2875   
;;;2876       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;2877       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2878       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2879   
;;;2880       /* Prepare transfer parameters */
;;;2881       hi2c->pBuffPtr = pData;
;;;2882       hi2c->XferSize = Size;
;;;2883       hi2c->XferCount = Size;
;;;2884       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2885       hi2c->Devaddress = DevAddress;
;;;2886       hi2c->Memaddress = MemAddress;
;;;2887       hi2c->MemaddSize = MemAddSize;
;;;2888       hi2c->EventCount = 0U;
;;;2889   
;;;2890       /* Generate Start */
;;;2891       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;2892   
;;;2893       /* Process Unlocked */
;;;2894       __HAL_UNLOCK(hi2c);
;;;2895   
;;;2896       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2897       to avoid the risk of I2C interrupt handle execution before current
;;;2898       process unlock */
;;;2899   
;;;2900       /* Enable EVT, BUF and ERR interrupt */
;;;2901       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2902   
;;;2903       return HAL_OK;
;;;2904     }
;;;2905     else
;;;2906     {
;;;2907       return HAL_BUSY;
000012  2002              MOVS     r0,#2
;;;2908     }
;;;2909   }
000014  bdf8              POP      {r3-r7,pc}
                  |L33.22|
000016  4c28              LDR      r4,|L33.184|
000018  f24615a8          MOV      r5,#0x61a8            ;2847
00001c  6824              LDR      r4,[r4,#0]            ;2847  ; SystemCoreClock
00001e  fbb4f4f5          UDIV     r4,r4,r5              ;2847
000022  eb0405c4          ADD      r5,r4,r4,LSL #3       ;2847
000026  eb051404          ADD      r4,r5,r4,LSL #4       ;2847
00002a  9400              STR      r4,[sp,#0]            ;2847
                  |L33.44|
00002c  9c00              LDR      r4,[sp,#0]            ;2850
00002e  1e65              SUBS     r5,r4,#1              ;2850
000030  9500              STR      r5,[sp,#0]            ;2850
000032  d206              BCS      |L33.66|
000034  f8406f30          STR      r6,[r0,#0x30]!        ;2852
000038  2120              MOVS     r1,#0x20              ;2853
00003a  7341              STRB     r1,[r0,#0xd]          ;2853
00003c  7306              STRB     r6,[r0,#0xc]          ;2856
00003e  2003              MOVS     r0,#3                 ;2858
000040  bdf8              POP      {r3-r7,pc}
                  |L33.66|
000042  6804              LDR      r4,[r0,#0]            ;2861
000044  69a4              LDR      r4,[r4,#0x18]         ;2861
000046  43e4              MVNS     r4,r4                 ;2861
000048  07a4              LSLS     r4,r4,#30             ;2861
00004a  d5ef              BPL      |L33.44|
00004c  f890403c          LDRB     r4,[r0,#0x3c]         ;2864
000050  2c01              CMP      r4,#1                 ;2864
000052  d007              BEQ      |L33.100|
000054  2401              MOVS     r4,#1                 ;2864
000056  f880403c          STRB     r4,[r0,#0x3c]         ;2864
00005a  6804              LDR      r4,[r0,#0]            ;2867
00005c  6825              LDR      r5,[r4,#0]            ;2867
00005e  07ed              LSLS     r5,r5,#31             ;2867
000060  d002              BEQ      |L33.104|
000062  e005              B        |L33.112|
                  |L33.100|
000064  2002              MOVS     r0,#2                 ;2864
000066  bdf8              POP      {r3-r7,pc}
                  |L33.104|
000068  6825              LDR      r5,[r4,#0]            ;2870
00006a  f0450501          ORR      r5,r5,#1              ;2870
00006e  6025              STR      r5,[r4,#0]            ;2870
                  |L33.112|
000070  6804              LDR      r4,[r0,#0]            ;2874
000072  6825              LDR      r5,[r4,#0]            ;2874
000074  f4256500          BIC      r5,r5,#0x800          ;2874
000078  6025              STR      r5,[r4,#0]            ;2874
00007a  2421              MOVS     r4,#0x21              ;2876
00007c  f880403d          STRB     r4,[r0,#0x3d]         ;2876
000080  2440              MOVS     r4,#0x40              ;2877
000082  f880403e          STRB     r4,[r0,#0x3e]         ;2877
000086  6406              STR      r6,[r0,#0x40]         ;2878
000088  f8c0c024          STR      r12,[r0,#0x24]        ;2881
00008c  8507              STRH     r7,[r0,#0x28]         ;2882
00008e  8547              STRH     r7,[r0,#0x2a]         ;2883
000090  4c0a              LDR      r4,|L33.188|
000092  62c4              STR      r4,[r0,#0x2c]         ;2884
000094  6441              STR      r1,[r0,#0x44]         ;2885
000096  6482              STR      r2,[r0,#0x48]         ;2886
000098  64c3              STR      r3,[r0,#0x4c]         ;2887
00009a  6506              STR      r6,[r0,#0x50]         ;2888
00009c  6801              LDR      r1,[r0,#0]            ;2891
00009e  680a              LDR      r2,[r1,#0]            ;2891
0000a0  f4427280          ORR      r2,r2,#0x100          ;2891
0000a4  600a              STR      r2,[r1,#0]            ;2891
0000a6  f880603c          STRB     r6,[r0,#0x3c]         ;2894
0000aa  6800              LDR      r0,[r0,#0]            ;2901
0000ac  6841              LDR      r1,[r0,#4]            ;2901
0000ae  f44161e0          ORR      r1,r1,#0x700          ;2901
0000b2  6041              STR      r1,[r0,#4]            ;2901
0000b4  2000              MOVS     r0,#0                 ;2903
0000b6  bdf8              POP      {r3-r7,pc}
;;;2910   
                          ENDP

                  |L33.184|
                          DCD      SystemCoreClock
                  |L33.188|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;503      */
;;;504     __WEAK void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;505    {
;;;506      /* Prevent unused argument(s) compilation warning */
;;;507      UNUSED(hi2c);
;;;508      /* NOTE : This function Should not be modified, when the callback is needed,
;;;509                the HAL_I2C_MspDeInit could be implemented in the user file
;;;510       */
;;;511    }
;;;512    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;488      */
;;;489     __WEAK void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;490    {
;;;491      /* Prevent unused argument(s) compilation warning */
;;;492      UNUSED(hi2c);
;;;493      /* NOTE : This function Should not be modified, when the callback is needed,
;;;494                the HAL_I2C_MspInit could be implemented in the user file
;;;495       */
;;;496    }
;;;497    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;3643     */
;;;3644   __WEAK void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3645   {
;;;3646     /* Prevent unused argument(s) compilation warning */
;;;3647     UNUSED(hi2c);
;;;3648   
;;;3649     /* NOTE : This function should not be modified, when the callback is needed,
;;;3650               the HAL_I2C_SlaveRxCpltCallback can be implemented in the user file
;;;3651      */
;;;3652   }
;;;3653   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;3627     */
;;;3628   __WEAK void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3629   {
;;;3630     /* Prevent unused argument(s) compilation warning */
;;;3631     UNUSED(hi2c);
;;;3632   
;;;3633     /* NOTE : This function should not be modified, when the callback is needed,
;;;3634               the HAL_I2C_SlaveTxCpltCallback can be implemented in the user file
;;;3635      */
;;;3636   }
;;;3637   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive PROC
;;;1111     */
;;;1112   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1113   {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
;;;1114     uint32_t tickstart = 0x00U;
;;;1115   
;;;1116     /* Init tickstart for timeout management*/
;;;1117     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;1118   
;;;1119     if(hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d002              BEQ      |L38.32|
;;;1120     {
;;;1121       if((pData == NULL) || (Size == 0U))
;;;1122       {
;;;1123         return  HAL_ERROR;
;;;1124       }
;;;1125   
;;;1126       /* Process Locked */
;;;1127       __HAL_LOCK(hi2c);
;;;1128   
;;;1129       /* Check if the I2C is already enabled */
;;;1130       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1131       {
;;;1132         /* Enable I2C peripheral */
;;;1133         __HAL_I2C_ENABLE(hi2c);
;;;1134       }
;;;1135   
;;;1136       /* Disable Pos */
;;;1137       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1138   
;;;1139       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1140       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1141       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1142   
;;;1143       /* Prepare transfer parameters */
;;;1144       hi2c->pBuffPtr    = pData;
;;;1145       hi2c->XferCount   = Size;
;;;1146       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1147       hi2c->XferSize    = hi2c->XferCount;
;;;1148   
;;;1149       /* Enable Address Acknowledge */
;;;1150       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1151   
;;;1152       /* Wait until ADDR flag is set */
;;;1153       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1154       {
;;;1155         return HAL_TIMEOUT;
;;;1156       }
;;;1157   
;;;1158       /* Clear ADDR flag */
;;;1159       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1160   
;;;1161       while(hi2c->XferSize > 0U)
;;;1162       {
;;;1163         /* Wait until RXNE flag is set */
;;;1164         if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
;;;1165         {
;;;1166           /* Disable Address Acknowledge */
;;;1167           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1168   
;;;1169           if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;1170           {
;;;1171             return HAL_TIMEOUT;
;;;1172           }
;;;1173           else
;;;1174           {
;;;1175             return HAL_ERROR;
;;;1176           }
;;;1177         }
;;;1178   
;;;1179         /* Read data from DR */
;;;1180         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;1181         hi2c->XferSize--;
;;;1182         hi2c->XferCount--;
;;;1183   
;;;1184         if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0U))
;;;1185         {
;;;1186           /* Read data from DR */
;;;1187         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;1188         hi2c->XferSize--;
;;;1189         hi2c->XferCount--;
;;;1190         }
;;;1191       }
;;;1192   
;;;1193       /* Wait until STOP flag is set */
;;;1194       if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1195       {
;;;1196         /* Disable Address Acknowledge */
;;;1197         hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1198   
;;;1199         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1200         {
;;;1201           return HAL_ERROR;
;;;1202         }
;;;1203         else
;;;1204         {
;;;1205           return HAL_TIMEOUT;
;;;1206         }
;;;1207       }
;;;1208   
;;;1209       /* Clear STOP flag */
;;;1210       __HAL_I2C_CLEAR_STOPFLAG(hi2c);
;;;1211   
;;;1212       /* Disable Address Acknowledge */
;;;1213       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1214   
;;;1215       hi2c->State = HAL_I2C_STATE_READY;
;;;1216       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1217   
;;;1218       /* Process Unlocked */
;;;1219       __HAL_UNLOCK(hi2c);
;;;1220   
;;;1221       return HAL_OK;
;;;1222     }
;;;1223     else
;;;1224     {
;;;1225       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L38.28|
;;;1226     }
;;;1227   }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L38.32|
000020  f1ba0f00          CMP      r10,#0                ;1121
000024  d00c              BEQ      |L38.64|
000026  b15d              CBZ      r5,|L38.64|
000028  f894003c          LDRB     r0,[r4,#0x3c]         ;1127
00002c  2801              CMP      r0,#1                 ;1127
00002e  d009              BEQ      |L38.68|
000030  2001              MOVS     r0,#1                 ;1127
000032  f884003c          STRB     r0,[r4,#0x3c]         ;1127
000036  6820              LDR      r0,[r4,#0]            ;1130
000038  6801              LDR      r1,[r0,#0]            ;1130
00003a  07c9              LSLS     r1,r1,#31             ;1130
00003c  d004              BEQ      |L38.72|
00003e  e007              B        |L38.80|
                  |L38.64|
000040  2001              MOVS     r0,#1                 ;1123
000042  e7eb              B        |L38.28|
                  |L38.68|
000044  2002              MOVS     r0,#2                 ;1127
000046  e7e9              B        |L38.28|
                  |L38.72|
000048  6801              LDR      r1,[r0,#0]            ;1133
00004a  f0410101          ORR      r1,r1,#1              ;1133
00004e  6001              STR      r1,[r0,#0]            ;1133
                  |L38.80|
000050  6820              LDR      r0,[r4,#0]            ;1137
000052  6801              LDR      r1,[r0,#0]            ;1137
000054  f4216100          BIC      r1,r1,#0x800          ;1137
000058  6001              STR      r1,[r0,#0]            ;1137
00005a  2022              MOVS     r0,#0x22              ;1139
00005c  f884003d          STRB     r0,[r4,#0x3d]         ;1139
000060  2720              MOVS     r7,#0x20              ;1140
000062  f884703e          STRB     r7,[r4,#0x3e]         ;1140
000066  f04f0800          MOV      r8,#0                 ;1141
00006a  f8c48040          STR      r8,[r4,#0x40]         ;1141
00006e  f8c4a024          STR      r10,[r4,#0x24]        ;1144
000072  8565              STRH     r5,[r4,#0x2a]         ;1145
000074  4837              LDR      r0,|L38.340|
000076  62e0              STR      r0,[r4,#0x2c]         ;1146
000078  8d60              LDRH     r0,[r4,#0x2a]         ;1147
00007a  8520              STRH     r0,[r4,#0x28]         ;1147
00007c  6820              LDR      r0,[r4,#0]            ;1150
00007e  6801              LDR      r1,[r0,#0]            ;1150
000080  f4416180          ORR      r1,r1,#0x400          ;1150
000084  6001              STR      r1,[r0,#0]            ;1150
000086  464b              MOV      r3,r9                 ;1153
000088  2200              MOVS     r2,#0                 ;1153
00008a  4933              LDR      r1,|L38.344|
00008c  4620              MOV      r0,r4                 ;1153
00008e  9600              STR      r6,[sp,#0]            ;1153
000090  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000094  b108              CBZ      r0,|L38.154|
000096  2003              MOVS     r0,#3                 ;1155
000098  e7c0              B        |L38.28|
                  |L38.154|
00009a  6820              LDR      r0,[r4,#0]            ;1159
00009c  6941              LDR      r1,[r0,#0x14]         ;1159
00009e  6980              LDR      r0,[r0,#0x18]         ;1159
0000a0  9000              STR      r0,[sp,#0]            ;1159
0000a2  e02e              B        |L38.258|
                  |L38.164|
0000a4  4632              MOV      r2,r6                 ;1164
0000a6  4649              MOV      r1,r9                 ;1164
0000a8  4620              MOV      r0,r4                 ;1164
0000aa  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000ae  b158              CBZ      r0,|L38.200|
0000b0  6820              LDR      r0,[r4,#0]            ;1167
0000b2  6801              LDR      r1,[r0,#0]            ;1167
0000b4  f4216180          BIC      r1,r1,#0x400          ;1167
0000b8  6001              STR      r1,[r0,#0]            ;1167
0000ba  6c20              LDR      r0,[r4,#0x40]         ;1169
0000bc  2820              CMP      r0,#0x20              ;1169
0000be  d001              BEQ      |L38.196|
0000c0  2001              MOVS     r0,#1                 ;1175
0000c2  e7ab              B        |L38.28|
                  |L38.196|
0000c4  2003              MOVS     r0,#3                 ;1171
0000c6  e7a9              B        |L38.28|
                  |L38.200|
0000c8  6820              LDR      r0,[r4,#0]            ;1180
0000ca  6901              LDR      r1,[r0,#0x10]         ;1180
0000cc  6a60              LDR      r0,[r4,#0x24]         ;1180
0000ce  1c42              ADDS     r2,r0,#1              ;1180
0000d0  6262              STR      r2,[r4,#0x24]         ;1180
0000d2  7001              STRB     r1,[r0,#0]            ;1180
0000d4  8d20              LDRH     r0,[r4,#0x28]         ;1181
0000d6  1e40              SUBS     r0,r0,#1              ;1181
0000d8  8520              STRH     r0,[r4,#0x28]         ;1181
0000da  8d60              LDRH     r0,[r4,#0x2a]         ;1182
0000dc  1e40              SUBS     r0,r0,#1              ;1182
0000de  8560              STRH     r0,[r4,#0x2a]         ;1182
0000e0  6820              LDR      r0,[r4,#0]            ;1184
0000e2  6941              LDR      r1,[r0,#0x14]         ;1184
0000e4  43c9              MVNS     r1,r1                 ;1184
0000e6  0749              LSLS     r1,r1,#29             ;1184
0000e8  d40b              BMI      |L38.258|
0000ea  b155              CBZ      r5,|L38.258|
0000ec  6901              LDR      r1,[r0,#0x10]         ;1187
0000ee  6a60              LDR      r0,[r4,#0x24]         ;1187
0000f0  1c42              ADDS     r2,r0,#1              ;1187
0000f2  6262              STR      r2,[r4,#0x24]         ;1187
0000f4  7001              STRB     r1,[r0,#0]            ;1187
0000f6  8d20              LDRH     r0,[r4,#0x28]         ;1188
0000f8  1e40              SUBS     r0,r0,#1              ;1188
0000fa  8520              STRH     r0,[r4,#0x28]         ;1188
0000fc  8d60              LDRH     r0,[r4,#0x2a]         ;1189
0000fe  1e40              SUBS     r0,r0,#1              ;1189
000100  8560              STRH     r0,[r4,#0x2a]         ;1189
                  |L38.258|
000102  8d20              LDRH     r0,[r4,#0x28]         ;1161
000104  2800              CMP      r0,#0                 ;1161
000106  d1cd              BNE      |L38.164|
000108  4632              MOV      r2,r6                 ;1194
00010a  4649              MOV      r1,r9                 ;1194
00010c  4620              MOV      r0,r4                 ;1194
00010e  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000112  b158              CBZ      r0,|L38.300|
000114  6820              LDR      r0,[r4,#0]            ;1197
000116  6801              LDR      r1,[r0,#0]            ;1197
000118  f4216180          BIC      r1,r1,#0x400          ;1197
00011c  6001              STR      r1,[r0,#0]            ;1197
00011e  6c20              LDR      r0,[r4,#0x40]         ;1199
000120  2804              CMP      r0,#4                 ;1199
000122  d001              BEQ      |L38.296|
000124  2003              MOVS     r0,#3                 ;1205
000126  e779              B        |L38.28|
                  |L38.296|
000128  2001              MOVS     r0,#1                 ;1201
00012a  e777              B        |L38.28|
                  |L38.300|
00012c  6820              LDR      r0,[r4,#0]            ;1210
00012e  6941              LDR      r1,[r0,#0x14]         ;1210
000130  9100              STR      r1,[sp,#0]            ;1210
000132  6801              LDR      r1,[r0,#0]            ;1210
000134  f0410101          ORR      r1,r1,#1              ;1210
000138  6001              STR      r1,[r0,#0]            ;1210
00013a  6820              LDR      r0,[r4,#0]            ;1213
00013c  6801              LDR      r1,[r0,#0]            ;1213
00013e  f4216180          BIC      r1,r1,#0x400          ;1213
000142  6001              STR      r1,[r0,#0]            ;1213
000144  f884703d          STRB     r7,[r4,#0x3d]         ;1215
000148  f884803e          STRB     r8,[r4,#0x3e]         ;1216
00014c  f884803c          STRB     r8,[r4,#0x3c]         ;1219
000150  2000              MOVS     r0,#0                 ;1221
000152  e763              B        |L38.28|
;;;1228   
                          ENDP

                  |L38.340|
                          DCD      0xffff0000
                  |L38.344|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;2341     */
;;;2342   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2343   {
000002  4604              MOV      r4,r0
;;;2344     __IO uint32_t count = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;2345   
;;;2346     if(hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d001              BEQ      |L39.20|
;;;2347     {
;;;2348       if((pData == NULL) || (Size == 0U))
;;;2349       {
;;;2350         return  HAL_ERROR;
;;;2351       }
;;;2352   
;;;2353       /* Wait until BUSY flag is reset */
;;;2354       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;2355       do
;;;2356       {
;;;2357         if(count-- == 0U)
;;;2358         {
;;;2359           hi2c->PreviousState = I2C_STATE_NONE;
;;;2360           hi2c->State= HAL_I2C_STATE_READY;
;;;2361   
;;;2362           /* Process Unlocked */
;;;2363           __HAL_UNLOCK(hi2c);
;;;2364   
;;;2365           return HAL_TIMEOUT; 
;;;2366         }
;;;2367       }
;;;2368       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2369   
;;;2370       /* Process Locked */
;;;2371       __HAL_LOCK(hi2c);
;;;2372   
;;;2373       /* Check if the I2C is already enabled */
;;;2374       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2375       {
;;;2376         /* Enable I2C peripheral */
;;;2377         __HAL_I2C_ENABLE(hi2c);
;;;2378       }
;;;2379   
;;;2380       /* Disable Pos */
;;;2381       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2382   
;;;2383       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2384       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2385       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2386   
;;;2387       /* Prepare transfer parameters */
;;;2388       hi2c->pBuffPtr    = pData;
;;;2389       hi2c->XferCount   = Size;
;;;2390       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2391       hi2c->XferSize    = hi2c->XferCount;
;;;2392   
;;;2393       /* Set the I2C DMA transfer complete callback */
;;;2394       hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
;;;2395   
;;;2396       /* Set the DMA error callback */
;;;2397       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2398   
;;;2399       /* Set the unused DMA callbacks to NULL */
;;;2400       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2401       hi2c->hdmarx->XferAbortCallback = NULL;
;;;2402   
;;;2403       /* Enable the DMA channel */
;;;2404       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
;;;2405   
;;;2406       /* Enable Address Acknowledge */
;;;2407       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2408   
;;;2409       /* Process Unlocked */
;;;2410       __HAL_UNLOCK(hi2c);
;;;2411   
;;;2412       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2413                 to avoid the risk of I2C interrupt handle execution before current
;;;2414                 process unlock */
;;;2415       /* Enable EVT and ERR interrupt */
;;;2416       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2417   
;;;2418       /* Enable DMA Request */
;;;2419       hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2420   
;;;2421       return HAL_OK;
;;;2422     }
;;;2423     else
;;;2424     {
;;;2425       return HAL_BUSY;
000010  2002              MOVS     r0,#2
;;;2426     }
;;;2427   }
000012  bdf8              POP      {r3-r7,pc}
                  |L39.20|
000014  b339              CBZ      r1,|L39.102|
000016  b332              CBZ      r2,|L39.102|
000018  4831              LDR      r0,|L39.224|
00001a  f24613a8          MOV      r3,#0x61a8            ;2354
00001e  6800              LDR      r0,[r0,#0]            ;2354  ; SystemCoreClock
000020  fbb0f0f3          UDIV     r0,r0,r3              ;2354
000024  eb0003c0          ADD      r3,r0,r0,LSL #3       ;2354
000028  eb031000          ADD      r0,r3,r0,LSL #4       ;2354
00002c  9000              STR      r0,[sp,#0]            ;2354
00002e  2620              MOVS     r6,#0x20              ;2360
                  |L39.48|
000030  9800              LDR      r0,[sp,#0]            ;2357
000032  1e43              SUBS     r3,r0,#1              ;2357
000034  9300              STR      r3,[sp,#0]            ;2357
000036  d205              BCS      |L39.68|
000038  f8445f30          STR      r5,[r4,#0x30]!        ;2359
00003c  7366              STRB     r6,[r4,#0xd]          ;2360
00003e  7325              STRB     r5,[r4,#0xc]          ;2363
000040  2003              MOVS     r0,#3                 ;2365
000042  bdf8              POP      {r3-r7,pc}
                  |L39.68|
000044  6820              LDR      r0,[r4,#0]            ;2368
000046  6980              LDR      r0,[r0,#0x18]         ;2368
000048  43c0              MVNS     r0,r0                 ;2368
00004a  0780              LSLS     r0,r0,#30             ;2368
00004c  d5f0              BPL      |L39.48|
00004e  f894003c          LDRB     r0,[r4,#0x3c]         ;2371
000052  2801              CMP      r0,#1                 ;2371
000054  d009              BEQ      |L39.106|
000056  2001              MOVS     r0,#1                 ;2371
000058  f884003c          STRB     r0,[r4,#0x3c]         ;2371
00005c  6820              LDR      r0,[r4,#0]            ;2374
00005e  6803              LDR      r3,[r0,#0]            ;2374
000060  07db              LSLS     r3,r3,#31             ;2374
000062  d004              BEQ      |L39.110|
000064  e007              B        |L39.118|
                  |L39.102|
000066  2001              MOVS     r0,#1                 ;2350
000068  bdf8              POP      {r3-r7,pc}
                  |L39.106|
00006a  2002              MOVS     r0,#2                 ;2371
00006c  bdf8              POP      {r3-r7,pc}
                  |L39.110|
00006e  6803              LDR      r3,[r0,#0]            ;2377
000070  f0430301          ORR      r3,r3,#1              ;2377
000074  6003              STR      r3,[r0,#0]            ;2377
                  |L39.118|
000076  6820              LDR      r0,[r4,#0]            ;2381
000078  6803              LDR      r3,[r0,#0]            ;2381
00007a  f4236300          BIC      r3,r3,#0x800          ;2381
00007e  6003              STR      r3,[r0,#0]            ;2381
000080  2022              MOVS     r0,#0x22              ;2383
000082  f884003d          STRB     r0,[r4,#0x3d]         ;2383
000086  f884603e          STRB     r6,[r4,#0x3e]         ;2384
00008a  6425              STR      r5,[r4,#0x40]         ;2385
00008c  6261              STR      r1,[r4,#0x24]         ;2388
00008e  8562              STRH     r2,[r4,#0x2a]         ;2389
000090  4814              LDR      r0,|L39.228|
000092  62e0              STR      r0,[r4,#0x2c]         ;2390
000094  8d60              LDRH     r0,[r4,#0x2a]         ;2391
000096  8520              STRH     r0,[r4,#0x28]         ;2391
000098  6ba1              LDR      r1,[r4,#0x38]         ;2394
00009a  4813              LDR      r0,|L39.232|
00009c  6288              STR      r0,[r1,#0x28]         ;2394
00009e  6ba1              LDR      r1,[r4,#0x38]         ;2397
0000a0  4812              LDR      r0,|L39.236|
0000a2  6308              STR      r0,[r1,#0x30]         ;2397
0000a4  6ba0              LDR      r0,[r4,#0x38]         ;2400
0000a6  62c5              STR      r5,[r0,#0x2c]         ;2400
0000a8  6ba0              LDR      r0,[r4,#0x38]         ;2401
0000aa  6345              STR      r5,[r0,#0x34]         ;2401
0000ac  6821              LDR      r1,[r4,#0]            ;2404
0000ae  8d23              LDRH     r3,[r4,#0x28]         ;2404
0000b0  3110              ADDS     r1,r1,#0x10           ;2404
0000b2  6a62              LDR      r2,[r4,#0x24]         ;2404
0000b4  6ba0              LDR      r0,[r4,#0x38]         ;2404
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6820              LDR      r0,[r4,#0]            ;2407
0000bc  6801              LDR      r1,[r0,#0]            ;2407
0000be  f4416180          ORR      r1,r1,#0x400          ;2407
0000c2  6001              STR      r1,[r0,#0]            ;2407
0000c4  f884503c          STRB     r5,[r4,#0x3c]         ;2410
0000c8  6820              LDR      r0,[r4,#0]            ;2416
0000ca  6841              LDR      r1,[r0,#4]            ;2416
0000cc  f4417140          ORR      r1,r1,#0x300          ;2416
0000d0  6041              STR      r1,[r0,#4]            ;2416
0000d2  6820              LDR      r0,[r4,#0]            ;2419
0000d4  6841              LDR      r1,[r0,#4]            ;2419
0000d6  f4416100          ORR      r1,r1,#0x800          ;2419
0000da  6041              STR      r1,[r0,#4]            ;2419
0000dc  2000              MOVS     r0,#0                 ;2421
0000de  bdf8              POP      {r3-r7,pc}
;;;2428   /**
                          ENDP

                  |L39.224|
                          DCD      SystemCoreClock
                  |L39.228|
                          DCD      0xffff0000
                  |L39.232|
                          DCD      I2C_DMAXferCplt
                  |L39.236|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1682     */
;;;1683   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b578              PUSH     {r3-r6,lr}
;;;1684   {
;;;1685     __IO uint32_t count = 0U;
000002  2500              MOVS     r5,#0
000004  9500              STR      r5,[sp,#0]
;;;1686   
;;;1687     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f890303d          LDRB     r3,[r0,#0x3d]
00000a  2b20              CMP      r3,#0x20
00000c  d001              BEQ      |L40.18|
;;;1688     {
;;;1689       if((pData == NULL) || (Size == 0U))
;;;1690       {
;;;1691         return  HAL_ERROR;
;;;1692       }
;;;1693   
;;;1694       /* Wait until BUSY flag is reset */
;;;1695       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1696       do
;;;1697       {
;;;1698         if(count-- == 0U)
;;;1699         {
;;;1700           hi2c->PreviousState = I2C_STATE_NONE;
;;;1701           hi2c->State= HAL_I2C_STATE_READY;
;;;1702   
;;;1703           /* Process Unlocked */
;;;1704           __HAL_UNLOCK(hi2c);
;;;1705   
;;;1706           return HAL_TIMEOUT; 
;;;1707         }
;;;1708       }
;;;1709       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1710   
;;;1711       /* Process Locked */
;;;1712       __HAL_LOCK(hi2c);
;;;1713   
;;;1714       /* Check if the I2C is already enabled */
;;;1715       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1716       {
;;;1717         /* Enable I2C peripheral */
;;;1718         __HAL_I2C_ENABLE(hi2c);
;;;1719       }
;;;1720   
;;;1721       /* Disable Pos */
;;;1722       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1723   
;;;1724       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1725       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1726       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1727   
;;;1728       /* Prepare transfer parameters */
;;;1729       hi2c->pBuffPtr = pData;
;;;1730       hi2c->XferSize = Size;
;;;1731       hi2c->XferCount = Size;
;;;1732       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1733   
;;;1734       /* Enable Address Acknowledge */
;;;1735       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1736   
;;;1737       /* Process Unlocked */
;;;1738       __HAL_UNLOCK(hi2c);
;;;1739   
;;;1740       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1741                 to avoid the risk of I2C interrupt handle execution before current
;;;1742                 process unlock */
;;;1743   
;;;1744       /* Enable EVT, BUF and ERR interrupt */
;;;1745       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1746   
;;;1747       return HAL_OK;
;;;1748     }
;;;1749     else
;;;1750     {
;;;1751       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;1752     }
;;;1753   }
000010  bd78              POP      {r3-r6,pc}
                  |L40.18|
000012  b339              CBZ      r1,|L40.100|
000014  b332              CBZ      r2,|L40.100|
000016  4b26              LDR      r3,|L40.176|
000018  f24614a8          MOV      r4,#0x61a8            ;1695
00001c  681b              LDR      r3,[r3,#0]            ;1695  ; SystemCoreClock
00001e  fbb3f3f4          UDIV     r3,r3,r4              ;1695
000022  eb0304c3          ADD      r4,r3,r3,LSL #3       ;1695
000026  eb041303          ADD      r3,r4,r3,LSL #4       ;1695
00002a  9300              STR      r3,[sp,#0]            ;1695
00002c  2620              MOVS     r6,#0x20              ;1701
                  |L40.46|
00002e  9b00              LDR      r3,[sp,#0]            ;1698
000030  1e5c              SUBS     r4,r3,#1              ;1698
000032  9400              STR      r4,[sp,#0]            ;1698
000034  d205              BCS      |L40.66|
000036  f8405f30          STR      r5,[r0,#0x30]!        ;1700
00003a  7346              STRB     r6,[r0,#0xd]          ;1701
00003c  7305              STRB     r5,[r0,#0xc]          ;1704
00003e  2003              MOVS     r0,#3                 ;1706
000040  bd78              POP      {r3-r6,pc}
                  |L40.66|
000042  6803              LDR      r3,[r0,#0]            ;1709
000044  699b              LDR      r3,[r3,#0x18]         ;1709
000046  43db              MVNS     r3,r3                 ;1709
000048  079b              LSLS     r3,r3,#30             ;1709
00004a  d5f0              BPL      |L40.46|
00004c  f890303c          LDRB     r3,[r0,#0x3c]         ;1712
000050  2b01              CMP      r3,#1                 ;1712
000052  d009              BEQ      |L40.104|
000054  2301              MOVS     r3,#1                 ;1712
000056  f880303c          STRB     r3,[r0,#0x3c]         ;1712
00005a  6803              LDR      r3,[r0,#0]            ;1715
00005c  681c              LDR      r4,[r3,#0]            ;1715
00005e  07e4              LSLS     r4,r4,#31             ;1715
000060  d004              BEQ      |L40.108|
000062  e007              B        |L40.116|
                  |L40.100|
000064  2001              MOVS     r0,#1                 ;1691
000066  bd78              POP      {r3-r6,pc}
                  |L40.104|
000068  2002              MOVS     r0,#2                 ;1712
00006a  bd78              POP      {r3-r6,pc}
                  |L40.108|
00006c  681c              LDR      r4,[r3,#0]            ;1718
00006e  f0440401          ORR      r4,r4,#1              ;1718
000072  601c              STR      r4,[r3,#0]            ;1718
                  |L40.116|
000074  6803              LDR      r3,[r0,#0]            ;1722
000076  681c              LDR      r4,[r3,#0]            ;1722
000078  f4246400          BIC      r4,r4,#0x800          ;1722
00007c  601c              STR      r4,[r3,#0]            ;1722
00007e  2322              MOVS     r3,#0x22              ;1724
000080  f880303d          STRB     r3,[r0,#0x3d]         ;1724
000084  f880603e          STRB     r6,[r0,#0x3e]         ;1725
000088  6405              STR      r5,[r0,#0x40]         ;1726
00008a  6241              STR      r1,[r0,#0x24]         ;1729
00008c  8502              STRH     r2,[r0,#0x28]         ;1730
00008e  8542              STRH     r2,[r0,#0x2a]         ;1731
000090  4908              LDR      r1,|L40.180|
000092  62c1              STR      r1,[r0,#0x2c]         ;1732
000094  6801              LDR      r1,[r0,#0]            ;1735
000096  680a              LDR      r2,[r1,#0]            ;1735
000098  f4426280          ORR      r2,r2,#0x400          ;1735
00009c  600a              STR      r2,[r1,#0]            ;1735
00009e  f880503c          STRB     r5,[r0,#0x3c]         ;1738
0000a2  6800              LDR      r0,[r0,#0]            ;1745
0000a4  6841              LDR      r1,[r0,#4]            ;1745
0000a6  f44161e0          ORR      r1,r1,#0x700          ;1745
0000aa  6041              STR      r1,[r0,#4]            ;1745
0000ac  2000              MOVS     r0,#0                 ;1747
0000ae  bd78              POP      {r3-r6,pc}
;;;1754   
                          ENDP

                  |L40.176|
                          DCD      SystemCoreClock
                  |L40.180|
                          DCD      0xffff0000

                          AREA ||i.HAL_I2C_Slave_Sequential_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Sequential_Receive_IT PROC
;;;1830     */
;;;1831   HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;1832   {
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;1835   
;;;1836     if(hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f890403d          LDRB     r4,[r0,#0x3d]
000006  2c28              CMP      r4,#0x28
000008  d001              BEQ      |L41.14|
;;;1837     {
;;;1838       if((pData == NULL) || (Size == 0U))
;;;1839       {
;;;1840         return  HAL_ERROR;
;;;1841       }
;;;1842   
;;;1843       /* Process Locked */
;;;1844       __HAL_LOCK(hi2c);
;;;1845   
;;;1846       /* Check if the I2C is already enabled */
;;;1847       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1848       {
;;;1849         /* Enable I2C peripheral */
;;;1850         __HAL_I2C_ENABLE(hi2c);
;;;1851       }
;;;1852   
;;;1853       /* Disable Pos */
;;;1854       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1855   
;;;1856       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;1857       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1858       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1859   
;;;1860       /* Prepare transfer parameters */
;;;1861       hi2c->pBuffPtr   = pData;
;;;1862       hi2c->XferCount   = Size;
;;;1863       hi2c->XferOptions = XferOptions;
;;;1864       hi2c->XferSize    = hi2c->XferCount;
;;;1865   
;;;1866       /* Clear ADDR flag */
;;;1867       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1868   
;;;1869       /* Process Unlocked */
;;;1870       __HAL_UNLOCK(hi2c);
;;;1871   
;;;1872       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1873                 to avoid the risk of I2C interrupt handle execution before current
;;;1874                 process unlock */
;;;1875   
;;;1876       /* Enable EVT, BUF and ERR interrupt */
;;;1877       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1878   
;;;1879       return HAL_OK;
;;;1880     }
;;;1881     else
;;;1882     {
;;;1883       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;1884     }
;;;1885   }
00000c  bd38              POP      {r3-r5,pc}
                  |L41.14|
00000e  b161              CBZ      r1,|L41.42|
000010  b15a              CBZ      r2,|L41.42|
000012  f890403c          LDRB     r4,[r0,#0x3c]         ;1844
000016  2c01              CMP      r4,#1                 ;1844
000018  d009              BEQ      |L41.46|
00001a  2401              MOVS     r4,#1                 ;1844
00001c  f880403c          STRB     r4,[r0,#0x3c]         ;1844
000020  6804              LDR      r4,[r0,#0]            ;1847
000022  6825              LDR      r5,[r4,#0]            ;1847
000024  07ed              LSLS     r5,r5,#31             ;1847
000026  d004              BEQ      |L41.50|
000028  e007              B        |L41.58|
                  |L41.42|
00002a  2001              MOVS     r0,#1                 ;1840
00002c  bd38              POP      {r3-r5,pc}
                  |L41.46|
00002e  2002              MOVS     r0,#2                 ;1844
000030  bd38              POP      {r3-r5,pc}
                  |L41.50|
000032  6825              LDR      r5,[r4,#0]            ;1850
000034  f0450501          ORR      r5,r5,#1              ;1850
000038  6025              STR      r5,[r4,#0]            ;1850
                  |L41.58|
00003a  6804              LDR      r4,[r0,#0]            ;1854
00003c  6825              LDR      r5,[r4,#0]            ;1854
00003e  f4256500          BIC      r5,r5,#0x800          ;1854
000042  6025              STR      r5,[r4,#0]            ;1854
000044  242a              MOVS     r4,#0x2a              ;1856
000046  f880403d          STRB     r4,[r0,#0x3d]         ;1856
00004a  2420              MOVS     r4,#0x20              ;1857
00004c  f880403e          STRB     r4,[r0,#0x3e]         ;1857
000050  2400              MOVS     r4,#0                 ;1858
000052  6404              STR      r4,[r0,#0x40]         ;1858
000054  6241              STR      r1,[r0,#0x24]         ;1861
000056  8542              STRH     r2,[r0,#0x2a]         ;1862
000058  62c3              STR      r3,[r0,#0x2c]         ;1863
00005a  8d41              LDRH     r1,[r0,#0x2a]         ;1864
00005c  8501              STRH     r1,[r0,#0x28]         ;1864
00005e  6801              LDR      r1,[r0,#0]            ;1867
000060  694a              LDR      r2,[r1,#0x14]         ;1867
000062  698a              LDR      r2,[r1,#0x18]         ;1867
000064  9200              STR      r2,[sp,#0]            ;1867
000066  f880403c          STRB     r4,[r0,#0x3c]         ;1870
00006a  6848              LDR      r0,[r1,#4]            ;1877
00006c  f44060e0          ORR      r0,r0,#0x700          ;1877
000070  6048              STR      r0,[r1,#4]            ;1877
000072  2000              MOVS     r0,#0                 ;1879
000074  bd38              POP      {r3-r5,pc}
;;;1886   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Sequential_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Sequential_Transmit_IT PROC
;;;1764     */
;;;1765   HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b538              PUSH     {r3-r5,lr}
;;;1766   {
;;;1767     /* Check the parameters */
;;;1768     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;1769   
;;;1770     if(hi2c->State == HAL_I2C_STATE_LISTEN)
000002  f890403d          LDRB     r4,[r0,#0x3d]
000006  2c28              CMP      r4,#0x28
000008  d001              BEQ      |L42.14|
;;;1771     {
;;;1772       if((pData == NULL) || (Size == 0U))
;;;1773       {
;;;1774         return  HAL_ERROR;
;;;1775       }
;;;1776   
;;;1777       /* Process Locked */
;;;1778       __HAL_LOCK(hi2c);
;;;1779   
;;;1780       /* Check if the I2C is already enabled */
;;;1781       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1782       {
;;;1783         /* Enable I2C peripheral */
;;;1784         __HAL_I2C_ENABLE(hi2c);
;;;1785       }
;;;1786   
;;;1787       /* Disable Pos */
;;;1788       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1789   
;;;1790       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;1791       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1792       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1793   
;;;1794       /* Prepare transfer parameters */
;;;1795       hi2c->pBuffPtr    = pData;
;;;1796       hi2c->XferCount   = Size;
;;;1797       hi2c->XferOptions = XferOptions;
;;;1798       hi2c->XferSize    = hi2c->XferCount;
;;;1799   
;;;1800       /* Clear ADDR flag */
;;;1801       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1802   
;;;1803       /* Process Unlocked */
;;;1804       __HAL_UNLOCK(hi2c);
;;;1805   
;;;1806       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1807                 to avoid the risk of I2C interrupt handle execution before current
;;;1808                 process unlock */
;;;1809   
;;;1810       /* Enable EVT, BUF and ERR interrupt */
;;;1811       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1812   
;;;1813       return HAL_OK;
;;;1814     }
;;;1815     else
;;;1816     {
;;;1817       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;1818     }
;;;1819   }
00000c  bd38              POP      {r3-r5,pc}
                  |L42.14|
00000e  b161              CBZ      r1,|L42.42|
000010  b15a              CBZ      r2,|L42.42|
000012  f890403c          LDRB     r4,[r0,#0x3c]         ;1778
000016  2c01              CMP      r4,#1                 ;1778
000018  d009              BEQ      |L42.46|
00001a  2401              MOVS     r4,#1                 ;1778
00001c  f880403c          STRB     r4,[r0,#0x3c]         ;1778
000020  6804              LDR      r4,[r0,#0]            ;1781
000022  6825              LDR      r5,[r4,#0]            ;1781
000024  07ed              LSLS     r5,r5,#31             ;1781
000026  d004              BEQ      |L42.50|
000028  e007              B        |L42.58|
                  |L42.42|
00002a  2001              MOVS     r0,#1                 ;1774
00002c  bd38              POP      {r3-r5,pc}
                  |L42.46|
00002e  2002              MOVS     r0,#2                 ;1778
000030  bd38              POP      {r3-r5,pc}
                  |L42.50|
000032  6825              LDR      r5,[r4,#0]            ;1784
000034  f0450501          ORR      r5,r5,#1              ;1784
000038  6025              STR      r5,[r4,#0]            ;1784
                  |L42.58|
00003a  6804              LDR      r4,[r0,#0]            ;1788
00003c  6825              LDR      r5,[r4,#0]            ;1788
00003e  f4256500          BIC      r5,r5,#0x800          ;1788
000042  6025              STR      r5,[r4,#0]            ;1788
000044  2429              MOVS     r4,#0x29              ;1790
000046  f880403d          STRB     r4,[r0,#0x3d]         ;1790
00004a  2420              MOVS     r4,#0x20              ;1791
00004c  f880403e          STRB     r4,[r0,#0x3e]         ;1791
000050  2400              MOVS     r4,#0                 ;1792
000052  6404              STR      r4,[r0,#0x40]         ;1792
000054  6241              STR      r1,[r0,#0x24]         ;1795
000056  8542              STRH     r2,[r0,#0x2a]         ;1796
000058  62c3              STR      r3,[r0,#0x2c]         ;1797
00005a  8d41              LDRH     r1,[r0,#0x2a]         ;1798
00005c  8501              STRH     r1,[r0,#0x28]         ;1798
00005e  6801              LDR      r1,[r0,#0]            ;1801
000060  694a              LDR      r2,[r1,#0x14]         ;1801
000062  698a              LDR      r2,[r1,#0x18]         ;1801
000064  9200              STR      r2,[sp,#0]            ;1801
000066  f880403c          STRB     r4,[r0,#0x3c]         ;1804
00006a  6848              LDR      r0,[r1,#4]            ;1811
00006c  f44060e0          ORR      r0,r0,#0x700          ;1811
000070  6048              STR      r0,[r1,#4]            ;1811
000072  2000              MOVS     r0,#0                 ;1813
000074  bd38              POP      {r3-r5,pc}
;;;1820   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit PROC
;;;982      */
;;;983    HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;984    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4692              MOV      r10,r2
00000a  4699              MOV      r9,r3
;;;985      uint32_t tickstart = 0x00U;
;;;986      
;;;987      /* Init tickstart for timeout management*/
;;;988      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;989      
;;;990      if(hi2c->State == HAL_I2C_STATE_READY)
000012  f894003d          LDRB     r0,[r4,#0x3d]
000016  2820              CMP      r0,#0x20
000018  d002              BEQ      |L43.32|
;;;991      {
;;;992        if((pData == NULL) || (Size == 0U))
;;;993        {
;;;994          return  HAL_ERROR;
;;;995        }
;;;996    
;;;997        /* Process Locked */
;;;998        __HAL_LOCK(hi2c);
;;;999        
;;;1000       /* Check if the I2C is already enabled */
;;;1001       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1002       {
;;;1003         /* Enable I2C peripheral */
;;;1004         __HAL_I2C_ENABLE(hi2c);
;;;1005       }
;;;1006   
;;;1007       /* Disable Pos */
;;;1008       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1009   
;;;1010       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1011       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1012       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1013   
;;;1014       /* Prepare transfer parameters */
;;;1015       hi2c->pBuffPtr    = pData;
;;;1016       hi2c->XferCount   = Size;
;;;1017       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1018       hi2c->XferSize    = hi2c->XferCount;
;;;1019   
;;;1020       /* Enable Address Acknowledge */
;;;1021       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1022   
;;;1023       /* Wait until ADDR flag is set */
;;;1024       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1025       {
;;;1026         return HAL_TIMEOUT;
;;;1027       }
;;;1028   
;;;1029       /* Clear ADDR flag */
;;;1030       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1031   
;;;1032       /* If 10bit addressing mode is selected */
;;;1033       if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;1034       {
;;;1035         /* Wait until ADDR flag is set */
;;;1036         if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1037         {
;;;1038           return HAL_TIMEOUT;
;;;1039         }
;;;1040   
;;;1041         /* Clear ADDR flag */
;;;1042         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1043       }
;;;1044   
;;;1045       while(hi2c->XferSize > 0U)
;;;1046       {
;;;1047         /* Wait until TXE flag is set */
;;;1048         if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1049         {
;;;1050           /* Disable Address Acknowledge */
;;;1051           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1052   
;;;1053           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1054           {
;;;1055             return HAL_ERROR;
;;;1056           }
;;;1057           else
;;;1058           {
;;;1059             return HAL_TIMEOUT;
;;;1060           }
;;;1061         }
;;;1062   
;;;1063         /* Write data to DR */
;;;1064         hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;1065         hi2c->XferCount--;
;;;1066         hi2c->XferSize--;
;;;1067   
;;;1068         if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
;;;1069         {
;;;1070           /* Write data to DR */
;;;1071           hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;1072           hi2c->XferCount--;
;;;1073           hi2c->XferSize--;
;;;1074         }
;;;1075       }
;;;1076   
;;;1077       /* Wait until AF flag is set */
;;;1078       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
;;;1079       {
;;;1080         return HAL_TIMEOUT;
;;;1081       }
;;;1082   
;;;1083       /* Clear AF flag */
;;;1084       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;1085   
;;;1086       /* Disable Address Acknowledge */
;;;1087       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;1088   
;;;1089       hi2c->State = HAL_I2C_STATE_READY;
;;;1090       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1091   
;;;1092       /* Process Unlocked */
;;;1093       __HAL_UNLOCK(hi2c);
;;;1094   
;;;1095       return HAL_OK;
;;;1096     }
;;;1097     else
;;;1098     {
;;;1099       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L43.28|
;;;1100     }
;;;1101   }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L43.32|
000020  b175              CBZ      r5,|L43.64|
000022  f1ba0f00          CMP      r10,#0                ;992
000026  d00b              BEQ      |L43.64|
000028  f894003c          LDRB     r0,[r4,#0x3c]         ;998
00002c  2801              CMP      r0,#1                 ;998
00002e  d009              BEQ      |L43.68|
000030  2001              MOVS     r0,#1                 ;998
000032  f884003c          STRB     r0,[r4,#0x3c]         ;998
000036  6820              LDR      r0,[r4,#0]            ;1001
000038  6801              LDR      r1,[r0,#0]            ;1001
00003a  07c9              LSLS     r1,r1,#31             ;1001
00003c  d004              BEQ      |L43.72|
00003e  e007              B        |L43.80|
                  |L43.64|
000040  2001              MOVS     r0,#1                 ;994
000042  e7eb              B        |L43.28|
                  |L43.68|
000044  2002              MOVS     r0,#2                 ;998
000046  e7e9              B        |L43.28|
                  |L43.72|
000048  6801              LDR      r1,[r0,#0]            ;1004
00004a  f0410101          ORR      r1,r1,#1              ;1004
00004e  6001              STR      r1,[r0,#0]            ;1004
                  |L43.80|
000050  6820              LDR      r0,[r4,#0]            ;1008
000052  6801              LDR      r1,[r0,#0]            ;1008
000054  f4216100          BIC      r1,r1,#0x800          ;1008
000058  6001              STR      r1,[r0,#0]            ;1008
00005a  2021              MOVS     r0,#0x21              ;1010
00005c  f884003d          STRB     r0,[r4,#0x3d]         ;1010
000060  2720              MOVS     r7,#0x20              ;1011
000062  f884703e          STRB     r7,[r4,#0x3e]         ;1011
000066  f04f0800          MOV      r8,#0                 ;1012
00006a  f8c48040          STR      r8,[r4,#0x40]         ;1012
00006e  6265              STR      r5,[r4,#0x24]         ;1015
000070  f8a4a02a          STRH     r10,[r4,#0x2a]        ;1016
000074  483c              LDR      r0,|L43.360|
000076  62e0              STR      r0,[r4,#0x2c]         ;1017
000078  8d60              LDRH     r0,[r4,#0x2a]         ;1018
00007a  8520              STRH     r0,[r4,#0x28]         ;1018
00007c  6820              LDR      r0,[r4,#0]            ;1021
00007e  6801              LDR      r1,[r0,#0]            ;1021
000080  f4416180          ORR      r1,r1,#0x400          ;1021
000084  6001              STR      r1,[r0,#0]            ;1021
000086  4d39              LDR      r5,|L43.364|
000088  464b              MOV      r3,r9                 ;1024
00008a  2200              MOVS     r2,#0                 ;1024
00008c  4629              MOV      r1,r5                 ;1024
00008e  4620              MOV      r0,r4                 ;1024
000090  9600              STR      r6,[sp,#0]            ;1024
000092  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000096  b108              CBZ      r0,|L43.156|
000098  2003              MOVS     r0,#3                 ;1026
00009a  e7bf              B        |L43.28|
                  |L43.156|
00009c  6820              LDR      r0,[r4,#0]            ;1030
00009e  6941              LDR      r1,[r0,#0x14]         ;1030
0000a0  6980              LDR      r0,[r0,#0x18]         ;1030
0000a2  9000              STR      r0,[sp,#0]            ;1030
0000a4  6920              LDR      r0,[r4,#0x10]         ;1033
0000a6  f5b04f40          CMP      r0,#0xc000            ;1033
0000aa  d13e              BNE      |L43.298|
0000ac  464b              MOV      r3,r9                 ;1036
0000ae  2200              MOVS     r2,#0                 ;1036
0000b0  4629              MOV      r1,r5                 ;1036
0000b2  4620              MOV      r0,r4                 ;1036
0000b4  9600              STR      r6,[sp,#0]            ;1036
0000b6  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000ba  b108              CBZ      r0,|L43.192|
0000bc  2003              MOVS     r0,#3                 ;1038
0000be  e7ad              B        |L43.28|
                  |L43.192|
0000c0  6820              LDR      r0,[r4,#0]            ;1042
0000c2  6941              LDR      r1,[r0,#0x14]         ;1042
0000c4  6980              LDR      r0,[r0,#0x18]         ;1042
0000c6  9000              STR      r0,[sp,#0]            ;1042
0000c8  e02f              B        |L43.298|
                  |L43.202|
0000ca  4632              MOV      r2,r6                 ;1048
0000cc  4649              MOV      r1,r9                 ;1048
0000ce  4620              MOV      r0,r4                 ;1048
0000d0  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000d4  b158              CBZ      r0,|L43.238|
0000d6  6820              LDR      r0,[r4,#0]            ;1051
0000d8  6801              LDR      r1,[r0,#0]            ;1051
0000da  f4216180          BIC      r1,r1,#0x400          ;1051
0000de  6001              STR      r1,[r0,#0]            ;1051
0000e0  6c20              LDR      r0,[r4,#0x40]         ;1053
0000e2  2804              CMP      r0,#4                 ;1053
0000e4  d001              BEQ      |L43.234|
0000e6  2003              MOVS     r0,#3                 ;1059
0000e8  e798              B        |L43.28|
                  |L43.234|
0000ea  2001              MOVS     r0,#1                 ;1055
0000ec  e796              B        |L43.28|
                  |L43.238|
0000ee  6a60              LDR      r0,[r4,#0x24]         ;1064
0000f0  1c41              ADDS     r1,r0,#1              ;1064
0000f2  6261              STR      r1,[r4,#0x24]         ;1064
0000f4  6821              LDR      r1,[r4,#0]            ;1064
0000f6  7800              LDRB     r0,[r0,#0]            ;1064
0000f8  6108              STR      r0,[r1,#0x10]         ;1064
0000fa  8d60              LDRH     r0,[r4,#0x2a]         ;1065
0000fc  1e40              SUBS     r0,r0,#1              ;1065
0000fe  8560              STRH     r0,[r4,#0x2a]         ;1065
000100  8d20              LDRH     r0,[r4,#0x28]         ;1066
000102  1e40              SUBS     r0,r0,#1              ;1066
000104  b280              UXTH     r0,r0                 ;1066
000106  8520              STRH     r0,[r4,#0x28]         ;1066
000108  6825              LDR      r5,[r4,#0]            ;1068
00010a  6969              LDR      r1,[r5,#0x14]         ;1068
00010c  43c9              MVNS     r1,r1                 ;1068
00010e  0749              LSLS     r1,r1,#29             ;1068
000110  d40b              BMI      |L43.298|
000112  b150              CBZ      r0,|L43.298|
000114  6a60              LDR      r0,[r4,#0x24]         ;1071
000116  1c41              ADDS     r1,r0,#1              ;1071
000118  6261              STR      r1,[r4,#0x24]         ;1071
00011a  7800              LDRB     r0,[r0,#0]            ;1071
00011c  6128              STR      r0,[r5,#0x10]         ;1071
00011e  8d60              LDRH     r0,[r4,#0x2a]         ;1072
000120  1e40              SUBS     r0,r0,#1              ;1072
000122  8560              STRH     r0,[r4,#0x2a]         ;1072
000124  8d20              LDRH     r0,[r4,#0x28]         ;1073
000126  1e40              SUBS     r0,r0,#1              ;1073
000128  8520              STRH     r0,[r4,#0x28]         ;1073
                  |L43.298|
00012a  8d20              LDRH     r0,[r4,#0x28]         ;1045
00012c  2800              CMP      r0,#0                 ;1045
00012e  d1cc              BNE      |L43.202|
000130  464b              MOV      r3,r9                 ;1078
000132  2200              MOVS     r2,#0                 ;1078
000134  f44f3182          MOV      r1,#0x10400           ;1078
000138  4620              MOV      r0,r4                 ;1078
00013a  9600              STR      r6,[sp,#0]            ;1078
00013c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000140  b108              CBZ      r0,|L43.326|
000142  2003              MOVS     r0,#3                 ;1080
000144  e76a              B        |L43.28|
                  |L43.326|
000146  6821              LDR      r1,[r4,#0]            ;1084
000148  f46f6080          MVN      r0,#0x400             ;1084
00014c  6148              STR      r0,[r1,#0x14]         ;1084
00014e  6820              LDR      r0,[r4,#0]            ;1087
000150  6801              LDR      r1,[r0,#0]            ;1087
000152  f4216180          BIC      r1,r1,#0x400          ;1087
000156  6001              STR      r1,[r0,#0]            ;1087
000158  f884703d          STRB     r7,[r4,#0x3d]         ;1089
00015c  f884803e          STRB     r8,[r4,#0x3e]         ;1090
000160  f884803c          STRB     r8,[r4,#0x3c]         ;1093
000164  2000              MOVS     r0,#0                 ;1095
000166  e759              B        |L43.28|
;;;1102   
                          ENDP

                  |L43.360|
                          DCD      0xffff0000
                  |L43.364|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;2246     */
;;;2247   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2248   {
000002  4604              MOV      r4,r0
;;;2249     __IO uint32_t count = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;2250     
;;;2251     if(hi2c->State == HAL_I2C_STATE_READY)
000008  f894003d          LDRB     r0,[r4,#0x3d]
00000c  2820              CMP      r0,#0x20
00000e  d001              BEQ      |L44.20|
;;;2252     {
;;;2253       if((pData == NULL) || (Size == 0U))
;;;2254       {
;;;2255         return  HAL_ERROR;
;;;2256       }
;;;2257   
;;;2258       /* Wait until BUSY flag is reset */
;;;2259       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;2260       do
;;;2261       {
;;;2262         if(count-- == 0U)
;;;2263         {
;;;2264           hi2c->PreviousState = I2C_STATE_NONE;
;;;2265           hi2c->State= HAL_I2C_STATE_READY;
;;;2266   
;;;2267           /* Process Unlocked */
;;;2268           __HAL_UNLOCK(hi2c);
;;;2269   
;;;2270           return HAL_TIMEOUT; 
;;;2271         }
;;;2272       }
;;;2273       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;2274   
;;;2275       /* Process Locked */
;;;2276       __HAL_LOCK(hi2c);
;;;2277   
;;;2278       /* Check if the I2C is already enabled */
;;;2279       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;2280       {
;;;2281         /* Enable I2C peripheral */
;;;2282         __HAL_I2C_ENABLE(hi2c);
;;;2283       }
;;;2284   
;;;2285       /* Disable Pos */
;;;2286       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;2287   
;;;2288       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2289       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2290       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2291   
;;;2292       /* Prepare transfer parameters */
;;;2293       hi2c->pBuffPtr    = pData;
;;;2294       hi2c->XferCount   = Size;
;;;2295       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2296       hi2c->XferSize    = hi2c->XferCount;
;;;2297   
;;;2298       /* Set the I2C DMA transfer complete callback */
;;;2299       hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
;;;2300       
;;;2301       /* Set the DMA error callback */
;;;2302       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2303   
;;;2304       /* Set the unused DMA callbacks to NULL */
;;;2305       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2306       hi2c->hdmatx->XferAbortCallback = NULL;
;;;2307   
;;;2308       /* Enable the DMA channel */
;;;2309       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
;;;2310   
;;;2311       /* Enable Address Acknowledge */
;;;2312       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;2313   
;;;2314       /* Process Unlocked */
;;;2315       __HAL_UNLOCK(hi2c);
;;;2316   
;;;2317         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2318                   to avoid the risk of I2C interrupt handle execution before current
;;;2319                   process unlock */
;;;2320       /* Enable EVT and ERR interrupt */
;;;2321       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;2322   
;;;2323       /* Enable DMA Request */
;;;2324       hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
;;;2325   
;;;2326       return HAL_OK;
;;;2327     }
;;;2328     else
;;;2329     {
;;;2330       return HAL_BUSY;
000010  2002              MOVS     r0,#2
;;;2331     }
;;;2332   }
000012  bdf8              POP      {r3-r7,pc}
                  |L44.20|
000014  b339              CBZ      r1,|L44.102|
000016  b332              CBZ      r2,|L44.102|
000018  4831              LDR      r0,|L44.224|
00001a  f24613a8          MOV      r3,#0x61a8            ;2259
00001e  6800              LDR      r0,[r0,#0]            ;2259  ; SystemCoreClock
000020  fbb0f0f3          UDIV     r0,r0,r3              ;2259
000024  eb0003c0          ADD      r3,r0,r0,LSL #3       ;2259
000028  eb031000          ADD      r0,r3,r0,LSL #4       ;2259
00002c  9000              STR      r0,[sp,#0]            ;2259
00002e  2620              MOVS     r6,#0x20              ;2265
                  |L44.48|
000030  9800              LDR      r0,[sp,#0]            ;2262
000032  1e43              SUBS     r3,r0,#1              ;2262
000034  9300              STR      r3,[sp,#0]            ;2262
000036  d205              BCS      |L44.68|
000038  f8445f30          STR      r5,[r4,#0x30]!        ;2264
00003c  7366              STRB     r6,[r4,#0xd]          ;2265
00003e  7325              STRB     r5,[r4,#0xc]          ;2268
000040  2003              MOVS     r0,#3                 ;2270
000042  bdf8              POP      {r3-r7,pc}
                  |L44.68|
000044  6820              LDR      r0,[r4,#0]            ;2273
000046  6980              LDR      r0,[r0,#0x18]         ;2273
000048  43c0              MVNS     r0,r0                 ;2273
00004a  0780              LSLS     r0,r0,#30             ;2273
00004c  d5f0              BPL      |L44.48|
00004e  f894003c          LDRB     r0,[r4,#0x3c]         ;2276
000052  2801              CMP      r0,#1                 ;2276
000054  d009              BEQ      |L44.106|
000056  2001              MOVS     r0,#1                 ;2276
000058  f884003c          STRB     r0,[r4,#0x3c]         ;2276
00005c  6820              LDR      r0,[r4,#0]            ;2279
00005e  6803              LDR      r3,[r0,#0]            ;2279
000060  07db              LSLS     r3,r3,#31             ;2279
000062  d004              BEQ      |L44.110|
000064  e007              B        |L44.118|
                  |L44.102|
000066  2001              MOVS     r0,#1                 ;2255
000068  bdf8              POP      {r3-r7,pc}
                  |L44.106|
00006a  2002              MOVS     r0,#2                 ;2276
00006c  bdf8              POP      {r3-r7,pc}
                  |L44.110|
00006e  6803              LDR      r3,[r0,#0]            ;2282
000070  f0430301          ORR      r3,r3,#1              ;2282
000074  6003              STR      r3,[r0,#0]            ;2282
                  |L44.118|
000076  6820              LDR      r0,[r4,#0]            ;2286
000078  6803              LDR      r3,[r0,#0]            ;2286
00007a  f4236300          BIC      r3,r3,#0x800          ;2286
00007e  6003              STR      r3,[r0,#0]            ;2286
000080  2021              MOVS     r0,#0x21              ;2288
000082  f884003d          STRB     r0,[r4,#0x3d]         ;2288
000086  f884603e          STRB     r6,[r4,#0x3e]         ;2289
00008a  6425              STR      r5,[r4,#0x40]         ;2290
00008c  6261              STR      r1,[r4,#0x24]         ;2293
00008e  8562              STRH     r2,[r4,#0x2a]         ;2294
000090  4814              LDR      r0,|L44.228|
000092  62e0              STR      r0,[r4,#0x2c]         ;2295
000094  8d60              LDRH     r0,[r4,#0x2a]         ;2296
000096  8520              STRH     r0,[r4,#0x28]         ;2296
000098  6b61              LDR      r1,[r4,#0x34]         ;2299
00009a  4813              LDR      r0,|L44.232|
00009c  6288              STR      r0,[r1,#0x28]         ;2299
00009e  6b61              LDR      r1,[r4,#0x34]         ;2302
0000a0  4812              LDR      r0,|L44.236|
0000a2  6308              STR      r0,[r1,#0x30]         ;2302
0000a4  6b60              LDR      r0,[r4,#0x34]         ;2305
0000a6  62c5              STR      r5,[r0,#0x2c]         ;2305
0000a8  6b60              LDR      r0,[r4,#0x34]         ;2306
0000aa  6345              STR      r5,[r0,#0x34]         ;2306
0000ac  6822              LDR      r2,[r4,#0]            ;2309
0000ae  8d23              LDRH     r3,[r4,#0x28]         ;2309
0000b0  3210              ADDS     r2,r2,#0x10           ;2309
0000b2  6a61              LDR      r1,[r4,#0x24]         ;2309
0000b4  6b60              LDR      r0,[r4,#0x34]         ;2309
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6820              LDR      r0,[r4,#0]            ;2312
0000bc  6801              LDR      r1,[r0,#0]            ;2312
0000be  f4416180          ORR      r1,r1,#0x400          ;2312
0000c2  6001              STR      r1,[r0,#0]            ;2312
0000c4  f884503c          STRB     r5,[r4,#0x3c]         ;2315
0000c8  6820              LDR      r0,[r4,#0]            ;2321
0000ca  6841              LDR      r1,[r0,#4]            ;2321
0000cc  f4417140          ORR      r1,r1,#0x300          ;2321
0000d0  6041              STR      r1,[r0,#4]            ;2321
0000d2  6820              LDR      r0,[r4,#0]            ;2324
0000d4  6841              LDR      r1,[r0,#4]            ;2324
0000d6  f4416100          ORR      r1,r1,#0x800          ;2324
0000da  6041              STR      r1,[r0,#4]            ;2324
0000dc  2000              MOVS     r0,#0                 ;2326
0000de  bdf8              POP      {r3-r7,pc}
;;;2333   
                          ENDP

                  |L44.224|
                          DCD      SystemCoreClock
                  |L44.228|
                          DCD      0xffff0000
                  |L44.232|
                          DCD      I2C_DMAXferCplt
                  |L44.236|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1602     */
;;;1603   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b578              PUSH     {r3-r6,lr}
;;;1604   {
;;;1605     __IO uint32_t count = 0U;
000002  2500              MOVS     r5,#0
000004  9500              STR      r5,[sp,#0]
;;;1606   
;;;1607     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f890303d          LDRB     r3,[r0,#0x3d]
00000a  2b20              CMP      r3,#0x20
00000c  d001              BEQ      |L45.18|
;;;1608     {
;;;1609       if((pData == NULL) || (Size == 0U))
;;;1610       {
;;;1611         return  HAL_ERROR;
;;;1612       }
;;;1613   
;;;1614       /* Wait until BUSY flag is reset */
;;;1615       count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
;;;1616       do
;;;1617       {
;;;1618         if(count-- == 0U)
;;;1619         {
;;;1620           hi2c->PreviousState = I2C_STATE_NONE;
;;;1621           hi2c->State= HAL_I2C_STATE_READY;
;;;1622   
;;;1623           /* Process Unlocked */
;;;1624           __HAL_UNLOCK(hi2c);
;;;1625   
;;;1626           return HAL_TIMEOUT; 
;;;1627         }
;;;1628       }
;;;1629       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
;;;1630   
;;;1631       /* Process Locked */
;;;1632       __HAL_LOCK(hi2c);
;;;1633   
;;;1634       /* Check if the I2C is already enabled */
;;;1635       if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
;;;1636       {
;;;1637         /* Enable I2C peripheral */
;;;1638         __HAL_I2C_ENABLE(hi2c);
;;;1639       }
;;;1640   
;;;1641       /* Disable Pos */
;;;1642       hi2c->Instance->CR1 &= ~I2C_CR1_POS;
;;;1643   
;;;1644       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1645       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1646       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1647   
;;;1648       /* Prepare transfer parameters */
;;;1649       hi2c->pBuffPtr    = pData;
;;;1650       hi2c->XferCount   = Size;
;;;1651       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1652       hi2c->XferSize    = hi2c->XferCount;
;;;1653   
;;;1654       /* Enable Address Acknowledge */
;;;1655       hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;1656   
;;;1657       /* Process Unlocked */
;;;1658       __HAL_UNLOCK(hi2c);
;;;1659   
;;;1660       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1661                 to avoid the risk of I2C interrupt handle execution before current
;;;1662                 process unlock */
;;;1663   
;;;1664       /* Enable EVT, BUF and ERR interrupt */
;;;1665       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1666   
;;;1667       return HAL_OK;
;;;1668     }
;;;1669     else
;;;1670     {
;;;1671       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;1672     }
;;;1673   }
000010  bd78              POP      {r3-r6,pc}
                  |L45.18|
000012  b339              CBZ      r1,|L45.100|
000014  b332              CBZ      r2,|L45.100|
000016  4b27              LDR      r3,|L45.180|
000018  f24614a8          MOV      r4,#0x61a8            ;1615
00001c  681b              LDR      r3,[r3,#0]            ;1615  ; SystemCoreClock
00001e  fbb3f3f4          UDIV     r3,r3,r4              ;1615
000022  eb0304c3          ADD      r4,r3,r3,LSL #3       ;1615
000026  eb041303          ADD      r3,r4,r3,LSL #4       ;1615
00002a  9300              STR      r3,[sp,#0]            ;1615
00002c  2620              MOVS     r6,#0x20              ;1621
                  |L45.46|
00002e  9b00              LDR      r3,[sp,#0]            ;1618
000030  1e5c              SUBS     r4,r3,#1              ;1618
000032  9400              STR      r4,[sp,#0]            ;1618
000034  d205              BCS      |L45.66|
000036  f8405f30          STR      r5,[r0,#0x30]!        ;1620
00003a  7346              STRB     r6,[r0,#0xd]          ;1621
00003c  7305              STRB     r5,[r0,#0xc]          ;1624
00003e  2003              MOVS     r0,#3                 ;1626
000040  bd78              POP      {r3-r6,pc}
                  |L45.66|
000042  6803              LDR      r3,[r0,#0]            ;1629
000044  699b              LDR      r3,[r3,#0x18]         ;1629
000046  43db              MVNS     r3,r3                 ;1629
000048  079b              LSLS     r3,r3,#30             ;1629
00004a  d5f0              BPL      |L45.46|
00004c  f890303c          LDRB     r3,[r0,#0x3c]         ;1632
000050  2b01              CMP      r3,#1                 ;1632
000052  d009              BEQ      |L45.104|
000054  2301              MOVS     r3,#1                 ;1632
000056  f880303c          STRB     r3,[r0,#0x3c]         ;1632
00005a  6803              LDR      r3,[r0,#0]            ;1635
00005c  681c              LDR      r4,[r3,#0]            ;1635
00005e  07e4              LSLS     r4,r4,#31             ;1635
000060  d004              BEQ      |L45.108|
000062  e007              B        |L45.116|
                  |L45.100|
000064  2001              MOVS     r0,#1                 ;1611
000066  bd78              POP      {r3-r6,pc}
                  |L45.104|
000068  2002              MOVS     r0,#2                 ;1632
00006a  bd78              POP      {r3-r6,pc}
                  |L45.108|
00006c  681c              LDR      r4,[r3,#0]            ;1638
00006e  f0440401          ORR      r4,r4,#1              ;1638
000072  601c              STR      r4,[r3,#0]            ;1638
                  |L45.116|
000074  6803              LDR      r3,[r0,#0]            ;1642
000076  681c              LDR      r4,[r3,#0]            ;1642
000078  f4246400          BIC      r4,r4,#0x800          ;1642
00007c  601c              STR      r4,[r3,#0]            ;1642
00007e  2321              MOVS     r3,#0x21              ;1644
000080  f880303d          STRB     r3,[r0,#0x3d]         ;1644
000084  f880603e          STRB     r6,[r0,#0x3e]         ;1645
000088  6405              STR      r5,[r0,#0x40]         ;1646
00008a  6241              STR      r1,[r0,#0x24]         ;1649
00008c  8542              STRH     r2,[r0,#0x2a]         ;1650
00008e  490a              LDR      r1,|L45.184|
000090  62c1              STR      r1,[r0,#0x2c]         ;1651
000092  8d41              LDRH     r1,[r0,#0x2a]         ;1652
000094  8501              STRH     r1,[r0,#0x28]         ;1652
000096  6801              LDR      r1,[r0,#0]            ;1655
000098  680a              LDR      r2,[r1,#0]            ;1655
00009a  f4426280          ORR      r2,r2,#0x400          ;1655
00009e  600a              STR      r2,[r1,#0]            ;1655
0000a0  f880503c          STRB     r5,[r0,#0x3c]         ;1658
0000a4  6800              LDR      r0,[r0,#0]            ;1665
0000a6  6841              LDR      r1,[r0,#4]            ;1665
0000a8  f44161e0          ORR      r1,r1,#0x700          ;1665
0000ac  6041              STR      r1,[r0,#4]            ;1665
0000ae  2000              MOVS     r0,#0                 ;1667
0000b0  bd78              POP      {r3-r6,pc}
;;;1674   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L45.180|
                          DCD      SystemCoreClock
                  |L45.184|
                          DCD      0xffff0000

                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=1

                  I2C_DMAAbort PROC
;;;5261     */
;;;5262   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5263   {
;;;5264     I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;5265     
;;;5266     /* Disable Acknowledge */
;;;5267     hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f4226280          BIC      r2,r2,#0x400
00000c  600a              STR      r2,[r1,#0]
;;;5268   
;;;5269     hi2c->XferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  8541              STRH     r1,[r0,#0x2a]
;;;5270   
;;;5271     /* Reset XferAbortCallback */
;;;5272     hi2c->hdmatx->XferAbortCallback = NULL;
000012  6b42              LDR      r2,[r0,#0x34]
000014  6351              STR      r1,[r2,#0x34]
;;;5273     hi2c->hdmarx->XferAbortCallback = NULL;
000016  6b82              LDR      r2,[r0,#0x38]
000018  6351              STR      r1,[r2,#0x34]
;;;5274   
;;;5275     /* Check if come from abort from user */
;;;5276     if(hi2c->State == HAL_I2C_STATE_ABORT)
00001a  f890303d          LDRB     r3,[r0,#0x3d]
;;;5277     {
;;;5278       hi2c->State = HAL_I2C_STATE_READY;
00001e  2220              MOVS     r2,#0x20
000020  2b60              CMP      r3,#0x60              ;5276
000022  d00b              BEQ      |L46.60|
;;;5279       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5280       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;5281   
;;;5282       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;5283       __HAL_I2C_DISABLE(hi2c);
;;;5284   
;;;5285       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5286       HAL_I2C_AbortCpltCallback(hi2c);
;;;5287     }
;;;5288     else
;;;5289     {
;;;5290       hi2c->State = HAL_I2C_STATE_READY;
000024  f880203d          STRB     r2,[r0,#0x3d]
;;;5291       hi2c->Mode = HAL_I2C_MODE_NONE;
000028  f880103e          STRB     r1,[r0,#0x3e]
;;;5292   
;;;5293       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;5294       __HAL_I2C_DISABLE(hi2c);
00002c  6801              LDR      r1,[r0,#0]
00002e  680a              LDR      r2,[r1,#0]
000030  f0220201          BIC      r2,r2,#1
000034  600a              STR      r2,[r1,#0]
;;;5295   
;;;5296       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;5297       HAL_I2C_ErrorCallback(hi2c);
000036  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;5298     }
;;;5299   }
00003a  bd10              POP      {r4,pc}
                  |L46.60|
00003c  f880203d          STRB     r2,[r0,#0x3d]         ;5278
000040  f880103e          STRB     r1,[r0,#0x3e]         ;5279
000044  6401              STR      r1,[r0,#0x40]         ;5280
000046  6801              LDR      r1,[r0,#0]            ;5283
000048  680a              LDR      r2,[r1,#0]            ;5283
00004a  f0220201          BIC      r2,r2,#1              ;5283
00004e  600a              STR      r2,[r1,#0]            ;5283
000050  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000054  bd10              POP      {r4,pc}
;;;5300   
                          ENDP


                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;5238     */
;;;5239   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5240   {
;;;5241     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;5242     
;;;5243     /* Disable Acknowledge */
;;;5244     hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f4226280          BIC      r2,r2,#0x400
00000c  600a              STR      r2,[r1,#0]
;;;5245     
;;;5246     hi2c->XferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  8541              STRH     r1,[r0,#0x2a]
;;;5247     
;;;5248     hi2c->State = HAL_I2C_STATE_READY;
000012  2220              MOVS     r2,#0x20
000014  f880203d          STRB     r2,[r0,#0x3d]
;;;5249     hi2c->Mode = HAL_I2C_MODE_NONE;
000018  f880103e          STRB     r1,[r0,#0x3e]
;;;5250     
;;;5251     hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
00001c  6c01              LDR      r1,[r0,#0x40]
00001e  f0410110          ORR      r1,r1,#0x10
000022  6401              STR      r1,[r0,#0x40]
;;;5252     
;;;5253       HAL_I2C_ErrorCallback(hi2c);
000024  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;5254   }
000028  bd10              POP      {r4,pc}
;;;5255   
                          ENDP


                          AREA ||i.I2C_DMAXferCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAXferCplt PROC
;;;5174     */
;;;5175   static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5176   {
000002  4601              MOV      r1,r0
;;;5177     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;5178     
;;;5179     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;5180     uint32_t CurrentState = hi2c->State;
000006  f890203d          LDRB     r2,[r0,#0x3d]
;;;5181     uint32_t CurrentMode  = hi2c->Mode;
00000a  f890403e          LDRB     r4,[r0,#0x3e]
00000e  6a49              LDR      r1,[r1,#0x24]         ;5177
;;;5182   
;;;5183     if((CurrentState == HAL_I2C_STATE_BUSY_TX) || ((CurrentState == HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE))) 
000010  2300              MOVS     r3,#0
000012  2a21              CMP      r2,#0x21
;;;5184     {
;;;5185       /* Disable DMA Request */
;;;5186       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
000014  6809              LDR      r1,[r1,#0]
000016  d01c              BEQ      |L48.82|
000018  2a22              CMP      r2,#0x22              ;5183
00001a  d101              BNE      |L48.32|
00001c  2c20              CMP      r4,#0x20              ;5183
00001e  d018              BEQ      |L48.82|
                  |L48.32|
;;;5187       
;;;5188       hi2c->XferCount = 0U;
;;;5189       
;;;5190       /* Enable EVT and ERR interrupt */
;;;5191       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;5192     }
;;;5193     else
;;;5194     {
;;;5195       /* Disable Acknowledge */
;;;5196       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000020  680a              LDR      r2,[r1,#0]
000022  f4226280          BIC      r2,r2,#0x400
000026  600a              STR      r2,[r1,#0]
;;;5197       
;;;5198       /* Generate Stop */
;;;5199       hi2c->Instance->CR1 |= I2C_CR1_STOP;
000028  6801              LDR      r1,[r0,#0]
00002a  680a              LDR      r2,[r1,#0]
00002c  f4427200          ORR      r2,r2,#0x200
000030  600a              STR      r2,[r1,#0]
;;;5200       
;;;5201       /* Disable Last DMA */
;;;5202       hi2c->Instance->CR2 &= ~I2C_CR2_LAST;
000032  6801              LDR      r1,[r0,#0]
000034  684a              LDR      r2,[r1,#4]
000036  f4225280          BIC      r2,r2,#0x1000
00003a  604a              STR      r2,[r1,#4]
;;;5203       
;;;5204       /* Disable DMA Request */
;;;5205       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
00003c  6801              LDR      r1,[r0,#0]
00003e  684a              LDR      r2,[r1,#4]
000040  f4226200          BIC      r2,r2,#0x800
000044  604a              STR      r2,[r1,#4]
;;;5206       
;;;5207       hi2c->XferCount = 0U;
000046  8543              STRH     r3,[r0,#0x2a]
;;;5208   
;;;5209       /* Check if Errors has been detected during transfer */
;;;5210       if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
000048  6c01              LDR      r1,[r0,#0x40]
00004a  b169              CBZ      r1,|L48.104|
;;;5211       {
;;;5212         HAL_I2C_ErrorCallback(hi2c);
00004c  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;5213       }
;;;5214       else
;;;5215       {
;;;5216         hi2c->State = HAL_I2C_STATE_READY;
;;;5217   
;;;5218         if(hi2c->Mode == HAL_I2C_MODE_MEM)
;;;5219         {
;;;5220           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5221   
;;;5222           HAL_I2C_MemRxCpltCallback(hi2c);
;;;5223         }
;;;5224         else
;;;5225         {
;;;5226           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;5227   
;;;5228           HAL_I2C_MasterRxCpltCallback(hi2c);
;;;5229         }
;;;5230       }
;;;5231     }
;;;5232   }
000050  bd10              POP      {r4,pc}
                  |L48.82|
000052  684a              LDR      r2,[r1,#4]            ;5186
000054  f4226200          BIC      r2,r2,#0x800          ;5186
000058  604a              STR      r2,[r1,#4]            ;5186
00005a  8543              STRH     r3,[r0,#0x2a]         ;5188
00005c  6800              LDR      r0,[r0,#0]            ;5191
00005e  6841              LDR      r1,[r0,#4]            ;5191
000060  f4417140          ORR      r1,r1,#0x300          ;5191
000064  6041              STR      r1,[r0,#4]            ;5191
000066  bd10              POP      {r4,pc}
                  |L48.104|
000068  2120              MOVS     r1,#0x20              ;5216
00006a  f880103d          STRB     r1,[r0,#0x3d]         ;5216
00006e  f890103e          LDRB     r1,[r0,#0x3e]         ;5218
000072  2940              CMP      r1,#0x40              ;5218
000074  d004              BEQ      |L48.128|
000076  f880303e          STRB     r3,[r0,#0x3e]         ;5226
00007a  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
00007e  bd10              POP      {r4,pc}
                  |L48.128|
000080  f880303e          STRB     r3,[r0,#0x3e]         ;5220
000084  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000088  bd10              POP      {r4,pc}
;;;5233   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;4646     */
;;;4647   static void I2C_ITError(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;4648   {
000002  4604              MOV      r4,r0
;;;4649     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;4650     uint32_t CurrentState = hi2c->State;
000004  f894103d          LDRB     r1,[r4,#0x3d]
;;;4651   
;;;4652     if((CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
000008  2600              MOVS     r6,#0
;;;4653     {
;;;4654       /* keep HAL_I2C_STATE_LISTEN */
;;;4655       hi2c->PreviousState = I2C_STATE_NONE;
;;;4656       hi2c->State = HAL_I2C_STATE_LISTEN;
;;;4657     }
;;;4658     else
;;;4659     {
;;;4660       /* If state is an abort treatment on going, don't change state */
;;;4661       /* This change will be do later */
;;;4662       if((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) != I2C_CR2_DMAEN))
;;;4663       {
;;;4664         hi2c->State = HAL_I2C_STATE_READY;
00000a  2520              MOVS     r5,#0x20
00000c  6820              LDR      r0,[r4,#0]            ;4652
00000e  2929              CMP      r1,#0x29              ;4652
000010  d02f              BEQ      |L49.114|
000012  292a              CMP      r1,#0x2a              ;4652
000014  d02d              BEQ      |L49.114|
000016  f894103d          LDRB     r1,[r4,#0x3d]         ;4662
00001a  2960              CMP      r1,#0x60              ;4662
00001c  d004              BEQ      |L49.40|
00001e  6841              LDR      r1,[r0,#4]            ;4662
000020  0509              LSLS     r1,r1,#20             ;4662
000022  d401              BMI      |L49.40|
000024  f884503d          STRB     r5,[r4,#0x3d]
                  |L49.40|
;;;4665       }
;;;4666       hi2c->PreviousState = I2C_STATE_NONE;
000028  6326              STR      r6,[r4,#0x30]
;;;4667       hi2c->Mode = HAL_I2C_MODE_NONE;
00002a  f884603e          STRB     r6,[r4,#0x3e]
                  |L49.46|
;;;4668     }
;;;4669   
;;;4670     /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
;;;4671     hi2c->Instance->CR1 &= ~I2C_CR1_POS;
00002e  6801              LDR      r1,[r0,#0]
000030  f4216100          BIC      r1,r1,#0x800
000034  6001              STR      r1,[r0,#0]
;;;4672   
;;;4673     /* Abort DMA transfer */
;;;4674     if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
000036  6820              LDR      r0,[r4,#0]
000038  6841              LDR      r1,[r0,#4]
00003a  0509              LSLS     r1,r1,#20
00003c  d539              BPL      |L49.178|
;;;4675     {
;;;4676       hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
00003e  6841              LDR      r1,[r0,#4]
000040  f4216100          BIC      r1,r1,#0x800
000044  6041              STR      r1,[r0,#4]
;;;4677   
;;;4678       if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
000046  6b60              LDR      r0,[r4,#0x34]
;;;4679       {
;;;4680         /* Set the DMA Abort callback : 
;;;4681         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4682         hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
000048  4935              LDR      r1,|L49.288|
00004a  f8902021          LDRB     r2,[r0,#0x21]         ;4678
00004e  2a01              CMP      r2,#1                 ;4678
000050  d014              BEQ      |L49.124|
000052  6341              STR      r1,[r0,#0x34]
;;;4683   
;;;4684         if(HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
000054  6b60              LDR      r0,[r4,#0x34]
000056  f7fffffe          BL       HAL_DMA_Abort_IT
00005a  b348              CBZ      r0,|L49.176|
;;;4685         {
;;;4686           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;4687           __HAL_I2C_DISABLE(hi2c);
00005c  6820              LDR      r0,[r4,#0]
00005e  6801              LDR      r1,[r0,#0]
000060  f0210101          BIC      r1,r1,#1
000064  6001              STR      r1,[r0,#0]
;;;4688   
;;;4689           hi2c->State = HAL_I2C_STATE_READY;
000066  f884503d          STRB     r5,[r4,#0x3d]
;;;4690   
;;;4691           /* Call Directly XferAbortCallback function in case of error */
;;;4692           hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
00006a  6b60              LDR      r0,[r4,#0x34]
00006c  6b41              LDR      r1,[r0,#0x34]
00006e  4788              BLX      r1
000070  e02f              B        |L49.210|
                  |L49.114|
000072  6326              STR      r6,[r4,#0x30]         ;4655
000074  2128              MOVS     r1,#0x28              ;4656
000076  f884103d          STRB     r1,[r4,#0x3d]         ;4656
00007a  e7d8              B        |L49.46|
                  |L49.124|
;;;4693         }
;;;4694       }
;;;4695       else
;;;4696       {
;;;4697         /* Set the DMA Abort callback : 
;;;4698         will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4699         hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
00007c  6ba0              LDR      r0,[r4,#0x38]
00007e  6341              STR      r1,[r0,#0x34]
;;;4700   
;;;4701         if(HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
000080  6ba0              LDR      r0,[r4,#0x38]
000082  f7fffffe          BL       HAL_DMA_Abort_IT
000086  b198              CBZ      r0,|L49.176|
;;;4702         {
;;;4703           /* Store Last receive data if any */
;;;4704           if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
000088  6820              LDR      r0,[r4,#0]
00008a  6941              LDR      r1,[r0,#0x14]
00008c  43c9              MVNS     r1,r1
00008e  0649              LSLS     r1,r1,#25
000090  d404              BMI      |L49.156|
;;;4705           {
;;;4706             /* Read data from DR */
;;;4707             (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000092  6901              LDR      r1,[r0,#0x10]
000094  6a60              LDR      r0,[r4,#0x24]
000096  1c42              ADDS     r2,r0,#1
000098  6262              STR      r2,[r4,#0x24]
00009a  7001              STRB     r1,[r0,#0]
                  |L49.156|
;;;4708           }
;;;4709   
;;;4710           /* Disable I2C peripheral to prevent dummy data in buffer */
;;;4711           __HAL_I2C_DISABLE(hi2c);
00009c  6820              LDR      r0,[r4,#0]
00009e  6801              LDR      r1,[r0,#0]
0000a0  f0210101          BIC      r1,r1,#1
0000a4  6001              STR      r1,[r0,#0]
;;;4712   
;;;4713           hi2c->State = HAL_I2C_STATE_READY;
0000a6  f884503d          STRB     r5,[r4,#0x3d]
;;;4714   
;;;4715           /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;4716           hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
0000aa  6ba0              LDR      r0,[r4,#0x38]
0000ac  6b41              LDR      r1,[r0,#0x34]
0000ae  4788              BLX      r1
                  |L49.176|
0000b0  e00f              B        |L49.210|
                  |L49.178|
;;;4717         }
;;;4718       }
;;;4719     }
;;;4720     else if(hi2c->State == HAL_I2C_STATE_ABORT)
0000b2  f894103d          LDRB     r1,[r4,#0x3d]
0000b6  2960              CMP      r1,#0x60
0000b8  d01d              BEQ      |L49.246|
;;;4721     {
;;;4722       hi2c->State = HAL_I2C_STATE_READY;
;;;4723       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4724   
;;;4725       /* Store Last receive data if any */
;;;4726       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
;;;4727       {
;;;4728         /* Read data from DR */
;;;4729         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;4730       }
;;;4731   
;;;4732       /* Disable I2C peripheral to prevent dummy data in buffer */
;;;4733       __HAL_I2C_DISABLE(hi2c);
;;;4734   
;;;4735       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4736       HAL_I2C_AbortCpltCallback(hi2c);
;;;4737     }
;;;4738     else
;;;4739     {
;;;4740       /* Store Last receive data if any */
;;;4741       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
0000ba  6941              LDR      r1,[r0,#0x14]
0000bc  43c9              MVNS     r1,r1
0000be  0649              LSLS     r1,r1,#25
0000c0  d404              BMI      |L49.204|
;;;4742       {
;;;4743         /* Read data from DR */
;;;4744         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
0000c2  6901              LDR      r1,[r0,#0x10]
0000c4  6a60              LDR      r0,[r4,#0x24]
0000c6  1c42              ADDS     r2,r0,#1
0000c8  6262              STR      r2,[r4,#0x24]
0000ca  7001              STRB     r1,[r0,#0]
                  |L49.204|
;;;4745       }
;;;4746   
;;;4747       /* Call user error callback */
;;;4748       HAL_I2C_ErrorCallback(hi2c);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L49.210|
;;;4749     }
;;;4750     /* STOP Flag is not set after a NACK reception */
;;;4751     /* So may inform upper layer that listen phase is stopped */
;;;4752     /* during NACK error treatment */
;;;4753     if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
0000d2  f894003d          LDRB     r0,[r4,#0x3d]
0000d6  2828              CMP      r0,#0x28
0000d8  d10c              BNE      |L49.244|
0000da  6c20              LDR      r0,[r4,#0x40]
0000dc  0740              LSLS     r0,r0,#29
0000de  d509              BPL      |L49.244|
;;;4754     {
;;;4755       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
0000e0  4810              LDR      r0,|L49.292|
0000e2  62e0              STR      r0,[r4,#0x2c]
;;;4756       hi2c->PreviousState = I2C_STATE_NONE;
0000e4  6326              STR      r6,[r4,#0x30]
;;;4757       hi2c->State = HAL_I2C_STATE_READY;
0000e6  f884503d          STRB     r5,[r4,#0x3d]
;;;4758       hi2c->Mode = HAL_I2C_MODE_NONE;
0000ea  f884603e          STRB     r6,[r4,#0x3e]
;;;4759       
;;;4760       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4761       HAL_I2C_ListenCpltCallback(hi2c);
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       HAL_I2C_ListenCpltCallback
                  |L49.244|
;;;4762     }
;;;4763   }
0000f4  bd70              POP      {r4-r6,pc}
                  |L49.246|
0000f6  f884503d          STRB     r5,[r4,#0x3d]         ;4722
0000fa  6426              STR      r6,[r4,#0x40]         ;4723
0000fc  6941              LDR      r1,[r0,#0x14]         ;4726
0000fe  43c9              MVNS     r1,r1                 ;4726
000100  0649              LSLS     r1,r1,#25             ;4726
000102  d404              BMI      |L49.270|
000104  6901              LDR      r1,[r0,#0x10]         ;4729
000106  6a60              LDR      r0,[r4,#0x24]         ;4729
000108  1c42              ADDS     r2,r0,#1              ;4729
00010a  6262              STR      r2,[r4,#0x24]         ;4729
00010c  7001              STRB     r1,[r0,#0]            ;4729
                  |L49.270|
00010e  6820              LDR      r0,[r4,#0]            ;4733
000110  6801              LDR      r1,[r0,#0]            ;4733
000112  f0210101          BIC      r1,r1,#1              ;4733
000116  6001              STR      r1,[r0,#0]            ;4733
000118  4620              MOV      r0,r4                 ;4736
00011a  f7fffffe          BL       HAL_I2C_AbortCpltCallback
00011e  e7d8              B        |L49.210|
;;;4764   
                          ENDP

                  |L49.288|
                          DCD      I2C_DMAAbort
                  |L49.292|
                          DCD      0xffff0000

                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=1

                  I2C_IsAcknowledgeFailed PROC
;;;5542     */
;;;5543   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
000000  6801              LDR      r1,[r0,#0]
;;;5544   {
;;;5545     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000002  694a              LDR      r2,[r1,#0x14]
000004  43d2              MVNS     r2,r2
000006  0552              LSLS     r2,r2,#21
000008  d40c              BMI      |L50.36|
;;;5546     {
;;;5547       /* Clear NACKF Flag */
;;;5548       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00000a  f46f6280          MVN      r2,#0x400
00000e  614a              STR      r2,[r1,#0x14]
;;;5549   
;;;5550       hi2c->ErrorCode = HAL_I2C_ERROR_AF;
000010  2104              MOVS     r1,#4
000012  3030              ADDS     r0,r0,#0x30
000014  6101              STR      r1,[r0,#0x10]
;;;5551       hi2c->PreviousState = I2C_STATE_NONE;
000016  2100              MOVS     r1,#0
000018  6001              STR      r1,[r0,#0]
;;;5552       hi2c->State= HAL_I2C_STATE_READY;
00001a  2220              MOVS     r2,#0x20
00001c  7342              STRB     r2,[r0,#0xd]
;;;5553   
;;;5554       /* Process Unlocked */
;;;5555       __HAL_UNLOCK(hi2c);
00001e  7301              STRB     r1,[r0,#0xc]
;;;5556   
;;;5557       return HAL_ERROR;
000020  2001              MOVS     r0,#1
;;;5558     }
;;;5559     return HAL_OK;
;;;5560   }
000022  4770              BX       lr
                  |L50.36|
000024  2000              MOVS     r0,#0                 ;5559
000026  4770              BX       lr
;;;5561   /**
                          ENDP


                          AREA ||i.I2C_MasterReceive_BTF||, CODE, READONLY, ALIGN=2

                  I2C_MasterReceive_BTF PROC
;;;4066     */
;;;4067   static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4068   {
;;;4069     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4070     uint32_t CurrentXferOptions = hi2c->XferOptions;
000002  6ac2              LDR      r2,[r0,#0x2c]
;;;4071   
;;;4072     if(hi2c->XferCount == 3U)
000004  8d43              LDRH     r3,[r0,#0x2a]
;;;4073     {
;;;4074       if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
000006  4c35              LDR      r4,|L51.220|
000008  6801              LDR      r1,[r0,#0]            ;4072
00000a  2b03              CMP      r3,#3                 ;4072
00000c  d00c              BEQ      |L51.40|
;;;4075       {
;;;4076         /* Disable Acknowledge */
;;;4077         hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4078       }
;;;4079   
;;;4080       /* Read data from DR */
;;;4081       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;4082       hi2c->XferCount--;
;;;4083     }
;;;4084     else if(hi2c->XferCount == 2U)
00000e  8d43              LDRH     r3,[r0,#0x2a]
000010  2b02              CMP      r3,#2
000012  d01d              BEQ      |L51.80|
;;;4085     {
;;;4086       /* Prepare next transfer or stop current transfer */
;;;4087       if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
;;;4088       {
;;;4089         if(CurrentXferOptions != I2C_NEXT_FRAME)
;;;4090         {
;;;4091           /* Disable Acknowledge */
;;;4092           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4093         }
;;;4094         else
;;;4095         {
;;;4096           /* Enable Acknowledge */
;;;4097           hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;4098         }
;;;4099   
;;;4100         /* Disable EVT and ERR interrupt */
;;;4101         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4102       }
;;;4103       else
;;;4104       {
;;;4105         /* Disable EVT and ERR interrupt */
;;;4106         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;4107         
;;;4108         /* Generate Stop */
;;;4109         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;4110       }
;;;4111   
;;;4112       /* Read data from DR */
;;;4113       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;4114       hi2c->XferCount--;
;;;4115   
;;;4116       /* Read data from DR */
;;;4117       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;4118       hi2c->XferCount--;
;;;4119   
;;;4120       hi2c->State = HAL_I2C_STATE_READY;
;;;4121       hi2c->PreviousState = I2C_STATE_NONE;
;;;4122   
;;;4123       if(hi2c->Mode == HAL_I2C_MODE_MEM)
;;;4124       {
;;;4125         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4126   
;;;4127         HAL_I2C_MemRxCpltCallback(hi2c);
;;;4128       }
;;;4129       else
;;;4130       {
;;;4131         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4132   
;;;4133         HAL_I2C_MasterRxCpltCallback(hi2c);
;;;4134       }
;;;4135     }
;;;4136     else
;;;4137     {
;;;4138       /* Read data from DR */
;;;4139       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000014  690a              LDR      r2,[r1,#0x10]
000016  6a41              LDR      r1,[r0,#0x24]
000018  1c4b              ADDS     r3,r1,#1
00001a  6243              STR      r3,[r0,#0x24]
00001c  700a              STRB     r2,[r1,#0]
;;;4140       hi2c->XferCount--;
00001e  8d41              LDRH     r1,[r0,#0x2a]
000020  1e49              SUBS     r1,r1,#1
000022  8541              STRH     r1,[r0,#0x2a]
                  |L51.36|
;;;4141     }
;;;4142     return HAL_OK;
000024  2000              MOVS     r0,#0
;;;4143   }
000026  bd10              POP      {r4,pc}
                  |L51.40|
000028  2a04              CMP      r2,#4                 ;4074
00002a  d003              BEQ      |L51.52|
00002c  2a08              CMP      r2,#8                 ;4074
00002e  d001              BEQ      |L51.52|
000030  42a2              CMP      r2,r4                 ;4074
000032  d103              BNE      |L51.60|
                  |L51.52|
000034  680a              LDR      r2,[r1,#0]            ;4077
000036  f4226280          BIC      r2,r2,#0x400          ;4077
00003a  600a              STR      r2,[r1,#0]            ;4077
                  |L51.60|
00003c  6801              LDR      r1,[r0,#0]            ;4081
00003e  690a              LDR      r2,[r1,#0x10]         ;4081
000040  6a41              LDR      r1,[r0,#0x24]         ;4081
000042  1c4b              ADDS     r3,r1,#1              ;4081
000044  6243              STR      r3,[r0,#0x24]         ;4081
000046  700a              STRB     r2,[r1,#0]            ;4081
000048  8d41              LDRH     r1,[r0,#0x2a]         ;4082
00004a  1e49              SUBS     r1,r1,#1              ;4082
00004c  8541              STRH     r1,[r0,#0x2a]         ;4082
00004e  e7e9              B        |L51.36|
                  |L51.80|
000050  2a04              CMP      r2,#4                 ;4087
000052  d014              BEQ      |L51.126|
000054  2a08              CMP      r2,#8                 ;4087
000056  d012              BEQ      |L51.126|
000058  42a2              CMP      r2,r4                 ;4087
00005a  d010              BEQ      |L51.126|
00005c  2a02              CMP      r2,#2                 ;4089
00005e  d004              BEQ      |L51.106|
000060  680a              LDR      r2,[r1,#0]            ;4092
000062  f4226280          BIC      r2,r2,#0x400          ;4092
000066  600a              STR      r2,[r1,#0]            ;4092
000068  e003              B        |L51.114|
                  |L51.106|
00006a  680a              LDR      r2,[r1,#0]            ;4097
00006c  f4426280          ORR      r2,r2,#0x400          ;4097
000070  600a              STR      r2,[r1,#0]            ;4097
                  |L51.114|
000072  6801              LDR      r1,[r0,#0]            ;4101
000074  684a              LDR      r2,[r1,#4]            ;4101
000076  f4227240          BIC      r2,r2,#0x300          ;4101
00007a  604a              STR      r2,[r1,#4]            ;4101
00007c  e008              B        |L51.144|
                  |L51.126|
00007e  684a              LDR      r2,[r1,#4]            ;4106
000080  f4227240          BIC      r2,r2,#0x300          ;4106
000084  604a              STR      r2,[r1,#4]            ;4106
000086  6801              LDR      r1,[r0,#0]            ;4109
000088  680a              LDR      r2,[r1,#0]            ;4109
00008a  f4427200          ORR      r2,r2,#0x200          ;4109
00008e  600a              STR      r2,[r1,#0]            ;4109
                  |L51.144|
000090  6801              LDR      r1,[r0,#0]            ;4113
000092  690a              LDR      r2,[r1,#0x10]         ;4113
000094  6a41              LDR      r1,[r0,#0x24]         ;4113
000096  1c4b              ADDS     r3,r1,#1              ;4113
000098  6243              STR      r3,[r0,#0x24]         ;4113
00009a  700a              STRB     r2,[r1,#0]            ;4113
00009c  8d41              LDRH     r1,[r0,#0x2a]         ;4114
00009e  1e49              SUBS     r1,r1,#1              ;4114
0000a0  8541              STRH     r1,[r0,#0x2a]         ;4114
0000a2  6801              LDR      r1,[r0,#0]            ;4117
0000a4  690a              LDR      r2,[r1,#0x10]         ;4117
0000a6  6a41              LDR      r1,[r0,#0x24]         ;4117
0000a8  1c4b              ADDS     r3,r1,#1              ;4117
0000aa  6243              STR      r3,[r0,#0x24]         ;4117
0000ac  700a              STRB     r2,[r1,#0]            ;4117
0000ae  8d41              LDRH     r1,[r0,#0x2a]         ;4118
0000b0  1e49              SUBS     r1,r1,#1              ;4118
0000b2  8541              STRH     r1,[r0,#0x2a]         ;4118
0000b4  2120              MOVS     r1,#0x20              ;4120
0000b6  f880103d          STRB     r1,[r0,#0x3d]         ;4120
0000ba  2100              MOVS     r1,#0                 ;4121
0000bc  6301              STR      r1,[r0,#0x30]         ;4121
0000be  f890203e          LDRB     r2,[r0,#0x3e]         ;4123
0000c2  2a40              CMP      r2,#0x40              ;4123
0000c4  d004              BEQ      |L51.208|
0000c6  f880103e          STRB     r1,[r0,#0x3e]         ;4131
0000ca  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
0000ce  e7a9              B        |L51.36|
                  |L51.208|
0000d0  f880103e          STRB     r1,[r0,#0x3e]         ;4125
0000d4  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000d8  e7a4              B        |L51.36|
;;;4144   
                          ENDP

0000da  0000              DCW      0x0000
                  |L51.220|
                          DCD      0xffff0000

                          AREA ||i.I2C_MasterReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_RXNE PROC
;;;3990     */
;;;3991   static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3992   {
;;;3993     if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
000002  f890103d          LDRB     r1,[r0,#0x3d]
000006  2922              CMP      r1,#0x22
000008  d152              BNE      |L52.176|
;;;3994     {
;;;3995       uint32_t tmp = 0U;
;;;3996       
;;;3997       tmp = hi2c->XferCount;
00000a  8d41              LDRH     r1,[r0,#0x2a]
;;;3998       if(tmp > 3U)
00000c  2903              CMP      r1,#3
00000e  d909              BLS      |L52.36|
;;;3999       {
;;;4000         /* Read data from DR */
;;;4001         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000010  6801              LDR      r1,[r0,#0]
000012  690a              LDR      r2,[r1,#0x10]
000014  6a41              LDR      r1,[r0,#0x24]
000016  1c4b              ADDS     r3,r1,#1
000018  6243              STR      r3,[r0,#0x24]
00001a  700a              STRB     r2,[r1,#0]
;;;4002         hi2c->XferCount--;
00001c  8d41              LDRH     r1,[r0,#0x2a]
00001e  1e49              SUBS     r1,r1,#1
000020  8541              STRH     r1,[r0,#0x2a]
000022  e045              B        |L52.176|
                  |L52.36|
;;;4003       }
;;;4004       else if((tmp == 2U) || (tmp == 3U))
000024  2902              CMP      r1,#2
000026  d00a              BEQ      |L52.62|
000028  2903              CMP      r1,#3
00002a  d008              BEQ      |L52.62|
;;;4005       {
;;;4006         if(hi2c->XferOptions != I2C_NEXT_FRAME)
;;;4007         {
;;;4008           /* Disable Acknowledge */
;;;4009           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4010           
;;;4011           /* Enable Pos */
;;;4012           hi2c->Instance->CR1 |= I2C_CR1_POS;
;;;4013         }
;;;4014         else
;;;4015         {
;;;4016           /* Enable Acknowledge */
;;;4017           hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;4018         }
;;;4019         
;;;4020         /* Disable BUF interrupt */
;;;4021         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
;;;4022       }
;;;4023       else
;;;4024       {
;;;4025         if(hi2c->XferOptions != I2C_NEXT_FRAME)
00002c  6ac1              LDR      r1,[r0,#0x2c]
00002e  2902              CMP      r1,#2
000030  d01e              BEQ      |L52.112|
;;;4026         {
;;;4027           /* Disable Acknowledge */
;;;4028           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000032  6801              LDR      r1,[r0,#0]
000034  680a              LDR      r2,[r1,#0]
000036  f4226280          BIC      r2,r2,#0x400
00003a  600a              STR      r2,[r1,#0]
00003c  e01d              B        |L52.122|
                  |L52.62|
00003e  6ac1              LDR      r1,[r0,#0x2c]         ;4006
000040  2902              CMP      r1,#2                 ;4006
000042  d00a              BEQ      |L52.90|
000044  6801              LDR      r1,[r0,#0]            ;4009
000046  680a              LDR      r2,[r1,#0]            ;4009
000048  f4226280          BIC      r2,r2,#0x400          ;4009
00004c  600a              STR      r2,[r1,#0]            ;4009
00004e  6801              LDR      r1,[r0,#0]            ;4012
000050  680a              LDR      r2,[r1,#0]            ;4012
000052  f4426200          ORR      r2,r2,#0x800          ;4012
000056  600a              STR      r2,[r1,#0]            ;4012
000058  e004              B        |L52.100|
                  |L52.90|
00005a  6801              LDR      r1,[r0,#0]            ;4017
00005c  680a              LDR      r2,[r1,#0]            ;4017
00005e  f4426280          ORR      r2,r2,#0x400          ;4017
000062  600a              STR      r2,[r1,#0]            ;4017
                  |L52.100|
000064  6800              LDR      r0,[r0,#0]            ;4021
000066  6841              LDR      r1,[r0,#4]            ;4021
000068  f4216180          BIC      r1,r1,#0x400          ;4021
00006c  6041              STR      r1,[r0,#4]            ;4021
00006e  e01f              B        |L52.176|
                  |L52.112|
;;;4029         }
;;;4030         else
;;;4031         {
;;;4032           /* Enable Acknowledge */
;;;4033           hi2c->Instance->CR1 |= I2C_CR1_ACK;
000070  6801              LDR      r1,[r0,#0]
000072  680a              LDR      r2,[r1,#0]
000074  f4426280          ORR      r2,r2,#0x400
000078  600a              STR      r2,[r1,#0]
                  |L52.122|
;;;4034         }
;;;4035   
;;;4036         /* Disable EVT, BUF and ERR interrupt */
;;;4037         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
00007a  6801              LDR      r1,[r0,#0]
00007c  684a              LDR      r2,[r1,#4]
00007e  f42262e0          BIC      r2,r2,#0x700
000082  604a              STR      r2,[r1,#4]
;;;4038         
;;;4039         /* Read data from DR */
;;;4040         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000084  6801              LDR      r1,[r0,#0]
000086  690a              LDR      r2,[r1,#0x10]
000088  6a41              LDR      r1,[r0,#0x24]
00008a  1c4b              ADDS     r3,r1,#1
00008c  6243              STR      r3,[r0,#0x24]
00008e  700a              STRB     r2,[r1,#0]
;;;4041         hi2c->XferCount--;
000090  8d41              LDRH     r1,[r0,#0x2a]
000092  1e49              SUBS     r1,r1,#1
000094  8541              STRH     r1,[r0,#0x2a]
;;;4042   
;;;4043         hi2c->State = HAL_I2C_STATE_READY;
000096  2120              MOVS     r1,#0x20
000098  f880103d          STRB     r1,[r0,#0x3d]
;;;4044         hi2c->PreviousState = I2C_STATE_NONE;
00009c  2100              MOVS     r1,#0
00009e  6301              STR      r1,[r0,#0x30]
;;;4045   
;;;4046         if(hi2c->Mode == HAL_I2C_MODE_MEM)
0000a0  f890203e          LDRB     r2,[r0,#0x3e]
0000a4  2a40              CMP      r2,#0x40
0000a6  d005              BEQ      |L52.180|
;;;4047         {
;;;4048           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4049           HAL_I2C_MemRxCpltCallback(hi2c);
;;;4050         }
;;;4051         else
;;;4052         {
;;;4053           hi2c->Mode = HAL_I2C_MODE_NONE;
0000a8  f880103e          STRB     r1,[r0,#0x3e]
;;;4054           HAL_I2C_MasterRxCpltCallback(hi2c);
0000ac  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L52.176|
;;;4055         }
;;;4056       }
;;;4057     }
;;;4058     return HAL_OK;
0000b0  2000              MOVS     r0,#0
;;;4059   }
0000b2  bd10              POP      {r4,pc}
                  |L52.180|
0000b4  f880103e          STRB     r1,[r0,#0x3e]         ;4048
0000b8  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000bc  e7f8              B        |L52.176|
;;;4060   
                          ENDP


                          AREA ||i.I2C_MasterRequestRead||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestRead PROC
;;;4849     */
;;;4850   static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4851   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;4852     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;4853     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000c  6ae0              LDR      r0,[r4,#0x2c]
;;;4854   
;;;4855     /* Enable Acknowledge */
;;;4856     hi2c->Instance->CR1 |= I2C_CR1_ACK;
00000e  6821              LDR      r1,[r4,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f4426280          ORR      r2,r2,#0x400
000016  600a              STR      r2,[r1,#0]
;;;4857   
;;;4858     /* Generate Start condition if first transfer */
;;;4859     if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
000018  2804              CMP      r0,#4
00001a  d008              BEQ      |L53.46|
00001c  2801              CMP      r0,#1
00001e  d006              BEQ      |L53.46|
000020  f5103f80          CMN      r0,#0x10000
000024  d003              BEQ      |L53.46|
;;;4860     {
;;;4861       /* Generate Start */
;;;4862       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;4863     }
;;;4864     else if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
000026  6b20              LDR      r0,[r4,#0x30]
000028  2811              CMP      r0,#0x11
00002a  d006              BEQ      |L53.58|
00002c  e00a              B        |L53.68|
                  |L53.46|
00002e  6820              LDR      r0,[r4,#0]            ;4862
000030  6801              LDR      r1,[r0,#0]            ;4862
000032  f4417180          ORR      r1,r1,#0x100          ;4862
000036  6001              STR      r1,[r0,#0]            ;4862
000038  e004              B        |L53.68|
                  |L53.58|
;;;4865     {
;;;4866       /* Generate ReStart */
;;;4867       hi2c->Instance->CR1 |= I2C_CR1_START;
00003a  6820              LDR      r0,[r4,#0]
00003c  6801              LDR      r1,[r0,#0]
00003e  f4417180          ORR      r1,r1,#0x100
000042  6001              STR      r1,[r0,#0]
                  |L53.68|
;;;4868     }
;;;4869   
;;;4870     /* Wait until SB flag is set */
;;;4871     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000044  f04f1801          MOV      r8,#0x10001
000048  464b              MOV      r3,r9
00004a  2200              MOVS     r2,#0
00004c  4641              MOV      r1,r8
00004e  4620              MOV      r0,r4
000050  9600              STR      r6,[sp,#0]
000052  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000056  b110              CBZ      r0,|L53.94|
;;;4872     {
;;;4873       return HAL_TIMEOUT;
000058  2003              MOVS     r0,#3
                  |L53.90|
;;;4874     }
;;;4875   
;;;4876     if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;4877     {
;;;4878       /* Send slave address */
;;;4879       hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;4880     }
;;;4881     else
;;;4882     {
;;;4883       /* Send header of slave address */
;;;4884       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;4885   
;;;4886       /* Wait until ADD10 flag is set */
;;;4887       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;4888       {
;;;4889         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4890         {
;;;4891           return HAL_ERROR;
;;;4892         }
;;;4893         else
;;;4894         {
;;;4895           return HAL_TIMEOUT;
;;;4896         }
;;;4897       }
;;;4898   
;;;4899       /* Send slave address */
;;;4900       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;4901   
;;;4902       /* Wait until ADDR flag is set */
;;;4903       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;4904       {
;;;4905         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4906         {
;;;4907           return HAL_ERROR;
;;;4908         }
;;;4909         else
;;;4910         {
;;;4911           return HAL_TIMEOUT;
;;;4912         }
;;;4913       }
;;;4914   
;;;4915       /* Clear ADDR flag */
;;;4916       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4917   
;;;4918       /* Generate Restart */
;;;4919       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;4920   
;;;4921       /* Wait until SB flag is set */
;;;4922       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;4923       {
;;;4924         return HAL_TIMEOUT;
;;;4925       }
;;;4926   
;;;4927       /* Send header of slave address */
;;;4928       hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
;;;4929     }
;;;4930   
;;;4931     /* Wait until ADDR flag is set */
;;;4932     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;4933     {
;;;4934       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4935       {
;;;4936         return HAL_ERROR;
;;;4937       }
;;;4938       else
;;;4939       {
;;;4940         return HAL_TIMEOUT;
;;;4941       }
;;;4942     }
;;;4943   
;;;4944     return HAL_OK;
;;;4945   }
00005a  e8bd8ff8          POP      {r3-r11,pc}
                  |L53.94|
00005e  6920              LDR      r0,[r4,#0x10]         ;4876
000060  f8dfa0b0          LDR      r10,|L53.276|
000064  f5b04f80          CMP      r0,#0x4000            ;4876
000068  d013              BEQ      |L53.146|
00006a  6821              LDR      r1,[r4,#0]            ;4884
00006c  f4057740          AND      r7,r5,#0x300          ;4884
000070  20f0              MOVS     r0,#0xf0              ;4884
000072  ea4010d7          ORR      r0,r0,r7,LSR #7       ;4884
000076  6108              STR      r0,[r1,#0x10]         ;4884
000078  4633              MOV      r3,r6                 ;4887
00007a  464a              MOV      r2,r9                 ;4887
00007c  f10a0106          ADD      r1,r10,#6             ;4887
000080  4620              MOV      r0,r4                 ;4887
000082  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000086  b160              CBZ      r0,|L53.162|
000088  6c20              LDR      r0,[r4,#0x40]         ;4889
00008a  2804              CMP      r0,#4                 ;4889
00008c  d007              BEQ      |L53.158|
00008e  2003              MOVS     r0,#3                 ;4895
000090  e7e3              B        |L53.90|
                  |L53.146|
000092  6821              LDR      r1,[r4,#0]            ;4879
000094  b2e8              UXTB     r0,r5                 ;4879
000096  f0400001          ORR      r0,r0,#1              ;4879
00009a  6108              STR      r0,[r1,#0x10]         ;4879
00009c  e029              B        |L53.242|
                  |L53.158|
00009e  2001              MOVS     r0,#1                 ;4891
0000a0  e7db              B        |L53.90|
                  |L53.162|
0000a2  6821              LDR      r1,[r4,#0]            ;4900
0000a4  b2e8              UXTB     r0,r5                 ;4900
0000a6  6108              STR      r0,[r1,#0x10]         ;4900
0000a8  4633              MOV      r3,r6                 ;4903
0000aa  464a              MOV      r2,r9                 ;4903
0000ac  4651              MOV      r1,r10                ;4903
0000ae  4620              MOV      r0,r4                 ;4903
0000b0  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000b4  b130              CBZ      r0,|L53.196|
0000b6  6c20              LDR      r0,[r4,#0x40]         ;4905
0000b8  2804              CMP      r0,#4                 ;4905
0000ba  d001              BEQ      |L53.192|
0000bc  2003              MOVS     r0,#3                 ;4911
0000be  e7cc              B        |L53.90|
                  |L53.192|
0000c0  2001              MOVS     r0,#1                 ;4907
0000c2  e7ca              B        |L53.90|
                  |L53.196|
0000c4  6820              LDR      r0,[r4,#0]            ;4916
0000c6  6941              LDR      r1,[r0,#0x14]         ;4916
0000c8  6981              LDR      r1,[r0,#0x18]         ;4916
0000ca  9100              STR      r1,[sp,#0]            ;4916
0000cc  6801              LDR      r1,[r0,#0]            ;4919
0000ce  f4417180          ORR      r1,r1,#0x100          ;4919
0000d2  6001              STR      r1,[r0,#0]            ;4919
0000d4  464b              MOV      r3,r9                 ;4922
0000d6  2200              MOVS     r2,#0                 ;4922
0000d8  4641              MOV      r1,r8                 ;4922
0000da  4620              MOV      r0,r4                 ;4922
0000dc  9600              STR      r6,[sp,#0]            ;4922
0000de  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000e2  b108              CBZ      r0,|L53.232|
0000e4  2003              MOVS     r0,#3                 ;4924
0000e6  e7b8              B        |L53.90|
                  |L53.232|
0000e8  6821              LDR      r1,[r4,#0]            ;4928
0000ea  20f1              MOVS     r0,#0xf1              ;4928
0000ec  ea4010d7          ORR      r0,r0,r7,LSR #7       ;4928
0000f0  6108              STR      r0,[r1,#0x10]         ;4928
                  |L53.242|
0000f2  4633              MOV      r3,r6                 ;4932
0000f4  464a              MOV      r2,r9                 ;4932
0000f6  4651              MOV      r1,r10                ;4932
0000f8  4620              MOV      r0,r4                 ;4932
0000fa  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000fe  b130              CBZ      r0,|L53.270|
000100  6c20              LDR      r0,[r4,#0x40]         ;4934
000102  2804              CMP      r0,#4                 ;4934
000104  d001              BEQ      |L53.266|
000106  2003              MOVS     r0,#3                 ;4940
000108  e7a7              B        |L53.90|
                  |L53.266|
00010a  2001              MOVS     r0,#1                 ;4936
00010c  e7a5              B        |L53.90|
                  |L53.270|
00010e  2000              MOVS     r0,#0                 ;4944
000110  e7a3              B        |L53.90|
;;;4946   
                          ENDP

000112  0000              DCW      0x0000
                  |L53.276|
                          DCD      0x00010002

                          AREA ||i.I2C_MasterRequestWrite||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestWrite PROC
;;;4773     */
;;;4774   static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4775   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
000008  461e              MOV      r6,r3
;;;4776     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;4777     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000a  6ae0              LDR      r0,[r4,#0x2c]
;;;4778   
;;;4779     /* Generate Start condition if first transfer */
;;;4780     if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
00000c  2804              CMP      r0,#4
00000e  d008              BEQ      |L54.34|
000010  2801              CMP      r0,#1
000012  d006              BEQ      |L54.34|
000014  f5103f80          CMN      r0,#0x10000
000018  d003              BEQ      |L54.34|
;;;4781     {
;;;4782       /* Generate Start */
;;;4783       hi2c->Instance->CR1 |= I2C_CR1_START;
;;;4784     }
;;;4785     else if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  2812              CMP      r0,#0x12
00001e  d006              BEQ      |L54.46|
000020  e00a              B        |L54.56|
                  |L54.34|
000022  6820              LDR      r0,[r4,#0]            ;4783
000024  6801              LDR      r1,[r0,#0]            ;4783
000026  f4417180          ORR      r1,r1,#0x100          ;4783
00002a  6001              STR      r1,[r0,#0]            ;4783
00002c  e004              B        |L54.56|
                  |L54.46|
;;;4786     {
;;;4787       /* Generate ReStart */
;;;4788       hi2c->Instance->CR1 |= I2C_CR1_START;
00002e  6820              LDR      r0,[r4,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f4417180          ORR      r1,r1,#0x100
000036  6001              STR      r1,[r0,#0]
                  |L54.56|
;;;4789     }
;;;4790   
;;;4791     /* Wait until SB flag is set */
;;;4792     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000038  463b              MOV      r3,r7
00003a  2200              MOVS     r2,#0
00003c  f04f1101          MOV      r1,#0x10001
000040  4620              MOV      r0,r4
000042  9600              STR      r6,[sp,#0]
000044  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000048  b108              CBZ      r0,|L54.78|
;;;4793     {
;;;4794       return HAL_TIMEOUT;
00004a  2003              MOVS     r0,#3
;;;4795     }
;;;4796   
;;;4797     if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;4798     {
;;;4799       /* Send slave address */
;;;4800       hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;4801     }
;;;4802     else
;;;4803     {
;;;4804       /* Send header of slave address */
;;;4805       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;4806   
;;;4807       /* Wait until ADD10 flag is set */
;;;4808       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
;;;4809       {
;;;4810         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4811         {
;;;4812           return HAL_ERROR;
;;;4813         }
;;;4814         else
;;;4815         {
;;;4816           return HAL_TIMEOUT;
;;;4817         }
;;;4818       }
;;;4819   
;;;4820       /* Send slave address */
;;;4821       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;4822     }
;;;4823   
;;;4824     /* Wait until ADDR flag is set */
;;;4825     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;4826     {
;;;4827       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4828       {
;;;4829         return HAL_ERROR;
;;;4830       }
;;;4831       else
;;;4832       {
;;;4833         return HAL_TIMEOUT;
;;;4834       }
;;;4835     }
;;;4836   
;;;4837     return HAL_OK;
;;;4838   }
00004c  bdf8              POP      {r3-r7,pc}
                  |L54.78|
00004e  6920              LDR      r0,[r4,#0x10]         ;4797
000050  f5b04f80          CMP      r0,#0x4000            ;4797
000054  d012              BEQ      |L54.124|
000056  f4057040          AND      r0,r5,#0x300          ;4805
00005a  21f0              MOVS     r1,#0xf0              ;4805
00005c  ea4110d0          ORR      r0,r1,r0,LSR #7       ;4805
000060  6821              LDR      r1,[r4,#0]            ;4805
000062  6108              STR      r0,[r1,#0x10]         ;4805
000064  4633              MOV      r3,r6                 ;4808
000066  463a              MOV      r2,r7                 ;4808
000068  4912              LDR      r1,|L54.180|
00006a  4620              MOV      r0,r4                 ;4808
00006c  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000070  b158              CBZ      r0,|L54.138|
000072  6c20              LDR      r0,[r4,#0x40]         ;4810
000074  2804              CMP      r0,#4                 ;4810
000076  d006              BEQ      |L54.134|
000078  2003              MOVS     r0,#3                 ;4816
00007a  bdf8              POP      {r3-r7,pc}
                  |L54.124|
00007c  6821              LDR      r1,[r4,#0]            ;4800
00007e  f00500fe          AND      r0,r5,#0xfe           ;4800
000082  6108              STR      r0,[r1,#0x10]         ;4800
000084  e004              B        |L54.144|
                  |L54.134|
000086  2001              MOVS     r0,#1                 ;4812
000088  bdf8              POP      {r3-r7,pc}
                  |L54.138|
00008a  6821              LDR      r1,[r4,#0]            ;4821
00008c  b2e8              UXTB     r0,r5                 ;4821
00008e  6108              STR      r0,[r1,#0x10]         ;4821
                  |L54.144|
000090  4908              LDR      r1,|L54.180|
000092  4633              MOV      r3,r6                 ;4825
000094  463a              MOV      r2,r7                 ;4825
000096  1f89              SUBS     r1,r1,#6              ;4825
000098  4620              MOV      r0,r4                 ;4825
00009a  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00009e  b130              CBZ      r0,|L54.174|
0000a0  6c20              LDR      r0,[r4,#0x40]         ;4827
0000a2  2804              CMP      r0,#4                 ;4827
0000a4  d001              BEQ      |L54.170|
0000a6  2003              MOVS     r0,#3                 ;4833
0000a8  bdf8              POP      {r3-r7,pc}
                  |L54.170|
0000aa  2001              MOVS     r0,#1                 ;4829
0000ac  bdf8              POP      {r3-r7,pc}
                  |L54.174|
0000ae  2000              MOVS     r0,#0                 ;4837
0000b0  bdf8              POP      {r3-r7,pc}
;;;4839   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L54.180|
                          DCD      0x00010008

                          AREA ||i.I2C_MasterTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_BTF PROC
;;;3929     */
;;;3930   static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3931   {
;;;3932     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;3933     uint32_t CurrentXferOptions = hi2c->XferOptions;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;3934   
;;;3935     if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
000004  f890203d          LDRB     r2,[r0,#0x3d]
000008  2a21              CMP      r2,#0x21
00000a  d137              BNE      |L55.124|
;;;3936     {    
;;;3937       if(hi2c->XferCount != 0U)
00000c  8d42              LDRH     r2,[r0,#0x2a]
00000e  b14a              CBZ      r2,|L55.36|
;;;3938       {
;;;3939         /* Write data to DR */
;;;3940         hi2c->Instance->DR = (*hi2c->pBuffPtr++);
000010  6a41              LDR      r1,[r0,#0x24]
000012  1c4a              ADDS     r2,r1,#1
000014  6242              STR      r2,[r0,#0x24]
000016  6802              LDR      r2,[r0,#0]
000018  7809              LDRB     r1,[r1,#0]
00001a  6111              STR      r1,[r2,#0x10]
;;;3941         hi2c->XferCount--;
00001c  8d41              LDRH     r1,[r0,#0x2a]
00001e  1e49              SUBS     r1,r1,#1
000020  8541              STRH     r1,[r0,#0x2a]
000022  e02b              B        |L55.124|
                  |L55.36|
;;;3942       }
;;;3943       else
;;;3944       {
;;;3945         /* Call TxCpltCallback() directly if no stop mode is set */
;;;3946         if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
;;;3947         {
;;;3948           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3949           
;;;3950           hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
;;;3951           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;3952           hi2c->State = HAL_I2C_STATE_READY;
000024  2320              MOVS     r3,#0x20
000026  2200              MOVS     r2,#0
000028  2904              CMP      r1,#4                 ;3946
00002a  d012              BEQ      |L55.82|
00002c  2908              CMP      r1,#8                 ;3946
00002e  d010              BEQ      |L55.82|
000030  f5113f80          CMN      r1,#0x10000           ;3946
000034  d00d              BEQ      |L55.82|
000036  6801              LDR      r1,[r0,#0]            ;3948
000038  684c              LDR      r4,[r1,#4]            ;3948
00003a  f42464e0          BIC      r4,r4,#0x700          ;3948
00003e  604c              STR      r4,[r1,#4]            ;3948
000040  2111              MOVS     r1,#0x11              ;3950
000042  6301              STR      r1,[r0,#0x30]         ;3950
000044  f880203e          STRB     r2,[r0,#0x3e]         ;3951
000048  f880303d          STRB     r3,[r0,#0x3d]
;;;3953           
;;;3954           HAL_I2C_MasterTxCpltCallback(hi2c);
00004c  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000050  e014              B        |L55.124|
                  |L55.82|
;;;3955         }
;;;3956         else /* Generate Stop condition then Call TxCpltCallback() */
;;;3957         {
;;;3958           /* Disable EVT, BUF and ERR interrupt */
;;;3959           __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000052  6801              LDR      r1,[r0,#0]
000054  684c              LDR      r4,[r1,#4]
000056  f42464e0          BIC      r4,r4,#0x700
00005a  604c              STR      r4,[r1,#4]
;;;3960           
;;;3961           /* Generate Stop */
;;;3962           hi2c->Instance->CR1 |= I2C_CR1_STOP;
00005c  6801              LDR      r1,[r0,#0]
00005e  680c              LDR      r4,[r1,#0]
000060  f4447400          ORR      r4,r4,#0x200
000064  600c              STR      r4,[r1,#0]
;;;3963           
;;;3964           hi2c->PreviousState = I2C_STATE_NONE;
000066  6302              STR      r2,[r0,#0x30]
;;;3965           hi2c->State = HAL_I2C_STATE_READY;
000068  f880303d          STRB     r3,[r0,#0x3d]
;;;3966           
;;;3967           if(hi2c->Mode == HAL_I2C_MODE_MEM)
00006c  f890103e          LDRB     r1,[r0,#0x3e]
000070  2940              CMP      r1,#0x40
000072  d005              BEQ      |L55.128|
;;;3968           {
;;;3969             hi2c->Mode = HAL_I2C_MODE_NONE;
;;;3970             
;;;3971             HAL_I2C_MemTxCpltCallback(hi2c);
;;;3972           }
;;;3973           else
;;;3974           {
;;;3975             hi2c->Mode = HAL_I2C_MODE_NONE;
000074  f880203e          STRB     r2,[r0,#0x3e]
;;;3976             
;;;3977             HAL_I2C_MasterTxCpltCallback(hi2c);
000078  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
                  |L55.124|
;;;3978           }
;;;3979         }
;;;3980       }
;;;3981     }
;;;3982     return HAL_OK;
00007c  2000              MOVS     r0,#0
;;;3983   }
00007e  bd10              POP      {r4,pc}
                  |L55.128|
000080  f880203e          STRB     r2,[r0,#0x3e]         ;3969
000084  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000088  e7f8              B        |L55.124|
;;;3984   
                          ENDP


                          AREA ||i.I2C_MasterTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransmit_TXE PROC
;;;3816     */
;;;3817   static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3818   {
;;;3819     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;3820     uint32_t CurrentState       = hi2c->State;
000002  f890103d          LDRB     r1,[r0,#0x3d]
;;;3821     uint32_t CurrentMode        = hi2c->Mode;
000006  f890303e          LDRB     r3,[r0,#0x3e]
;;;3822     uint32_t CurrentXferOptions = hi2c->XferOptions;
00000a  6ac2              LDR      r2,[r0,#0x2c]
;;;3823   
;;;3824     if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
00000c  8d04              LDRH     r4,[r0,#0x28]
00000e  2c00              CMP      r4,#0
000010  d101              BNE      |L56.22|
000012  2921              CMP      r1,#0x21
000014  d004              BEQ      |L56.32|
                  |L56.22|
;;;3825     {
;;;3826       /* Call TxCpltCallback() directly if no stop mode is set */
;;;3827       if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
;;;3828       {
;;;3829         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3830   
;;;3831         hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
;;;3832         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;3833         hi2c->State = HAL_I2C_STATE_READY;
;;;3834   
;;;3835         HAL_I2C_MasterTxCpltCallback(hi2c);
;;;3836       }
;;;3837       else /* Generate Stop condition then Call TxCpltCallback() */
;;;3838       {
;;;3839         /* Disable EVT, BUF and ERR interrupt */
;;;3840         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;3841   
;;;3842         /* Generate Stop */
;;;3843         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;3844   
;;;3845         hi2c->PreviousState = I2C_STATE_NONE;
;;;3846         hi2c->State = HAL_I2C_STATE_READY;
;;;3847   
;;;3848         if(hi2c->Mode == HAL_I2C_MODE_MEM)
;;;3849         {
;;;3850           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;3851           HAL_I2C_MemTxCpltCallback(hi2c);
;;;3852         }
;;;3853         else
;;;3854         {
;;;3855           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;3856           HAL_I2C_MasterTxCpltCallback(hi2c);
;;;3857         }
;;;3858       }
;;;3859     }
;;;3860     else if((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
000016  2921              CMP      r1,#0x21
000018  d036              BEQ      |L56.136|
;;;3861       ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
00001a  2b40              CMP      r3,#0x40
00001c  d032              BEQ      |L56.132|
00001e  e042              B        |L56.166|
                  |L56.32|
000020  2420              MOVS     r4,#0x20              ;3833
000022  2300              MOVS     r3,#0                 ;3833
000024  2a04              CMP      r2,#4                 ;3827
000026  d012              BEQ      |L56.78|
000028  2a08              CMP      r2,#8                 ;3827
00002a  d010              BEQ      |L56.78|
00002c  f5123f80          CMN      r2,#0x10000           ;3827
000030  d00d              BEQ      |L56.78|
000032  6801              LDR      r1,[r0,#0]            ;3829
000034  684a              LDR      r2,[r1,#4]            ;3829
000036  f42262e0          BIC      r2,r2,#0x700          ;3829
00003a  604a              STR      r2,[r1,#4]            ;3829
00003c  2111              MOVS     r1,#0x11              ;3831
00003e  6301              STR      r1,[r0,#0x30]         ;3831
000040  f880303e          STRB     r3,[r0,#0x3e]         ;3832
000044  f880403d          STRB     r4,[r0,#0x3d]         ;3833
000048  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
00004c  e02b              B        |L56.166|
                  |L56.78|
00004e  6801              LDR      r1,[r0,#0]            ;3840
000050  684a              LDR      r2,[r1,#4]            ;3840
000052  f42262e0          BIC      r2,r2,#0x700          ;3840
000056  604a              STR      r2,[r1,#4]            ;3840
000058  6801              LDR      r1,[r0,#0]            ;3843
00005a  680a              LDR      r2,[r1,#0]            ;3843
00005c  f4427200          ORR      r2,r2,#0x200          ;3843
000060  600a              STR      r2,[r1,#0]            ;3843
000062  6303              STR      r3,[r0,#0x30]         ;3845
000064  f880403d          STRB     r4,[r0,#0x3d]         ;3846
000068  f890103e          LDRB     r1,[r0,#0x3e]         ;3848
00006c  2940              CMP      r1,#0x40              ;3848
00006e  d004              BEQ      |L56.122|
000070  f880303e          STRB     r3,[r0,#0x3e]         ;3855
000074  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000078  e015              B        |L56.166|
                  |L56.122|
00007a  f880303e          STRB     r3,[r0,#0x3e]         ;3850
00007e  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000082  e010              B        |L56.166|
                  |L56.132|
000084  2922              CMP      r1,#0x22
000086  d10e              BNE      |L56.166|
                  |L56.136|
;;;3862     {
;;;3863       if(hi2c->XferCount == 0U)
000088  8d41              LDRH     r1,[r0,#0x2a]
00008a  b171              CBZ      r1,|L56.170|
;;;3864       {
;;;3865         /* Disable BUF interrupt */
;;;3866         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
;;;3867       }
;;;3868       else
;;;3869       {
;;;3870         if(hi2c->Mode == HAL_I2C_MODE_MEM)
00008c  f890103e          LDRB     r1,[r0,#0x3e]
000090  2940              CMP      r1,#0x40
000092  d010              BEQ      |L56.182|
;;;3871         {
;;;3872           if(hi2c->EventCount == 0)
;;;3873           {
;;;3874             /* If Memory address size is 8Bit */
;;;3875             if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
;;;3876             {
;;;3877               /* Send Memory Address */
;;;3878               hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
;;;3879               
;;;3880               hi2c->EventCount += 2;
;;;3881             }
;;;3882             /* If Memory address size is 16Bit */
;;;3883             else
;;;3884             {
;;;3885               /* Send MSB of Memory Address */
;;;3886               hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
;;;3887               
;;;3888               hi2c->EventCount++;
;;;3889             }
;;;3890           }
;;;3891           else if(hi2c->EventCount == 1)
;;;3892           {
;;;3893             /* Send LSB of Memory Address */
;;;3894             hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
;;;3895             
;;;3896             hi2c->EventCount++;
;;;3897           }
;;;3898           else if(hi2c->EventCount == 2)
;;;3899           {
;;;3900             if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
;;;3901             {
;;;3902               /* Generate Restart */
;;;3903               hi2c->Instance->CR1 |= I2C_CR1_START;
;;;3904             }
;;;3905             else if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
;;;3906             {
;;;3907               /* Write data to DR */
;;;3908               hi2c->Instance->DR = (*hi2c->pBuffPtr++);
;;;3909               hi2c->XferCount--;
;;;3910             }
;;;3911           }
;;;3912         }
;;;3913         else
;;;3914         {
;;;3915           /* Write data to DR */
;;;3916           hi2c->Instance->DR = (*hi2c->pBuffPtr++);
000094  6a41              LDR      r1,[r0,#0x24]
000096  1c4a              ADDS     r2,r1,#1
000098  6242              STR      r2,[r0,#0x24]
00009a  6802              LDR      r2,[r0,#0]
00009c  7809              LDRB     r1,[r1,#0]
00009e  6111              STR      r1,[r2,#0x10]
;;;3917           hi2c->XferCount--;
0000a0  8d41              LDRH     r1,[r0,#0x2a]
0000a2  1e49              SUBS     r1,r1,#1
0000a4  8541              STRH     r1,[r0,#0x2a]
                  |L56.166|
;;;3918         }
;;;3919       }
;;;3920     }
;;;3921     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;3922   }
0000a8  bd10              POP      {r4,pc}
                  |L56.170|
0000aa  6800              LDR      r0,[r0,#0]            ;3866
0000ac  6841              LDR      r1,[r0,#4]            ;3866
0000ae  f4216180          BIC      r1,r1,#0x400          ;3866
0000b2  6041              STR      r1,[r0,#4]            ;3866
0000b4  e7f7              B        |L56.166|
                  |L56.182|
0000b6  6d01              LDR      r1,[r0,#0x50]         ;3872
0000b8  b1b9              CBZ      r1,|L56.234|
0000ba  6d01              LDR      r1,[r0,#0x50]         ;3891
0000bc  2901              CMP      r1,#1                 ;3891
0000be  d028              BEQ      |L56.274|
0000c0  6d01              LDR      r1,[r0,#0x50]         ;3898
0000c2  2902              CMP      r1,#2                 ;3898
0000c4  d1ef              BNE      |L56.166|
0000c6  f890103d          LDRB     r1,[r0,#0x3d]         ;3900
0000ca  2922              CMP      r1,#0x22              ;3900
0000cc  d029              BEQ      |L56.290|
0000ce  f890103d          LDRB     r1,[r0,#0x3d]         ;3905
0000d2  2921              CMP      r1,#0x21              ;3905
0000d4  d1e7              BNE      |L56.166|
0000d6  6a41              LDR      r1,[r0,#0x24]         ;3908
0000d8  1c4a              ADDS     r2,r1,#1              ;3908
0000da  6242              STR      r2,[r0,#0x24]         ;3908
0000dc  6802              LDR      r2,[r0,#0]            ;3908
0000de  7809              LDRB     r1,[r1,#0]            ;3908
0000e0  6111              STR      r1,[r2,#0x10]         ;3908
0000e2  8d41              LDRH     r1,[r0,#0x2a]         ;3909
0000e4  1e49              SUBS     r1,r1,#1              ;3909
0000e6  8541              STRH     r1,[r0,#0x2a]         ;3909
0000e8  e7dd              B        |L56.166|
                  |L56.234|
0000ea  6cc1              LDR      r1,[r0,#0x4c]         ;3875
0000ec  2901              CMP      r1,#1                 ;3875
0000ee  d008              BEQ      |L56.258|
0000f0  6c81              LDR      r1,[r0,#0x48]         ;3886
0000f2  6802              LDR      r2,[r0,#0]            ;3886
0000f4  f3c12107          UBFX     r1,r1,#8,#8           ;3886
0000f8  6111              STR      r1,[r2,#0x10]         ;3886
0000fa  6d01              LDR      r1,[r0,#0x50]         ;3888
0000fc  1c49              ADDS     r1,r1,#1              ;3888
0000fe  6501              STR      r1,[r0,#0x50]         ;3888
000100  e7d1              B        |L56.166|
                  |L56.258|
000102  6c81              LDR      r1,[r0,#0x48]         ;3878
000104  6802              LDR      r2,[r0,#0]            ;3878
000106  b2c9              UXTB     r1,r1                 ;3878
000108  6111              STR      r1,[r2,#0x10]         ;3878
00010a  6d01              LDR      r1,[r0,#0x50]         ;3880
00010c  1c89              ADDS     r1,r1,#2              ;3880
00010e  6501              STR      r1,[r0,#0x50]         ;3880
000110  e7c9              B        |L56.166|
                  |L56.274|
000112  6c81              LDR      r1,[r0,#0x48]         ;3894
000114  6802              LDR      r2,[r0,#0]            ;3894
000116  b2c9              UXTB     r1,r1                 ;3894
000118  6111              STR      r1,[r2,#0x10]         ;3894
00011a  6d01              LDR      r1,[r0,#0x50]         ;3896
00011c  1c49              ADDS     r1,r1,#1              ;3896
00011e  6501              STR      r1,[r0,#0x50]         ;3896
000120  e7c1              B        |L56.166|
                  |L56.290|
000122  6800              LDR      r0,[r0,#0]            ;3903
000124  6801              LDR      r1,[r0,#0]            ;3903
000126  f4417180          ORR      r1,r1,#0x100          ;3903
00012a  6001              STR      r1,[r0,#0]            ;3903
00012c  e7bb              B        |L56.166|
;;;3923   
                          ENDP


                          AREA ||i.I2C_Master_ADD10||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADD10 PROC
;;;4202     */
;;;4203   static HAL_StatusTypeDef I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
000000  6c41              LDR      r1,[r0,#0x44]
;;;4204   {
;;;4205     /* Send slave address */
;;;4206     hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
000002  6800              LDR      r0,[r0,#0]
000004  b2c9              UXTB     r1,r1
000006  6101              STR      r1,[r0,#0x10]
;;;4207   
;;;4208     return HAL_OK;
000008  2000              MOVS     r0,#0
;;;4209   }
00000a  4770              BX       lr
;;;4210   
                          ENDP


                          AREA ||i.I2C_Master_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Master_ADDR PROC
;;;4216     */
;;;4217   static HAL_StatusTypeDef I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
000000  b578              PUSH     {r3-r6,lr}
;;;4218   {
;;;4219     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;4220     uint32_t CurrentMode        = hi2c->Mode;
000002  f890403e          LDRB     r4,[r0,#0x3e]
;;;4221     uint32_t CurrentXferOptions = hi2c->XferOptions;
000006  6ac2              LDR      r2,[r0,#0x2c]
;;;4222     uint32_t Prev_State         = hi2c->PreviousState;
000008  6b05              LDR      r5,[r0,#0x30]
;;;4223   
;;;4224     if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
00000a  f890603d          LDRB     r6,[r0,#0x3d]
00000e  2300              MOVS     r3,#0
000010  6801              LDR      r1,[r0,#0]
000012  2e22              CMP      r6,#0x22
000014  d004              BEQ      |L58.32|
;;;4225     {
;;;4226       if((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
;;;4227       {
;;;4228         /* Clear ADDR flag */
;;;4229         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4230       }
;;;4231       else if((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
;;;4232       {
;;;4233         /* Clear ADDR flag */
;;;4234         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4235         
;;;4236         /* Generate Restart */
;;;4237         hi2c->Instance->CR1 |= I2C_CR1_START;
;;;4238         
;;;4239         hi2c->EventCount++;
;;;4240       }
;;;4241       else
;;;4242       {
;;;4243         if(hi2c->XferCount == 0U)
;;;4244         {
;;;4245           /* Clear ADDR flag */
;;;4246           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4247           
;;;4248           /* Generate Stop */
;;;4249           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;4250         }
;;;4251         else if(hi2c->XferCount == 1U)   
;;;4252         {
;;;4253           if(CurrentXferOptions == I2C_NO_OPTION_FRAME)
;;;4254           {
;;;4255             /* Disable Acknowledge */
;;;4256               hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4257   
;;;4258             if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4259             {
;;;4260               /* Disable Acknowledge */
;;;4261               hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4262   
;;;4263               /* Clear ADDR flag */
;;;4264               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4265             }
;;;4266             else
;;;4267             {
;;;4268               /* Clear ADDR flag */
;;;4269               __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4270   
;;;4271               /* Generate Stop */
;;;4272               hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;4273             }
;;;4274           }
;;;4275           /* Prepare next transfer or stop current transfer */
;;;4276           else if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
;;;4277             && (Prev_State != I2C_STATE_MASTER_BUSY_RX))
;;;4278           {
;;;4279             if(hi2c->XferOptions != I2C_NEXT_FRAME)
;;;4280             {
;;;4281               /* Disable Acknowledge */
;;;4282               hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4283             }
;;;4284             else
;;;4285             {
;;;4286               /* Enable Acknowledge */
;;;4287               hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;4288             }
;;;4289             
;;;4290             /* Clear ADDR flag */
;;;4291             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4292           }
;;;4293           else
;;;4294           {
;;;4295             /* Disable Acknowledge */
;;;4296             hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4297             
;;;4298             /* Clear ADDR flag */
;;;4299             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4300             
;;;4301             /* Generate Stop */
;;;4302             hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;4303           }
;;;4304         }
;;;4305         else if(hi2c->XferCount == 2U)
;;;4306         {
;;;4307           if(hi2c->XferOptions != I2C_NEXT_FRAME)
;;;4308           {
;;;4309             /* Enable Pos */
;;;4310             hi2c->Instance->CR1 |= I2C_CR1_POS;
;;;4311             
;;;4312             /* Clear ADDR flag */
;;;4313             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4314             
;;;4315             /* Disable Acknowledge */
;;;4316             hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4317           }
;;;4318           else
;;;4319           {
;;;4320             /* Enable Acknowledge */
;;;4321             hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;4322             
;;;4323             /* Clear ADDR flag */
;;;4324             __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4325           }
;;;4326   
;;;4327           if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4328           {
;;;4329             /* Enable Last DMA bit */
;;;4330             hi2c->Instance->CR2 |= I2C_CR2_LAST;
;;;4331           }
;;;4332         }
;;;4333         else
;;;4334         {
;;;4335           /* Enable Acknowledge */
;;;4336           hi2c->Instance->CR1 |= I2C_CR1_ACK;
;;;4337   
;;;4338           if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
;;;4339           {
;;;4340             /* Enable Last DMA bit */
;;;4341             hi2c->Instance->CR2 |= I2C_CR2_LAST;
;;;4342           }
;;;4343   
;;;4344           /* Clear ADDR flag */
;;;4345           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4346         }
;;;4347         
;;;4348         /* Reset Event counter  */
;;;4349         hi2c->EventCount = 0U;
;;;4350       }
;;;4351     }
;;;4352     else
;;;4353     {
;;;4354       /* Clear ADDR flag */
;;;4355       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000016  6948              LDR      r0,[r1,#0x14]
000018  6988              LDR      r0,[r1,#0x18]
00001a  9000              STR      r0,[sp,#0]
                  |L58.28|
;;;4356     }
;;;4357   
;;;4358     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;4359   }
00001e  bd78              POP      {r3-r6,pc}
                  |L58.32|
000020  6d06              LDR      r6,[r0,#0x50]         ;4226
000022  b90e              CBNZ     r6,|L58.40|
000024  2c40              CMP      r4,#0x40              ;4226
000026  d002              BEQ      |L58.46|
                  |L58.40|
000028  6d04              LDR      r4,[r0,#0x50]         ;4231
00002a  b124              CBZ      r4,|L58.54|
00002c  e007              B        |L58.62|
                  |L58.46|
00002e  6948              LDR      r0,[r1,#0x14]         ;4229
000030  6988              LDR      r0,[r1,#0x18]         ;4229
000032  9000              STR      r0,[sp,#0]            ;4229
000034  e7f2              B        |L58.28|
                  |L58.54|
000036  6904              LDR      r4,[r0,#0x10]         ;4231
000038  f5b44f40          CMP      r4,#0xc000            ;4231
00003c  d019              BEQ      |L58.114|
                  |L58.62|
00003e  8d44              LDRH     r4,[r0,#0x2a]         ;4243
000040  b314              CBZ      r4,|L58.136|
000042  8d44              LDRH     r4,[r0,#0x2a]         ;4251
000044  2c01              CMP      r4,#1                 ;4251
000046  d027              BEQ      |L58.152|
000048  8d42              LDRH     r2,[r0,#0x2a]         ;4305
00004a  2a02              CMP      r2,#2                 ;4305
00004c  d064              BEQ      |L58.280|
00004e  680a              LDR      r2,[r1,#0]            ;4336
000050  f4426280          ORR      r2,r2,#0x400          ;4336
000054  600a              STR      r2,[r1,#0]            ;4336
000056  6801              LDR      r1,[r0,#0]            ;4338
000058  684a              LDR      r2,[r1,#4]            ;4338
00005a  0512              LSLS     r2,r2,#20             ;4338
00005c  d503              BPL      |L58.102|
00005e  684a              LDR      r2,[r1,#4]            ;4341
000060  f4425280          ORR      r2,r2,#0x1000         ;4341
000064  604a              STR      r2,[r1,#4]            ;4341
                  |L58.102|
000066  6801              LDR      r1,[r0,#0]            ;4345
000068  694a              LDR      r2,[r1,#0x14]         ;4345
00006a  6989              LDR      r1,[r1,#0x18]         ;4345
00006c  9100              STR      r1,[sp,#0]            ;4345
                  |L58.110|
00006e  6503              STR      r3,[r0,#0x50]         ;4349
000070  e7d4              B        |L58.28|
                  |L58.114|
000072  694a              LDR      r2,[r1,#0x14]         ;4234
000074  698a              LDR      r2,[r1,#0x18]         ;4234
000076  9200              STR      r2,[sp,#0]            ;4234
000078  680a              LDR      r2,[r1,#0]            ;4237
00007a  f4427280          ORR      r2,r2,#0x100          ;4237
00007e  600a              STR      r2,[r1,#0]            ;4237
000080  6d01              LDR      r1,[r0,#0x50]         ;4239
000082  1c49              ADDS     r1,r1,#1              ;4239
000084  6501              STR      r1,[r0,#0x50]         ;4239
000086  e7c9              B        |L58.28|
                  |L58.136|
000088  694a              LDR      r2,[r1,#0x14]         ;4246
00008a  698a              LDR      r2,[r1,#0x18]         ;4246
00008c  9200              STR      r2,[sp,#0]            ;4246
00008e  680a              LDR      r2,[r1,#0]            ;4249
000090  f4427200          ORR      r2,r2,#0x200          ;4249
000094  600a              STR      r2,[r1,#0]            ;4249
000096  e7ea              B        |L58.110|
                  |L58.152|
000098  f5123f80          CMN      r2,#0x10000           ;4253
00009c  d00d              BEQ      |L58.186|
00009e  2a04              CMP      r2,#4                 ;4276
0000a0  d02d              BEQ      |L58.254|
0000a2  2a08              CMP      r2,#8                 ;4276
0000a4  d02b              BEQ      |L58.254|
0000a6  2d12              CMP      r5,#0x12              ;4277
0000a8  d029              BEQ      |L58.254|
0000aa  6ac2              LDR      r2,[r0,#0x2c]         ;4279
0000ac  2a02              CMP      r2,#2                 ;4279
0000ae  d01d              BEQ      |L58.236|
0000b0  680a              LDR      r2,[r1,#0]            ;4282
0000b2  f4226280          BIC      r2,r2,#0x400          ;4282
0000b6  600a              STR      r2,[r1,#0]            ;4282
0000b8  e01c              B        |L58.244|
                  |L58.186|
0000ba  680a              LDR      r2,[r1,#0]            ;4256
0000bc  f4226280          BIC      r2,r2,#0x400          ;4256
0000c0  600a              STR      r2,[r1,#0]            ;4256
0000c2  6801              LDR      r1,[r0,#0]            ;4258
0000c4  684a              LDR      r2,[r1,#4]            ;4258
0000c6  0512              LSLS     r2,r2,#20             ;4258
0000c8  d508              BPL      |L58.220|
0000ca  680a              LDR      r2,[r1,#0]            ;4261
0000cc  f4226280          BIC      r2,r2,#0x400          ;4261
0000d0  600a              STR      r2,[r1,#0]            ;4261
0000d2  6801              LDR      r1,[r0,#0]            ;4264
0000d4  694a              LDR      r2,[r1,#0x14]         ;4264
0000d6  6989              LDR      r1,[r1,#0x18]         ;4264
0000d8  9100              STR      r1,[sp,#0]            ;4264
0000da  e7c8              B        |L58.110|
                  |L58.220|
0000dc  694a              LDR      r2,[r1,#0x14]         ;4269
0000de  698a              LDR      r2,[r1,#0x18]         ;4269
0000e0  9200              STR      r2,[sp,#0]            ;4269
0000e2  680a              LDR      r2,[r1,#0]            ;4272
0000e4  f4427200          ORR      r2,r2,#0x200          ;4272
0000e8  600a              STR      r2,[r1,#0]            ;4272
0000ea  e7c0              B        |L58.110|
                  |L58.236|
0000ec  680a              LDR      r2,[r1,#0]            ;4287
0000ee  f4426280          ORR      r2,r2,#0x400          ;4287
0000f2  600a              STR      r2,[r1,#0]            ;4287
                  |L58.244|
0000f4  6801              LDR      r1,[r0,#0]            ;4291
0000f6  694a              LDR      r2,[r1,#0x14]         ;4291
0000f8  6989              LDR      r1,[r1,#0x18]         ;4291
0000fa  9100              STR      r1,[sp,#0]            ;4291
0000fc  e7b7              B        |L58.110|
                  |L58.254|
0000fe  680a              LDR      r2,[r1,#0]            ;4296
000100  f4226280          BIC      r2,r2,#0x400          ;4296
000104  600a              STR      r2,[r1,#0]            ;4296
000106  6801              LDR      r1,[r0,#0]            ;4299
000108  694a              LDR      r2,[r1,#0x14]         ;4299
00010a  698a              LDR      r2,[r1,#0x18]         ;4299
00010c  9200              STR      r2,[sp,#0]            ;4299
00010e  680a              LDR      r2,[r1,#0]            ;4302
000110  f4427200          ORR      r2,r2,#0x200          ;4302
000114  600a              STR      r2,[r1,#0]            ;4302
000116  e7aa              B        |L58.110|
                  |L58.280|
000118  6ac2              LDR      r2,[r0,#0x2c]         ;4307
00011a  2a02              CMP      r2,#2                 ;4307
00011c  d00c              BEQ      |L58.312|
00011e  680a              LDR      r2,[r1,#0]            ;4310
000120  f4426200          ORR      r2,r2,#0x800          ;4310
000124  600a              STR      r2,[r1,#0]            ;4310
000126  6801              LDR      r1,[r0,#0]            ;4313
000128  694a              LDR      r2,[r1,#0x14]         ;4313
00012a  698a              LDR      r2,[r1,#0x18]         ;4313
00012c  9200              STR      r2,[sp,#0]            ;4313
00012e  680a              LDR      r2,[r1,#0]            ;4316
000130  f4226280          BIC      r2,r2,#0x400          ;4316
000134  600a              STR      r2,[r1,#0]            ;4316
000136  e007              B        |L58.328|
                  |L58.312|
000138  680a              LDR      r2,[r1,#0]            ;4321
00013a  f4426280          ORR      r2,r2,#0x400          ;4321
00013e  600a              STR      r2,[r1,#0]            ;4321
000140  6801              LDR      r1,[r0,#0]            ;4324
000142  694a              LDR      r2,[r1,#0x14]         ;4324
000144  6989              LDR      r1,[r1,#0x18]         ;4324
000146  9100              STR      r1,[sp,#0]            ;4324
                  |L58.328|
000148  6801              LDR      r1,[r0,#0]            ;4327
00014a  684a              LDR      r2,[r1,#4]            ;4327
00014c  0512              LSLS     r2,r2,#20             ;4327
00014e  d58e              BPL      |L58.110|
000150  684a              LDR      r2,[r1,#4]            ;4330
000152  f4425280          ORR      r2,r2,#0x1000         ;4330
000156  604a              STR      r2,[r1,#4]            ;4330
000158  e789              B        |L58.110|
;;;4360   
                          ENDP


                          AREA ||i.I2C_Master_SB||, CODE, READONLY, ALIGN=1

                  I2C_Master_SB PROC
;;;4150     */
;;;4151   static HAL_StatusTypeDef I2C_Master_SB(I2C_HandleTypeDef *hi2c)
000000  f890103e          LDRB     r1,[r0,#0x3e]
;;;4152   {
;;;4153     if(hi2c->Mode == HAL_I2C_MODE_MEM)
000004  2940              CMP      r1,#0x40
000006  d009              BEQ      |L59.28|
;;;4154     {
;;;4155       if(hi2c->EventCount == 0U)
;;;4156       {
;;;4157         /* Send slave address */
;;;4158         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
;;;4159       }
;;;4160       else
;;;4161       {
;;;4162         hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
;;;4163       }
;;;4164     }
;;;4165     else
;;;4166     {
;;;4167       if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000008  6901              LDR      r1,[r0,#0x10]
00000a  f5b14f80          CMP      r1,#0x4000
00000e  d014              BEQ      |L59.58|
;;;4168       {
;;;4169         /* Send slave 7 Bits address */
;;;4170         if(hi2c->State == HAL_I2C_STATE_BUSY_TX) 
;;;4171         {
;;;4172           hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
;;;4173         }
;;;4174         else
;;;4175         {
;;;4176           hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
;;;4177         }
;;;4178       }
;;;4179       else
;;;4180       {
;;;4181         if(hi2c->EventCount == 0U)
000010  6d01              LDR      r1,[r0,#0x50]
000012  b319              CBZ      r1,|L59.92|
;;;4182         {
;;;4183           /* Send header of slave address */
;;;4184           hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
;;;4185         }
;;;4186         else if(hi2c->EventCount == 1U)
000014  6d01              LDR      r1,[r0,#0x50]
000016  2901              CMP      r1,#1
000018  d029              BEQ      |L59.110|
00001a  e030              B        |L59.126|
                  |L59.28|
00001c  6d01              LDR      r1,[r0,#0x50]         ;4155
00001e  b131              CBZ      r1,|L59.46|
000020  6c41              LDR      r1,[r0,#0x44]         ;4162
000022  6800              LDR      r0,[r0,#0]            ;4162
000024  b2c9              UXTB     r1,r1                 ;4162
000026  f0410101          ORR      r1,r1,#1              ;4162
00002a  6101              STR      r1,[r0,#0x10]         ;4162
00002c  e027              B        |L59.126|
                  |L59.46|
00002e  6c41              LDR      r1,[r0,#0x44]         ;4158
000030  6800              LDR      r0,[r0,#0]            ;4158
000032  f00101fe          AND      r1,r1,#0xfe           ;4158
000036  6101              STR      r1,[r0,#0x10]         ;4158
000038  e021              B        |L59.126|
                  |L59.58|
00003a  f890103d          LDRB     r1,[r0,#0x3d]         ;4170
00003e  2921              CMP      r1,#0x21              ;4170
000040  d006              BEQ      |L59.80|
000042  6c41              LDR      r1,[r0,#0x44]         ;4176
000044  6800              LDR      r0,[r0,#0]            ;4176
000046  b2c9              UXTB     r1,r1                 ;4176
000048  f0410101          ORR      r1,r1,#1              ;4176
00004c  6101              STR      r1,[r0,#0x10]         ;4176
00004e  e016              B        |L59.126|
                  |L59.80|
000050  6c41              LDR      r1,[r0,#0x44]         ;4172
000052  6800              LDR      r0,[r0,#0]            ;4172
000054  f00101fe          AND      r1,r1,#0xfe           ;4172
000058  6101              STR      r1,[r0,#0x10]         ;4172
00005a  e010              B        |L59.126|
                  |L59.92|
00005c  6c41              LDR      r1,[r0,#0x44]         ;4184
00005e  6800              LDR      r0,[r0,#0]            ;4184
000060  f4017140          AND      r1,r1,#0x300          ;4184
000064  22f0              MOVS     r2,#0xf0              ;4184
000066  ea4211d1          ORR      r1,r2,r1,LSR #7       ;4184
00006a  6101              STR      r1,[r0,#0x10]         ;4184
00006c  e007              B        |L59.126|
                  |L59.110|
;;;4187         {
;;;4188           /* Send header of slave address */
;;;4189           hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
00006e  6c41              LDR      r1,[r0,#0x44]
000070  6800              LDR      r0,[r0,#0]
000072  f4017140          AND      r1,r1,#0x300
000076  22f1              MOVS     r2,#0xf1
000078  ea4211d1          ORR      r1,r2,r1,LSR #7
00007c  6101              STR      r1,[r0,#0x10]
                  |L59.126|
;;;4190         }
;;;4191       }
;;;4192     }
;;;4193   
;;;4194     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;4195   }
000080  4770              BX       lr
;;;4196   
                          ENDP


                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryRead PROC
;;;5047     */
;;;5048   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;5049   {
000004  4604              MOV      r4,r0
000006  e9ddb60a          LDRD     r11,r6,[sp,#0x28]
00000a  460f              MOV      r7,r1
00000c  4690              MOV      r8,r2
00000e  461d              MOV      r5,r3
;;;5050     /* Enable Acknowledge */
;;;5051     hi2c->Instance->CR1 |= I2C_CR1_ACK;
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4416180          ORR      r1,r1,#0x400
000018  6001              STR      r1,[r0,#0]
;;;5052   
;;;5053     /* Generate Start */
;;;5054     hi2c->Instance->CR1 |= I2C_CR1_START;
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f4417180          ORR      r1,r1,#0x100
000022  6001              STR      r1,[r0,#0]
;;;5055   
;;;5056     /* Wait until SB flag is set */
;;;5057     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
000024  f04f1901          MOV      r9,#0x10001
000028  465b              MOV      r3,r11
00002a  2200              MOVS     r2,#0
00002c  4649              MOV      r1,r9
00002e  4620              MOV      r0,r4
000030  9600              STR      r6,[sp,#0]
000032  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000036  b110              CBZ      r0,|L60.62|
;;;5058     {
;;;5059       return HAL_TIMEOUT;
000038  2003              MOVS     r0,#3
                  |L60.58|
;;;5060     }
;;;5061   
;;;5062     /* Send slave address */
;;;5063     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;5064   
;;;5065     /* Wait until ADDR flag is set */
;;;5066     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;5067     {
;;;5068       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5069       {
;;;5070         return HAL_ERROR;
;;;5071       }
;;;5072       else
;;;5073       {
;;;5074         return HAL_TIMEOUT;
;;;5075       }
;;;5076     }
;;;5077   
;;;5078     /* Clear ADDR flag */
;;;5079     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;5080   
;;;5081     /* Wait until TXE flag is set */
;;;5082     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5083     {
;;;5084       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5085       {
;;;5086         /* Generate Stop */
;;;5087         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;5088         return HAL_ERROR;
;;;5089       }
;;;5090       else
;;;5091       {
;;;5092         return HAL_TIMEOUT;
;;;5093       }
;;;5094     }
;;;5095   
;;;5096     /* If Memory address size is 8Bit */
;;;5097     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;5098     {
;;;5099       /* Send Memory Address */
;;;5100       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;5101     }
;;;5102     /* If Memory address size is 16Bit */
;;;5103     else
;;;5104     {
;;;5105       /* Send MSB of Memory Address */
;;;5106       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;5107   
;;;5108       /* Wait until TXE flag is set */
;;;5109       if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5110       {
;;;5111         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5112         {
;;;5113           /* Generate Stop */
;;;5114           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;5115           return HAL_ERROR;
;;;5116         }
;;;5117         else
;;;5118         {
;;;5119           return HAL_TIMEOUT;
;;;5120         }
;;;5121       }
;;;5122   
;;;5123       /* Send LSB of Memory Address */
;;;5124       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;5125     }
;;;5126   
;;;5127     /* Wait until TXE flag is set */
;;;5128     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5129     {
;;;5130       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5131       {
;;;5132         /* Generate Stop */
;;;5133         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;5134         return HAL_ERROR;
;;;5135       }
;;;5136       else
;;;5137       {
;;;5138         return HAL_TIMEOUT;
;;;5139       }
;;;5140     }
;;;5141   
;;;5142     /* Generate Restart */
;;;5143     hi2c->Instance->CR1 |= I2C_CR1_START;
;;;5144   
;;;5145     /* Wait until SB flag is set */
;;;5146     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
;;;5147     {
;;;5148       return HAL_TIMEOUT;
;;;5149     }
;;;5150   
;;;5151     /* Send slave address */
;;;5152     hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;5153   
;;;5154     /* Wait until ADDR flag is set */
;;;5155     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;5156     {
;;;5157       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5158       {
;;;5159         return HAL_ERROR;
;;;5160       }
;;;5161       else
;;;5162       {
;;;5163         return HAL_TIMEOUT;
;;;5164       }
;;;5165     }
;;;5166   
;;;5167     return HAL_OK;
;;;5168   }
00003a  e8bd8ff8          POP      {r3-r11,pc}
                  |L60.62|
00003e  6821              LDR      r1,[r4,#0]            ;5063
000040  f00700fe          AND      r0,r7,#0xfe           ;5063
000044  6108              STR      r0,[r1,#0x10]         ;5063
000046  f8dfa0f8          LDR      r10,|L60.320|
00004a  4633              MOV      r3,r6                 ;5066
00004c  465a              MOV      r2,r11                ;5066
00004e  4651              MOV      r1,r10                ;5066
000050  4620              MOV      r0,r4                 ;5066
000052  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000056  b130              CBZ      r0,|L60.102|
000058  6c20              LDR      r0,[r4,#0x40]         ;5068
00005a  2804              CMP      r0,#4                 ;5068
00005c  d001              BEQ      |L60.98|
00005e  2003              MOVS     r0,#3                 ;5074
000060  e7eb              B        |L60.58|
                  |L60.98|
000062  2001              MOVS     r0,#1                 ;5070
000064  e7e9              B        |L60.58|
                  |L60.102|
000066  6820              LDR      r0,[r4,#0]            ;5079
000068  6941              LDR      r1,[r0,#0x14]         ;5079
00006a  6980              LDR      r0,[r0,#0x18]         ;5079
00006c  9000              STR      r0,[sp,#0]            ;5079
00006e  4632              MOV      r2,r6                 ;5082
000070  4659              MOV      r1,r11                ;5082
000072  4620              MOV      r0,r4                 ;5082
000074  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000078  b158              CBZ      r0,|L60.146|
00007a  6c20              LDR      r0,[r4,#0x40]         ;5084
00007c  2804              CMP      r0,#4                 ;5084
00007e  d001              BEQ      |L60.132|
000080  2003              MOVS     r0,#3                 ;5092
000082  e7da              B        |L60.58|
                  |L60.132|
000084  6820              LDR      r0,[r4,#0]            ;5087
000086  6801              LDR      r1,[r0,#0]            ;5087
000088  f4417100          ORR      r1,r1,#0x200          ;5087
00008c  6001              STR      r1,[r0,#0]            ;5087
00008e  2001              MOVS     r0,#1                 ;5088
000090  e7d3              B        |L60.58|
                  |L60.146|
000092  4628              MOV      r0,r5                 ;5097
000094  f00805ff          AND      r5,r8,#0xff           ;5100
000098  2801              CMP      r0,#1                 ;5097
00009a  d00e              BEQ      |L60.186|
00009c  6821              LDR      r1,[r4,#0]            ;5106
00009e  ea4f2018          LSR      r0,r8,#8              ;5106
0000a2  6108              STR      r0,[r1,#0x10]         ;5106
0000a4  4632              MOV      r2,r6                 ;5109
0000a6  4659              MOV      r1,r11                ;5109
0000a8  4620              MOV      r0,r4                 ;5109
0000aa  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000ae  b170              CBZ      r0,|L60.206|
0000b0  6c20              LDR      r0,[r4,#0x40]         ;5111
0000b2  2804              CMP      r0,#4                 ;5111
0000b4  d004              BEQ      |L60.192|
0000b6  2003              MOVS     r0,#3                 ;5119
0000b8  e7bf              B        |L60.58|
                  |L60.186|
0000ba  6820              LDR      r0,[r4,#0]            ;5100
0000bc  6105              STR      r5,[r0,#0x10]         ;5100
0000be  e008              B        |L60.210|
                  |L60.192|
0000c0  6820              LDR      r0,[r4,#0]            ;5114
0000c2  6801              LDR      r1,[r0,#0]            ;5114
0000c4  f4417100          ORR      r1,r1,#0x200          ;5114
0000c8  6001              STR      r1,[r0,#0]            ;5114
0000ca  2001              MOVS     r0,#1                 ;5115
0000cc  e7b5              B        |L60.58|
                  |L60.206|
0000ce  6820              LDR      r0,[r4,#0]            ;5124
0000d0  6105              STR      r5,[r0,#0x10]         ;5124
                  |L60.210|
0000d2  4632              MOV      r2,r6                 ;5128
0000d4  4659              MOV      r1,r11                ;5128
0000d6  4620              MOV      r0,r4                 ;5128
0000d8  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000dc  b158              CBZ      r0,|L60.246|
0000de  6c20              LDR      r0,[r4,#0x40]         ;5130
0000e0  2804              CMP      r0,#4                 ;5130
0000e2  d001              BEQ      |L60.232|
0000e4  2003              MOVS     r0,#3                 ;5138
0000e6  e7a8              B        |L60.58|
                  |L60.232|
0000e8  6820              LDR      r0,[r4,#0]            ;5133
0000ea  6801              LDR      r1,[r0,#0]            ;5133
0000ec  f4417100          ORR      r1,r1,#0x200          ;5133
0000f0  6001              STR      r1,[r0,#0]            ;5133
0000f2  2001              MOVS     r0,#1                 ;5134
0000f4  e7a1              B        |L60.58|
                  |L60.246|
0000f6  6820              LDR      r0,[r4,#0]            ;5143
0000f8  6801              LDR      r1,[r0,#0]            ;5143
0000fa  f4417180          ORR      r1,r1,#0x100          ;5143
0000fe  6001              STR      r1,[r0,#0]            ;5143
000100  465b              MOV      r3,r11                ;5146
000102  2200              MOVS     r2,#0                 ;5146
000104  4649              MOV      r1,r9                 ;5146
000106  4620              MOV      r0,r4                 ;5146
000108  9600              STR      r6,[sp,#0]            ;5146
00010a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00010e  b108              CBZ      r0,|L60.276|
000110  2003              MOVS     r0,#3                 ;5148
000112  e792              B        |L60.58|
                  |L60.276|
000114  6821              LDR      r1,[r4,#0]            ;5152
000116  b2f8              UXTB     r0,r7                 ;5152
000118  f0400001          ORR      r0,r0,#1              ;5152
00011c  6108              STR      r0,[r1,#0x10]         ;5152
00011e  4633              MOV      r3,r6                 ;5155
000120  465a              MOV      r2,r11                ;5155
000122  4651              MOV      r1,r10                ;5155
000124  4620              MOV      r0,r4                 ;5155
000126  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00012a  b130              CBZ      r0,|L60.314|
00012c  6c20              LDR      r0,[r4,#0x40]         ;5157
00012e  2804              CMP      r0,#4                 ;5157
000130  d001              BEQ      |L60.310|
000132  2003              MOVS     r0,#3                 ;5163
000134  e781              B        |L60.58|
                  |L60.310|
000136  2001              MOVS     r0,#1                 ;5159
000138  e77f              B        |L60.58|
                  |L60.314|
00013a  2000              MOVS     r0,#0                 ;5167
00013c  e77d              B        |L60.58|
;;;5169   
                          ENDP

00013e  0000              DCW      0x0000
                  |L60.320|
                          DCD      0x00010002

                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;4957     */
;;;4958   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;4959   {
000004  4604              MOV      r4,r0
000006  e9dd9708          LDRD     r9,r7,[sp,#0x20]
00000a  460d              MOV      r5,r1
00000c  4616              MOV      r6,r2
00000e  4698              MOV      r8,r3
;;;4960     /* Generate Start */
;;;4961     hi2c->Instance->CR1 |= I2C_CR1_START;
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  f4417180          ORR      r1,r1,#0x100
000018  6001              STR      r1,[r0,#0]
;;;4962   
;;;4963     /* Wait until SB flag is set */
;;;4964     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
00001a  464b              MOV      r3,r9
00001c  2200              MOVS     r2,#0
00001e  f04f1101          MOV      r1,#0x10001
000022  4620              MOV      r0,r4
000024  9700              STR      r7,[sp,#0]
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  b110              CBZ      r0,|L61.50|
;;;4965     {
;;;4966       return HAL_TIMEOUT;
00002c  2003              MOVS     r0,#3
                  |L61.46|
;;;4967     }
;;;4968   
;;;4969     /* Send slave address */
;;;4970     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;4971   
;;;4972     /* Wait until ADDR flag is set */
;;;4973     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
;;;4974     {
;;;4975       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4976       {
;;;4977         return HAL_ERROR;
;;;4978       }
;;;4979       else
;;;4980       {
;;;4981         return HAL_TIMEOUT;
;;;4982       }
;;;4983     }
;;;4984   
;;;4985     /* Clear ADDR flag */
;;;4986     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;4987   
;;;4988     /* Wait until TXE flag is set */
;;;4989     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;4990     {
;;;4991       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;4992       {
;;;4993         /* Generate Stop */
;;;4994         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;4995         return HAL_ERROR;
;;;4996       }
;;;4997       else
;;;4998       {
;;;4999         return HAL_TIMEOUT;
;;;5000       }
;;;5001     }
;;;5002   
;;;5003     /* If Memory address size is 8Bit */
;;;5004     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;5005     {
;;;5006       /* Send Memory Address */
;;;5007       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;5008     }
;;;5009     /* If Memory address size is 16Bit */
;;;5010     else
;;;5011     {
;;;5012       /* Send MSB of Memory Address */
;;;5013       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;5014   
;;;5015       /* Wait until TXE flag is set */
;;;5016       if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;5017       {
;;;5018         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;5019         {
;;;5020           /* Generate Stop */
;;;5021           hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;5022           return HAL_ERROR;
;;;5023         }
;;;5024         else
;;;5025         {
;;;5026           return HAL_TIMEOUT;
;;;5027         }
;;;5028       }
;;;5029   
;;;5030       /* Send LSB of Memory Address */
;;;5031       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;5032     }
;;;5033   
;;;5034     return HAL_OK;
;;;5035   }
00002e  e8bd83f8          POP      {r3-r9,pc}
                  |L61.50|
000032  6821              LDR      r1,[r4,#0]            ;4970
000034  f00500fe          AND      r0,r5,#0xfe           ;4970
000038  6108              STR      r0,[r1,#0x10]         ;4970
00003a  463b              MOV      r3,r7                 ;4973
00003c  464a              MOV      r2,r9                 ;4973
00003e  4921              LDR      r1,|L61.196|
000040  4620              MOV      r0,r4                 ;4973
000042  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000046  b130              CBZ      r0,|L61.86|
000048  6c20              LDR      r0,[r4,#0x40]         ;4975
00004a  2804              CMP      r0,#4                 ;4975
00004c  d001              BEQ      |L61.82|
00004e  2003              MOVS     r0,#3                 ;4981
000050  e7ed              B        |L61.46|
                  |L61.82|
000052  2001              MOVS     r0,#1                 ;4977
000054  e7eb              B        |L61.46|
                  |L61.86|
000056  6820              LDR      r0,[r4,#0]            ;4986
000058  6941              LDR      r1,[r0,#0x14]         ;4986
00005a  6980              LDR      r0,[r0,#0x18]         ;4986
00005c  9000              STR      r0,[sp,#0]            ;4986
00005e  463a              MOV      r2,r7                 ;4989
000060  4649              MOV      r1,r9                 ;4989
000062  4620              MOV      r0,r4                 ;4989
000064  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000068  b158              CBZ      r0,|L61.130|
00006a  6c20              LDR      r0,[r4,#0x40]         ;4991
00006c  2804              CMP      r0,#4                 ;4991
00006e  d001              BEQ      |L61.116|
000070  2003              MOVS     r0,#3                 ;4999
000072  e7dc              B        |L61.46|
                  |L61.116|
000074  6820              LDR      r0,[r4,#0]            ;4994
000076  6801              LDR      r1,[r0,#0]            ;4994
000078  f4417100          ORR      r1,r1,#0x200          ;4994
00007c  6001              STR      r1,[r0,#0]            ;4994
00007e  2001              MOVS     r0,#1                 ;4995
000080  e7d5              B        |L61.46|
                  |L61.130|
000082  b2f5              UXTB     r5,r6                 ;5007
000084  f1b80f01          CMP      r8,#1                 ;5004
000088  d00d              BEQ      |L61.166|
00008a  6821              LDR      r1,[r4,#0]            ;5013
00008c  0a30              LSRS     r0,r6,#8              ;5013
00008e  6108              STR      r0,[r1,#0x10]         ;5013
000090  463a              MOV      r2,r7                 ;5016
000092  4649              MOV      r1,r9                 ;5016
000094  4620              MOV      r0,r4                 ;5016
000096  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00009a  b170              CBZ      r0,|L61.186|
00009c  6c20              LDR      r0,[r4,#0x40]         ;5018
00009e  2804              CMP      r0,#4                 ;5018
0000a0  d004              BEQ      |L61.172|
0000a2  2003              MOVS     r0,#3                 ;5026
0000a4  e7c3              B        |L61.46|
                  |L61.166|
0000a6  6820              LDR      r0,[r4,#0]            ;5007
0000a8  6105              STR      r5,[r0,#0x10]         ;5007
0000aa  e008              B        |L61.190|
                  |L61.172|
0000ac  6820              LDR      r0,[r4,#0]            ;5021
0000ae  6801              LDR      r1,[r0,#0]            ;5021
0000b0  f4417100          ORR      r1,r1,#0x200          ;5021
0000b4  6001              STR      r1,[r0,#0]            ;5021
0000b6  2001              MOVS     r0,#1                 ;5022
0000b8  e7b9              B        |L61.46|
                  |L61.186|
0000ba  6820              LDR      r0,[r4,#0]            ;5031
0000bc  6105              STR      r5,[r0,#0x10]         ;5031
                  |L61.190|
0000be  2000              MOVS     r0,#0                 ;5034
0000c0  e7b5              B        |L61.46|
;;;5036   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L61.196|
                          DCD      0x00010002

                          AREA ||i.I2C_SlaveReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_BTF PROC
;;;4449     */
;;;4450   static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;4451   {
;;;4452     if(hi2c->XferCount != 0U)
000002  2900              CMP      r1,#0
000004  d008              BEQ      |L62.24|
;;;4453     {
;;;4454       /* Read data from DR */
;;;4455       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000006  6801              LDR      r1,[r0,#0]
000008  690a              LDR      r2,[r1,#0x10]
00000a  6a41              LDR      r1,[r0,#0x24]
00000c  1c4b              ADDS     r3,r1,#1
00000e  6243              STR      r3,[r0,#0x24]
000010  700a              STRB     r2,[r1,#0]
;;;4456       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L62.24|
;;;4457     }
;;;4458     return HAL_OK;
000018  2000              MOVS     r0,#0
;;;4459   }
00001a  4770              BX       lr
;;;4460   
                          ENDP


                          AREA ||i.I2C_SlaveReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReceive_RXNE PROC
;;;4416     */
;;;4417   static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4418   {
;;;4419     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4420     uint32_t CurrentState = hi2c->State;
000002  f890203d          LDRB     r2,[r0,#0x3d]
;;;4421   
;;;4422     if(hi2c->XferCount != 0U)
000006  8d41              LDRH     r1,[r0,#0x2a]
000008  2900              CMP      r1,#0
00000a  d018              BEQ      |L63.62|
;;;4423     {
;;;4424       /* Read data from DR */
;;;4425       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
00000c  6801              LDR      r1,[r0,#0]
00000e  690b              LDR      r3,[r1,#0x10]
000010  6a41              LDR      r1,[r0,#0x24]
000012  1c4c              ADDS     r4,r1,#1
000014  6244              STR      r4,[r0,#0x24]
000016  700b              STRB     r3,[r1,#0]
;;;4426       hi2c->XferCount--;
000018  8d41              LDRH     r1,[r0,#0x2a]
00001a  1e49              SUBS     r1,r1,#1
00001c  8541              STRH     r1,[r0,#0x2a]
;;;4427   
;;;4428       if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
00001e  8d41              LDRH     r1,[r0,#0x2a]
000020  b969              CBNZ     r1,|L63.62|
000022  2a2a              CMP      r2,#0x2a
000024  d10b              BNE      |L63.62|
;;;4429       {
;;;4430         /* Last Byte is received, disable Interrupt */
;;;4431         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  f4226280          BIC      r2,r2,#0x400
00002e  604a              STR      r2,[r1,#4]
;;;4432   
;;;4433         /* Set state at HAL_I2C_STATE_LISTEN */
;;;4434         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000030  2122              MOVS     r1,#0x22
000032  6301              STR      r1,[r0,#0x30]
;;;4435         hi2c->State = HAL_I2C_STATE_LISTEN;
000034  2128              MOVS     r1,#0x28
000036  f880103d          STRB     r1,[r0,#0x3d]
;;;4436   
;;;4437         /* Call the Rx complete callback to inform upper layer of the end of receive process */
;;;4438         HAL_I2C_SlaveRxCpltCallback(hi2c);
00003a  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L63.62|
;;;4439       }
;;;4440     }
;;;4441     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;4442   }
000040  bd10              POP      {r4,pc}
;;;4443   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_BTF||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_BTF PROC
;;;4399     */
;;;4400   static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
000000  8d41              LDRH     r1,[r0,#0x2a]
;;;4401   {
;;;4402     if(hi2c->XferCount != 0U)
000002  2900              CMP      r1,#0
000004  d008              BEQ      |L64.24|
;;;4403     {
;;;4404       /* Write data to DR */
;;;4405       hi2c->Instance->DR = (*hi2c->pBuffPtr++);
000006  6a41              LDR      r1,[r0,#0x24]
000008  1c4a              ADDS     r2,r1,#1
00000a  6242              STR      r2,[r0,#0x24]
00000c  6802              LDR      r2,[r0,#0]
00000e  7809              LDRB     r1,[r1,#0]
000010  6111              STR      r1,[r2,#0x10]
;;;4406       hi2c->XferCount--;
000012  8d41              LDRH     r1,[r0,#0x2a]
000014  1e49              SUBS     r1,r1,#1
000016  8541              STRH     r1,[r0,#0x2a]
                  |L64.24|
;;;4407     }
;;;4408     return HAL_OK;
000018  2000              MOVS     r0,#0
;;;4409   }
00001a  4770              BX       lr
;;;4410   
                          ENDP


                          AREA ||i.I2C_SlaveTransmit_TXE||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransmit_TXE PROC
;;;4366     */
;;;4367   static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4368   {
;;;4369     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4370     uint32_t CurrentState = hi2c->State;
000002  f890203d          LDRB     r2,[r0,#0x3d]
;;;4371   
;;;4372     if(hi2c->XferCount != 0U)
000006  8d41              LDRH     r1,[r0,#0x2a]
000008  2900              CMP      r1,#0
00000a  d018              BEQ      |L65.62|
;;;4373     {
;;;4374       /* Write data to DR */
;;;4375       hi2c->Instance->DR = (*hi2c->pBuffPtr++);
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c4b              ADDS     r3,r1,#1
000010  6243              STR      r3,[r0,#0x24]
000012  6803              LDR      r3,[r0,#0]
000014  7809              LDRB     r1,[r1,#0]
000016  6119              STR      r1,[r3,#0x10]
;;;4376       hi2c->XferCount--;
000018  8d41              LDRH     r1,[r0,#0x2a]
00001a  1e49              SUBS     r1,r1,#1
00001c  8541              STRH     r1,[r0,#0x2a]
;;;4377   
;;;4378       if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
00001e  8d41              LDRH     r1,[r0,#0x2a]
000020  b969              CBNZ     r1,|L65.62|
000022  2a29              CMP      r2,#0x29
000024  d10b              BNE      |L65.62|
;;;4379       {
;;;4380         /* Last Byte is received, disable Interrupt */
;;;4381         __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  f4226280          BIC      r2,r2,#0x400
00002e  604a              STR      r2,[r1,#4]
;;;4382         
;;;4383         /* Set state at HAL_I2C_STATE_LISTEN */
;;;4384         hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000030  2121              MOVS     r1,#0x21
000032  6301              STR      r1,[r0,#0x30]
;;;4385         hi2c->State = HAL_I2C_STATE_LISTEN;
000034  2128              MOVS     r1,#0x28
000036  f880103d          STRB     r1,[r0,#0x3d]
;;;4386         
;;;4387         /* Call the Tx complete callback to inform upper layer of the end of receive process */
;;;4388         HAL_I2C_SlaveTxCpltCallback(hi2c);
00003a  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
                  |L65.62|
;;;4389       }
;;;4390     }
;;;4391     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;4392   }
000040  bd10              POP      {r4,pc}
;;;4393   
                          ENDP


                          AREA ||i.I2C_Slave_ADDR||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ADDR PROC
;;;4466     */
;;;4467   static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;4468   {
;;;4469     uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
000002  2100              MOVS     r1,#0
;;;4470     uint16_t SlaveAddrCode = 0U;
;;;4471   
;;;4472     /* Transfer Direction requested by Master */
;;;4473     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
000004  6802              LDR      r2,[r0,#0]
000006  6993              LDR      r3,[r2,#0x18]
000008  43db              MVNS     r3,r3
00000a  075b              LSLS     r3,r3,#29
00000c  d500              BPL      |L66.16|
;;;4474     {
;;;4475       TransferDirection = I2C_DIRECTION_TRANSMIT;
00000e  2101              MOVS     r1,#1
                  |L66.16|
;;;4476     }
;;;4477     
;;;4478     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
000010  6992              LDR      r2,[r2,#0x18]
000012  43d2              MVNS     r2,r2
000014  0612              LSLS     r2,r2,#24
000016  d502              BPL      |L66.30|
;;;4479     {
;;;4480       SlaveAddrCode = hi2c->Init.OwnAddress1;
000018  8982              LDRH     r2,[r0,#0xc]
00001a  b292              UXTH     r2,r2
00001c  e001              B        |L66.34|
                  |L66.30|
;;;4481     }
;;;4482     else
;;;4483     {
;;;4484       SlaveAddrCode = hi2c->Init.OwnAddress2;
00001e  8b02              LDRH     r2,[r0,#0x18]
000020  b292              UXTH     r2,r2
                  |L66.34|
;;;4485     }
;;;4486   
;;;4487     /* Call Slave Addr callback */
;;;4488     HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
000022  f7fffffe          BL       HAL_I2C_AddrCallback
;;;4489   
;;;4490     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;4491   }
000028  bd10              POP      {r4,pc}
;;;4492   
                          ENDP


                          AREA ||i.I2C_Slave_AF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_AF PROC
;;;4586     */
;;;4587   static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4588   {
;;;4589     /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
;;;4590     uint32_t CurrentState       = hi2c->State;
000004  f890203d          LDRB     r2,[r0,#0x3d]
;;;4591     uint32_t CurrentXferOptions = hi2c->XferOptions;
000008  6ac3              LDR      r3,[r0,#0x2c]
;;;4592   
;;;4593     if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
00000a  2500              MOVS     r5,#0
;;;4594             (CurrentState == HAL_I2C_STATE_LISTEN))
;;;4595     {
;;;4596       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
00000c  4e1c              LDR      r6,|L67.128|
;;;4597   
;;;4598       /* Disable EVT, BUF and ERR interrupt */
;;;4599       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4600   
;;;4601       /* Clear AF flag */
;;;4602       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4603   
;;;4604       /* Disable Acknowledge */
;;;4605       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4606   
;;;4607       hi2c->PreviousState = I2C_STATE_NONE;
;;;4608       hi2c->State = HAL_I2C_STATE_READY;
00000e  2720              MOVS     r7,#0x20
000010  6801              LDR      r1,[r0,#0]            ;4593
000012  f46f6480          MVN      r4,#0x400             ;4602
000016  2b04              CMP      r3,#4                 ;4593
000018  d001              BEQ      |L67.30|
00001a  2b08              CMP      r3,#8                 ;4593
00001c  d101              BNE      |L67.34|
                  |L67.30|
00001e  2a28              CMP      r2,#0x28              ;4594
000020  d005              BEQ      |L67.46|
                  |L67.34|
;;;4609       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4610         
;;;4611       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4612       HAL_I2C_ListenCpltCallback(hi2c);
;;;4613     }
;;;4614     else if(CurrentState == HAL_I2C_STATE_BUSY_TX)
000022  2a21              CMP      r2,#0x21
000024  d017              BEQ      |L67.86|
;;;4615     {
;;;4616       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;4617       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
;;;4618       hi2c->State = HAL_I2C_STATE_READY;
;;;4619       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4620       
;;;4621       /* Disable EVT, BUF and ERR interrupt */
;;;4622       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;4623   
;;;4624       /* Clear AF flag */
;;;4625       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4626   
;;;4627       /* Disable Acknowledge */
;;;4628       hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
;;;4629   
;;;4630       HAL_I2C_SlaveTxCpltCallback(hi2c);
;;;4631     }
;;;4632     else
;;;4633     {
;;;4634       /* Clear AF flag only */
;;;4635       /* State Listen, but XferOptions == FIRST or NEXT */
;;;4636       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000026  614c              STR      r4,[r1,#0x14]
                  |L67.40|
;;;4637     }
;;;4638     
;;;4639     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;4640   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L67.46|
00002e  62c6              STR      r6,[r0,#0x2c]         ;4596
000030  684a              LDR      r2,[r1,#4]            ;4599
000032  f42262e0          BIC      r2,r2,#0x700          ;4599
000036  604a              STR      r2,[r1,#4]            ;4599
000038  6801              LDR      r1,[r0,#0]            ;4602
00003a  614c              STR      r4,[r1,#0x14]         ;4602
00003c  6801              LDR      r1,[r0,#0]            ;4605
00003e  680a              LDR      r2,[r1,#0]            ;4605
000040  f4226280          BIC      r2,r2,#0x400          ;4605
000044  600a              STR      r2,[r1,#0]            ;4605
000046  6305              STR      r5,[r0,#0x30]         ;4607
000048  f880703d          STRB     r7,[r0,#0x3d]         ;4608
00004c  f880503e          STRB     r5,[r0,#0x3e]         ;4609
000050  f7fffffe          BL       HAL_I2C_ListenCpltCallback
000054  e7e8              B        |L67.40|
                  |L67.86|
000056  62c6              STR      r6,[r0,#0x2c]         ;4616
000058  2221              MOVS     r2,#0x21              ;4617
00005a  6302              STR      r2,[r0,#0x30]         ;4617
00005c  f880703d          STRB     r7,[r0,#0x3d]         ;4618
000060  f880503e          STRB     r5,[r0,#0x3e]         ;4619
000064  684a              LDR      r2,[r1,#4]            ;4622
000066  f42262e0          BIC      r2,r2,#0x700          ;4622
00006a  604a              STR      r2,[r1,#4]            ;4622
00006c  6801              LDR      r1,[r0,#0]            ;4625
00006e  614c              STR      r4,[r1,#0x14]         ;4625
000070  6801              LDR      r1,[r0,#0]            ;4628
000072  680a              LDR      r2,[r1,#0]            ;4628
000074  f4226280          BIC      r2,r2,#0x400          ;4628
000078  600a              STR      r2,[r1,#0]            ;4628
00007a  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
00007e  e7d3              B        |L67.40|
;;;4641   
                          ENDP

                  |L67.128|
                          DCD      0xffff0000

                          AREA ||i.I2C_Slave_STOPF||, CODE, READONLY, ALIGN=2

                  I2C_Slave_STOPF PROC
;;;4498     */
;;;4499   static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
000000  b538              PUSH     {r3-r5,lr}
;;;4500   {
;;;4501     /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
;;;4502     uint32_t CurrentState = hi2c->State;
000002  f890103d          LDRB     r1,[r0,#0x3d]
;;;4503     
;;;4504     /* Disable EVT, BUF and ERR interrupt */
;;;4505     __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000006  6802              LDR      r2,[r0,#0]
000008  6853              LDR      r3,[r2,#4]
00000a  f42363e0          BIC      r3,r3,#0x700
00000e  6053              STR      r3,[r2,#4]
;;;4506   
;;;4507     /* Clear STOPF flag */
;;;4508     __HAL_I2C_CLEAR_STOPFLAG(hi2c);
000010  2300              MOVS     r3,#0
000012  6802              LDR      r2,[r0,#0]
000014  6954              LDR      r4,[r2,#0x14]
000016  9400              STR      r4,[sp,#0]
000018  6814              LDR      r4,[r2,#0]
00001a  f0440401          ORR      r4,r4,#1
00001e  6014              STR      r4,[r2,#0]
;;;4509   
;;;4510     /* Disable Acknowledge */
;;;4511     hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000020  6802              LDR      r2,[r0,#0]
000022  6814              LDR      r4,[r2,#0]
000024  f4246480          BIC      r4,r4,#0x400
000028  6014              STR      r4,[r2,#0]
;;;4512   
;;;4513     /* If a DMA is ongoing, Update handle size context */
;;;4514     if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
00002a  6802              LDR      r2,[r0,#0]
00002c  6854              LDR      r4,[r2,#4]
00002e  0524              LSLS     r4,r4,#20
000030  d50b              BPL      |L68.74|
;;;4515     {
;;;4516       if((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
000032  f890403d          LDRB     r4,[r0,#0x3d]
000036  2c22              CMP      r4,#0x22
000038  d02b              BEQ      |L68.146|
00003a  f890403d          LDRB     r4,[r0,#0x3d]
00003e  2c2a              CMP      r4,#0x2a
000040  d027              BEQ      |L68.146|
;;;4517       {
;;;4518         hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmarx);
;;;4519       }
;;;4520       else
;;;4521       {
;;;4522         hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmatx);
000042  6b44              LDR      r4,[r0,#0x34]
000044  6824              LDR      r4,[r4,#0]
000046  6864              LDR      r4,[r4,#4]
000048  8544              STRH     r4,[r0,#0x2a]
                  |L68.74|
;;;4523       }
;;;4524     }
;;;4525   
;;;4526     /* All data are not transferred, so set error code accordingly */
;;;4527     if(hi2c->XferCount != 0U)
00004a  8d44              LDRH     r4,[r0,#0x2a]
00004c  b1e4              CBZ      r4,|L68.136|
;;;4528     {
;;;4529       /* Store Last receive data if any */
;;;4530       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
00004e  6954              LDR      r4,[r2,#0x14]
000050  43e4              MVNS     r4,r4
000052  0764              LSLS     r4,r4,#29
000054  d407              BMI      |L68.102|
;;;4531       {
;;;4532         /* Read data from DR */
;;;4533         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000056  6914              LDR      r4,[r2,#0x10]
000058  6a42              LDR      r2,[r0,#0x24]
00005a  1c55              ADDS     r5,r2,#1
00005c  6245              STR      r5,[r0,#0x24]
00005e  7014              STRB     r4,[r2,#0]
;;;4534         hi2c->XferCount--;
000060  8d42              LDRH     r2,[r0,#0x2a]
000062  1e52              SUBS     r2,r2,#1
000064  8542              STRH     r2,[r0,#0x2a]
                  |L68.102|
;;;4535       }
;;;4536   
;;;4537       /* Store Last receive data if any */
;;;4538       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
000066  6802              LDR      r2,[r0,#0]
000068  6954              LDR      r4,[r2,#0x14]
00006a  43e4              MVNS     r4,r4
00006c  0664              LSLS     r4,r4,#25
00006e  d407              BMI      |L68.128|
;;;4539       {
;;;4540         /* Read data from DR */
;;;4541         (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
000070  6914              LDR      r4,[r2,#0x10]
000072  6a42              LDR      r2,[r0,#0x24]
000074  1c55              ADDS     r5,r2,#1
000076  6245              STR      r5,[r0,#0x24]
000078  7014              STRB     r4,[r2,#0]
;;;4542         hi2c->XferCount--;
00007a  8d42              LDRH     r2,[r0,#0x2a]
00007c  1e52              SUBS     r2,r2,#1
00007e  8542              STRH     r2,[r0,#0x2a]
                  |L68.128|
;;;4543       }
;;;4544   
;;;4545       /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;4546       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000080  6c02              LDR      r2,[r0,#0x40]
000082  f0420204          ORR      r2,r2,#4
000086  6402              STR      r2,[r0,#0x40]
                  |L68.136|
;;;4547     }
;;;4548   
;;;4549     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
000088  6c02              LDR      r2,[r0,#0x40]
00008a  b13a              CBZ      r2,|L68.156|
;;;4550     {
;;;4551       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4552       I2C_ITError(hi2c);
00008c  f7fffffe          BL       I2C_ITError
000090  e022              B        |L68.216|
                  |L68.146|
000092  6b84              LDR      r4,[r0,#0x38]         ;4518
000094  6824              LDR      r4,[r4,#0]            ;4518
000096  6864              LDR      r4,[r4,#4]            ;4518
000098  8544              STRH     r4,[r0,#0x2a]         ;4518
00009a  e7d6              B        |L68.74|
                  |L68.156|
;;;4553     }
;;;4554     else
;;;4555     {
;;;4556       if((CurrentState == HAL_I2C_STATE_LISTEN ) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN) || \
;;;4557          (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;4558       {
;;;4559         hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;4560         hi2c->PreviousState = I2C_STATE_NONE;
;;;4561         hi2c->State = HAL_I2C_STATE_READY;
00009c  2220              MOVS     r2,#0x20
00009e  2928              CMP      r1,#0x28              ;4556
0000a0  d009              BEQ      |L68.182|
0000a2  292a              CMP      r1,#0x2a              ;4556
0000a4  d007              BEQ      |L68.182|
0000a6  2929              CMP      r1,#0x29              ;4557
0000a8  d005              BEQ      |L68.182|
;;;4562         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4563   
;;;4564         /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4565         HAL_I2C_ListenCpltCallback(hi2c);
;;;4566       }
;;;4567       else
;;;4568       {
;;;4569         if((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
0000aa  6b04              LDR      r4,[r0,#0x30]
0000ac  2c22              CMP      r4,#0x22
0000ae  d00c              BEQ      |L68.202|
0000b0  2922              CMP      r1,#0x22
0000b2  d00a              BEQ      |L68.202|
0000b4  e010              B        |L68.216|
                  |L68.182|
0000b6  4909              LDR      r1,|L68.220|
0000b8  62c1              STR      r1,[r0,#0x2c]         ;4559
0000ba  6303              STR      r3,[r0,#0x30]         ;4560
0000bc  f880203d          STRB     r2,[r0,#0x3d]         ;4561
0000c0  f880303e          STRB     r3,[r0,#0x3e]         ;4562
0000c4  f7fffffe          BL       HAL_I2C_ListenCpltCallback
0000c8  e006              B        |L68.216|
                  |L68.202|
;;;4570         {
;;;4571           hi2c->PreviousState = I2C_STATE_NONE;
0000ca  6303              STR      r3,[r0,#0x30]
;;;4572           hi2c->State = HAL_I2C_STATE_READY;
0000cc  f880203d          STRB     r2,[r0,#0x3d]
;;;4573           hi2c->Mode = HAL_I2C_MODE_NONE;
0000d0  f880303e          STRB     r3,[r0,#0x3e]
;;;4574   
;;;4575           HAL_I2C_SlaveRxCpltCallback(hi2c);
0000d4  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L68.216|
;;;4576         }
;;;4577       }
;;;4578     }
;;;4579     return HAL_OK;
0000d8  2000              MOVS     r0,#0
;;;4580   }
0000da  bd38              POP      {r3-r5,pc}
;;;4581   
                          ENDP

                  |L68.220|
                          DCD      0xffff0000

                          AREA ||i.I2C_WaitOnBTFFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnBTFFlagUntilTimeout PROC
;;;5429     */
;;;5430   static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;5431   {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;5432     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
;;;5433     {
;;;5434       /* Check if a NACK is detected */
;;;5435       if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
;;;5436       {
;;;5437         return HAL_ERROR;
;;;5438       }
;;;5439   
;;;5440       /* Check for the Timeout */
;;;5441       if(Timeout != HAL_MAX_DELAY)
;;;5442       {
;;;5443         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
;;;5444         {
;;;5445           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;5446           hi2c->PreviousState = I2C_STATE_NONE;
;;;5447           hi2c->State= HAL_I2C_STATE_READY;
;;;5448   
;;;5449           /* Process Unlocked */
;;;5450           __HAL_UNLOCK(hi2c);
;;;5451   
;;;5452           return HAL_TIMEOUT;
000008  e019              B        |L69.62|
                  |L69.10|
00000a  4620              MOV      r0,r4                 ;5435
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L69.22|
000012  2001              MOVS     r0,#1                 ;5437
;;;5453         }
;;;5454       }
;;;5455     }
;;;5456     return HAL_OK;
;;;5457   }
000014  bd70              POP      {r4-r6,pc}
                  |L69.22|
000016  1c68              ADDS     r0,r5,#1              ;5441
000018  d011              BEQ      |L69.62|
00001a  b125              CBZ      r5,|L69.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1b80              SUBS     r0,r0,r6              ;5443
000022  42a8              CMP      r0,r5                 ;5443
000024  d90b              BLS      |L69.62|
                  |L69.38|
000026  3430              ADDS     r4,r4,#0x30           ;5445
000028  6920              LDR      r0,[r4,#0x10]         ;5445
00002a  f0400020          ORR      r0,r0,#0x20           ;5445
00002e  6120              STR      r0,[r4,#0x10]         ;5445
000030  2000              MOVS     r0,#0                 ;5446
000032  6020              STR      r0,[r4,#0]            ;5446
000034  2120              MOVS     r1,#0x20              ;5447
000036  7361              STRB     r1,[r4,#0xd]          ;5447
000038  7320              STRB     r0,[r4,#0xc]          ;5450
00003a  2003              MOVS     r0,#3                 ;5452
00003c  bd70              POP      {r4-r6,pc}
                  |L69.62|
00003e  6820              LDR      r0,[r4,#0]            ;5432
000040  6940              LDR      r0,[r0,#0x14]         ;5432
000042  43c0              MVNS     r0,r0                 ;5432
000044  0740              LSLS     r0,r0,#29             ;5432
000046  d4e0              BMI      |L69.10|
000048  2000              MOVS     r0,#0                 ;5456
00004a  bd70              POP      {r4-r6,pc}
;;;5458   
                          ENDP


                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;5310     */
;;;5311   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;5312   {
000004  4605              MOV      r5,r0
000006  f8dda020          LDR      r10,[sp,#0x20]
00000a  460f              MOV      r7,r1
00000c  4691              MOV      r9,r2
00000e  461e              MOV      r6,r3
;;;5313     /* Wait until flag is set */
;;;5314     while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
000010  f3c74807          UBFX     r8,r7,#16,#8
000014  e012              B        |L70.60|
                  |L70.22|
;;;5315     {
;;;5316       /* Check for the Timeout */
;;;5317       if(Timeout != HAL_MAX_DELAY)
000016  1c70              ADDS     r0,r6,#1
000018  d010              BEQ      |L70.60|
;;;5318       {
;;;5319         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
00001a  b12e              CBZ      r6,|L70.40|
00001c  f7fffffe          BL       HAL_GetTick
000020  eba0000a          SUB      r0,r0,r10
000024  42b0              CMP      r0,r6
000026  d909              BLS      |L70.60|
                  |L70.40|
;;;5320         {
;;;5321           hi2c->PreviousState = I2C_STATE_NONE;
000028  2000              MOVS     r0,#0
00002a  f8450f30          STR      r0,[r5,#0x30]!
;;;5322           hi2c->State= HAL_I2C_STATE_READY;
00002e  2120              MOVS     r1,#0x20
000030  7369              STRB     r1,[r5,#0xd]
;;;5323           hi2c->Mode = HAL_I2C_MODE_NONE;
000032  73a8              STRB     r0,[r5,#0xe]
;;;5324   
;;;5325           /* Process Unlocked */
;;;5326           __HAL_UNLOCK(hi2c);
000034  7328              STRB     r0,[r5,#0xc]
;;;5327           
;;;5328           return HAL_TIMEOUT;
000036  2003              MOVS     r0,#3
                  |L70.56|
;;;5329         }
;;;5330       }
;;;5331     }
;;;5332     
;;;5333     return HAL_OK;
;;;5334   }
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L70.60|
00003c  f1b80f01          CMP      r8,#1                 ;5314
000040  d00b              BEQ      |L70.90|
000042  6828              LDR      r0,[r5,#0]            ;5314
000044  6980              LDR      r0,[r0,#0x18]         ;5314
000046  ea270000          BIC      r0,r7,r0              ;5314
00004a  0400              LSLS     r0,r0,#16             ;5314
00004c  0c00              LSRS     r0,r0,#16             ;5314
00004e  d00f              BEQ      |L70.112|
000050  2400              MOVS     r4,#0                 ;5314
                  |L70.82|
000052  454c              CMP      r4,r9                 ;5314
000054  d0df              BEQ      |L70.22|
000056  2000              MOVS     r0,#0                 ;5333
000058  e7ee              B        |L70.56|
                  |L70.90|
00005a  6828              LDR      r0,[r5,#0]            ;5314
00005c  6940              LDR      r0,[r0,#0x14]         ;5314
00005e  ea270000          BIC      r0,r7,r0              ;5314
000062  0400              LSLS     r0,r0,#16             ;5314
000064  0c00              LSRS     r0,r0,#16             ;5314
000066  d001              BEQ      |L70.108|
000068  2400              MOVS     r4,#0                 ;5314
00006a  e7f2              B        |L70.82|
                  |L70.108|
00006c  2401              MOVS     r4,#1                 ;5314
00006e  e7f0              B        |L70.82|
                  |L70.112|
000070  2401              MOVS     r4,#1                 ;5314
000072  e7ee              B        |L70.82|
;;;5335   
                          ENDP


                          AREA ||i.I2C_WaitOnMasterAddressFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnMasterAddressFlagUntilTimeout PROC
;;;5344     */
;;;5345   static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;5346   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;5347     while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
00000c  f04f0900          MOV      r9,#0
;;;5348     {
;;;5349       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
;;;5350       {
;;;5351         /* Generate Stop */
;;;5352         hi2c->Instance->CR1 |= I2C_CR1_STOP;
;;;5353   
;;;5354         /* Clear AF Flag */
;;;5355         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;5356   
;;;5357         hi2c->ErrorCode = HAL_I2C_ERROR_AF;
;;;5358         hi2c->PreviousState = I2C_STATE_NONE;
;;;5359         hi2c->State= HAL_I2C_STATE_READY;
000010  f04f0a20          MOV      r10,#0x20
000014  f3c64707          UBFX     r7,r6,#16,#8          ;5347
000018  e029              B        |L71.110|
                  |L71.26|
00001a  6820              LDR      r0,[r4,#0]            ;5349
00001c  6940              LDR      r0,[r0,#0x14]         ;5349
00001e  43c0              MVNS     r0,r0                 ;5349
000020  0540              LSLS     r0,r0,#21             ;5349
000022  d413              BMI      |L71.76|
000024  6820              LDR      r0,[r4,#0]            ;5352
000026  6801              LDR      r1,[r0,#0]            ;5352
000028  f4417100          ORR      r1,r1,#0x200          ;5352
00002c  6001              STR      r1,[r0,#0]            ;5352
00002e  6821              LDR      r1,[r4,#0]            ;5355
000030  f46f6080          MVN      r0,#0x400             ;5355
000034  6148              STR      r0,[r1,#0x14]         ;5355
000036  2004              MOVS     r0,#4                 ;5357
000038  6420              STR      r0,[r4,#0x40]         ;5357
00003a  f8c49030          STR      r9,[r4,#0x30]         ;5358
00003e  f884a03d          STRB     r10,[r4,#0x3d]
;;;5360   
;;;5361         /* Process Unlocked */
;;;5362         __HAL_UNLOCK(hi2c);
000042  f884903c          STRB     r9,[r4,#0x3c]
;;;5363   
;;;5364         return HAL_ERROR;
000046  2001              MOVS     r0,#1
                  |L71.72|
;;;5365       }
;;;5366   
;;;5367       /* Check for the Timeout */
;;;5368       if(Timeout != HAL_MAX_DELAY)
;;;5369       {
;;;5370         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
;;;5371         {
;;;5372           hi2c->PreviousState = I2C_STATE_NONE;
;;;5373           hi2c->State= HAL_I2C_STATE_READY;
;;;5374   
;;;5375           /* Process Unlocked */
;;;5376           __HAL_UNLOCK(hi2c);
;;;5377   
;;;5378           return HAL_TIMEOUT;
;;;5379         }
;;;5380       }
;;;5381     }
;;;5382     return HAL_OK;
;;;5383   }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L71.76|
00004c  1c68              ADDS     r0,r5,#1              ;5368
00004e  d00e              BEQ      |L71.110|
000050  b12d              CBZ      r5,|L71.94|
000052  f7fffffe          BL       HAL_GetTick
000056  eba00008          SUB      r0,r0,r8              ;5370
00005a  42a8              CMP      r0,r5                 ;5370
00005c  d907              BLS      |L71.110|
                  |L71.94|
00005e  f8c49030          STR      r9,[r4,#0x30]         ;5372
000062  f884a03d          STRB     r10,[r4,#0x3d]        ;5373
000066  f884903c          STRB     r9,[r4,#0x3c]         ;5376
00006a  2003              MOVS     r0,#3                 ;5378
00006c  e7ec              B        |L71.72|
                  |L71.110|
00006e  2f01              CMP      r7,#1                 ;5347
000070  d008              BEQ      |L71.132|
000072  6820              LDR      r0,[r4,#0]            ;5347
000074  6980              LDR      r0,[r0,#0x18]         ;5347
000076  ea260000          BIC      r0,r6,r0              ;5347
00007a  0400              LSLS     r0,r0,#16             ;5347
00007c  0c00              LSRS     r0,r0,#16             ;5347
00007e  d1cc              BNE      |L71.26|
                  |L71.128|
000080  2000              MOVS     r0,#0                 ;5382
000082  e7e1              B        |L71.72|
                  |L71.132|
000084  6820              LDR      r0,[r4,#0]            ;5347
000086  6940              LDR      r0,[r0,#0x14]         ;5347
000088  ea260000          BIC      r0,r6,r0              ;5347
00008c  0400              LSLS     r0,r0,#16             ;5347
00008e  0c00              LSRS     r0,r0,#16             ;5347
000090  d0f6              BEQ      |L71.128|
000092  e7c2              B        |L71.26|
;;;5384   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;5500     */
;;;5501   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5502   {  
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;5503   
;;;5504     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
00000a  2700              MOVS     r7,#0
;;;5505     {
;;;5506       /* Check if a STOPF is detected */
;;;5507       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
;;;5508       {
;;;5509         /* Clear STOP Flag */
;;;5510         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;5511   
;;;5512         hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;5513         hi2c->PreviousState = I2C_STATE_NONE;
;;;5514         hi2c->State= HAL_I2C_STATE_READY;
00000c  f04f0820          MOV      r8,#0x20
000010  e020              B        |L72.84|
                  |L72.18|
000012  6940              LDR      r0,[r0,#0x14]         ;5507
000014  43c0              MVNS     r0,r0                 ;5507
000016  06c0              LSLS     r0,r0,#27             ;5507
000018  d40c              BMI      |L72.52|
00001a  6821              LDR      r1,[r4,#0]            ;5510
00001c  f06f0010          MVN      r0,#0x10              ;5510
000020  6148              STR      r0,[r1,#0x14]         ;5510
000022  6427              STR      r7,[r4,#0x40]         ;5512
000024  6327              STR      r7,[r4,#0x30]         ;5513
000026  f884803d          STRB     r8,[r4,#0x3d]
;;;5515   
;;;5516         /* Process Unlocked */
;;;5517         __HAL_UNLOCK(hi2c);
00002a  f884703c          STRB     r7,[r4,#0x3c]
;;;5518   
;;;5519         return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L72.48|
;;;5520       }
;;;5521   
;;;5522       /* Check for the Timeout */
;;;5523       if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
;;;5524       {
;;;5525         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;5526         hi2c->State= HAL_I2C_STATE_READY;
;;;5527   
;;;5528         /* Process Unlocked */
;;;5529         __HAL_UNLOCK(hi2c);
;;;5530   
;;;5531         return HAL_TIMEOUT;
;;;5532       }
;;;5533     }
;;;5534     return HAL_OK;
;;;5535   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L72.52|
000034  b125              CBZ      r5,|L72.64|
000036  f7fffffe          BL       HAL_GetTick
00003a  1b80              SUBS     r0,r0,r6              ;5523
00003c  42a8              CMP      r0,r5                 ;5523
00003e  d909              BLS      |L72.84|
                  |L72.64|
000040  6c20              LDR      r0,[r4,#0x40]         ;5525
000042  f0400020          ORR      r0,r0,#0x20           ;5525
000046  6420              STR      r0,[r4,#0x40]         ;5525
000048  f884803d          STRB     r8,[r4,#0x3d]         ;5526
00004c  f884703c          STRB     r7,[r4,#0x3c]         ;5529
000050  2003              MOVS     r0,#3                 ;5531
000052  e7ed              B        |L72.48|
                  |L72.84|
000054  6820              LDR      r0,[r4,#0]            ;5504
000056  6941              LDR      r1,[r0,#0x14]         ;5504
000058  43c9              MVNS     r1,r1                 ;5504
00005a  0649              LSLS     r1,r1,#25             ;5504
00005c  d4d9              BMI      |L72.18|
00005e  2000              MOVS     r0,#0                 ;5534
000060  e7e6              B        |L72.48|
;;;5536   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;5466     */
;;;5467   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;5468   {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;5469     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
;;;5470     {
;;;5471       /* Check if a NACK is detected */
;;;5472       if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
;;;5473       {
;;;5474         return HAL_ERROR;
;;;5475       }
;;;5476   
;;;5477       /* Check for the Timeout */
;;;5478       if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
;;;5479       {
;;;5480         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;5481         hi2c->PreviousState = I2C_STATE_NONE;
;;;5482         hi2c->State= HAL_I2C_STATE_READY;
;;;5483   
;;;5484         /* Process Unlocked */
;;;5485         __HAL_UNLOCK(hi2c);
;;;5486   
;;;5487         return HAL_TIMEOUT;
000008  e017              B        |L73.58|
                  |L73.10|
00000a  4620              MOV      r0,r4                 ;5472
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L73.22|
000012  2001              MOVS     r0,#1                 ;5474
;;;5488       }
;;;5489     }
;;;5490     return HAL_OK;
;;;5491   }
000014  bd70              POP      {r4-r6,pc}
                  |L73.22|
000016  b125              CBZ      r5,|L73.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6              ;5478
00001e  42a8              CMP      r0,r5                 ;5478
000020  d90b              BLS      |L73.58|
                  |L73.34|
000022  3430              ADDS     r4,r4,#0x30           ;5480
000024  6920              LDR      r0,[r4,#0x10]         ;5480
000026  f0400020          ORR      r0,r0,#0x20           ;5480
00002a  6120              STR      r0,[r4,#0x10]         ;5480
00002c  2000              MOVS     r0,#0                 ;5481
00002e  6020              STR      r0,[r4,#0]            ;5481
000030  2120              MOVS     r1,#0x20              ;5482
000032  7361              STRB     r1,[r4,#0xd]          ;5482
000034  7320              STRB     r0,[r4,#0xc]          ;5485
000036  2003              MOVS     r0,#3                 ;5487
000038  bd70              POP      {r4-r6,pc}
                  |L73.58|
00003a  6820              LDR      r0,[r4,#0]            ;5469
00003c  6940              LDR      r0,[r0,#0x14]         ;5469
00003e  43c0              MVNS     r0,r0                 ;5469
000040  06c0              LSLS     r0,r0,#27             ;5469
000042  d4e2              BMI      |L73.10|
000044  2000              MOVS     r0,#0                 ;5490
000046  bd70              POP      {r4-r6,pc}
;;;5492   
                          ENDP


                          AREA ||i.I2C_WaitOnTXEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXEFlagUntilTimeout PROC
;;;5392     */
;;;5393   static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;5394   {    
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;5395     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
;;;5396     {
;;;5397       /* Check if a NACK is detected */
;;;5398       if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
;;;5399       {
;;;5400         return HAL_ERROR;
;;;5401       }
;;;5402   		
;;;5403       /* Check for the Timeout */
;;;5404       if(Timeout != HAL_MAX_DELAY)
;;;5405       {
;;;5406         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
;;;5407         {
;;;5408           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;5409           hi2c->PreviousState = I2C_STATE_NONE;
;;;5410           hi2c->State= HAL_I2C_STATE_READY;
;;;5411   
;;;5412           /* Process Unlocked */
;;;5413           __HAL_UNLOCK(hi2c);
;;;5414   
;;;5415           return HAL_TIMEOUT;
000008  e019              B        |L74.62|
                  |L74.10|
00000a  4620              MOV      r0,r4                 ;5398
00000c  f7fffffe          BL       I2C_IsAcknowledgeFailed
000010  b108              CBZ      r0,|L74.22|
000012  2001              MOVS     r0,#1                 ;5400
;;;5416         }
;;;5417       }
;;;5418     }
;;;5419     return HAL_OK;      
;;;5420   }
000014  bd70              POP      {r4-r6,pc}
                  |L74.22|
000016  1c68              ADDS     r0,r5,#1              ;5404
000018  d011              BEQ      |L74.62|
00001a  b125              CBZ      r5,|L74.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1b80              SUBS     r0,r0,r6              ;5406
000022  42a8              CMP      r0,r5                 ;5406
000024  d90b              BLS      |L74.62|
                  |L74.38|
000026  3430              ADDS     r4,r4,#0x30           ;5408
000028  6920              LDR      r0,[r4,#0x10]         ;5408
00002a  f0400020          ORR      r0,r0,#0x20           ;5408
00002e  6120              STR      r0,[r4,#0x10]         ;5408
000030  2000              MOVS     r0,#0                 ;5409
000032  6020              STR      r0,[r4,#0]            ;5409
000034  2120              MOVS     r1,#0x20              ;5410
000036  7361              STRB     r1,[r4,#0xd]          ;5410
000038  7320              STRB     r0,[r4,#0xc]          ;5413
00003a  2003              MOVS     r0,#3                 ;5415
00003c  bd70              POP      {r4-r6,pc}
                  |L74.62|
00003e  6820              LDR      r0,[r4,#0]            ;5395
000040  6940              LDR      r0,[r0,#0x14]         ;5395
000042  43c0              MVNS     r0,r0                 ;5395
000044  0600              LSLS     r0,r0,#24             ;5395
000046  d4e0              BMI      |L74.10|
000048  2000              MOVS     r0,#0                 ;5419
00004a  bd70              POP      {r4-r6,pc}
;;;5421   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REVSH|
#line 456
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____RRX|
#line 643
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
