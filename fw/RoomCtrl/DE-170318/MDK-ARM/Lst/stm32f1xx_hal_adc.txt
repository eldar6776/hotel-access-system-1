; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_adc.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_adc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_adc.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_ConversionStop_Disable||, CODE, READONLY, ALIGN=1

                  ADC_ConversionStop_Disable PROC
;;;1988     */
;;;1989   HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1990   {
000002  4604              MOV      r4,r0
;;;1991     uint32_t tickstart = 0U;
;;;1992     
;;;1993     /* Verification if ADC is not already disabled */
;;;1994     if (ADC_IS_ENABLE(hadc) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6881              LDR      r1,[r0,#8]
000008  43c9              MVNS     r1,r1
00000a  07c9              LSLS     r1,r1,#31
00000c  d11b              BNE      |L1.70|
;;;1995     {
;;;1996       /* Disable the ADC peripheral */
;;;1997       __HAL_ADC_DISABLE(hadc);
00000e  6881              LDR      r1,[r0,#8]
000010  f0210101          BIC      r1,r1,#1
000014  6081              STR      r1,[r0,#8]
;;;1998        
;;;1999       /* Get tick count */
;;;2000       tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4605              MOV      r5,r0
;;;2001       
;;;2002       /* Wait for ADC effectively disabled */
;;;2003       while(ADC_IS_ENABLE(hadc) != RESET)
00001c  e00e              B        |L1.60|
                  |L1.30|
;;;2004       {
;;;2005         if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
00001e  f7fffffe          BL       HAL_GetTick
000022  1b40              SUBS     r0,r0,r5
000024  2802              CMP      r0,#2
000026  d909              BLS      |L1.60|
;;;2006         {
;;;2007           /* Update ADC state machine to error */
;;;2008           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000028  6aa0              LDR      r0,[r4,#0x28]
00002a  f0400010          ORR      r0,r0,#0x10
00002e  62a0              STR      r0,[r4,#0x28]
;;;2009           
;;;2010           /* Set ADC error code to ADC IP internal error */
;;;2011           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  f0400001          ORR      r0,r0,#1
000036  62e0              STR      r0,[r4,#0x2c]
;;;2012           
;;;2013           return HAL_ERROR;
000038  2001              MOVS     r0,#1
;;;2014         }
;;;2015       }
;;;2016     }
;;;2017     
;;;2018     /* Return HAL status */
;;;2019     return HAL_OK;
;;;2020   }
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  6820              LDR      r0,[r4,#0]            ;2003
00003e  6880              LDR      r0,[r0,#8]            ;2003
000040  43c0              MVNS     r0,r0                 ;2003
000042  07c0              LSLS     r0,r0,#31             ;2003
000044  d0eb              BEQ      |L1.30|
                  |L1.70|
000046  2000              MOVS     r0,#0                 ;2019
000048  bd70              POP      {r4-r6,pc}
;;;2021   
                          ENDP


                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;2026     */
;;;2027   void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2028   {
000002  4601              MOV      r1,r0
;;;2029     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2030     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2031    
;;;2032     /* Update state machine on conversion status if not in error state */
;;;2033     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
000006  6a82              LDR      r2,[r0,#0x28]
000008  f0120f50          TST      r2,#0x50
00000c  d005              BEQ      |L2.26|
;;;2034     {
;;;2035       /* Update ADC state machine */
;;;2036       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;2037       
;;;2038       /* Determine whether any further conversion upcoming on group regular     */
;;;2039       /* by external trigger, continuous mode or scan sequence on going.        */
;;;2040       /* Note: On STM32F1 devices, in case of sequencer enabled                 */
;;;2041       /*       (several ranks selected), end of conversion flag is raised       */
;;;2042       /*       at the end of the sequence.                                      */
;;;2043       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;2044          (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;2045       {
;;;2046         /* Set ADC state */
;;;2047         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;2048         
;;;2049         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;2050         {
;;;2051           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;2052         }
;;;2053       }
;;;2054       
;;;2055       /* Conversion complete callback */
;;;2056       HAL_ADC_ConvCpltCallback(hadc); 
;;;2057     }
;;;2058     else
;;;2059     {
;;;2060       /* Call DMA error callback */
;;;2061       hadc->DMA_Handle->XferErrorCallback(hdma);
00000e  6a00              LDR      r0,[r0,#0x20]
000010  6b02              LDR      r2,[r0,#0x30]
000012  e8bd4010          POP      {r4,lr}
000016  4608              MOV      r0,r1
000018  4710              BX       r2
                  |L2.26|
00001a  6a81              LDR      r1,[r0,#0x28]         ;2036
00001c  f4417100          ORR      r1,r1,#0x200          ;2036
000020  6281              STR      r1,[r0,#0x28]         ;2036
000022  6801              LDR      r1,[r0,#0]            ;2043
000024  6889              LDR      r1,[r1,#8]            ;2043
000026  f3c14142          UBFX     r1,r1,#17,#3          ;2043
00002a  2907              CMP      r1,#7                 ;2043
00002c  d10c              BNE      |L2.72|
00002e  68c1              LDR      r1,[r0,#0xc]          ;2044
000030  b951              CBNZ     r1,|L2.72|
000032  6a81              LDR      r1,[r0,#0x28]         ;2047
000034  f4217180          BIC      r1,r1,#0x100          ;2047
000038  6281              STR      r1,[r0,#0x28]         ;2047
00003a  6a81              LDR      r1,[r0,#0x28]         ;2049
00003c  04c9              LSLS     r1,r1,#19             ;2049
00003e  d403              BMI      |L2.72|
000040  6a81              LDR      r1,[r0,#0x28]         ;2051
000042  f0410101          ORR      r1,r1,#1              ;2051
000046  6281              STR      r1,[r0,#0x28]         ;2051
                  |L2.72|
000048  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;2062     }
;;;2063   }
00004c  bd10              POP      {r4,pc}
;;;2064   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;2083     */
;;;2084   void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;2085   {
;;;2086     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2087     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2088     
;;;2089     /* Set ADC state */
;;;2090     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
000004  6a81              LDR      r1,[r0,#0x28]
000006  f0410140          ORR      r1,r1,#0x40
00000a  6281              STR      r1,[r0,#0x28]
;;;2091     
;;;2092     /* Set ADC error code to DMA error */
;;;2093     SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
00000c  6ac1              LDR      r1,[r0,#0x2c]
00000e  f0410104          ORR      r1,r1,#4
000012  62c1              STR      r1,[r0,#0x2c]
;;;2094     
;;;2095     /* Error callback */
;;;2096     HAL_ADC_ErrorCallback(hadc); 
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2097   }
000018  bd10              POP      {r4,pc}
;;;2098   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;2069     */
;;;2070   void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;2071   {
;;;2072     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2073     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2074     
;;;2075     /* Half conversion callback */
;;;2076     HAL_ADC_ConvHalfCpltCallback(hadc); 
000004  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2077   }
000008  bd10              POP      {r4,pc}
;;;2078   
                          ENDP


                          AREA ||i.ADC_Enable||, CODE, READONLY, ALIGN=2

                  ADC_Enable PROC
;;;1933     */
;;;1934   HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1935   {
000002  4604              MOV      r4,r0
;;;1936     uint32_t tickstart = 0U;
;;;1937     __IO uint32_t wait_loop_index = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;1938     
;;;1939     /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
;;;1940     /* enabling phase not yet completed: flag ADC ready not yet set).           */
;;;1941     /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
;;;1942     /* causes: ADC clock not running, ...).                                     */
;;;1943     if (ADC_IS_ENABLE(hadc) == RESET)
000008  6820              LDR      r0,[r4,#0]
00000a  6881              LDR      r1,[r0,#8]
00000c  43c9              MVNS     r1,r1
00000e  07c9              LSLS     r1,r1,#31
000010  d02a              BEQ      |L5.104|
;;;1944     {
;;;1945       /* Enable the Peripheral */
;;;1946       __HAL_ADC_ENABLE(hadc);
000012  6881              LDR      r1,[r0,#8]
000014  f0410101          ORR      r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;1947       
;;;1948       /* Delay for ADC stabilization time */
;;;1949       /* Compute number of CPU cycles to wait for */
;;;1950       wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
00001a  4814              LDR      r0,|L5.108|
00001c  4914              LDR      r1,|L5.112|
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  fbb0f0f1          UDIV     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;1951       while(wait_loop_index != 0U)
000026  e002              B        |L5.46|
                  |L5.40|
;;;1952       {
;;;1953         wait_loop_index--;
000028  9800              LDR      r0,[sp,#0]
00002a  1e40              SUBS     r0,r0,#1
00002c  9000              STR      r0,[sp,#0]
                  |L5.46|
00002e  9800              LDR      r0,[sp,#0]            ;1951
000030  2800              CMP      r0,#0                 ;1951
000032  d1f9              BNE      |L5.40|
;;;1954       }
;;;1955       
;;;1956       /* Get tick count */
;;;1957       tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
000038  4605              MOV      r5,r0
;;;1958   
;;;1959       /* Wait for ADC effectively enabled */
;;;1960       while(ADC_IS_ENABLE(hadc) == RESET)
00003a  e010              B        |L5.94|
                  |L5.60|
;;;1961       {
;;;1962         if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
00003c  f7fffffe          BL       HAL_GetTick
000040  1b40              SUBS     r0,r0,r5
000042  2802              CMP      r0,#2
000044  d90b              BLS      |L5.94|
;;;1963         {
;;;1964           /* Update ADC state machine to error */
;;;1965           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f0400010          ORR      r0,r0,#0x10
00004c  62a0              STR      r0,[r4,#0x28]
;;;1966         
;;;1967           /* Set ADC error code to ADC IP internal error */
;;;1968           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f0400001          ORR      r0,r0,#1
000054  62e0              STR      r0,[r4,#0x2c]
;;;1969           
;;;1970           /* Process unlocked */
;;;1971           __HAL_UNLOCK(hadc);
000056  f8846024          STRB     r6,[r4,#0x24]
;;;1972         
;;;1973           return HAL_ERROR;
00005a  2001              MOVS     r0,#1
;;;1974         }
;;;1975       }
;;;1976     }
;;;1977      
;;;1978     /* Return HAL status */
;;;1979     return HAL_OK;
;;;1980   }
00005c  bdf8              POP      {r3-r7,pc}
                  |L5.94|
00005e  6820              LDR      r0,[r4,#0]            ;1960
000060  6880              LDR      r0,[r0,#8]            ;1960
000062  43c0              MVNS     r0,r0                 ;1960
000064  07c0              LSLS     r0,r0,#31             ;1960
000066  d1e9              BNE      |L5.60|
                  |L5.104|
000068  2000              MOVS     r0,#0                 ;1979
00006a  bdf8              POP      {r3-r7,pc}
;;;1981   
                          ENDP

                  |L5.108|
                          DCD      SystemCoreClock
                  |L5.112|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1811     */
;;;1812   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;1813   {
;;;1814     /* Check the parameters */
;;;1815     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1816     assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
;;;1817     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1818     assert_param(IS_ADC_RANGE(AnalogWDGConfig->HighThreshold));
;;;1819     assert_param(IS_ADC_RANGE(AnalogWDGConfig->LowThreshold));
;;;1820     
;;;1821     if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
000002  4b19              LDR      r3,|L6.104|
000004  680a              LDR      r2,[r1,#0]
000006  429a              CMP      r2,r3
000008  d003              BEQ      |L6.18|
;;;1822        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
00000a  4b18              LDR      r3,|L6.108|
00000c  429a              CMP      r2,r3
00000e  d000              BEQ      |L6.18|
;;;1823        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
000010  4b17              LDR      r3,|L6.112|
                  |L6.18|
;;;1824     {
;;;1825       assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;1826     }
;;;1827     
;;;1828     /* Process locked */
;;;1829     __HAL_LOCK(hadc);
000012  f8902024          LDRB     r2,[r0,#0x24]
000016  2a01              CMP      r2,#1
000018  d01e              BEQ      |L6.88|
00001a  2201              MOVS     r2,#1
00001c  f8802024          STRB     r2,[r0,#0x24]
;;;1830     
;;;1831     /* Analog watchdog configuration */
;;;1832   
;;;1833     /* Configure ADC Analog watchdog interrupt */
;;;1834     if(AnalogWDGConfig->ITMode == ENABLE)
000020  688a              LDR      r2,[r1,#8]
000022  2a01              CMP      r2,#1
000024  d01a              BEQ      |L6.92|
;;;1835     {
;;;1836       /* Enable the ADC Analog watchdog interrupt */
;;;1837       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1838     }
;;;1839     else
;;;1840     {
;;;1841       /* Disable the ADC Analog watchdog interrupt */
;;;1842       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
000026  6802              LDR      r2,[r0,#0]
000028  6853              LDR      r3,[r2,#4]
00002a  f0230340          BIC      r3,r3,#0x40
00002e  6053              STR      r3,[r2,#4]
                  |L6.48|
;;;1843     }
;;;1844     
;;;1845     /* Configuration of analog watchdog:                                        */
;;;1846     /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
;;;1847     /*    one or all channels.                                                  */
;;;1848     /*  - Set the Analog watchdog channel (is not used if watchdog              */
;;;1849     /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
;;;1850     MODIFY_REG(hadc->Instance->CR1            ,
000030  e9d13200          LDRD     r3,r2,[r1,#0]
000034  4313              ORRS     r3,r3,r2
000036  6802              LDR      r2,[r0,#0]
000038  6854              LDR      r4,[r2,#4]
00003a  4d0e              LDR      r5,|L6.116|
00003c  402c              ANDS     r4,r4,r5
00003e  4323              ORRS     r3,r3,r4
000040  6053              STR      r3,[r2,#4]
;;;1851                ADC_CR1_AWDSGL |
;;;1852                ADC_CR1_JAWDEN |
;;;1853                ADC_CR1_AWDEN  |
;;;1854                ADC_CR1_AWDCH                  ,
;;;1855                AnalogWDGConfig->WatchdogMode |
;;;1856                AnalogWDGConfig->Channel        );
;;;1857     
;;;1858     /* Set the high threshold */
;;;1859     WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
000042  6803              LDR      r3,[r0,#0]
000044  68ca              LDR      r2,[r1,#0xc]
000046  625a              STR      r2,[r3,#0x24]
;;;1860     
;;;1861     /* Set the low threshold */
;;;1862     WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
000048  6802              LDR      r2,[r0,#0]
00004a  6909              LDR      r1,[r1,#0x10]
00004c  6291              STR      r1,[r2,#0x28]
;;;1863   
;;;1864     /* Process unlocked */
;;;1865     __HAL_UNLOCK(hadc);
00004e  2100              MOVS     r1,#0
000050  f8801024          STRB     r1,[r0,#0x24]
;;;1866     
;;;1867     /* Return function status */
;;;1868     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1869   }
000056  bd30              POP      {r4,r5,pc}
                  |L6.88|
000058  2002              MOVS     r0,#2                 ;1829
00005a  bd30              POP      {r4,r5,pc}
                  |L6.92|
00005c  6802              LDR      r2,[r0,#0]            ;1837
00005e  6853              LDR      r3,[r2,#4]            ;1837
000060  f0430340          ORR      r3,r3,#0x40           ;1837
000064  6053              STR      r3,[r2,#4]            ;1837
000066  e7e3              B        |L6.48|
;;;1870   
                          ENDP

                  |L6.104|
                          DCD      0x00800200
                  |L6.108|
                          DCD      0x00400200
                  |L6.112|
                          DCD      0x00c00200
                  |L6.116|
                          DCD      0xff3ffde0

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1701     */
;;;1702   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1703   { 
;;;1704     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1705     __IO uint32_t wait_loop_index = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;1706     
;;;1707     /* Check the parameters */
;;;1708     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1709     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1710     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;1711     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;1712     
;;;1713     /* Process locked */
;;;1714     __HAL_LOCK(hadc);
000008  f8902024          LDRB     r2,[r0,#0x24]
00000c  2a01              CMP      r2,#1
00000e  d012              BEQ      |L7.54|
000010  2201              MOVS     r2,#1
000012  f8802024          STRB     r2,[r0,#0x24]
;;;1715     
;;;1716     
;;;1717     /* Regular sequence configuration */
;;;1718     /* For Rank 1 to 6 */
;;;1719     if (sConfig->Rank < 7U)
000016  684a              LDR      r2,[r1,#4]
;;;1720     {
;;;1721       MODIFY_REG(hadc->Instance->SQR3                        ,
000018  261f              MOVS     r6,#0x1f
00001a  2a07              CMP      r2,#7                 ;1719
00001c  d20d              BCS      |L7.58|
00001e  6804              LDR      r4,[r0,#0]
000020  6b67              LDR      r7,[r4,#0x34]
000022  1e52              SUBS     r2,r2,#1
000024  eb020282          ADD      r2,r2,r2,LSL #2
000028  4096              LSLS     r6,r6,r2
00002a  43b7              BICS     r7,r7,r6
00002c  680e              LDR      r6,[r1,#0]
00002e  4096              LSLS     r6,r6,r2
000030  4337              ORRS     r7,r7,r6
000032  6367              STR      r7,[r4,#0x34]
000034  e01a              B        |L7.108|
                  |L7.54|
000036  2002              MOVS     r0,#2                 ;1714
;;;1722                  ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
;;;1723                  ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
;;;1724     }
;;;1725     /* For Rank 7 to 12 */
;;;1726     else if (sConfig->Rank < 13U)
;;;1727     {
;;;1728       MODIFY_REG(hadc->Instance->SQR2                        ,
;;;1729                  ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank)    ,
;;;1730                  ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
;;;1731     }
;;;1732     /* For Rank 13 to 16 */
;;;1733     else
;;;1734     {
;;;1735       MODIFY_REG(hadc->Instance->SQR1                        ,
;;;1736                  ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank)   ,
;;;1737                  ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
;;;1738     }
;;;1739     
;;;1740     
;;;1741     /* Channel sampling time configuration */
;;;1742     /* For channels 10 to 17 */
;;;1743     if (sConfig->Channel >= ADC_CHANNEL_10)
;;;1744     {
;;;1745       MODIFY_REG(hadc->Instance->SMPR1                             ,
;;;1746                  ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
;;;1747                  ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
;;;1748     }
;;;1749     else /* For channels 0 to 9 */
;;;1750     {
;;;1751       MODIFY_REG(hadc->Instance->SMPR2                             ,
;;;1752                  ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel)       ,
;;;1753                  ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
;;;1754     }
;;;1755     
;;;1756     /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
;;;1757     /* and VREFINT measurement path.                                            */
;;;1758     if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1759         (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
;;;1760     {
;;;1761       /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
;;;1762       /* measurement channels (VrefInt/TempSensor). If these channels are       */
;;;1763       /* intended to be set on other ADC instances, an error is reported.       */
;;;1764       if (hadc->Instance == ADC1)
;;;1765       {
;;;1766         if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
;;;1767         {
;;;1768           SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1769           
;;;1770           if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
;;;1771           {
;;;1772             /* Delay for temperature sensor stabilization time */
;;;1773             /* Compute number of CPU cycles to wait for */
;;;1774             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1775             while(wait_loop_index != 0U)
;;;1776             {
;;;1777               wait_loop_index--;
;;;1778             }
;;;1779           }
;;;1780         }
;;;1781       }
;;;1782       else
;;;1783       {
;;;1784         /* Update ADC state machine to error */
;;;1785         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1786         
;;;1787         tmp_hal_status = HAL_ERROR;
;;;1788       }
;;;1789     }
;;;1790     
;;;1791     /* Process unlocked */
;;;1792     __HAL_UNLOCK(hadc);
;;;1793     
;;;1794     /* Return function status */
;;;1795     return tmp_hal_status;
;;;1796   }
000038  bdf8              POP      {r3-r7,pc}
                  |L7.58|
00003a  2a0d              CMP      r2,#0xd               ;1726
00003c  d20b              BCS      |L7.86|
00003e  6804              LDR      r4,[r0,#0]            ;1728
000040  6b27              LDR      r7,[r4,#0x30]         ;1728
000042  1fd2              SUBS     r2,r2,#7              ;1728
000044  eb020282          ADD      r2,r2,r2,LSL #2       ;1728
000048  4096              LSLS     r6,r6,r2              ;1728
00004a  43b7              BICS     r7,r7,r6              ;1728
00004c  680e              LDR      r6,[r1,#0]            ;1728
00004e  4096              LSLS     r6,r6,r2              ;1728
000050  4337              ORRS     r7,r7,r6              ;1728
000052  6327              STR      r7,[r4,#0x30]         ;1728
000054  e00a              B        |L7.108|
                  |L7.86|
000056  6804              LDR      r4,[r0,#0]            ;1735
000058  6ae7              LDR      r7,[r4,#0x2c]         ;1735
00005a  3a0d              SUBS     r2,r2,#0xd            ;1735
00005c  eb020282          ADD      r2,r2,r2,LSL #2       ;1735
000060  4096              LSLS     r6,r6,r2              ;1735
000062  43b7              BICS     r7,r7,r6              ;1735
000064  680e              LDR      r6,[r1,#0]            ;1735
000066  4096              LSLS     r6,r6,r2              ;1735
000068  4337              ORRS     r7,r7,r6              ;1735
00006a  62e7              STR      r7,[r4,#0x2c]         ;1735
                  |L7.108|
00006c  680a              LDR      r2,[r1,#0]            ;1743
00006e  2607              MOVS     r6,#7                 ;1745
000070  2a0a              CMP      r2,#0xa               ;1743
000072  d30b              BCC      |L7.140|
000074  6804              LDR      r4,[r0,#0]            ;1745
000076  68e7              LDR      r7,[r4,#0xc]          ;1745
000078  3a0a              SUBS     r2,r2,#0xa            ;1745
00007a  eb020242          ADD      r2,r2,r2,LSL #1       ;1745
00007e  4096              LSLS     r6,r6,r2              ;1745
000080  43b7              BICS     r7,r7,r6              ;1745
000082  688e              LDR      r6,[r1,#8]            ;1745
000084  4096              LSLS     r6,r6,r2              ;1745
000086  4337              ORRS     r7,r7,r6              ;1745
000088  60e7              STR      r7,[r4,#0xc]          ;1745
00008a  e009              B        |L7.160|
                  |L7.140|
00008c  6804              LDR      r4,[r0,#0]            ;1751
00008e  6927              LDR      r7,[r4,#0x10]         ;1751
000090  eb020242          ADD      r2,r2,r2,LSL #1       ;1751
000094  4096              LSLS     r6,r6,r2              ;1751
000096  43b7              BICS     r7,r7,r6              ;1751
000098  688e              LDR      r6,[r1,#8]            ;1751
00009a  4096              LSLS     r6,r6,r2              ;1751
00009c  4337              ORRS     r7,r7,r6              ;1751
00009e  6127              STR      r7,[r4,#0x10]         ;1751
                  |L7.160|
0000a0  680a              LDR      r2,[r1,#0]            ;1758
0000a2  2a10              CMP      r2,#0x10              ;1758
0000a4  d001              BEQ      |L7.170|
0000a6  2a11              CMP      r2,#0x11              ;1759
0000a8  d123              BNE      |L7.242|
                  |L7.170|
0000aa  4c14              LDR      r4,|L7.252|
0000ac  6802              LDR      r2,[r0,#0]            ;1764
0000ae  42a2              CMP      r2,r4                 ;1764
0000b0  d11a              BNE      |L7.232|
0000b2  6894              LDR      r4,[r2,#8]            ;1766
0000b4  0224              LSLS     r4,r4,#8              ;1766
0000b6  d41c              BMI      |L7.242|
0000b8  6894              LDR      r4,[r2,#8]            ;1768
0000ba  f4440400          ORR      r4,r4,#0x800000       ;1768
0000be  6094              STR      r4,[r2,#8]            ;1768
0000c0  6809              LDR      r1,[r1,#0]            ;1770
0000c2  2910              CMP      r1,#0x10              ;1770
0000c4  d115              BNE      |L7.242|
0000c6  490e              LDR      r1,|L7.256|
0000c8  4a0e              LDR      r2,|L7.260|
0000ca  6809              LDR      r1,[r1,#0]            ;1774  ; SystemCoreClock
0000cc  fbb1f1f2          UDIV     r1,r1,r2              ;1774
0000d0  eb010181          ADD      r1,r1,r1,LSL #2       ;1774
0000d4  0049              LSLS     r1,r1,#1              ;1774
0000d6  9100              STR      r1,[sp,#0]            ;1774
0000d8  e002              B        |L7.224|
                  |L7.218|
0000da  9900              LDR      r1,[sp,#0]            ;1777
0000dc  1e49              SUBS     r1,r1,#1              ;1777
0000de  9100              STR      r1,[sp,#0]            ;1777
                  |L7.224|
0000e0  9900              LDR      r1,[sp,#0]            ;1775
0000e2  2900              CMP      r1,#0                 ;1775
0000e4  d1f9              BNE      |L7.218|
0000e6  e004              B        |L7.242|
                  |L7.232|
0000e8  6a81              LDR      r1,[r0,#0x28]         ;1785
0000ea  f0410120          ORR      r1,r1,#0x20           ;1785
0000ee  6281              STR      r1,[r0,#0x28]         ;1785
0000f0  2301              MOVS     r3,#1                 ;1787
                  |L7.242|
0000f2  f8805024          STRB     r5,[r0,#0x24]         ;1792
0000f6  4618              MOV      r0,r3                 ;1795
0000f8  bdf8              POP      {r3-r7,pc}
;;;1797   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L7.252|
                          DCD      0x40012400
                  |L7.256|
                          DCD      SystemCoreClock
                  |L7.260|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;1610     */
;;;1611   __WEAK void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1612   {
;;;1613     /* Prevent unused argument(s) compilation warning */
;;;1614     UNUSED(hadc);
;;;1615     /* NOTE : This function should not be modified. When the callback is needed,
;;;1616               function HAL_ADC_ConvCpltCallback must be implemented in the user file.
;;;1617      */
;;;1618   }
;;;1619   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1624     */
;;;1625   __WEAK void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1626   {
;;;1627     /* Prevent unused argument(s) compilation warning */
;;;1628     UNUSED(hadc);
;;;1629     /* NOTE : This function should not be modified. When the callback is needed,
;;;1630               function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;1631     */
;;;1632   }
;;;1633   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_ADC_DeInit PROC
;;;574      */
;;;575    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;576    {
000002  4604              MOV      r4,r0
;;;577      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;578      
;;;579      /* Check ADC handle */
;;;580      if(hadc == NULL)
000004  2c00              CMP      r4,#0
000006  d00a              BEQ      |L10.30|
;;;581      {
;;;582         return HAL_ERROR;
;;;583      }
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;587      
;;;588      /* Set ADC state */
;;;589      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  f0400002          ORR      r0,r0,#2
00000e  62a0              STR      r0,[r4,#0x28]
;;;590      
;;;591      /* Stop potential conversion on going, on regular and injected groups */
;;;592      /* Disable ADC peripheral */
;;;593      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       ADC_ConversionStop_Disable
000016  4605              MOV      r5,r0
;;;594      
;;;595      
;;;596      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;597      /* correctly completed.                                                     */
;;;598      if (tmp_hal_status == HAL_OK)
000018  2600              MOVS     r6,#0
00001a  b115              CBZ      r5,|L10.34|
00001c  e05a              B        |L10.212|
                  |L10.30|
00001e  2001              MOVS     r0,#1                 ;582
;;;599      {
;;;600        /* ========== Reset ADC registers ========== */
;;;601    
;;;602    
;;;603    
;;;604    
;;;605        /* Reset register SR */
;;;606        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
;;;607                                    ADC_FLAG_JSTRT | ADC_FLAG_STRT));
;;;608                             
;;;609        /* Reset register CR1 */
;;;610        CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
;;;611                                        ADC_CR1_JDISCEN | ADC_CR1_DISCEN | ADC_CR1_JAUTO   | 
;;;612                                        ADC_CR1_AWDSGL  | ADC_CR1_SCAN   | ADC_CR1_JEOCIE  |   
;;;613                                        ADC_CR1_AWDIE   | ADC_CR1_EOCIE  | ADC_CR1_AWDCH    ));
;;;614        
;;;615        /* Reset register CR2 */
;;;616        CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
;;;617                                        ADC_CR2_EXTTRIG | ADC_CR2_EXTSEL  | ADC_CR2_JEXTTRIG |  
;;;618                                        ADC_CR2_JEXTSEL | ADC_CR2_ALIGN   | ADC_CR2_DMA      |        
;;;619                                        ADC_CR2_RSTCAL  | ADC_CR2_CAL     | ADC_CR2_CONT     |          
;;;620                                        ADC_CR2_ADON                                          ));
;;;621        
;;;622        /* Reset register SMPR1 */
;;;623        CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
;;;624                                          ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP12 | 
;;;625                                          ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10                    ));
;;;626        
;;;627        /* Reset register SMPR2 */
;;;628        CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
;;;629                                          ADC_SMPR2_SMP6 | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | 
;;;630                                          ADC_SMPR2_SMP3 | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | 
;;;631                                          ADC_SMPR2_SMP0                                    ));
;;;632    
;;;633        /* Reset register JOFR1 */
;;;634        CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
;;;635        /* Reset register JOFR2 */
;;;636        CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
;;;637        /* Reset register JOFR3 */
;;;638        CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
;;;639        /* Reset register JOFR4 */
;;;640        CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
;;;641        
;;;642        /* Reset register HTR */
;;;643        CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
;;;644        /* Reset register LTR */
;;;645        CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
;;;646        
;;;647        /* Reset register SQR1 */
;;;648        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;649                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;650                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;651        
;;;652        /* Reset register SQR1 */
;;;653        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;654                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;655                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;656        
;;;657        /* Reset register SQR2 */
;;;658        CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
;;;659                                        ADC_SQR2_SQ9  | ADC_SQR2_SQ8  | ADC_SQR2_SQ7   );
;;;660        
;;;661        /* Reset register SQR3 */
;;;662        CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
;;;663                                        ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1  );
;;;664        
;;;665        /* Reset register JSQR */
;;;666        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;667                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;668                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;669        
;;;670        /* Reset register JSQR */
;;;671        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;672                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;673                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;674        
;;;675        /* Reset register DR */
;;;676        /* bits in access mode read only, no direct reset applicable*/
;;;677        
;;;678        /* Reset registers JDR1, JDR2, JDR3, JDR4 */
;;;679        /* bits in access mode read only, no direct reset applicable*/
;;;680        
;;;681        /* ========== Hard reset ADC peripheral ========== */
;;;682        /* Performs a global reset of the entire ADC peripheral: ADC state is     */
;;;683        /* forced to a similar state after device power-on.                       */
;;;684        /* If needed, copy-paste and uncomment the following reset code into      */
;;;685        /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
;;;686        /*                                                                        */
;;;687        /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
;;;688        /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
;;;689        
;;;690        /* DeInit the low level hardware */
;;;691        HAL_ADC_MspDeInit(hadc);
;;;692        
;;;693        /* Set ADC error code to none */
;;;694        ADC_CLEAR_ERRORCODE(hadc);
;;;695        
;;;696        /* Set ADC state */
;;;697        hadc->State = HAL_ADC_STATE_RESET; 
;;;698      
;;;699      }
;;;700      
;;;701      /* Process unlocked */
;;;702      __HAL_UNLOCK(hadc);
;;;703      
;;;704      /* Return function status */
;;;705      return tmp_hal_status;
;;;706    }
000020  bd70              POP      {r4-r6,pc}
                  |L10.34|
000022  6821              LDR      r1,[r4,#0]            ;606
000024  f06f001f          MVN      r0,#0x1f              ;606
000028  6008              STR      r0,[r1,#0]            ;606
00002a  6820              LDR      r0,[r4,#0]            ;610
00002c  6841              LDR      r1,[r0,#4]            ;610
00002e  4a2b              LDR      r2,|L10.220|
000030  4011              ANDS     r1,r1,r2              ;610
000032  6041              STR      r1,[r0,#4]            ;610
000034  6820              LDR      r0,[r4,#0]            ;616
000036  6881              LDR      r1,[r0,#8]            ;616
000038  4a29              LDR      r2,|L10.224|
00003a  4011              ANDS     r1,r1,r2              ;616
00003c  6081              STR      r1,[r0,#8]            ;616
00003e  6820              LDR      r0,[r4,#0]            ;623
000040  68c1              LDR      r1,[r0,#0xc]          ;623
000042  f001417f          AND      r1,r1,#0xff000000     ;623
000046  60c1              STR      r1,[r0,#0xc]          ;623
000048  6820              LDR      r0,[r4,#0]            ;628
00004a  6901              LDR      r1,[r0,#0x10]         ;628
00004c  f0014140          AND      r1,r1,#0xc0000000     ;628
000050  6101              STR      r1,[r0,#0x10]         ;628
000052  6820              LDR      r0,[r4,#0]            ;634
000054  6941              LDR      r1,[r0,#0x14]         ;634
000056  f36f010b          BFC      r1,#0,#12             ;634
00005a  6141              STR      r1,[r0,#0x14]         ;634
00005c  6820              LDR      r0,[r4,#0]            ;636
00005e  6981              LDR      r1,[r0,#0x18]         ;636
000060  f36f010b          BFC      r1,#0,#12             ;636
000064  6181              STR      r1,[r0,#0x18]         ;636
000066  6820              LDR      r0,[r4,#0]            ;638
000068  69c1              LDR      r1,[r0,#0x1c]         ;638
00006a  f36f010b          BFC      r1,#0,#12             ;638
00006e  61c1              STR      r1,[r0,#0x1c]         ;638
000070  6820              LDR      r0,[r4,#0]            ;640
000072  6a01              LDR      r1,[r0,#0x20]         ;640
000074  f36f010b          BFC      r1,#0,#12             ;640
000078  6201              STR      r1,[r0,#0x20]         ;640
00007a  6820              LDR      r0,[r4,#0]            ;643
00007c  6a41              LDR      r1,[r0,#0x24]         ;643
00007e  f36f010b          BFC      r1,#0,#12             ;643
000082  6241              STR      r1,[r0,#0x24]         ;643
000084  6820              LDR      r0,[r4,#0]            ;645
000086  6a81              LDR      r1,[r0,#0x28]         ;645
000088  f36f010b          BFC      r1,#0,#12             ;645
00008c  6281              STR      r1,[r0,#0x28]         ;645
00008e  6820              LDR      r0,[r4,#0]            ;648
000090  6ac1              LDR      r1,[r0,#0x2c]         ;648
000092  f001417f          AND      r1,r1,#0xff000000     ;648
000096  62c1              STR      r1,[r0,#0x2c]         ;648
000098  6820              LDR      r0,[r4,#0]            ;653
00009a  6ac1              LDR      r1,[r0,#0x2c]         ;653
00009c  f001417f          AND      r1,r1,#0xff000000     ;653
0000a0  62c1              STR      r1,[r0,#0x2c]         ;653
0000a2  6820              LDR      r0,[r4,#0]            ;658
0000a4  6b01              LDR      r1,[r0,#0x30]         ;658
0000a6  f0014140          AND      r1,r1,#0xc0000000     ;658
0000aa  6301              STR      r1,[r0,#0x30]         ;658
0000ac  6820              LDR      r0,[r4,#0]            ;662
0000ae  6b41              LDR      r1,[r0,#0x34]         ;662
0000b0  f0014140          AND      r1,r1,#0xc0000000     ;662
0000b4  6341              STR      r1,[r0,#0x34]         ;662
0000b6  6820              LDR      r0,[r4,#0]            ;666
0000b8  6b81              LDR      r1,[r0,#0x38]         ;666
0000ba  f36f0115          BFC      r1,#0,#22             ;666
0000be  6381              STR      r1,[r0,#0x38]         ;666
0000c0  6820              LDR      r0,[r4,#0]            ;671
0000c2  6b81              LDR      r1,[r0,#0x38]         ;671
0000c4  f36f0115          BFC      r1,#0,#22             ;671
0000c8  6381              STR      r1,[r0,#0x38]         ;671
0000ca  4620              MOV      r0,r4                 ;691
0000cc  f7fffffe          BL       HAL_ADC_MspDeInit
0000d0  62e6              STR      r6,[r4,#0x2c]         ;694
0000d2  62a6              STR      r6,[r4,#0x28]         ;697
                  |L10.212|
0000d4  f8846024          STRB     r6,[r4,#0x24]         ;702
0000d8  4628              MOV      r0,r5                 ;705
0000da  bd70              POP      {r4-r6,pc}
;;;707    
                          ENDP

                  |L10.220|
                          DCD      0xff3f0000
                  |L10.224|
                          DCD      0xff0106f0

                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1653     */
;;;1654   __WEAK void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1655   {
;;;1656     /* Prevent unused argument(s) compilation warning */
;;;1657     UNUSED(hadc);
;;;1658     /* NOTE : This function should not be modified. When the callback is needed,
;;;1659               function HAL_ADC_ErrorCallback must be implemented in the user file.
;;;1660     */
;;;1661   }
;;;1662   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1909     */
;;;1910   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  6ac0              LDR      r0,[r0,#0x2c]
;;;1911   {
;;;1912     return hadc->ErrorCode;
;;;1913   }
000002  4770              BX       lr
;;;1914   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1898     */
;;;1899   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  6a80              LDR      r0,[r0,#0x28]
;;;1900   {
;;;1901     /* Return ADC state */
;;;1902     return hadc->State;
;;;1903   }
000002  4770              BX       lr
;;;1904   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;1478     */
;;;1479   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  6800              LDR      r0,[r0,#0]
;;;1480   {
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1483   
;;;1484     /* Note: EOC flag is not cleared here by software because automatically     */
;;;1485     /*       cleared by hardware when reading register DR.                      */
;;;1486     
;;;1487     /* Return ADC converted value */ 
;;;1488     return hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;1489   }
000004  4770              BX       lr
;;;1490   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;1495     */
;;;1496   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1497   {
000002  4604              MOV      r4,r0
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1500     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1501     assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;1502     
;;;1503     
;;;1504     /* ========== Check End of Conversion flag for regular group ========== */
;;;1505     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
000004  6820              LDR      r0,[r4,#0]
000006  6841              LDR      r1,[r0,#4]
000008  0689              LSLS     r1,r1,#26
00000a  d526              BPL      |L15.90|
;;;1506     {
;;;1507       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
00000c  6801              LDR      r1,[r0,#0]
00000e  0789              LSLS     r1,r1,#30
000010  d523              BPL      |L15.90|
;;;1508       {
;;;1509         /* Update state machine on conversion status if not in error state */
;;;1510         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000012  6aa1              LDR      r1,[r4,#0x28]
000014  06c9              LSLS     r1,r1,#27
000016  d403              BMI      |L15.32|
;;;1511         {
;;;1512           /* Set ADC state */
;;;1513           SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000018  6aa1              LDR      r1,[r4,#0x28]
00001a  f4417100          ORR      r1,r1,#0x200
00001e  62a1              STR      r1,[r4,#0x28]
                  |L15.32|
;;;1514         }
;;;1515         
;;;1516         /* Determine whether any further conversion upcoming on group regular   */
;;;1517         /* by external trigger, continuous mode or scan sequence on going.      */
;;;1518         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1519         /*       (several ranks selected), end of conversion flag is raised     */
;;;1520         /*       at the end of the sequence.                                    */
;;;1521         if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
000020  6881              LDR      r1,[r0,#8]
000022  f3c14142          UBFX     r1,r1,#17,#3
000026  2907              CMP      r1,#7
000028  d110              BNE      |L15.76|
;;;1522            (hadc->Init.ContinuousConvMode == DISABLE)   )
00002a  68e1              LDR      r1,[r4,#0xc]
00002c  b971              CBNZ     r1,|L15.76|
;;;1523         {
;;;1524           /* Disable ADC end of conversion interrupt on group regular */
;;;1525           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
00002e  6841              LDR      r1,[r0,#4]
000030  f0210120          BIC      r1,r1,#0x20
000034  6041              STR      r1,[r0,#4]
;;;1526           
;;;1527           /* Set ADC state */
;;;1528           CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f4207080          BIC      r0,r0,#0x100
00003c  62a0              STR      r0,[r4,#0x28]
;;;1529           
;;;1530           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
00003e  6aa0              LDR      r0,[r4,#0x28]
000040  04c0              LSLS     r0,r0,#19
000042  d403              BMI      |L15.76|
;;;1531           {
;;;1532             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
000044  6aa0              LDR      r0,[r4,#0x28]
000046  f0400001          ORR      r0,r0,#1
00004a  62a0              STR      r0,[r4,#0x28]
                  |L15.76|
;;;1533           }
;;;1534         }
;;;1535   
;;;1536         /* Conversion complete callback */
;;;1537         HAL_ADC_ConvCpltCallback(hadc);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1538         
;;;1539         /* Clear regular group conversion flag */
;;;1540         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
000052  6821              LDR      r1,[r4,#0]
000054  f06f0012          MVN      r0,#0x12
000058  6008              STR      r0,[r1,#0]
                  |L15.90|
;;;1541       }
;;;1542     }
;;;1543     
;;;1544     /* ========== Check End of Conversion flag for injected group ========== */
;;;1545     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
00005a  6820              LDR      r0,[r4,#0]
00005c  6841              LDR      r1,[r0,#4]
00005e  0609              LSLS     r1,r1,#24
000060  d52e              BPL      |L15.192|
;;;1546     {
;;;1547       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
000062  6801              LDR      r1,[r0,#0]
000064  0749              LSLS     r1,r1,#29
000066  d52b              BPL      |L15.192|
;;;1548       {
;;;1549         /* Update state machine on conversion status if not in error state */
;;;1550         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000068  6aa1              LDR      r1,[r4,#0x28]
00006a  06c9              LSLS     r1,r1,#27
00006c  d403              BMI      |L15.118|
;;;1551         {
;;;1552           /* Set ADC state */
;;;1553           SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
00006e  6aa1              LDR      r1,[r4,#0x28]
000070  f4415100          ORR      r1,r1,#0x2000
000074  62a1              STR      r1,[r4,#0x28]
                  |L15.118|
;;;1554         }
;;;1555   
;;;1556         /* Determine whether any further conversion upcoming on group injected  */
;;;1557         /* by external trigger, scan sequence on going or by automatic injected */
;;;1558         /* conversion from group regular (same conditions as group regular      */
;;;1559         /* interruption disabling above).                                       */
;;;1560         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1561         /*       (several ranks selected), end of conversion flag is raised     */
;;;1562         /*       at the end of the sequence.                                    */
;;;1563         if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
000076  6881              LDR      r1,[r0,#8]
000078  f3c13102          UBFX     r1,r1,#12,#3
00007c  2907              CMP      r1,#7
00007e  d009              BEQ      |L15.148|
;;;1564            (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
000080  6841              LDR      r1,[r0,#4]
000082  0549              LSLS     r1,r1,#21
000084  d415              BMI      |L15.178|
;;;1565            (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
000086  6881              LDR      r1,[r0,#8]
000088  f3c14142          UBFX     r1,r1,#17,#3
00008c  2907              CMP      r1,#7
00008e  d110              BNE      |L15.178|
;;;1566             (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
000090  68e1              LDR      r1,[r4,#0xc]
000092  b971              CBNZ     r1,|L15.178|
                  |L15.148|
;;;1567         {
;;;1568           /* Disable ADC end of conversion interrupt on group injected */
;;;1569           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
000094  6841              LDR      r1,[r0,#4]
000096  f0210180          BIC      r1,r1,#0x80
00009a  6041              STR      r1,[r0,#4]
;;;1570           
;;;1571           /* Set ADC state */
;;;1572           CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
00009c  6aa0              LDR      r0,[r4,#0x28]
00009e  f4205080          BIC      r0,r0,#0x1000
0000a2  62a0              STR      r0,[r4,#0x28]
;;;1573   
;;;1574           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
0000a4  6aa0              LDR      r0,[r4,#0x28]
0000a6  05c0              LSLS     r0,r0,#23
0000a8  d403              BMI      |L15.178|
;;;1575           { 
;;;1576             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
0000aa  6aa0              LDR      r0,[r4,#0x28]
0000ac  f0400001          ORR      r0,r0,#1
0000b0  62a0              STR      r0,[r4,#0x28]
                  |L15.178|
;;;1577           }
;;;1578         }
;;;1579   
;;;1580         /* Conversion complete callback */ 
;;;1581         HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;1582         
;;;1583         /* Clear injected group conversion flag */
;;;1584         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
0000b8  6821              LDR      r1,[r4,#0]
0000ba  f06f000c          MVN      r0,#0xc
0000be  6008              STR      r0,[r1,#0]
                  |L15.192|
;;;1585       }
;;;1586     }
;;;1587      
;;;1588     /* ========== Check Analog watchdog flags ========== */
;;;1589     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6841              LDR      r1,[r0,#4]
0000c4  0649              LSLS     r1,r1,#25
0000c6  d50d              BPL      |L15.228|
;;;1590     {
;;;1591       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
0000c8  6800              LDR      r0,[r0,#0]
0000ca  07c0              LSLS     r0,r0,#31
0000cc  d00a              BEQ      |L15.228|
;;;1592       {
;;;1593         /* Set ADC state */
;;;1594         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
0000ce  6aa0              LDR      r0,[r4,#0x28]
0000d0  f4403080          ORR      r0,r0,#0x10000
0000d4  62a0              STR      r0,[r4,#0x28]
;;;1595         
;;;1596         /* Level out of window callback */ 
;;;1597         HAL_ADC_LevelOutOfWindowCallback(hadc);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1598         
;;;1599         /* Clear the ADC analog watchdog flag */
;;;1600         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
0000dc  6821              LDR      r1,[r4,#0]
0000de  f06f0001          MVN      r0,#1
0000e2  6008              STR      r0,[r1,#0]
                  |L15.228|
;;;1601       }
;;;1602     }
;;;1603     
;;;1604   }
0000e4  bd10              POP      {r4,pc}
;;;1605   
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;373      */
;;;374    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;375    {
000004  4604              MOV      r4,r0
;;;376      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;377      uint32_t tmp_cr1 = 0U;
;;;378      uint32_t tmp_cr2 = 0U;
000006  2700              MOVS     r7,#0
;;;379      uint32_t tmp_sqr1 = 0U;
000008  2500              MOVS     r5,#0
;;;380      
;;;381      /* Check ADC handle */
;;;382      if(hadc == NULL)
00000a  2c00              CMP      r4,#0
00000c  d003              BEQ      |L16.22|
;;;383      {
;;;384        return HAL_ERROR;
;;;385      }
;;;386      
;;;387      /* Check the parameters */
;;;388      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;389      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;390      assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
;;;391      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;392      assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
;;;393      
;;;394      if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
;;;395      {
;;;396        assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;397        assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;398        if(hadc->Init.DiscontinuousConvMode != DISABLE)
;;;399        {
;;;400          assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;401        }
;;;402      }
;;;403      
;;;404      /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
;;;405      /* at RCC top level.                                                        */
;;;406      /* Refer to header of this file for more details on clock enabling          */
;;;407      /* procedure.                                                               */
;;;408    
;;;409      /* Actions performed only if ADC is coming from state reset:                */
;;;410      /* - Initialization of ADC MSP                                              */
;;;411      if (hadc->State == HAL_ADC_STATE_RESET)
00000e  6aa0              LDR      r0,[r4,#0x28]
000010  2600              MOVS     r6,#0
000012  b118              CBZ      r0,|L16.28|
000014  e008              B        |L16.40|
                  |L16.22|
000016  2001              MOVS     r0,#1                 ;384
                  |L16.24|
;;;412      {
;;;413        /* Initialize ADC error code */
;;;414        ADC_CLEAR_ERRORCODE(hadc);
;;;415        
;;;416        /* Allocate lock resource and initialize it */
;;;417        hadc->Lock = HAL_UNLOCKED;
;;;418        
;;;419        /* Init the low level hardware */
;;;420        HAL_ADC_MspInit(hadc);
;;;421      }
;;;422      
;;;423      /* Stop potential conversion on going, on regular and injected groups */
;;;424      /* Disable ADC peripheral */
;;;425      /* Note: In case of ADC already enabled, precaution to not launch an        */
;;;426      /*       unwanted conversion while modifying register CR2 by writing 1 to   */
;;;427      /*       bit ADON.                                                          */
;;;428      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;429      
;;;430      
;;;431      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;432      /* correctly completed.                                                     */
;;;433      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
;;;434          (tmp_hal_status == HAL_OK)                                  )
;;;435      {
;;;436        /* Set ADC state */
;;;437        ADC_STATE_CLR_SET(hadc->State,
;;;438                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;439                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;440        
;;;441        /* Set ADC parameters */
;;;442        
;;;443        /* Configuration of ADC:                                                  */
;;;444        /*  - data alignment                                                      */
;;;445        /*  - external trigger to start conversion                                */
;;;446        /*  - external trigger polarity (always set to 1, because needed for all  */
;;;447        /*    triggers: external trigger of SW start)                             */
;;;448        /*  - continuous conversion mode                                          */
;;;449        /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
;;;450        /*       HAL_ADC_Start_xxx functions because if set in this function,     */
;;;451        /*       a conversion on injected group would start a conversion also on  */
;;;452        /*       regular group after ADC enabling.                                */
;;;453        tmp_cr2 |= (hadc->Init.DataAlign                               |
;;;454                    ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
;;;455                    ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
;;;456        
;;;457        /* Configuration of ADC:                                                  */
;;;458        /*  - scan mode                                                           */
;;;459        /*  - discontinuous mode disable/enable                                   */
;;;460        /*  - discontinuous mode number of conversions                            */
;;;461        tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
;;;462        
;;;463        /* Enable discontinuous mode only if continuous mode is disabled */
;;;464        /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
;;;465        /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
;;;466        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;467        {
;;;468          if (hadc->Init.ContinuousConvMode == DISABLE)
;;;469          {
;;;470            /* Enable the selected ADC regular discontinuous mode */
;;;471            /* Set the number of channels to be converted in discontinuous mode */
;;;472            SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
;;;473                             ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
;;;474          }
;;;475          else
;;;476          {
;;;477            /* ADC regular group settings continuous and sequencer discontinuous*/
;;;478            /* cannot be enabled simultaneously.                                */
;;;479            
;;;480            /* Update ADC state machine to error */
;;;481            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;482            
;;;483            /* Set ADC error code to ADC IP internal error */
;;;484            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;485          }
;;;486        }
;;;487        
;;;488        /* Update ADC configuration register CR1 with previous settings */
;;;489          MODIFY_REG(hadc->Instance->CR1,
;;;490                     ADC_CR1_SCAN    |
;;;491                     ADC_CR1_DISCEN  |
;;;492                     ADC_CR1_DISCNUM    ,
;;;493                     tmp_cr1             );
;;;494        
;;;495        /* Update ADC configuration register CR2 with previous settings */
;;;496          MODIFY_REG(hadc->Instance->CR2,
;;;497                     ADC_CR2_ALIGN   |
;;;498                     ADC_CR2_EXTSEL  |
;;;499                     ADC_CR2_EXTTRIG |
;;;500                     ADC_CR2_CONT       ,
;;;501                     tmp_cr2             );
;;;502    
;;;503        /* Configuration of regular group sequencer:                              */
;;;504        /* - if scan mode is disabled, regular channels sequence length is set to */
;;;505        /*   0x00: 1 channel converted (channel on regular rank 1)                */
;;;506        /*   Parameter "NbrOfConversion" is discarded.                            */
;;;507        /*   Note: Scan mode is present by hardware on this device and, if        */
;;;508        /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
;;;509        /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
;;;510        /* - if scan mode is enabled, regular channels sequence length is set to  */
;;;511        /*   parameter "NbrOfConversion"                                          */
;;;512        if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
;;;513        {
;;;514          tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
;;;515        }
;;;516          
;;;517        MODIFY_REG(hadc->Instance->SQR1,
;;;518                   ADC_SQR1_L          ,
;;;519                   tmp_sqr1             );
;;;520        
;;;521        /* Check back that ADC registers have effectively been configured to      */
;;;522        /* ensure of no potential problem of ADC core IP clocking.                */
;;;523        /* Check through register CR2 (excluding bits set in other functions:     */
;;;524        /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
;;;525        /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
;;;526        /* measurement path bit (TSVREFE).                                        */
;;;527        if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
;;;528                                            ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
;;;529                                            ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
;;;530                                            ADC_CR2_TSVREFE                     ))
;;;531             == tmp_cr2)
;;;532        {
;;;533          /* Set ADC error code to none */
;;;534          ADC_CLEAR_ERRORCODE(hadc);
;;;535          
;;;536          /* Set the ADC state */
;;;537          ADC_STATE_CLR_SET(hadc->State,
;;;538                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;539                            HAL_ADC_STATE_READY);
;;;540        }
;;;541        else
;;;542        {
;;;543          /* Update ADC state machine to error */
;;;544          ADC_STATE_CLR_SET(hadc->State,
;;;545                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;546                            HAL_ADC_STATE_ERROR_INTERNAL);
;;;547          
;;;548          /* Set ADC error code to ADC IP internal error */
;;;549          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;550          
;;;551          tmp_hal_status = HAL_ERROR;
;;;552        }
;;;553      
;;;554      }
;;;555      else
;;;556      {
;;;557        /* Update ADC state machine to error */
;;;558        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;559            
;;;560        tmp_hal_status = HAL_ERROR;
;;;561      }
;;;562      
;;;563      /* Return function status */
;;;564      return tmp_hal_status;
;;;565    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L16.28|
00001c  62e6              STR      r6,[r4,#0x2c]         ;414
00001e  f8846024          STRB     r6,[r4,#0x24]         ;417
000022  4620              MOV      r0,r4                 ;420
000024  f7fffffe          BL       HAL_ADC_MspInit
                  |L16.40|
000028  4620              MOV      r0,r4                 ;428
00002a  f7fffffe          BL       ADC_ConversionStop_Disable
00002e  6aa1              LDR      r1,[r4,#0x28]         ;433
000030  06c9              LSLS     r1,r1,#27             ;433
000032  d400              BMI      |L16.54|
000034  b128              CBZ      r0,|L16.66|
                  |L16.54|
000036  6aa0              LDR      r0,[r4,#0x28]         ;558
000038  f0400010          ORR      r0,r0,#0x10           ;558
00003c  62a0              STR      r0,[r4,#0x28]         ;558
00003e  2001              MOVS     r0,#1                 ;560
000040  e7ea              B        |L16.24|
                  |L16.66|
000042  6aa1              LDR      r1,[r4,#0x28]         ;437
000044  f4215188          BIC      r1,r1,#0x1100         ;437
000048  f0410102          ORR      r1,r1,#2              ;437
00004c  62a1              STR      r1,[r4,#0x28]         ;437
00004e  6862              LDR      r2,[r4,#4]            ;453
000050  69e1              LDR      r1,[r4,#0x1c]         ;453
000052  68e3              LDR      r3,[r4,#0xc]          ;453
000054  430a              ORRS     r2,r2,r1              ;453
000056  ea470143          ORR      r1,r7,r3,LSL #1       ;453
00005a  430a              ORRS     r2,r2,r1              ;453
00005c  68a1              LDR      r1,[r4,#8]            ;461
00005e  f44f7780          MOV      r7,#0x100             ;461
000062  42b9              CMP      r1,r7                 ;461
000064  d008              BEQ      |L16.120|
000066  2901              CMP      r1,#1                 ;461
000068  d006              BEQ      |L16.120|
00006a  2100              MOVS     r1,#0                 ;461
                  |L16.108|
00006c  f8d4c014          LDR      r12,[r4,#0x14]        ;466
000070  f1bc0f01          CMP      r12,#1                ;466
000074  d002              BEQ      |L16.124|
000076  e00a              B        |L16.142|
                  |L16.120|
000078  4639              MOV      r1,r7                 ;461
00007a  e7f7              B        |L16.108|
                  |L16.124|
00007c  b1f3              CBZ      r3,|L16.188|
00007e  6aa3              LDR      r3,[r4,#0x28]         ;481
000080  f0430320          ORR      r3,r3,#0x20           ;481
000084  62a3              STR      r3,[r4,#0x28]         ;481
000086  6ae3              LDR      r3,[r4,#0x2c]         ;484
000088  f0430301          ORR      r3,r3,#1              ;484
00008c  62e3              STR      r3,[r4,#0x2c]         ;484
                  |L16.142|
00008e  6823              LDR      r3,[r4,#0]            ;489
000090  f8d3c004          LDR      r12,[r3,#4]           ;489
000094  f42c4c69          BIC      r12,r12,#0xe900       ;489
000098  ea4c0c01          ORR      r12,r12,r1            ;489
00009c  f8c3c004          STR      r12,[r3,#4]           ;489
0000a0  6821              LDR      r1,[r4,#0]            ;496
0000a2  688b              LDR      r3,[r1,#8]            ;496
0000a4  f8dfc068          LDR      r12,|L16.272|
0000a8  ea03030c          AND      r3,r3,r12             ;496
0000ac  4313              ORRS     r3,r3,r2              ;496
0000ae  608b              STR      r3,[r1,#8]            ;496
0000b0  68a1              LDR      r1,[r4,#8]            ;512
0000b2  42b9              CMP      r1,r7                 ;512
0000b4  d009              BEQ      |L16.202|
0000b6  2901              CMP      r1,#1                 ;512
0000b8  d007              BEQ      |L16.202|
0000ba  e009              B        |L16.208|
                  |L16.188|
0000bc  69a3              LDR      r3,[r4,#0x18]         ;472
0000be  1e5b              SUBS     r3,r3,#1              ;472
0000c0  ea413143          ORR      r1,r1,r3,LSL #13      ;472
0000c4  f4416100          ORR      r1,r1,#0x800          ;472
0000c8  e7e1              B        |L16.142|
                  |L16.202|
0000ca  8a21              LDRH     r1,[r4,#0x10]         ;514
0000cc  1e49              SUBS     r1,r1,#1              ;514
0000ce  050d              LSLS     r5,r1,#20             ;514
                  |L16.208|
0000d0  6821              LDR      r1,[r4,#0]            ;517
0000d2  6acb              LDR      r3,[r1,#0x2c]         ;517
0000d4  f4230370          BIC      r3,r3,#0xf00000       ;517
0000d8  432b              ORRS     r3,r3,r5              ;517
0000da  62cb              STR      r3,[r1,#0x2c]         ;517
0000dc  6821              LDR      r1,[r4,#0]            ;527
0000de  6889              LDR      r1,[r1,#8]            ;527
0000e0  4b0c              LDR      r3,|L16.276|
0000e2  4019              ANDS     r1,r1,r3              ;527
0000e4  4291              CMP      r1,r2                 ;527
0000e6  d107              BNE      |L16.248|
0000e8  62e6              STR      r6,[r4,#0x2c]         ;534
0000ea  6aa1              LDR      r1,[r4,#0x28]         ;537
0000ec  f0210102          BIC      r1,r1,#2              ;537
0000f0  f0410101          ORR      r1,r1,#1              ;537
0000f4  62a1              STR      r1,[r4,#0x28]         ;537
0000f6  e78f              B        |L16.24|
                  |L16.248|
0000f8  6aa0              LDR      r0,[r4,#0x28]         ;544
0000fa  f0200002          BIC      r0,r0,#2              ;544
0000fe  f0400010          ORR      r0,r0,#0x10           ;544
000102  62a0              STR      r0,[r4,#0x28]         ;544
000104  6ae0              LDR      r0,[r4,#0x2c]         ;549
000106  f0400001          ORR      r0,r0,#1              ;549
00010a  62e0              STR      r0,[r4,#0x2c]         ;549
00010c  2001              MOVS     r0,#1                 ;551
00010e  e783              B        |L16.24|
;;;566    
                          ENDP

                  |L16.272|
                          DCD      0xffe1f7fd
                  |L16.276|
                          DCD      0xff1f0efe

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1638     */
;;;1639   __WEAK void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1640   {
;;;1641     /* Prevent unused argument(s) compilation warning */
;;;1642     UNUSED(hadc);
;;;1643     /* NOTE : This function should not be modified. When the callback is needed,
;;;1644               function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
;;;1645     */
;;;1646   }
;;;1647   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;726      */
;;;727    __WEAK void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;728    {
;;;729      /* Prevent unused argument(s) compilation warning */
;;;730      UNUSED(hadc);
;;;731      /* NOTE : This function should not be modified. When the callback is needed,
;;;732                function HAL_ADC_MspDeInit must be implemented in the user file.
;;;733       */ 
;;;734    }
;;;735    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;712      */
;;;713    __WEAK void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;714    {
;;;715      /* Prevent unused argument(s) compilation warning */
;;;716      UNUSED(hadc);
;;;717      /* NOTE : This function should not be modified. When the callback is needed,
;;;718                function HAL_ADC_MspInit must be implemented in the user file.
;;;719       */ 
;;;720    }
;;;721    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADC_PollForConversion PROC
;;;924      */
;;;925    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;926    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;927      uint32_t tickstart = 0U;
;;;928      
;;;929      /* Variables for polling in case of scan mode enabled and polling for each  */
;;;930      /* conversion.                                                              */
;;;931      __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
000008  2700              MOVS     r7,#0
00000a  9700              STR      r7,[sp,#0]
;;;932      uint32_t Conversion_Timeout_CPU_cycles_max = 0U;
;;;933     
;;;934      /* Check the parameters */
;;;935      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;936      
;;;937      /* Get tick count */
;;;938      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;939      
;;;940      /* Verification that ADC configuration is compliant with polling for        */
;;;941      /* each conversion:                                                         */
;;;942      /* Particular case is ADC configured in DMA mode                            */
;;;943      if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
000012  6820              LDR      r0,[r4,#0]
000014  6881              LDR      r1,[r0,#8]
000016  05c9              LSLS     r1,r1,#23
000018  d508              BPL      |L20.44|
;;;944      {
;;;945        /* Update ADC state machine to error */
;;;946        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  f0400020          ORR      r0,r0,#0x20
000020  62a0              STR      r0,[r4,#0x28]
;;;947        
;;;948        /* Process unlocked */
;;;949        __HAL_UNLOCK(hadc);
000022  f8847024          STRB     r7,[r4,#0x24]
;;;950        
;;;951        return HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L20.40|
;;;952      }
;;;953      
;;;954      /* Polling for end of conversion: differentiation if single/sequence        */
;;;955      /* conversion.                                                              */
;;;956      /*  - If single conversion for regular group (Scan mode disabled or enabled */
;;;957      /*    with NbrOfConversion =1), flag EOC is used to determine the           */
;;;958      /*    conversion completion.                                                */
;;;959      /*  - If sequence conversion for regular group (scan mode enabled and       */
;;;960      /*    NbrOfConversion >=2), flag EOC is set only at the end of the          */
;;;961      /*    sequence.                                                             */
;;;962      /*    To poll for each conversion, the maximum conversion time is computed  */
;;;963      /*    from ADC conversion time (selected sampling time + conversion time of */
;;;964      /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
;;;965      /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
;;;966      /*    As flag EOC is not set after each conversion, no timeout status can   */
;;;967      /*    be set.                                                               */
;;;968      if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
;;;969          HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
;;;970      {
;;;971        /* Wait until End of Conversion flag is raised */
;;;972        while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
;;;973        {
;;;974          /* Check if timeout is disabled (set to infinite wait) */
;;;975          if(Timeout != HAL_MAX_DELAY)
;;;976          {
;;;977            if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;978            {
;;;979              /* Update ADC state machine to timeout */
;;;980              SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;981              
;;;982              /* Process unlocked */
;;;983              __HAL_UNLOCK(hadc);
;;;984              
;;;985              return HAL_TIMEOUT;
;;;986            }
;;;987          }
;;;988        }
;;;989      }
;;;990      else
;;;991      {
;;;992        /* Replace polling by wait for maximum conversion time */
;;;993        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
;;;994        /*    and ADC maximum conversion cycles on all channels.                  */
;;;995        /*  - Wait for the expected ADC clock cycles delay                        */
;;;996        Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
;;;997                                              / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;998                                             * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
;;;999        
;;;1000       while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;1001       {
;;;1002         /* Check if timeout is disabled (set to infinite wait) */
;;;1003         if(Timeout != HAL_MAX_DELAY)
;;;1004         {
;;;1005           if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;1006           {
;;;1007             /* Update ADC state machine to timeout */
;;;1008             SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;1009             
;;;1010             /* Process unlocked */
;;;1011             __HAL_UNLOCK(hadc);
;;;1012             
;;;1013             return HAL_TIMEOUT;
;;;1014           }
;;;1015         }
;;;1016         Conversion_Timeout_CPU_cycles ++;
;;;1017       }
;;;1018     }
;;;1019     
;;;1020     /* Clear regular group conversion flag */
;;;1021     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
;;;1022     
;;;1023     /* Update ADC state machine */
;;;1024     SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;1025     
;;;1026     /* Determine whether any further conversion upcoming on group regular       */
;;;1027     /* by external trigger, continuous mode or scan sequence on going.          */
;;;1028     /* Note: On STM32F1 devices, in case of sequencer enabled                   */
;;;1029     /*       (several ranks selected), end of conversion flag is raised         */
;;;1030     /*       at the end of the sequence.                                        */
;;;1031     if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;1032        (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;1033     {   
;;;1034       /* Set ADC state */
;;;1035       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;1036   
;;;1037       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1038       { 
;;;1039         SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;1040       }
;;;1041     }
;;;1042     
;;;1043     /* Return ADC state */
;;;1044     return HAL_OK;
;;;1045   }
000028  e8bd83f8          POP      {r3-r9,pc}
                  |L20.44|
00002c  6841              LDR      r1,[r0,#4]            ;968
00002e  05c9              LSLS     r1,r1,#23             ;968
000030  d403              BMI      |L20.58|
000032  6ac0              LDR      r0,[r0,#0x2c]         ;969
000034  f4100f70          TST      r0,#0xf00000          ;969
000038  d02d              BEQ      |L20.150|
                  |L20.58|
00003a  2002              MOVS     r0,#2                 ;996
00003c  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000040  493b              LDR      r1,|L20.304|
000042  6809              LDR      r1,[r1,#0]            ;996  ; SystemCoreClock
000044  fbb1f8f0          UDIV     r8,r1,r0              ;996
000048  6820              LDR      r0,[r4,#0]            ;996
00004a  6901              LDR      r1,[r0,#0x10]         ;996
00004c  4a39              LDR      r2,|L20.308|
00004e  4211              TST      r1,r2                 ;996
000050  ea4f0262          ASR      r2,r2,#1              ;998
000054  ea4f13a2          ASR      r3,r2,#6              ;998
000058  d122              BNE      |L20.160|
00005a  68c1              LDR      r1,[r0,#0xc]          ;998
00005c  ea4f1c62          ASR      r12,r2,#5             ;998
000060  ea110f0c          TST      r1,r12                ;998
000064  d11c              BNE      |L20.160|
000066  6901              LDR      r1,[r0,#0x10]         ;998
000068  4211              TST      r1,r2                 ;998
00006a  d128              BNE      |L20.190|
00006c  68c0              LDR      r0,[r0,#0xc]          ;998
00006e  4218              TST      r0,r3                 ;998
000070  d125              BNE      |L20.190|
000072  2014              MOVS     r0,#0x14              ;998
000074  e026              B        |L20.196|
                  |L20.118|
000076  1c68              ADDS     r0,r5,#1              ;975
000078  d00d              BEQ      |L20.150|
00007a  b125              CBZ      r5,|L20.134|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b80              SUBS     r0,r0,r6              ;977
000082  42a8              CMP      r0,r5                 ;977
000084  d907              BLS      |L20.150|
                  |L20.134|
000086  6aa0              LDR      r0,[r4,#0x28]         ;980
000088  f0400004          ORR      r0,r0,#4              ;980
00008c  62a0              STR      r0,[r4,#0x28]         ;980
00008e  f8847024          STRB     r7,[r4,#0x24]         ;983
000092  2003              MOVS     r0,#3                 ;985
000094  e7c8              B        |L20.40|
                  |L20.150|
000096  6820              LDR      r0,[r4,#0]            ;972
000098  6800              LDR      r0,[r0,#0]            ;972
00009a  0780              LSLS     r0,r0,#30             ;972
00009c  d5eb              BPL      |L20.118|
00009e  e02a              B        |L20.246|
                  |L20.160|
0000a0  6901              LDR      r1,[r0,#0x10]         ;998
0000a2  4211              TST      r1,r2                 ;998
0000a4  d102              BNE      |L20.172|
0000a6  68c1              LDR      r1,[r0,#0xc]          ;998
0000a8  4219              TST      r1,r3                 ;998
0000aa  d006              BEQ      |L20.186|
                  |L20.172|
0000ac  6902              LDR      r2,[r0,#0x10]         ;998
0000ae  4922              LDR      r1,|L20.312|
0000b0  420a              TST      r2,r1                 ;998
0000b2  d106              BNE      |L20.194|
0000b4  68c0              LDR      r0,[r0,#0xc]          ;998
0000b6  4208              TST      r0,r1                 ;998
0000b8  d103              BNE      |L20.194|
                  |L20.186|
0000ba  2054              MOVS     r0,#0x54              ;998
0000bc  e002              B        |L20.196|
                  |L20.190|
0000be  2029              MOVS     r0,#0x29              ;998
0000c0  e000              B        |L20.196|
                  |L20.194|
0000c2  20fc              MOVS     r0,#0xfc              ;998
                  |L20.196|
0000c4  fb08f800          MUL      r8,r8,r0              ;998
0000c8  e012              B        |L20.240|
                  |L20.202|
0000ca  1c68              ADDS     r0,r5,#1              ;1003
0000cc  d00d              BEQ      |L20.234|
0000ce  b125              CBZ      r5,|L20.218|
0000d0  f7fffffe          BL       HAL_GetTick
0000d4  1b80              SUBS     r0,r0,r6              ;1005
0000d6  42a8              CMP      r0,r5                 ;1005
0000d8  d907              BLS      |L20.234|
                  |L20.218|
0000da  6aa0              LDR      r0,[r4,#0x28]         ;1008
0000dc  f0400004          ORR      r0,r0,#4              ;1008
0000e0  62a0              STR      r0,[r4,#0x28]         ;1008
0000e2  f8847024          STRB     r7,[r4,#0x24]         ;1011
0000e6  2003              MOVS     r0,#3                 ;1013
0000e8  e79e              B        |L20.40|
                  |L20.234|
0000ea  9800              LDR      r0,[sp,#0]            ;1016
0000ec  1c40              ADDS     r0,r0,#1              ;1016
0000ee  9000              STR      r0,[sp,#0]            ;1016
                  |L20.240|
0000f0  9800              LDR      r0,[sp,#0]            ;1000
0000f2  4540              CMP      r0,r8                 ;1000
0000f4  d3e9              BCC      |L20.202|
                  |L20.246|
0000f6  6821              LDR      r1,[r4,#0]            ;1021
0000f8  f06f0012          MVN      r0,#0x12              ;1021
0000fc  6008              STR      r0,[r1,#0]            ;1021
0000fe  6aa0              LDR      r0,[r4,#0x28]         ;1024
000100  f4407000          ORR      r0,r0,#0x200          ;1024
000104  62a0              STR      r0,[r4,#0x28]         ;1024
000106  6820              LDR      r0,[r4,#0]            ;1031
000108  6880              LDR      r0,[r0,#8]            ;1031
00010a  f3c04042          UBFX     r0,r0,#17,#3          ;1031
00010e  2807              CMP      r0,#7                 ;1031
000110  d10c              BNE      |L20.300|
000112  68e0              LDR      r0,[r4,#0xc]          ;1032
000114  b950              CBNZ     r0,|L20.300|
000116  6aa0              LDR      r0,[r4,#0x28]         ;1035
000118  f4207080          BIC      r0,r0,#0x100          ;1035
00011c  62a0              STR      r0,[r4,#0x28]         ;1035
00011e  6aa0              LDR      r0,[r4,#0x28]         ;1037
000120  04c0              LSLS     r0,r0,#19             ;1037
000122  d403              BMI      |L20.300|
000124  6aa0              LDR      r0,[r4,#0x28]         ;1039
000126  f0400001          ORR      r0,r0,#1              ;1039
00012a  62a0              STR      r0,[r4,#0x28]         ;1039
                  |L20.300|
00012c  2000              MOVS     r0,#0                 ;1044
00012e  e77b              B        |L20.40|
;;;1046   
                          ENDP

                  |L20.304|
                          DCD      SystemCoreClock
                  |L20.308|
                          DCD      0x24924924
                  |L20.312|
                          DCD      0x00249249

                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;1055     */
;;;1056   HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1057   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1058     uint32_t tickstart = 0U; 
;;;1059   
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1062     assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;1063     
;;;1064     /* Get tick count */
;;;1065     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4607              MOV      r7,r0
;;;1066     
;;;1067     /* Check selected event flag */
;;;1068     while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
000010  e011              B        |L21.54|
                  |L21.18|
;;;1069     {
;;;1070       /* Check if timeout is disabled (set to infinite wait) */
;;;1071       if(Timeout != HAL_MAX_DELAY)
000012  1c68              ADDS     r0,r5,#1
000014  d00f              BEQ      |L21.54|
;;;1072       {
;;;1073         if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
000016  b125              CBZ      r5,|L21.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1bc0              SUBS     r0,r0,r7
00001e  42a8              CMP      r0,r5
000020  d909              BLS      |L21.54|
                  |L21.34|
;;;1074         {
;;;1075           /* Update ADC state machine to timeout */
;;;1076           SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
000022  6aa0              LDR      r0,[r4,#0x28]
000024  f0400004          ORR      r0,r0,#4
000028  62a0              STR      r0,[r4,#0x28]
;;;1077           
;;;1078           /* Process unlocked */
;;;1079           __HAL_UNLOCK(hadc);
00002a  2000              MOVS     r0,#0
00002c  f8840024          STRB     r0,[r4,#0x24]
;;;1080           
;;;1081           return HAL_TIMEOUT;
000030  2003              MOVS     r0,#3
                  |L21.50|
;;;1082         }
;;;1083       }
;;;1084     }
;;;1085     
;;;1086     /* Analog watchdog (level out of window) event */
;;;1087     /* Set ADC state */
;;;1088     SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;1089       
;;;1090     /* Clear ADC analog watchdog flag */
;;;1091     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;1092     
;;;1093     /* Return ADC state */
;;;1094     return HAL_OK;
;;;1095   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L21.54|
000036  6820              LDR      r0,[r4,#0]            ;1068
000038  6800              LDR      r0,[r0,#0]            ;1068
00003a  ea360000          BICS     r0,r6,r0              ;1068
00003e  d1e8              BNE      |L21.18|
000040  6aa0              LDR      r0,[r4,#0x28]         ;1088
000042  f4403080          ORR      r0,r0,#0x10000        ;1088
000046  62a0              STR      r0,[r4,#0x28]         ;1088
000048  6821              LDR      r1,[r4,#0]            ;1091
00004a  f06f0001          MVN      r0,#1                 ;1091
00004e  6008              STR      r0,[r1,#0]            ;1091
000050  2000              MOVS     r0,#0                 ;1094
000052  e7ee              B        |L21.50|
;;;1096   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;767      */
;;;768    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;769    {
000002  4604              MOV      r4,r0
;;;770      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;771      
;;;772      /* Check the parameters */
;;;773      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;774      
;;;775      /* Process locked */
;;;776      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L22.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;777       
;;;778      /* Enable the ADC peripheral */
;;;779      tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;780      
;;;781      /* Start conversion if ADC is effectively enabled */
;;;782      if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L22.42|
;;;783      {
;;;784        /* Set ADC state                                                          */
;;;785        /* - Clear state bitfield related to regular group conversion results     */
;;;786        /* - Set state bitfield related to regular operation                      */
;;;787        ADC_STATE_CLR_SET(hadc->State,
;;;788                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC,
;;;789                          HAL_ADC_STATE_REG_BUSY);
;;;790        
;;;791        /* Set group injected state (from auto-injection) and multimode state     */
;;;792        /* for all cases of multimode: independent mode, multimode ADC master     */
;;;793        /* or multimode ADC slave (for devices with several ADCs):                */
;;;794        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;795        {
;;;796          /* Set ADC state (ADC independent or master) */
;;;797          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;798          
;;;799          /* If conversions on group regular are also triggering group injected,  */
;;;800          /* update ADC state.                                                    */
;;;801          if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;802          {
;;;803            ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;804          }
;;;805        }
;;;806        else
;;;807        {
;;;808          /* Set ADC state (ADC slave) */
;;;809          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;810          
;;;811          /* If conversions on group regular are also triggering group injected,  */
;;;812          /* update ADC state.                                                    */
;;;813          if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;814          {
;;;815            ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;816          }
;;;817        }
;;;818        
;;;819        /* State machine update: Check if an injected conversion is ongoing */
;;;820        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;821        {
;;;822          /* Reset ADC error code fields related to conversions on group regular */
;;;823          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;824        }
;;;825        else
;;;826        {
;;;827          /* Reset ADC all error code fields */
;;;828          ADC_CLEAR_ERRORCODE(hadc);
;;;829        }
;;;830        
;;;831        /* Process unlocked */
;;;832        /* Unlock before starting ADC conversions: in case of potential           */
;;;833        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;834        __HAL_UNLOCK(hadc);
;;;835      
;;;836        /* Clear regular group conversion flag */
;;;837        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;838        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;839        
;;;840        /* Enable conversion of regular group.                                    */
;;;841        /* If software start has been selected, conversion starts immediately.    */
;;;842        /* If external trigger has been selected, conversion will start at next   */
;;;843        /* trigger event.                                                         */
;;;844        /* Case of multimode enabled:                                             */ 
;;;845        /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;846        /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;847        /* If ADC is master, ADC is enabled and conversion is started.            */
;;;848        /* Note: Alternate trigger for single conversion could be to force an     */
;;;849        /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
;;;850        if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;851            ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;852        {
;;;853          /* Start ADC conversion on regular group with SW start */
;;;854          SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;855        }
;;;856        else
;;;857        {
;;;858          /* Start ADC conversion on regular group with external trigger */
;;;859          SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;860        }
;;;861      }
;;;862      else
;;;863      {
;;;864        /* Process unlocked */
;;;865        __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L22.34|
;;;866      }
;;;867        
;;;868      /* Return function status */
;;;869      return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;870    }
000024  bd70              POP      {r4-r6,pc}
                  |L22.38|
000026  2002              MOVS     r0,#2                 ;776
000028  bd70              POP      {r4-r6,pc}
                  |L22.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;787
00002c  f2402301          MOV      r3,#0x201             ;787
000030  4398              BICS     r0,r0,r3              ;787
000032  f4407080          ORR      r0,r0,#0x100          ;787
000036  62a0              STR      r0,[r4,#0x28]         ;787
000038  4d23              LDR      r5,|L22.200|
00003a  6820              LDR      r0,[r4,#0]            ;794
00003c  4b23              LDR      r3,|L22.204|
00003e  42a8              CMP      r0,r5                 ;794
000040  d118              BNE      |L22.116|
000042  681e              LDR      r6,[r3,#0]            ;794
000044  f4162f70          TST      r6,#0xf0000           ;794
000048  d014              BEQ      |L22.116|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;809
00004c  f4461680          ORR      r6,r6,#0x100000       ;809
000050  62a6              STR      r6,[r4,#0x28]         ;809
000052  681e              LDR      r6,[r3,#0]            ;813
000054  0576              LSLS     r6,r6,#21             ;813
000056  d505              BPL      |L22.100|
000058  6aa6              LDR      r6,[r4,#0x28]         ;815
00005a  f4265600          BIC      r6,r6,#0x2000         ;815
00005e  f4465680          ORR      r6,r6,#0x1000         ;815
000062  62a6              STR      r6,[r4,#0x28]         ;815
                  |L22.100|
000064  6aa6              LDR      r6,[r4,#0x28]         ;820
000066  04f6              LSLS     r6,r6,#19             ;820
000068  d512              BPL      |L22.144|
00006a  6ae6              LDR      r6,[r4,#0x2c]         ;823
00006c  f0260606          BIC      r6,r6,#6              ;823
000070  62e6              STR      r6,[r4,#0x2c]         ;823
000072  e00e              B        |L22.146|
                  |L22.116|
000074  6aa6              LDR      r6,[r4,#0x28]         ;797
000076  f4261680          BIC      r6,r6,#0x100000       ;797
00007a  62a6              STR      r6,[r4,#0x28]         ;797
00007c  6846              LDR      r6,[r0,#4]            ;801
00007e  0576              LSLS     r6,r6,#21             ;801
000080  d5f0              BPL      |L22.100|
000082  6aa6              LDR      r6,[r4,#0x28]         ;803
000084  f4265600          BIC      r6,r6,#0x2000         ;803
000088  f4465680          ORR      r6,r6,#0x1000         ;803
00008c  62a6              STR      r6,[r4,#0x28]         ;803
00008e  e7e9              B        |L22.100|
                  |L22.144|
000090  62e2              STR      r2,[r4,#0x2c]         ;828
                  |L22.146|
000092  f8842024          STRB     r2,[r4,#0x24]         ;834
000096  f06f0202          MVN      r2,#2                 ;838
00009a  6002              STR      r2,[r0,#0]            ;838
00009c  6820              LDR      r0,[r4,#0]            ;850
00009e  6882              LDR      r2,[r0,#8]            ;850
0000a0  f3c24242          UBFX     r2,r2,#17,#3          ;850
0000a4  2a07              CMP      r2,#7                 ;850
0000a6  d105              BNE      |L22.180|
0000a8  42a8              CMP      r0,r5                 ;851
0000aa  d108              BNE      |L22.190|
0000ac  681a              LDR      r2,[r3,#0]            ;851
0000ae  f4122f70          TST      r2,#0xf0000           ;851
0000b2  d004              BEQ      |L22.190|
                  |L22.180|
0000b4  6882              LDR      r2,[r0,#8]            ;859
0000b6  f4421280          ORR      r2,r2,#0x100000       ;859
0000ba  6082              STR      r2,[r0,#8]            ;859
0000bc  e7b1              B        |L22.34|
                  |L22.190|
0000be  6882              LDR      r2,[r0,#8]            ;854
0000c0  f44202a0          ORR      r2,r2,#0x500000       ;854
0000c4  6082              STR      r2,[r0,#8]            ;854
0000c6  e7ac              B        |L22.34|
;;;871    
                          ENDP

                  |L22.200|
                          DCD      0x40012800
                  |L22.204|
                          DCD      0x40012404

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1272     */
;;;1273   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1274   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
;;;1275     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1276     
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1279       
;;;1280     /* Verification if multimode is disabled (for devices with several ADC)     */
;;;1281     /* If multimode is enabled, dedicated function multimode conversion         */
;;;1282     /* start DMA must be used.                                                  */
;;;1283     if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
00000a  f8df8100          LDR      r8,|L23.268|
00000e  6820              LDR      r0,[r4,#0]
000010  4f3f              LDR      r7,|L23.272|
000012  f1080604          ADD      r6,r8,#4
000016  4540              CMP      r0,r8
000018  d001              BEQ      |L23.30|
00001a  42b8              CMP      r0,r7
00001c  d107              BNE      |L23.46|
                  |L23.30|
00001e  6830              LDR      r0,[r6,#0]
000020  f4102f70          TST      r0,#0xf0000
000024  d003              BEQ      |L23.46|
;;;1284     {
;;;1285       /* Process locked */
;;;1286       __HAL_LOCK(hadc);
;;;1287       
;;;1288       /* Enable the ADC peripheral */
;;;1289       tmp_hal_status = ADC_Enable(hadc);
;;;1290       
;;;1291       /* Start conversion if ADC is effectively enabled */
;;;1292       if (tmp_hal_status == HAL_OK)
;;;1293       {
;;;1294         /* Set ADC state                                                        */
;;;1295         /* - Clear state bitfield related to regular group conversion results   */
;;;1296         /* - Set state bitfield related to regular operation                    */
;;;1297         ADC_STATE_CLR_SET(hadc->State,
;;;1298                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1299                           HAL_ADC_STATE_REG_BUSY);
;;;1300       
;;;1301       /* Set group injected state (from auto-injection) and multimode state     */
;;;1302       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1303       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1304       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1305       {
;;;1306         /* Set ADC state (ADC independent or master) */
;;;1307         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1308         
;;;1309         /* If conversions on group regular are also triggering group injected,  */
;;;1310         /* update ADC state.                                                    */
;;;1311         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1312         {
;;;1313           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1314         }
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* Set ADC state (ADC slave) */
;;;1319         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1320         
;;;1321         /* If conversions on group regular are also triggering group injected,  */
;;;1322         /* update ADC state.                                                    */
;;;1323         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1324         {
;;;1325           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1326         }
;;;1327       }
;;;1328         
;;;1329         /* State machine update: Check if an injected conversion is ongoing */
;;;1330         if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1331         {
;;;1332           /* Reset ADC error code fields related to conversions on group regular */
;;;1333           CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1334         }
;;;1335         else
;;;1336         {
;;;1337           /* Reset ADC all error code fields */
;;;1338           ADC_CLEAR_ERRORCODE(hadc);
;;;1339         }
;;;1340         
;;;1341         /* Process unlocked */
;;;1342         /* Unlock before starting ADC conversions: in case of potential         */
;;;1343         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1344         __HAL_UNLOCK(hadc);
;;;1345         
;;;1346         /* Set the DMA transfer complete callback */
;;;1347         hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1348   
;;;1349         /* Set the DMA half transfer complete callback */
;;;1350         hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1351         
;;;1352         /* Set the DMA error callback */
;;;1353         hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1354   
;;;1355         
;;;1356         /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
;;;1357         /* start (in case of SW start):                                         */
;;;1358         
;;;1359         /* Clear regular group conversion flag and overrun flag */
;;;1360         /* (To ensure of no unknown state from potential previous ADC           */
;;;1361         /* operations)                                                          */
;;;1362         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1363         
;;;1364         /* Enable ADC DMA mode */
;;;1365         SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1366         
;;;1367         /* Start the DMA channel */
;;;1368         HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1369         
;;;1370         /* Enable conversion of regular group.                                  */
;;;1371         /* If software start has been selected, conversion starts immediately.  */
;;;1372         /* If external trigger has been selected, conversion will start at next */
;;;1373         /* trigger event.                                                       */
;;;1374         if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
;;;1375         {
;;;1376           /* Start ADC conversion on regular group with SW start */
;;;1377           SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1378         }
;;;1379         else
;;;1380         {
;;;1381           /* Start ADC conversion on regular group with external trigger */
;;;1382           SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1383         }
;;;1384       }
;;;1385       else
;;;1386       {
;;;1387         /* Process unlocked */
;;;1388         __HAL_UNLOCK(hadc);
;;;1389       }
;;;1390     }
;;;1391     else
;;;1392     {
;;;1393       tmp_hal_status = HAL_ERROR;
000026  2501              MOVS     r5,#1
                  |L23.40|
;;;1394     }
;;;1395     
;;;1396     /* Return function status */
;;;1397     return tmp_hal_status;
000028  4628              MOV      r0,r5
                  |L23.42|
;;;1398   }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L23.46|
00002e  f8940024          LDRB     r0,[r4,#0x24]         ;1286
000032  2801              CMP      r0,#1                 ;1286
000034  d00b              BEQ      |L23.78|
000036  2001              MOVS     r0,#1                 ;1286
000038  f8840024          STRB     r0,[r4,#0x24]         ;1286
00003c  4620              MOV      r0,r4                 ;1289
00003e  f7fffffe          BL       ADC_Enable
000042  4605              MOV      r5,r0                 ;1289
000044  2100              MOVS     r1,#0                 ;1292
000046  b125              CBZ      r5,|L23.82|
000048  f8841024          STRB     r1,[r4,#0x24]         ;1388
00004c  e7ec              B        |L23.40|
                  |L23.78|
00004e  2002              MOVS     r0,#2                 ;1286
000050  e7eb              B        |L23.42|
                  |L23.82|
000052  6aa0              LDR      r0,[r4,#0x28]         ;1297
000054  f6406201          MOV      r2,#0xe01             ;1297
000058  4390              BICS     r0,r0,r2              ;1297
00005a  f4407080          ORR      r0,r0,#0x100          ;1297
00005e  62a0              STR      r0,[r4,#0x28]         ;1297
000060  6820              LDR      r0,[r4,#0]            ;1304
000062  42b8              CMP      r0,r7                 ;1304
000064  d118              BNE      |L23.152|
000066  6832              LDR      r2,[r6,#0]            ;1304
000068  f4122f70          TST      r2,#0xf0000           ;1304
00006c  d014              BEQ      |L23.152|
00006e  6aa2              LDR      r2,[r4,#0x28]         ;1319
000070  f4421280          ORR      r2,r2,#0x100000       ;1319
000074  62a2              STR      r2,[r4,#0x28]         ;1319
000076  6830              LDR      r0,[r6,#0]            ;1323
000078  0540              LSLS     r0,r0,#21             ;1323
00007a  d505              BPL      |L23.136|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;1325
00007e  f4205000          BIC      r0,r0,#0x2000         ;1325
000082  f4405080          ORR      r0,r0,#0x1000         ;1325
000086  62a0              STR      r0,[r4,#0x28]         ;1325
                  |L23.136|
000088  6aa0              LDR      r0,[r4,#0x28]         ;1330
00008a  04c0              LSLS     r0,r0,#19             ;1330
00008c  d512              BPL      |L23.180|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;1333
000090  f0200006          BIC      r0,r0,#6              ;1333
000094  62e0              STR      r0,[r4,#0x2c]         ;1333
000096  e00e              B        |L23.182|
                  |L23.152|
000098  6aa2              LDR      r2,[r4,#0x28]         ;1307
00009a  f4221280          BIC      r2,r2,#0x100000       ;1307
00009e  62a2              STR      r2,[r4,#0x28]         ;1307
0000a0  6840              LDR      r0,[r0,#4]            ;1311
0000a2  0540              LSLS     r0,r0,#21             ;1311
0000a4  d5f0              BPL      |L23.136|
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;1313
0000a8  f4205000          BIC      r0,r0,#0x2000         ;1313
0000ac  f4405080          ORR      r0,r0,#0x1000         ;1313
0000b0  62a0              STR      r0,[r4,#0x28]         ;1313
0000b2  e7e9              B        |L23.136|
                  |L23.180|
0000b4  62e1              STR      r1,[r4,#0x2c]         ;1338
                  |L23.182|
0000b6  f8841024          STRB     r1,[r4,#0x24]         ;1344
0000ba  6a21              LDR      r1,[r4,#0x20]         ;1347
0000bc  4815              LDR      r0,|L23.276|
0000be  6288              STR      r0,[r1,#0x28]         ;1347
0000c0  6a21              LDR      r1,[r4,#0x20]         ;1350
0000c2  4815              LDR      r0,|L23.280|
0000c4  62c8              STR      r0,[r1,#0x2c]         ;1350
0000c6  6a21              LDR      r1,[r4,#0x20]         ;1353
0000c8  4814              LDR      r0,|L23.284|
0000ca  6308              STR      r0,[r1,#0x30]         ;1353
0000cc  6821              LDR      r1,[r4,#0]            ;1362
0000ce  f06f0002          MVN      r0,#2                 ;1362
0000d2  6008              STR      r0,[r1,#0]            ;1362
0000d4  6820              LDR      r0,[r4,#0]            ;1365
0000d6  6881              LDR      r1,[r0,#8]            ;1365
0000d8  f4417180          ORR      r1,r1,#0x100          ;1365
0000dc  6081              STR      r1,[r0,#8]            ;1365
0000de  6821              LDR      r1,[r4,#0]            ;1368
0000e0  4653              MOV      r3,r10                ;1368
0000e2  314c              ADDS     r1,r1,#0x4c           ;1368
0000e4  464a              MOV      r2,r9                 ;1368
0000e6  6a20              LDR      r0,[r4,#0x20]         ;1368
0000e8  f7fffffe          BL       HAL_DMA_Start_IT
0000ec  6820              LDR      r0,[r4,#0]            ;1374
0000ee  6881              LDR      r1,[r0,#8]            ;1374
0000f0  f3c14142          UBFX     r1,r1,#17,#3          ;1374
0000f4  2907              CMP      r1,#7                 ;1374
0000f6  d004              BEQ      |L23.258|
0000f8  6881              LDR      r1,[r0,#8]            ;1382
0000fa  f4411180          ORR      r1,r1,#0x100000       ;1382
0000fe  6081              STR      r1,[r0,#8]            ;1382
000100  e792              B        |L23.40|
                  |L23.258|
000102  6881              LDR      r1,[r0,#8]            ;1377
000104  f44101a0          ORR      r1,r1,#0x500000       ;1377
000108  6081              STR      r1,[r0,#8]            ;1377
00010a  e78d              B        |L23.40|
;;;1399   
                          ENDP

                  |L23.268|
                          DCD      0x40012400
                  |L23.272|
                          DCD      0x40012800
                  |L23.276|
                          DCD      ADC_DMAConvCplt
                  |L23.280|
                          DCD      ADC_DMAHalfConvCplt
                  |L23.284|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1106   {
000002  4604              MOV      r4,r0
;;;1107     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1108     
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1111     
;;;1112     /* Process locked */
;;;1113     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L24.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1114       
;;;1115     /* Enable the ADC peripheral */
;;;1116     tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;1117     
;;;1118     /* Start conversion if ADC is effectively enabled */
;;;1119     if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L24.42|
;;;1120     {
;;;1121       /* Set ADC state                                                          */
;;;1122       /* - Clear state bitfield related to regular group conversion results     */
;;;1123       /* - Set state bitfield related to regular operation                      */
;;;1124       ADC_STATE_CLR_SET(hadc->State,
;;;1125                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1126                         HAL_ADC_STATE_REG_BUSY);
;;;1127       
;;;1128       /* Set group injected state (from auto-injection) and multimode state     */
;;;1129       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1130       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1131       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1132       {
;;;1133         /* Set ADC state (ADC independent or master) */
;;;1134         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1135         
;;;1136         /* If conversions on group regular are also triggering group injected,  */
;;;1137         /* update ADC state.                                                    */
;;;1138         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1139         {
;;;1140           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1141         }
;;;1142       }
;;;1143       else
;;;1144       {
;;;1145         /* Set ADC state (ADC slave) */
;;;1146         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1147         
;;;1148         /* If conversions on group regular are also triggering group injected,  */
;;;1149         /* update ADC state.                                                    */
;;;1150         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1151         {
;;;1152           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1153         }
;;;1154       }
;;;1155       
;;;1156       /* State machine update: Check if an injected conversion is ongoing */
;;;1157       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1158       {
;;;1159         /* Reset ADC error code fields related to conversions on group regular */
;;;1160         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1161       }
;;;1162       else
;;;1163       {
;;;1164         /* Reset ADC all error code fields */
;;;1165         ADC_CLEAR_ERRORCODE(hadc);
;;;1166       }
;;;1167       
;;;1168       /* Process unlocked */
;;;1169       /* Unlock before starting ADC conversions: in case of potential           */
;;;1170       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1171       __HAL_UNLOCK(hadc);
;;;1172       
;;;1173       /* Clear regular group conversion flag and overrun flag */
;;;1174       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1175       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1176       
;;;1177       /* Enable end of conversion interrupt for regular group */
;;;1178       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;1179       
;;;1180       /* Enable conversion of regular group.                                    */
;;;1181       /* If software start has been selected, conversion starts immediately.    */
;;;1182       /* If external trigger has been selected, conversion will start at next   */
;;;1183       /* trigger event.                                                         */
;;;1184       /* Case of multimode enabled:                                             */ 
;;;1185       /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;1186       /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;1187       if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;1188           ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;1189       {
;;;1190         /* Start ADC conversion on regular group with SW start */
;;;1191         SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1192       }
;;;1193       else
;;;1194       {
;;;1195         /* Start ADC conversion on regular group with external trigger */
;;;1196         SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1197       }
;;;1198     }
;;;1199     else
;;;1200     {
;;;1201       /* Process unlocked */
;;;1202       __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L24.34|
;;;1203     }
;;;1204     
;;;1205     /* Return function status */
;;;1206     return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;1207   }
000024  bd70              POP      {r4-r6,pc}
                  |L24.38|
000026  2002              MOVS     r0,#2                 ;1113
000028  bd70              POP      {r4-r6,pc}
                  |L24.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;1124
00002c  f6406301          MOV      r3,#0xe01             ;1124
000030  4398              BICS     r0,r0,r3              ;1124
000032  f4407080          ORR      r0,r0,#0x100          ;1124
000036  62a0              STR      r0,[r4,#0x28]         ;1124
000038  4d26              LDR      r5,|L24.212|
00003a  6820              LDR      r0,[r4,#0]            ;1131
00003c  4b26              LDR      r3,|L24.216|
00003e  42a8              CMP      r0,r5                 ;1131
000040  d118              BNE      |L24.116|
000042  681e              LDR      r6,[r3,#0]            ;1131
000044  f4162f70          TST      r6,#0xf0000           ;1131
000048  d014              BEQ      |L24.116|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;1146
00004c  f4461680          ORR      r6,r6,#0x100000       ;1146
000050  62a6              STR      r6,[r4,#0x28]         ;1146
000052  681e              LDR      r6,[r3,#0]            ;1150
000054  0576              LSLS     r6,r6,#21             ;1150
000056  d505              BPL      |L24.100|
000058  6aa6              LDR      r6,[r4,#0x28]         ;1152
00005a  f4265600          BIC      r6,r6,#0x2000         ;1152
00005e  f4465680          ORR      r6,r6,#0x1000         ;1152
000062  62a6              STR      r6,[r4,#0x28]         ;1152
                  |L24.100|
000064  6aa6              LDR      r6,[r4,#0x28]         ;1157
000066  04f6              LSLS     r6,r6,#19             ;1157
000068  d512              BPL      |L24.144|
00006a  6ae6              LDR      r6,[r4,#0x2c]         ;1160
00006c  f0260606          BIC      r6,r6,#6              ;1160
000070  62e6              STR      r6,[r4,#0x2c]         ;1160
000072  e00e              B        |L24.146|
                  |L24.116|
000074  6aa6              LDR      r6,[r4,#0x28]         ;1134
000076  f4261680          BIC      r6,r6,#0x100000       ;1134
00007a  62a6              STR      r6,[r4,#0x28]         ;1134
00007c  6846              LDR      r6,[r0,#4]            ;1138
00007e  0576              LSLS     r6,r6,#21             ;1138
000080  d5f0              BPL      |L24.100|
000082  6aa6              LDR      r6,[r4,#0x28]         ;1140
000084  f4265600          BIC      r6,r6,#0x2000         ;1140
000088  f4465680          ORR      r6,r6,#0x1000         ;1140
00008c  62a6              STR      r6,[r4,#0x28]         ;1140
00008e  e7e9              B        |L24.100|
                  |L24.144|
000090  62e2              STR      r2,[r4,#0x2c]         ;1165
                  |L24.146|
000092  f8842024          STRB     r2,[r4,#0x24]         ;1171
000096  f06f0202          MVN      r2,#2                 ;1175
00009a  6002              STR      r2,[r0,#0]            ;1175
00009c  6820              LDR      r0,[r4,#0]            ;1178
00009e  6842              LDR      r2,[r0,#4]            ;1178
0000a0  f0420220          ORR      r2,r2,#0x20           ;1178
0000a4  6042              STR      r2,[r0,#4]            ;1178
0000a6  6820              LDR      r0,[r4,#0]            ;1187
0000a8  6882              LDR      r2,[r0,#8]            ;1187
0000aa  f3c24242          UBFX     r2,r2,#17,#3          ;1187
0000ae  2a07              CMP      r2,#7                 ;1187
0000b0  d105              BNE      |L24.190|
0000b2  42a8              CMP      r0,r5                 ;1188
0000b4  d108              BNE      |L24.200|
0000b6  681a              LDR      r2,[r3,#0]            ;1188
0000b8  f4122f70          TST      r2,#0xf0000           ;1188
0000bc  d004              BEQ      |L24.200|
                  |L24.190|
0000be  6882              LDR      r2,[r0,#8]            ;1196
0000c0  f4421280          ORR      r2,r2,#0x100000       ;1196
0000c4  6082              STR      r2,[r0,#8]            ;1196
0000c6  e7ac              B        |L24.34|
                  |L24.200|
0000c8  6882              LDR      r2,[r0,#8]            ;1191
0000ca  f44202a0          ORR      r2,r2,#0x500000       ;1191
0000ce  6082              STR      r2,[r0,#8]            ;1191
0000d0  e7a7              B        |L24.34|
;;;1208   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L24.212|
                          DCD      0x40012800
                  |L24.216|
                          DCD      0x40012404

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;880      */
;;;881    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;882    {
000002  4604              MOV      r4,r0
;;;883      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;884      
;;;885      /* Check the parameters */
;;;886      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;887         
;;;888      /* Process locked */
;;;889      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L25.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;890      
;;;891      /* Stop potential conversion on going, on regular and injected groups */
;;;892      /* Disable ADC peripheral */
;;;893      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L25.32|
00001a  e007              B        |L25.44|
                  |L25.28|
00001c  2002              MOVS     r0,#2                 ;889
;;;894      
;;;895      /* Check if ADC is effectively disabled */
;;;896      if (tmp_hal_status == HAL_OK)
;;;897      {
;;;898        /* Set ADC state */
;;;899        ADC_STATE_CLR_SET(hadc->State,
;;;900                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;901                          HAL_ADC_STATE_READY);
;;;902      }
;;;903      
;;;904      /* Process unlocked */
;;;905      __HAL_UNLOCK(hadc);
;;;906      
;;;907      /* Return function status */
;;;908      return tmp_hal_status;
;;;909    }
00001e  bd10              POP      {r4,pc}
                  |L25.32|
000020  6aa1              LDR      r1,[r4,#0x28]         ;899
000022  f4215188          BIC      r1,r1,#0x1100         ;899
000026  f0410101          ORR      r1,r1,#1              ;899
00002a  62a1              STR      r1,[r4,#0x28]         ;899
                  |L25.44|
00002c  2100              MOVS     r1,#0                 ;905
00002e  f8841024          STRB     r1,[r4,#0x24]         ;905
000032  bd10              POP      {r4,pc}
;;;910    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;1413     */
;;;1414   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1415   {
000002  4604              MOV      r4,r0
;;;1416     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1417     
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1420        
;;;1421     /* Process locked */
;;;1422     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L26.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1423     
;;;1424     /* Stop potential conversion on going, on regular and injected groups */
;;;1425     /* Disable ADC peripheral */
;;;1426     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L26.32|
00001a  e00e              B        |L26.58|
                  |L26.28|
00001c  2002              MOVS     r0,#2                 ;1422
;;;1427     
;;;1428     /* Check if ADC is effectively disabled */
;;;1429     if (tmp_hal_status == HAL_OK)
;;;1430     {
;;;1431       /* Disable ADC DMA mode */
;;;1432       CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1433       
;;;1434       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1435       /* DMA transfer is on going)                                              */
;;;1436       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1437       
;;;1438       /* Check if DMA channel effectively disabled */
;;;1439       if (tmp_hal_status == HAL_OK)
;;;1440       {
;;;1441         /* Set ADC state */
;;;1442         ADC_STATE_CLR_SET(hadc->State,
;;;1443                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1444                           HAL_ADC_STATE_READY);
;;;1445       }
;;;1446       else
;;;1447       {
;;;1448         /* Update ADC state machine to error */
;;;1449         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1450       }
;;;1451     }
;;;1452       
;;;1453     /* Process unlocked */
;;;1454     __HAL_UNLOCK(hadc);
;;;1455       
;;;1456     /* Return function status */
;;;1457     return tmp_hal_status;
;;;1458   }
00001e  bd10              POP      {r4,pc}
                  |L26.32|
000020  6820              LDR      r0,[r4,#0]            ;1432
000022  6881              LDR      r1,[r0,#8]            ;1432
000024  f4217180          BIC      r1,r1,#0x100          ;1432
000028  6081              STR      r1,[r0,#8]            ;1432
00002a  6a20              LDR      r0,[r4,#0x20]         ;1436
00002c  f7fffffe          BL       HAL_DMA_Abort
000030  b138              CBZ      r0,|L26.66|
000032  6aa1              LDR      r1,[r4,#0x28]         ;1449
000034  f0410140          ORR      r1,r1,#0x40           ;1449
000038  62a1              STR      r1,[r4,#0x28]         ;1449
                  |L26.58|
00003a  2100              MOVS     r1,#0                 ;1454
00003c  f8841024          STRB     r1,[r4,#0x24]         ;1454
000040  bd10              POP      {r4,pc}
                  |L26.66|
000042  6aa1              LDR      r1,[r4,#0x28]         ;1442
000044  f4215188          BIC      r1,r1,#0x1100         ;1442
000048  f0410101          ORR      r1,r1,#1              ;1442
00004c  62a1              STR      r1,[r4,#0x28]         ;1442
00004e  e7f4              B        |L26.58|
;;;1459   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;1215     */
;;;1216   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1217   {
000002  4604              MOV      r4,r0
;;;1218     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1219     
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1222        
;;;1223     /* Process locked */
;;;1224     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L27.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1225     
;;;1226     /* Stop potential conversion on going, on regular and injected groups */
;;;1227     /* Disable ADC peripheral */
;;;1228     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L27.32|
00001a  e00c              B        |L27.54|
                  |L27.28|
00001c  2002              MOVS     r0,#2                 ;1224
;;;1229     
;;;1230     /* Check if ADC is effectively disabled */
;;;1231     if (tmp_hal_status == HAL_OK)
;;;1232     {
;;;1233       /* Disable ADC end of conversion interrupt for regular group */
;;;1234       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
;;;1235       
;;;1236       /* Set ADC state */
;;;1237       ADC_STATE_CLR_SET(hadc->State,
;;;1238                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1239                         HAL_ADC_STATE_READY);
;;;1240     }
;;;1241     
;;;1242     /* Process unlocked */
;;;1243     __HAL_UNLOCK(hadc);
;;;1244     
;;;1245     /* Return function status */
;;;1246     return tmp_hal_status;
;;;1247   }
00001e  bd10              POP      {r4,pc}
                  |L27.32|
000020  6821              LDR      r1,[r4,#0]            ;1234
000022  684a              LDR      r2,[r1,#4]            ;1234
000024  f0220220          BIC      r2,r2,#0x20           ;1234
000028  604a              STR      r2,[r1,#4]            ;1234
00002a  6aa1              LDR      r1,[r4,#0x28]         ;1237
00002c  f4215188          BIC      r1,r1,#0x1100         ;1237
000030  f0410101          ORR      r1,r1,#1              ;1237
000034  62a1              STR      r1,[r4,#0x28]         ;1237
                  |L27.54|
000036  2100              MOVS     r1,#0                 ;1243
000038  f8841024          STRB     r1,[r4,#0x24]         ;1243
00003c  bd10              POP      {r4,pc}
;;;1248   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH|
#line 456
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX|
#line 643
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
