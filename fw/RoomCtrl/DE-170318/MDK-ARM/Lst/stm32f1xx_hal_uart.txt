; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_uart.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_uart.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1946     */
;;;1947   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1948   {
;;;1949     uint32_t tmpreg = 0x00U;
;;;1950   
;;;1951     /* Process Locked */
;;;1952     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L1.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1953   
;;;1954     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1955   
;;;1956     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1957     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1958   
;;;1959     /* Clear TE and RE bits */
;;;1960     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1961   
;;;1962     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1963     tmpreg |= (uint32_t)USART_CR1_RE;
00001c  f0420204          ORR      r2,r2,#4
;;;1964   
;;;1965     /* Write to USART CR1 */
;;;1966     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1967   
;;;1968     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1969   
;;;1970     /* Process Unlocked */
;;;1971     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1972     
;;;1973     return HAL_OK; 
00002a  2000              MOVS     r0,#0
;;;1974   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;1952
000030  4770              BX       lr
;;;1975   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1911     */
;;;1912   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1913   {
;;;1914     uint32_t tmpreg = 0x00U;
;;;1915   
;;;1916     /* Process Locked */
;;;1917     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L2.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1918     
;;;1919     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1920   
;;;1921     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1922     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;1923   
;;;1924     /* Clear TE and RE bits */
;;;1925     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;1926   
;;;1927     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1928     tmpreg |= (uint32_t)USART_CR1_TE;
00001c  f0420208          ORR      r2,r2,#8
;;;1929   
;;;1930     /* Write to USART CR1 */
;;;1931     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;1932   
;;;1933     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;1934     
;;;1935     /* Process Unlocked */
;;;1936     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;1937     
;;;1938     return HAL_OK; 
00002a  2000              MOVS     r0,#0
;;;1939   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;1917
000030  4770              BX       lr
;;;1940   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;330      */
;;;331    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4604              MOV      r4,r0
;;;333      /* Check the UART handle allocation */
;;;334      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L3.18|
;;;335      {
;;;336        return HAL_ERROR;
;;;337      }
;;;338     
;;;339      /* Check the parameters */ 
;;;340      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;341      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;342    #if defined(USART_CR1_OVER8)
;;;343      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;344    #endif /* USART_CR1_OVER8 */
;;;345      if(huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L3.22|
000010  e006              B        |L3.32|
                  |L3.18|
000012  2001              MOVS     r0,#1                 ;336
;;;346      {
;;;347        /* Allocate lock resource and initialize it */
;;;348        huart->Lock = HAL_UNLOCKED;
;;;349        /* Init the low level hardware */
;;;350        HAL_UART_MspInit(huart);
;;;351      }
;;;352    
;;;353      huart->gState = HAL_UART_STATE_BUSY;
;;;354    
;;;355      /* Disable the peripheral */
;;;356      __HAL_UART_DISABLE(huart);
;;;357      
;;;358      /* Set the UART Communication parameters */
;;;359      UART_SetConfig(huart);
;;;360      
;;;361      /* In half-duplex mode, the following bits must be kept cleared:
;;;362         - LINEN and CLKEN bits in the USART_CR2 register,
;;;363         - SCEN and IREN bits in the USART_CR3 register.*/
;;;364      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;365      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;366      
;;;367      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;368      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;369     
;;;370      /* Enable the peripheral */
;;;371      __HAL_UART_ENABLE(huart);
;;;372      
;;;373      /* Initialize the UART state*/
;;;374      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;375      huart->gState= HAL_UART_STATE_READY;
;;;376      huart->RxState= HAL_UART_STATE_READY;
;;;377      
;;;378      return HAL_OK;
;;;379    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;348
00001a  4620              MOV      r0,r4                 ;350
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L3.32|
000020  2024              MOVS     r0,#0x24              ;353
000022  f8840039          STRB     r0,[r4,#0x39]         ;353
000026  6820              LDR      r0,[r4,#0]            ;356
000028  68c1              LDR      r1,[r0,#0xc]          ;356
00002a  f4215100          BIC      r1,r1,#0x2000         ;356
00002e  60c1              STR      r1,[r0,#0xc]          ;356
000030  4620              MOV      r0,r4                 ;359
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;364
000038  6901              LDR      r1,[r0,#0x10]         ;364
00003a  f4214190          BIC      r1,r1,#0x4800         ;364
00003e  6101              STR      r1,[r0,#0x10]         ;364
000040  6820              LDR      r0,[r4,#0]            ;365
000042  6941              LDR      r1,[r0,#0x14]         ;365
000044  f0210122          BIC      r1,r1,#0x22           ;365
000048  6141              STR      r1,[r0,#0x14]         ;365
00004a  6820              LDR      r0,[r4,#0]            ;368
00004c  6941              LDR      r1,[r0,#0x14]         ;368
00004e  f0410108          ORR      r1,r1,#8              ;368
000052  6141              STR      r1,[r0,#0x14]         ;368
000054  6820              LDR      r0,[r4,#0]            ;371
000056  68c1              LDR      r1,[r0,#0xc]          ;371
000058  f4415100          ORR      r1,r1,#0x2000         ;371
00005c  60c1              STR      r1,[r0,#0xc]          ;371
00005e  63e5              STR      r5,[r4,#0x3c]         ;374
000060  2020              MOVS     r0,#0x20              ;375
000062  f8840039          STRB     r0,[r4,#0x39]         ;375
000066  f884003a          STRB     r0,[r4,#0x3a]         ;376
00006a  2000              MOVS     r0,#0                 ;378
00006c  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;393    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;394      /* Check the UART handle allocation */
;;;395      if(huart == NULL)
000006  2c00              CMP      r4,#0
000008  d004              BEQ      |L4.20|
;;;396      {
;;;397        return HAL_ERROR;
;;;398      }
;;;399      
;;;400      /* Check the LIN UART instance */  
;;;401      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;402      /* Check the Break detection length parameter */
;;;403      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;404      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;405    #if defined(USART_CR1_OVER8)
;;;406      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;407    #endif /* USART_CR1_OVER8 */
;;;408      
;;;409      if(huart->gState == HAL_UART_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  2500              MOVS     r5,#0
000010  b110              CBZ      r0,|L4.24|
000012  e006              B        |L4.34|
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;397
;;;410      {
;;;411        /* Allocate lock resource and initialize it */
;;;412        huart->Lock = HAL_UNLOCKED;
;;;413        /* Init the low level hardware */
;;;414        HAL_UART_MspInit(huart);
;;;415      }
;;;416    
;;;417      huart->gState = HAL_UART_STATE_BUSY;
;;;418    
;;;419      /* Disable the peripheral */
;;;420      __HAL_UART_DISABLE(huart);
;;;421      
;;;422      /* Set the UART Communication parameters */
;;;423      UART_SetConfig(huart);
;;;424      
;;;425      /* In LIN mode, the following bits must be kept cleared: 
;;;426         - CLKEN bits in the USART_CR2 register,
;;;427         - SCEN and IREN bits in the USART_CR3 register.*/
;;;428      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;429      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;430      
;;;431      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;432      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;433      
;;;434      /* Set the USART LIN Break detection length. */
;;;435      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;436      
;;;437      /* Enable the peripheral */
;;;438      __HAL_UART_ENABLE(huart);
;;;439      
;;;440      /* Initialize the UART state*/
;;;441      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;442      huart->gState= HAL_UART_STATE_READY;
;;;443      huart->RxState= HAL_UART_STATE_READY;
;;;444      
;;;445      return HAL_OK;
;;;446    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  f8845038          STRB     r5,[r4,#0x38]         ;412
00001c  4620              MOV      r0,r4                 ;414
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L4.34|
000022  2024              MOVS     r0,#0x24              ;417
000024  f8840039          STRB     r0,[r4,#0x39]         ;417
000028  6820              LDR      r0,[r4,#0]            ;420
00002a  68c1              LDR      r1,[r0,#0xc]          ;420
00002c  f4215100          BIC      r1,r1,#0x2000         ;420
000030  60c1              STR      r1,[r0,#0xc]          ;420
000032  4620              MOV      r0,r4                 ;423
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;428
00003a  6901              LDR      r1,[r0,#0x10]         ;428
00003c  f4216100          BIC      r1,r1,#0x800          ;428
000040  6101              STR      r1,[r0,#0x10]         ;428
000042  6820              LDR      r0,[r4,#0]            ;429
000044  6941              LDR      r1,[r0,#0x14]         ;429
000046  f021012a          BIC      r1,r1,#0x2a           ;429
00004a  6141              STR      r1,[r0,#0x14]         ;429
00004c  6820              LDR      r0,[r4,#0]            ;432
00004e  6901              LDR      r1,[r0,#0x10]         ;432
000050  f4414180          ORR      r1,r1,#0x4000         ;432
000054  6101              STR      r1,[r0,#0x10]         ;432
000056  6820              LDR      r0,[r4,#0]            ;435
000058  6901              LDR      r1,[r0,#0x10]         ;435
00005a  f0210120          BIC      r1,r1,#0x20           ;435
00005e  4331              ORRS     r1,r1,r6              ;435
000060  6101              STR      r1,[r0,#0x10]         ;435
000062  6820              LDR      r0,[r4,#0]            ;438
000064  68c1              LDR      r1,[r0,#0xc]          ;438
000066  f4415100          ORR      r1,r1,#0x2000         ;438
00006a  60c1              STR      r1,[r0,#0xc]          ;438
00006c  63e5              STR      r5,[r4,#0x3c]         ;441
00006e  2020              MOVS     r0,#0x20              ;442
000070  f8840039          STRB     r0,[r4,#0x39]         ;442
000074  f884003a          STRB     r0,[r4,#0x3a]         ;443
000078  2000              MOVS     r0,#0                 ;445
00007a  bd70              POP      {r4-r6,pc}
;;;447    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1830     */
;;;1831   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1832   {
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1835     
;;;1836     /* Process Locked */
;;;1837     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1838     
;;;1839     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1840     
;;;1841     /* Send break characters */
;;;1842     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420201          ORR      r2,r2,#1
00001c  60ca              STR      r2,[r1,#0xc]
;;;1843    
;;;1844     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1845     
;;;1846     /* Process Unlocked */
;;;1847     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1848     
;;;1849     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1850   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;1837
00002c  4770              BX       lr
;;;1851   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1857     */
;;;1858   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1859   {
;;;1860     /* Check the parameters */
;;;1861     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1862     
;;;1863     /* Process Locked */
;;;1864     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L6.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1865     
;;;1866     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1867     
;;;1868     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1869     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420202          ORR      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1870     
;;;1871     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1872     
;;;1873     /* Process Unlocked */
;;;1874     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1875     
;;;1876     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1877   }
000028  4770              BX       lr
                  |L6.42|
00002a  2002              MOVS     r0,#2                 ;1864
00002c  4770              BX       lr
;;;1878   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1884     */
;;;1885   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1886   {
;;;1887     /* Check the parameters */
;;;1888     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1889     
;;;1890     /* Process Locked */
;;;1891     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L7.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;1892     
;;;1893     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;1894     
;;;1895     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1896     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0220202          BIC      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;1897     
;;;1898     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;1899     
;;;1900     /* Process Unlocked */
;;;1901     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;1902     
;;;1903     return HAL_OK; 
000026  2000              MOVS     r0,#0
;;;1904   }
000028  4770              BX       lr
                  |L7.42|
00002a  2002              MOVS     r0,#2                 ;1891
00002c  4770              BX       lr
;;;1905   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;459      */
;;;460    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;461    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;462      /* Check the UART handle allocation */
;;;463      if(huart == NULL)
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L8.24|
;;;464      {
;;;465        return HAL_ERROR;
;;;466      }
;;;467    
;;;468      /* Check UART instance capabilities */  
;;;469      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;470    
;;;471      /* Check the Address & wake up method parameters */
;;;472      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;473      assert_param(IS_UART_ADDRESS(Address));
;;;474      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;475    #if defined(USART_CR1_OVER8)
;;;476      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;477    #endif /* USART_CR1_OVER8 */
;;;478    
;;;479      if(huart->gState == HAL_UART_STATE_RESET)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2500              MOVS     r5,#0
000014  b118              CBZ      r0,|L8.30|
000016  e007              B        |L8.40|
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;465
                  |L8.26|
;;;480      {
;;;481        /* Allocate lock resource and initialize it */
;;;482        huart->Lock = HAL_UNLOCKED;
;;;483        /* Init the low level hardware */
;;;484        HAL_UART_MspInit(huart);
;;;485      }
;;;486    
;;;487      huart->gState = HAL_UART_STATE_BUSY;
;;;488    
;;;489      /* Disable the peripheral */
;;;490      __HAL_UART_DISABLE(huart);
;;;491      
;;;492      /* Set the UART Communication parameters */
;;;493      UART_SetConfig(huart);
;;;494      
;;;495      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;496         - LINEN and CLKEN bits in the USART_CR2 register,
;;;497         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;498      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;499      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;500      
;;;501      /* Set the USART address node */
;;;502      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;503      
;;;504      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;505      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;506      
;;;507      /* Enable the peripheral */
;;;508      __HAL_UART_ENABLE(huart);
;;;509      
;;;510      /* Initialize the UART state */
;;;511      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;512      huart->gState = HAL_UART_STATE_READY;
;;;513      huart->RxState = HAL_UART_STATE_READY;
;;;514      
;;;515      return HAL_OK;
;;;516    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.30|
00001e  f8845038          STRB     r5,[r4,#0x38]         ;482
000022  4620              MOV      r0,r4                 ;484
000024  f7fffffe          BL       HAL_UART_MspInit
                  |L8.40|
000028  2024              MOVS     r0,#0x24              ;487
00002a  f8840039          STRB     r0,[r4,#0x39]         ;487
00002e  6820              LDR      r0,[r4,#0]            ;490
000030  68c1              LDR      r1,[r0,#0xc]          ;490
000032  f4215100          BIC      r1,r1,#0x2000         ;490
000036  60c1              STR      r1,[r0,#0xc]          ;490
000038  4620              MOV      r0,r4                 ;493
00003a  f7fffffe          BL       UART_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;498
000040  6901              LDR      r1,[r0,#0x10]         ;498
000042  f4214190          BIC      r1,r1,#0x4800         ;498
000046  6101              STR      r1,[r0,#0x10]         ;498
000048  6820              LDR      r0,[r4,#0]            ;499
00004a  6941              LDR      r1,[r0,#0x14]         ;499
00004c  f021012a          BIC      r1,r1,#0x2a           ;499
000050  6141              STR      r1,[r0,#0x14]         ;499
000052  6820              LDR      r0,[r4,#0]            ;502
000054  6901              LDR      r1,[r0,#0x10]         ;502
000056  f021010f          BIC      r1,r1,#0xf            ;502
00005a  4339              ORRS     r1,r1,r7              ;502
00005c  6101              STR      r1,[r0,#0x10]         ;502
00005e  6820              LDR      r0,[r4,#0]            ;505
000060  68c1              LDR      r1,[r0,#0xc]          ;505
000062  f4216100          BIC      r1,r1,#0x800          ;505
000066  4331              ORRS     r1,r1,r6              ;505
000068  60c1              STR      r1,[r0,#0xc]          ;505
00006a  6820              LDR      r0,[r4,#0]            ;508
00006c  68c1              LDR      r1,[r0,#0xc]          ;508
00006e  f4415100          ORR      r1,r1,#0x2000         ;508
000072  60c1              STR      r1,[r0,#0xc]          ;508
000074  63e5              STR      r5,[r4,#0x3c]         ;511
000076  2020              MOVS     r0,#0x20              ;512
000078  f8840039          STRB     r0,[r4,#0x39]         ;512
00007c  f884003a          STRB     r0,[r4,#0x3a]         ;513
000080  2000              MOVS     r0,#0                 ;515
000082  e7ca              B        |L8.26|
;;;517    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1165   */
;;;1166   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1167   {
000002  4604              MOV      r4,r0
;;;1168     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1169     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1170     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1171     
;;;1172     /* Disable the UART DMA Tx request if enabled */
;;;1173     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0609              LSLS     r1,r1,#24
000022  d509              BPL      |L9.56|
;;;1174     {
;;;1175       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210180          BIC      r1,r1,#0x80
00002a  6141              STR      r1,[r0,#0x14]
;;;1176   
;;;1177       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1178       if(huart->hdmatx != NULL)
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  b118              CBZ      r0,|L9.56|
;;;1179       {
;;;1180         /* Set the UART DMA Abort callback to Null. 
;;;1181            No call back execution at end of DMA abort procedure */
;;;1182         huart->hdmatx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1183   
;;;1184         HAL_DMA_Abort(huart->hdmatx);
000032  6b20              LDR      r0,[r4,#0x30]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L9.56|
;;;1185       }
;;;1186     }
;;;1187   
;;;1188     /* Disable the UART DMA Rx request if enabled */
;;;1189     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000038  6820              LDR      r0,[r4,#0]
00003a  6941              LDR      r1,[r0,#0x14]
00003c  0649              LSLS     r1,r1,#25
00003e  d509              BPL      |L9.84|
;;;1190     {
;;;1191       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6941              LDR      r1,[r0,#0x14]
000042  f0210140          BIC      r1,r1,#0x40
000046  6141              STR      r1,[r0,#0x14]
;;;1192   
;;;1193       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1194       if(huart->hdmarx != NULL)
000048  6b60              LDR      r0,[r4,#0x34]
00004a  b118              CBZ      r0,|L9.84|
;;;1195       {
;;;1196         /* Set the UART DMA Abort callback to Null. 
;;;1197            No call back execution at end of DMA abort procedure */
;;;1198         huart->hdmarx->XferAbortCallback = NULL;
00004c  6345              STR      r5,[r0,#0x34]
;;;1199   
;;;1200         HAL_DMA_Abort(huart->hdmarx);
00004e  6b60              LDR      r0,[r4,#0x34]
000050  f7fffffe          BL       HAL_DMA_Abort
                  |L9.84|
;;;1201       }
;;;1202     }
;;;1203   
;;;1204     /* Reset Tx and Rx transfer counters */
;;;1205     huart->TxXferCount = 0x00U;
000054  84e5              STRH     r5,[r4,#0x26]
;;;1206     huart->RxXferCount = 0x00U;
000056  85e5              STRH     r5,[r4,#0x2e]
;;;1207   
;;;1208     /* Reset ErrorCode */
;;;1209     huart->ErrorCode = HAL_UART_ERROR_NONE;
000058  63e5              STR      r5,[r4,#0x3c]
;;;1210   
;;;1211     /* Restore huart->RxState and huart->gState to Ready */
;;;1212     huart->RxState = HAL_UART_STATE_READY;
00005a  2020              MOVS     r0,#0x20
00005c  f884003a          STRB     r0,[r4,#0x3a]
;;;1213     huart->gState = HAL_UART_STATE_READY;
000060  f8840039          STRB     r0,[r4,#0x39]
;;;1214   
;;;1215     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1216   }
000066  bd70              POP      {r4-r6,pc}
;;;1217   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1762     */
;;;1763   __WEAK void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1764   {
;;;1765     /* Prevent unused argument(s) compilation warning */
;;;1766     UNUSED(huart);
;;;1767   
;;;1768     /* NOTE : This function should not be modified, when the callback is needed,
;;;1769               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1770      */
;;;1771   }
;;;1772   /**
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1271   */
;;;1272   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1273   {
000002  4604              MOV      r4,r0
;;;1274     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1275     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1276     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1277   
;;;1278     /* Disable the UART DMA Rx request if enabled */
;;;1279     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d509              BPL      |L11.56|
;;;1280     {
;;;1281       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6141              STR      r1,[r0,#0x14]
;;;1282   
;;;1283       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1284       if(huart->hdmarx != NULL)
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  b118              CBZ      r0,|L11.56|
;;;1285       {
;;;1286         /* Set the UART DMA Abort callback to Null. 
;;;1287            No call back execution at end of DMA abort procedure */
;;;1288         huart->hdmarx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1289   
;;;1290         HAL_DMA_Abort(huart->hdmarx);
000032  6b60              LDR      r0,[r4,#0x34]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L11.56|
;;;1291       }
;;;1292     }
;;;1293   
;;;1294     /* Reset Rx transfer counter */
;;;1295     huart->RxXferCount = 0x00U;
000038  85e5              STRH     r5,[r4,#0x2e]
;;;1296   
;;;1297     /* Restore huart->RxState to Ready */
;;;1298     huart->RxState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  f884003a          STRB     r0,[r4,#0x3a]
;;;1299   
;;;1300     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1301   }
000042  bd70              POP      {r4-r6,pc}
;;;1302   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1791     */
;;;1792   __WEAK void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1793   {
;;;1794     /* Prevent unused argument(s) compilation warning */
;;;1795     UNUSED(huart);
;;;1796   
;;;1797     /* NOTE : This function should not be modified, when the callback is needed,
;;;1798               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1799      */
;;;1800   }
;;;1801   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1503   */
;;;1504   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1505   {
000002  4604              MOV      r4,r0
;;;1506     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1507     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1508     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1509   
;;;1510     /* Disable the UART DMA Rx request if enabled */
;;;1511     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0200          MOV      r2,#0
000020  064b              LSLS     r3,r1,#25
;;;1512     {
;;;1513       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1514   
;;;1515       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1516       if(huart->hdmarx != NULL)
;;;1517       {
;;;1518         /* Set the UART DMA Abort callback : 
;;;1519            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1520         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1521   
;;;1522         /* Abort DMA RX */
;;;1523         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1524         {
;;;1525           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1526           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1527         }
;;;1528       }
;;;1529       else
;;;1530       {
;;;1531         /* Reset Rx transfer counter */
;;;1532         huart->RxXferCount = 0x00U;
;;;1533   
;;;1534         /* Restore huart->RxState to Ready */
;;;1535         huart->RxState = HAL_UART_STATE_READY;
000022  f04f0120          MOV      r1,#0x20
000026  d516              BPL      |L13.86|
000028  6943              LDR      r3,[r0,#0x14]         ;1513
00002a  f0230340          BIC      r3,r3,#0x40           ;1513
00002e  6143              STR      r3,[r0,#0x14]         ;1513
000030  6b60              LDR      r0,[r4,#0x34]         ;1516
000032  b148              CBZ      r0,|L13.72|
000034  490c              LDR      r1,|L13.104|
000036  6341              STR      r1,[r0,#0x34]         ;1520
000038  6b60              LDR      r0,[r4,#0x34]         ;1523
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  b180              CBZ      r0,|L13.98|
000040  6b60              LDR      r0,[r4,#0x34]         ;1526
000042  6b41              LDR      r1,[r0,#0x34]         ;1526
000044  4788              BLX      r1                    ;1526
000046  e00c              B        |L13.98|
                  |L13.72|
000048  85e2              STRH     r2,[r4,#0x2e]         ;1532
00004a  f884103a          STRB     r1,[r4,#0x3a]
;;;1536   
;;;1537         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1538         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000054  e005              B        |L13.98|
                  |L13.86|
;;;1539       }
;;;1540     }
;;;1541     else
;;;1542     {
;;;1543       /* Reset Rx transfer counter */
;;;1544       huart->RxXferCount = 0x00U;
000056  85e2              STRH     r2,[r4,#0x2e]
;;;1545   
;;;1546       /* Restore huart->RxState to Ready */
;;;1547       huart->RxState = HAL_UART_STATE_READY;
000058  f884103a          STRB     r1,[r4,#0x3a]
;;;1548   
;;;1549       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1550       HAL_UART_AbortReceiveCpltCallback(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.98|
;;;1551     }
;;;1552   
;;;1553     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;1554   }
000064  bd10              POP      {r4,pc}
;;;1555   
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1229   */
;;;1230   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1231   {
000002  4604              MOV      r4,r0
;;;1232     /* Disable TXEIE and TCIE interrupts */
;;;1233     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1234   
;;;1235     /* Disable the UART DMA Tx request if enabled */
;;;1236     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d509              BPL      |L14.46|
;;;1237     {
;;;1238       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6141              STR      r1,[r0,#0x14]
;;;1239   
;;;1240       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1241       if(huart->hdmatx != NULL)
000022  6b20              LDR      r0,[r4,#0x30]
000024  b118              CBZ      r0,|L14.46|
;;;1242       {
;;;1243         /* Set the UART DMA Abort callback to Null. 
;;;1244            No call back execution at end of DMA abort procedure */
;;;1245         huart->hdmatx->XferAbortCallback = NULL;
000026  6345              STR      r5,[r0,#0x34]
;;;1246   
;;;1247         HAL_DMA_Abort(huart->hdmatx);
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L14.46|
;;;1248       }
;;;1249     }
;;;1250   
;;;1251     /* Reset Tx transfer counter */
;;;1252     huart->TxXferCount = 0x00U;
00002e  84e5              STRH     r5,[r4,#0x26]
;;;1253   
;;;1254     /* Restore huart->gState to Ready */
;;;1255     huart->gState = HAL_UART_STATE_READY;
000030  2020              MOVS     r0,#0x20
000032  f8840039          STRB     r0,[r4,#0x39]
;;;1256   
;;;1257     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1258   }
000038  bd70              POP      {r4-r6,pc}
;;;1259   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1776     */
;;;1777   __WEAK void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1778   {
;;;1779     /* Prevent unused argument(s) compilation warning */
;;;1780     UNUSED(huart);
;;;1781   
;;;1782     /* NOTE : This function should not be modified, when the callback is needed,
;;;1783               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1784      */
;;;1785   }
;;;1786   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1438   */
;;;1439   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1440   {
000002  4604              MOV      r4,r0
;;;1441     /* Disable TXEIE and TCIE interrupts */
;;;1442     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1443   
;;;1444     /* Disable the UART DMA Tx request if enabled */
;;;1445     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1446     {
;;;1447       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1448   
;;;1449       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1450       if(huart->hdmatx != NULL)
;;;1451       {
;;;1452         /* Set the UART DMA Abort callback : 
;;;1453            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1454         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1455   
;;;1456         /* Abort DMA TX */
;;;1457         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1458         {
;;;1459           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1460           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1461         }
;;;1462       }
;;;1463       else
;;;1464       {
;;;1465         /* Reset Tx transfer counter */
;;;1466         huart->TxXferCount = 0x00U;
;;;1467   
;;;1468         /* Restore huart->gState to Ready */
;;;1469         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;1445
000018  f04f0100          MOV      r1,#0                 ;1445
00001c  d516              BPL      |L16.76|
00001e  6943              LDR      r3,[r0,#0x14]         ;1447
000020  f0230380          BIC      r3,r3,#0x80           ;1447
000024  6143              STR      r3,[r0,#0x14]         ;1447
000026  6b20              LDR      r0,[r4,#0x30]         ;1450
000028  b148              CBZ      r0,|L16.62|
00002a  490c              LDR      r1,|L16.92|
00002c  6341              STR      r1,[r0,#0x34]         ;1454
00002e  6b20              LDR      r0,[r4,#0x30]         ;1457
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b180              CBZ      r0,|L16.88|
000036  6b20              LDR      r0,[r4,#0x30]         ;1460
000038  6b41              LDR      r1,[r0,#0x34]         ;1460
00003a  4788              BLX      r1                    ;1460
00003c  e00c              B        |L16.88|
                  |L16.62|
00003e  84e1              STRH     r1,[r4,#0x26]         ;1466
000040  f8842039          STRB     r2,[r4,#0x39]
;;;1470   
;;;1471         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1472         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
00004a  e005              B        |L16.88|
                  |L16.76|
;;;1473       }
;;;1474     }
;;;1475     else
;;;1476     {
;;;1477       /* Reset Tx transfer counter */
;;;1478       huart->TxXferCount = 0x00U;
00004c  84e1              STRH     r1,[r4,#0x26]
;;;1479   
;;;1480       /* Restore huart->gState to Ready */
;;;1481       huart->gState = HAL_UART_STATE_READY;
00004e  f8842039          STRB     r2,[r4,#0x39]
;;;1482   
;;;1483       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1484       HAL_UART_AbortTransmitCpltCallback(huart);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.88|
;;;1485     }
;;;1486   
;;;1487     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1488   }
00005a  bd10              POP      {r4,pc}
;;;1489   
                          ENDP

                  |L16.92|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1316   */
;;;1317   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1318   {
000002  4604              MOV      r4,r0
;;;1319     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1320   
;;;1321     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1322     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1323     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
;;;1324   
;;;1325     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1326        before any call to DMA Abort functions */
;;;1327     /* DMA Tx Handle is valid */
;;;1328     if(huart->hdmatx != NULL)
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  2600              MOVS     r6,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L17.50|
;;;1329     {
;;;1330       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1331          Otherwise, set it to NULL */
;;;1332       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6949              LDR      r1,[r1,#0x14]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L17.48|
;;;1333       {
;;;1334         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4920              LDR      r1,|L17.172|
00002c  6341              STR      r1,[r0,#0x34]
00002e  e000              B        |L17.50|
                  |L17.48|
;;;1335       }
;;;1336       else
;;;1337       {
;;;1338         huart->hdmatx->XferAbortCallback = NULL;
000030  6346              STR      r6,[r0,#0x34]
                  |L17.50|
;;;1339       }
;;;1340     }
;;;1341     /* DMA Rx Handle is valid */
;;;1342     if(huart->hdmarx != NULL)
000032  6b60              LDR      r0,[r4,#0x34]
000034  b138              CBZ      r0,|L17.70|
;;;1343     {
;;;1344       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1345          Otherwise, set it to NULL */
;;;1346       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000036  6821              LDR      r1,[r4,#0]
000038  6949              LDR      r1,[r1,#0x14]
00003a  0649              LSLS     r1,r1,#25
00003c  d502              BPL      |L17.68|
;;;1347       {
;;;1348         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003e  491c              LDR      r1,|L17.176|
000040  6341              STR      r1,[r0,#0x34]
000042  e000              B        |L17.70|
                  |L17.68|
;;;1349       }
;;;1350       else
;;;1351       {
;;;1352         huart->hdmarx->XferAbortCallback = NULL;
000044  6346              STR      r6,[r0,#0x34]
                  |L17.70|
;;;1353       }
;;;1354     }
;;;1355   
;;;1356     /* Disable the UART DMA Tx request if enabled */
;;;1357     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  0609              LSLS     r1,r1,#24
00004c  d50c              BPL      |L17.104|
;;;1358     {
;;;1359       /* Disable DMA Tx at UART level */
;;;1360       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1361   
;;;1362       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1363       if(huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1364       {
;;;1365         /* UART Tx DMA Abort callback has already been initialised : 
;;;1366            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1367   
;;;1368         /* Abort DMA TX */
;;;1369         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  b110              CBZ      r0,|L17.102|
;;;1370         {
;;;1371           huart->hdmatx->XferAbortCallback = NULL;
000060  6b20              LDR      r0,[r4,#0x30]
000062  6346              STR      r6,[r0,#0x34]
000064  e000              B        |L17.104|
                  |L17.102|
;;;1372         }
;;;1373         else
;;;1374         {
;;;1375           AbortCplt = 0x00U;
000066  2500              MOVS     r5,#0
                  |L17.104|
;;;1376         }
;;;1377       }
;;;1378     }
;;;1379   
;;;1380     /* Disable the UART DMA Rx request if enabled */
;;;1381     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  0649              LSLS     r1,r1,#25
00006e  d50d              BPL      |L17.140|
;;;1382     {
;;;1383       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  6941              LDR      r1,[r0,#0x14]
000072  f0210140          BIC      r1,r1,#0x40
000076  6141              STR      r1,[r0,#0x14]
;;;1384   
;;;1385       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1386       if(huart->hdmarx != NULL)
000078  6b60              LDR      r0,[r4,#0x34]
00007a  b138              CBZ      r0,|L17.140|
;;;1387       {
;;;1388         /* UART Rx DMA Abort callback has already been initialised : 
;;;1389            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1390   
;;;1391         /* Abort DMA RX */
;;;1392         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  b118              CBZ      r0,|L17.138|
;;;1393         {
;;;1394           huart->hdmarx->XferAbortCallback = NULL;
000082  6b60              LDR      r0,[r4,#0x34]
000084  6346              STR      r6,[r0,#0x34]
;;;1395           AbortCplt = 0x01U;
000086  2501              MOVS     r5,#1
000088  e000              B        |L17.140|
                  |L17.138|
;;;1396         }
;;;1397         else
;;;1398         {
;;;1399           AbortCplt = 0x00U;
00008a  2500              MOVS     r5,#0
                  |L17.140|
;;;1400         }
;;;1401       }
;;;1402     }
;;;1403   
;;;1404     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1405     if(AbortCplt == 0x01U)
00008c  2d01              CMP      r5,#1
00008e  d10a              BNE      |L17.166|
;;;1406     {
;;;1407       /* Reset Tx and Rx transfer counters */
;;;1408       huart->TxXferCount = 0x00U; 
000090  84e6              STRH     r6,[r4,#0x26]
;;;1409       huart->RxXferCount = 0x00U;
000092  85e6              STRH     r6,[r4,#0x2e]
;;;1410   
;;;1411       /* Reset ErrorCode */
;;;1412       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  63e6              STR      r6,[r4,#0x3c]
;;;1413   
;;;1414       /* Restore huart->gState and huart->RxState to Ready */
;;;1415       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  f8840039          STRB     r0,[r4,#0x39]
;;;1416       huart->RxState = HAL_UART_STATE_READY;
00009c  f884003a          STRB     r0,[r4,#0x3a]
;;;1417   
;;;1418       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1419       HAL_UART_AbortCpltCallback(huart);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.166|
;;;1420     }
;;;1421   
;;;1422     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1423   }
0000a8  bd70              POP      {r4-r6,pc}
;;;1424   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
                          DCD      UART_DMATxAbortCallback
                  |L17.176|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1040     */
;;;1041   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1042   {
;;;1043     uint32_t dmarequest = 0x00U;
;;;1044   
;;;1045     /* Process Locked */
;;;1046     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L18.32|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1047   
;;;1048     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f3c212c0          UBFX     r2,r2,#7,#1
;;;1049     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000016  f8903039          LDRB     r3,[r0,#0x39]
00001a  2b21              CMP      r3,#0x21
00001c  d002              BEQ      |L18.36|
00001e  e006              B        |L18.46|
                  |L18.32|
000020  2002              MOVS     r0,#2                 ;1046
;;;1050     {
;;;1051       /* Disable the UART DMA Tx request */
;;;1052       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1053     }
;;;1054   
;;;1055     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1056     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1057     {
;;;1058       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1059       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1060       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1061   
;;;1062       /* Disable the UART DMA Rx request */
;;;1063       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1064     }
;;;1065   
;;;1066     /* Process Unlocked */
;;;1067     __HAL_UNLOCK(huart);
;;;1068     
;;;1069     return HAL_OK;
;;;1070   }
000022  4770              BX       lr
                  |L18.36|
000024  b11a              CBZ      r2,|L18.46|
000026  694a              LDR      r2,[r1,#0x14]         ;1052
000028  f0220280          BIC      r2,r2,#0x80           ;1052
00002c  614a              STR      r2,[r1,#0x14]         ;1052
                  |L18.46|
00002e  6801              LDR      r1,[r0,#0]            ;1055
000030  694a              LDR      r2,[r1,#0x14]         ;1055
000032  f3c21280          UBFX     r2,r2,#6,#1           ;1055
000036  f890303a          LDRB     r3,[r0,#0x3a]         ;1056
00003a  2b22              CMP      r3,#0x22              ;1056
00003c  d10e              BNE      |L18.92|
00003e  b16a              CBZ      r2,|L18.92|
000040  68ca              LDR      r2,[r1,#0xc]          ;1059
000042  f4227280          BIC      r2,r2,#0x100          ;1059
000046  60ca              STR      r2,[r1,#0xc]          ;1059
000048  6801              LDR      r1,[r0,#0]            ;1060
00004a  694a              LDR      r2,[r1,#0x14]         ;1060
00004c  f0220201          BIC      r2,r2,#1              ;1060
000050  614a              STR      r2,[r1,#0x14]         ;1060
000052  6801              LDR      r1,[r0,#0]            ;1063
000054  694a              LDR      r2,[r1,#0x14]         ;1063
000056  f0220240          BIC      r2,r2,#0x40           ;1063
00005a  614a              STR      r2,[r1,#0x14]         ;1063
                  |L18.92|
00005c  2100              MOVS     r1,#0                 ;1067
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1067
000062  2000              MOVS     r0,#0                 ;1069
000064  4770              BX       lr
;;;1071   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1077     */
;;;1078   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1079   {
;;;1080     /* Process Locked */
;;;1081     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d007              BEQ      |L19.26|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1082     
;;;1083     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2921              CMP      r1,#0x21
000016  d002              BEQ      |L19.30|
000018  e006              B        |L19.40|
                  |L19.26|
00001a  2002              MOVS     r0,#2                 ;1081
;;;1084     {
;;;1085       /* Enable the UART DMA Tx request */
;;;1086       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1087     }
;;;1088   
;;;1089     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1090     {
;;;1091       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1092       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1093       
;;;1094       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1095       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1096       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1097       
;;;1098       /* Enable the UART DMA Rx request */
;;;1099       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1100     }
;;;1101   
;;;1102     /* Process Unlocked */
;;;1103     __HAL_UNLOCK(huart);
;;;1104     
;;;1105     return HAL_OK;
;;;1106   }
00001c  bd08              POP      {r3,pc}
                  |L19.30|
00001e  6801              LDR      r1,[r0,#0]            ;1086
000020  694a              LDR      r2,[r1,#0x14]         ;1086
000022  f0420280          ORR      r2,r2,#0x80           ;1086
000026  614a              STR      r2,[r1,#0x14]         ;1086
                  |L19.40|
000028  f890103a          LDRB     r1,[r0,#0x3a]         ;1089
00002c  2200              MOVS     r2,#0                 ;1089
00002e  2922              CMP      r1,#0x22              ;1089
000030  d111              BNE      |L19.86|
000032  6801              LDR      r1,[r0,#0]            ;1092
000034  680b              LDR      r3,[r1,#0]            ;1092
000036  684b              LDR      r3,[r1,#4]            ;1092
000038  9300              STR      r3,[sp,#0]            ;1092
00003a  68cb              LDR      r3,[r1,#0xc]          ;1095
00003c  f4437380          ORR      r3,r3,#0x100          ;1095
000040  60cb              STR      r3,[r1,#0xc]          ;1095
000042  6801              LDR      r1,[r0,#0]            ;1096
000044  694b              LDR      r3,[r1,#0x14]         ;1096
000046  f0430301          ORR      r3,r3,#1              ;1096
00004a  614b              STR      r3,[r1,#0x14]         ;1096
00004c  6801              LDR      r1,[r0,#0]            ;1099
00004e  694b              LDR      r3,[r1,#0x14]         ;1099
000050  f0430340          ORR      r3,r3,#0x40           ;1099
000054  614b              STR      r3,[r1,#0x14]         ;1099
                  |L19.86|
000056  f8802038          STRB     r2,[r0,#0x38]         ;1103
00005a  2000              MOVS     r0,#0                 ;1105
00005c  bd08              POP      {r3,pc}
;;;1107   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1113     */
;;;1114   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1115   {
000002  4604              MOV      r4,r0
;;;1116     uint32_t dmarequest = 0x00U;
;;;1117     /* The Lock is not implemented on this API to allow the user application
;;;1118        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1119        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1120        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1121        */
;;;1122   
;;;1123     /* Stop UART DMA Tx request if ongoing */
;;;1124     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f3c111c0          UBFX     r1,r1,#7,#1
;;;1125     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8942039          LDRB     r2,[r4,#0x39]
000010  2a21              CMP      r2,#0x21
000012  d10b              BNE      |L20.44|
000014  b151              CBZ      r1,|L20.44|
;;;1126     {
;;;1127       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1128   
;;;1129       /* Abort the UART DMA Tx channel */
;;;1130       if(huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b108              CBZ      r0,|L20.38|
;;;1131       {
;;;1132         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L20.38|
;;;1133       }
;;;1134       UART_EndTxTransfer(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UART_EndTxTransfer
                  |L20.44|
;;;1135     }
;;;1136   
;;;1137     /* Stop UART DMA Rx request if ongoing */
;;;1138     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  f3c11180          UBFX     r1,r1,#6,#1
;;;1139     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  f894203a          LDRB     r2,[r4,#0x3a]
000038  2a22              CMP      r2,#0x22
00003a  d10b              BNE      |L20.84|
00003c  b151              CBZ      r1,|L20.84|
;;;1140     {
;;;1141       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003e  6941              LDR      r1,[r0,#0x14]
000040  f0210140          BIC      r1,r1,#0x40
000044  6141              STR      r1,[r0,#0x14]
;;;1142   
;;;1143       /* Abort the UART DMA Rx channel */
;;;1144       if(huart->hdmarx != NULL)
000046  6b60              LDR      r0,[r4,#0x34]
000048  b108              CBZ      r0,|L20.78|
;;;1145       {
;;;1146         HAL_DMA_Abort(huart->hdmarx);
00004a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.78|
;;;1147       }
;;;1148       UART_EndRxTransfer(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       UART_EndRxTransfer
                  |L20.84|
;;;1149     }
;;;1150   
;;;1151     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1152   }
000056  bd10              POP      {r4,pc}
;;;1153   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;523      */
;;;524    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;525    {
000002  4604              MOV      r4,r0
;;;526      /* Check the UART handle allocation */
;;;527      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d00c              BEQ      |L21.34|
;;;528      {
;;;529        return HAL_ERROR;
;;;530      }
;;;531    
;;;532      /* Check the parameters */
;;;533      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;534    
;;;535      huart->gState = HAL_UART_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f8840039          STRB     r0,[r4,#0x39]
;;;536    
;;;537      /* DeInit the low level hardware */
;;;538      HAL_UART_MspDeInit(huart);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_UART_MspDeInit
;;;539    
;;;540      huart->ErrorCode = HAL_UART_ERROR_NONE;
000014  2000              MOVS     r0,#0
000016  3438              ADDS     r4,r4,#0x38
000018  6060              STR      r0,[r4,#4]
;;;541      huart->gState = HAL_UART_STATE_RESET;
00001a  7060              STRB     r0,[r4,#1]
;;;542      huart->RxState = HAL_UART_STATE_RESET;
00001c  70a0              STRB     r0,[r4,#2]
;;;543    
;;;544      /* Process Unlock */
;;;545      __HAL_UNLOCK(huart);
00001e  7020              STRB     r0,[r4,#0]
;;;546    
;;;547      return HAL_OK;
;;;548    }
000020  bd10              POP      {r4,pc}
                  |L21.34|
000022  2001              MOVS     r0,#1                 ;529
000024  bd10              POP      {r4,pc}
;;;549    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1748     */
;;;1749    __WEAK void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1750   {
;;;1751     /* Prevent unused argument(s) compilation warning */
;;;1752     UNUSED(huart); 
;;;1753     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1754              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1755      */ 
;;;1756   }
;;;1757   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2018     */
;;;2019   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2020   {
;;;2021     return huart->ErrorCode;
;;;2022   }
000002  4770              BX       lr
;;;2023   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2003     */
;;;2004   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2005   {
;;;2006     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2007     temp1 = huart->gState;
000002  f8110f39          LDRB     r0,[r1,#0x39]!
;;;2008     temp2 = huart->RxState;
000006  7849              LDRB     r1,[r1,#1]
;;;2009     
;;;2010     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000008  4308              ORRS     r0,r0,r1
;;;2011   }
00000a  4770              BX       lr
;;;2012   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1561     */
;;;1562   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1563   {
000002  4604              MOV      r4,r0
;;;1564      uint32_t isrflags   = READ_REG(huart->Instance->SR);
000004  6822              LDR      r2,[r4,#0]
000006  6810              LDR      r0,[r2,#0]
;;;1565      uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;1566      uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  6952              LDR      r2,[r2,#0x14]
;;;1567      uint32_t errorflags = 0x00U;
;;;1568      uint32_t dmarequest = 0x00U;
;;;1569   
;;;1570     /* If no error occurs */
;;;1571     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f000030f          AND      r3,r0,#0xf
;;;1572     if(errorflags == RESET)
000010  2b00              CMP      r3,#0
000012  d108              BNE      |L25.38|
;;;1573     {
;;;1574       /* UART in mode Receiver -------------------------------------------------*/
;;;1575       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000014  0685              LSLS     r5,r0,#26
000016  d506              BPL      |L25.38|
000018  068d              LSLS     r5,r1,#26
00001a  d504              BPL      |L25.38|
;;;1576       {
;;;1577         UART_Receive_IT(huart);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      UART_Receive_IT
                  |L25.38|
;;;1578         return;
;;;1579       }
;;;1580     }
;;;1581   
;;;1582     /* If some errors occur */
;;;1583     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000026  2b00              CMP      r3,#0
000028  d05e              BEQ      |L25.232|
00002a  f0020301          AND      r3,r2,#1
00002e  f4017590          AND      r5,r1,#0x120
000032  432b              ORRS     r3,r3,r5
000034  d058              BEQ      |L25.232|
;;;1584     {
;;;1585       /* UART parity error interrupt occurred ----------------------------------*/
;;;1586       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000036  07c3              LSLS     r3,r0,#31
000038  d005              BEQ      |L25.70|
00003a  05cb              LSLS     r3,r1,#23
00003c  d503              BPL      |L25.70|
;;;1587       {
;;;1588         huart->ErrorCode |= HAL_UART_ERROR_PE;
00003e  6be3              LDR      r3,[r4,#0x3c]
000040  f0430301          ORR      r3,r3,#1
000044  63e3              STR      r3,[r4,#0x3c]
                  |L25.70|
;;;1589       }
;;;1590   
;;;1591       /* UART noise error interrupt occurred -----------------------------------*/
;;;1592       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000046  0743              LSLS     r3,r0,#29
000048  d505              BPL      |L25.86|
00004a  07d3              LSLS     r3,r2,#31
00004c  d003              BEQ      |L25.86|
;;;1593       {
;;;1594         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004e  6be3              LDR      r3,[r4,#0x3c]
000050  f0430302          ORR      r3,r3,#2
000054  63e3              STR      r3,[r4,#0x3c]
                  |L25.86|
;;;1595       }
;;;1596   
;;;1597       /* UART frame error interrupt occurred -----------------------------------*/
;;;1598       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  0783              LSLS     r3,r0,#30
000058  d505              BPL      |L25.102|
00005a  07d3              LSLS     r3,r2,#31
00005c  d003              BEQ      |L25.102|
;;;1599       {
;;;1600         huart->ErrorCode |= HAL_UART_ERROR_FE;
00005e  6be3              LDR      r3,[r4,#0x3c]
000060  f0430304          ORR      r3,r3,#4
000064  63e3              STR      r3,[r4,#0x3c]
                  |L25.102|
;;;1601       }
;;;1602   
;;;1603       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;1604       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000066  0703              LSLS     r3,r0,#28
000068  d505              BPL      |L25.118|
00006a  07d2              LSLS     r2,r2,#31
00006c  d003              BEQ      |L25.118|
;;;1605       { 
;;;1606         huart->ErrorCode |= HAL_UART_ERROR_ORE;
00006e  6be2              LDR      r2,[r4,#0x3c]
000070  f0420208          ORR      r2,r2,#8
000074  63e2              STR      r2,[r4,#0x3c]
                  |L25.118|
;;;1607       }
;;;1608   
;;;1609       /* Call UART Error Call back function if need be --------------------------*/
;;;1610       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000076  6be2              LDR      r2,[r4,#0x3c]
000078  2a00              CMP      r2,#0
00007a  d02a              BEQ      |L25.210|
;;;1611       {
;;;1612         /* UART in mode Receiver -----------------------------------------------*/
;;;1613         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00007c  0680              LSLS     r0,r0,#26
00007e  d504              BPL      |L25.138|
000080  0688              LSLS     r0,r1,#26
000082  d502              BPL      |L25.138|
;;;1614         {
;;;1615           UART_Receive_IT(huart);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       UART_Receive_IT
                  |L25.138|
;;;1616         }
;;;1617   
;;;1618         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1619            consider error as blocking */
;;;1620         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00008a  6820              LDR      r0,[r4,#0]
00008c  6940              LDR      r0,[r0,#0x14]
00008e  f3c01080          UBFX     r0,r0,#6,#1
;;;1621         if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
000092  6be1              LDR      r1,[r4,#0x3c]
000094  0709              LSLS     r1,r1,#28
000096  d400              BMI      |L25.154|
000098  b300              CBZ      r0,|L25.220|
                  |L25.154|
;;;1622         {
;;;1623           /* Blocking error : transfer is aborted
;;;1624              Set the UART state ready to be able to start again the process,
;;;1625              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1626           UART_EndRxTransfer(huart);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       UART_EndRxTransfer
;;;1627   
;;;1628           /* Disable the UART DMA Rx request if enabled */
;;;1629           if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6941              LDR      r1,[r0,#0x14]
0000a4  0649              LSLS     r1,r1,#25
0000a6  d515              BPL      |L25.212|
;;;1630           {
;;;1631             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000a8  6941              LDR      r1,[r0,#0x14]
0000aa  f0210140          BIC      r1,r1,#0x40
0000ae  6141              STR      r1,[r0,#0x14]
;;;1632   
;;;1633             /* Abort the UART DMA Rx channel */
;;;1634             if(huart->hdmarx != NULL)
0000b0  6b60              LDR      r0,[r4,#0x34]
0000b2  b158              CBZ      r0,|L25.204|
;;;1635             {
;;;1636               /* Set the UART DMA Abort callback : 
;;;1637                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1638               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000b4  4915              LDR      r1,|L25.268|
0000b6  6341              STR      r1,[r0,#0x34]
;;;1639               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000b8  6b60              LDR      r0,[r4,#0x34]
0000ba  f7fffffe          BL       HAL_DMA_Abort_IT
0000be  2800              CMP      r0,#0
0000c0  d007              BEQ      |L25.210|
;;;1640               {
;;;1641                 /* Call Directly XferAbortCallback function in case of error */
;;;1642                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  6b41              LDR      r1,[r0,#0x34]
0000c6  e8bd4070          POP      {r4-r6,lr}
0000ca  4708              BX       r1
                  |L25.204|
;;;1643               }
;;;1644             }
;;;1645             else
;;;1646             {
;;;1647               /* Call user error callback */
;;;1648               HAL_UART_ErrorCallback(huart);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L25.210|
;;;1649             }
;;;1650           }
;;;1651           else
;;;1652           {
;;;1653             /* Call user error callback */
;;;1654             HAL_UART_ErrorCallback(huart);
;;;1655           }
;;;1656         }
;;;1657         else
;;;1658         {
;;;1659           /* Non Blocking error : transfer could go on. 
;;;1660              Error is notified to user through user error callback */
;;;1661           HAL_UART_ErrorCallback(huart);
;;;1662           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1663         }
;;;1664       }
;;;1665       return;
;;;1666     } /* End if some error occurs */
;;;1667   
;;;1668     /* UART in mode Transmitter ------------------------------------------------*/
;;;1669     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1670     {
;;;1671       UART_Transmit_IT(huart);
;;;1672       return;
;;;1673     }
;;;1674     
;;;1675     /* UART in mode Transmitter end --------------------------------------------*/
;;;1676     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1677     {
;;;1678       UART_EndTransmit_IT(huart);
;;;1679       return;
;;;1680     }
;;;1681   }
0000d2  bd70              POP      {r4-r6,pc}
                  |L25.212|
0000d4  4620              MOV      r0,r4                 ;1654
0000d6  f7fffffe          BL       HAL_UART_ErrorCallback
0000da  bd70              POP      {r4-r6,pc}
                  |L25.220|
0000dc  4620              MOV      r0,r4                 ;1661
0000de  f7fffffe          BL       HAL_UART_ErrorCallback
0000e2  2000              MOVS     r0,#0                 ;1662
0000e4  63e0              STR      r0,[r4,#0x3c]         ;1662
                  |L25.230|
0000e6  bd70              POP      {r4-r6,pc}
                  |L25.232|
0000e8  0602              LSLS     r2,r0,#24             ;1669
0000ea  d506              BPL      |L25.250|
0000ec  060a              LSLS     r2,r1,#24             ;1669
0000ee  d504              BPL      |L25.250|
0000f0  4620              MOV      r0,r4                 ;1671
0000f2  e8bd4070          POP      {r4-r6,lr}            ;1671
0000f6  f7ffbffe          B.W      UART_Transmit_IT
                  |L25.250|
0000fa  0640              LSLS     r0,r0,#25             ;1676
0000fc  d5f3              BPL      |L25.230|
0000fe  0648              LSLS     r0,r1,#25             ;1676
000100  d5f1              BPL      |L25.230|
000102  4620              MOV      r0,r4                 ;1678
000104  e8bd4070          POP      {r4-r6,lr}            ;1678
000108  f7ffbffe          B.W      UART_EndTransmit_IT
;;;1682   
                          ENDP

                  |L25.268|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;265      */
;;;266    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4604              MOV      r4,r0
;;;268      /* Check the UART handle allocation */
;;;269      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L26.18|
;;;270      {
;;;271        return HAL_ERROR;
;;;272      }
;;;273    
;;;274      /* Check the parameters */
;;;275      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;276      {
;;;277        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;278        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;279        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;280      }
;;;281      else
;;;282      {
;;;283        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;284      }
;;;285      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;286    #if defined(USART_CR1_OVER8)
;;;287      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;288    #endif /* USART_CR1_OVER8 */
;;;289      
;;;290      if(huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L26.22|
000010  e006              B        |L26.32|
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;271
;;;291      {  
;;;292        /* Allocate lock resource and initialize it */
;;;293        huart->Lock = HAL_UNLOCKED;
;;;294    
;;;295        /* Init the low level hardware */
;;;296        HAL_UART_MspInit(huart);
;;;297      }
;;;298    
;;;299      huart->gState = HAL_UART_STATE_BUSY;
;;;300    
;;;301      /* Disable the peripheral */
;;;302      __HAL_UART_DISABLE(huart);
;;;303      
;;;304      /* Set the UART Communication parameters */
;;;305      UART_SetConfig(huart);
;;;306      
;;;307      /* In asynchronous mode, the following bits must be kept cleared: 
;;;308         - LINEN and CLKEN bits in the USART_CR2 register,
;;;309         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;310      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;311      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;312      
;;;313      /* Enable the peripheral */
;;;314      __HAL_UART_ENABLE(huart);
;;;315      
;;;316      /* Initialize the UART state */
;;;317      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;318      huart->gState= HAL_UART_STATE_READY;
;;;319      huart->RxState= HAL_UART_STATE_READY;
;;;320      
;;;321      return HAL_OK;
;;;322    }
000014  bd70              POP      {r4-r6,pc}
                  |L26.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;293
00001a  4620              MOV      r0,r4                 ;296
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L26.32|
000020  2024              MOVS     r0,#0x24              ;299
000022  f8840039          STRB     r0,[r4,#0x39]         ;299
000026  6820              LDR      r0,[r4,#0]            ;302
000028  68c1              LDR      r1,[r0,#0xc]          ;302
00002a  f4215100          BIC      r1,r1,#0x2000         ;302
00002e  60c1              STR      r1,[r0,#0xc]          ;302
000030  4620              MOV      r0,r4                 ;305
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;310
000038  6901              LDR      r1,[r0,#0x10]         ;310
00003a  f4214190          BIC      r1,r1,#0x4800         ;310
00003e  6101              STR      r1,[r0,#0x10]         ;310
000040  6820              LDR      r0,[r4,#0]            ;311
000042  6941              LDR      r1,[r0,#0x14]         ;311
000044  f021012a          BIC      r1,r1,#0x2a           ;311
000048  6141              STR      r1,[r0,#0x14]         ;311
00004a  6820              LDR      r0,[r4,#0]            ;314
00004c  68c1              LDR      r1,[r0,#0xc]          ;314
00004e  f4415100          ORR      r1,r1,#0x2000         ;314
000052  60c1              STR      r1,[r0,#0xc]          ;314
000054  63e5              STR      r5,[r4,#0x3c]         ;317
000056  2020              MOVS     r0,#0x20              ;318
000058  f8840039          STRB     r0,[r4,#0x39]         ;318
00005c  f884003a          STRB     r0,[r4,#0x3a]         ;319
000060  2000              MOVS     r0,#0                 ;321
000062  bd70              POP      {r4-r6,pc}
;;;323    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;570      */
;;;571    __WEAK void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;572    {
;;;573      /* Prevent unused argument(s) compilation warning */
;;;574      UNUSED(huart);
;;;575      /* NOTE: This function should not be modified, when the callback is needed,
;;;576               the HAL_UART_MspDeInit could be implemented in the user file
;;;577       */
;;;578    }
;;;579    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;555      */
;;;556    __WEAK void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;557    {
;;;558      /* Prevent unused argument(s) compilation warning */
;;;559      UNUSED(huart);
;;;560      /* NOTE: This function should not be modified, when the callback is needed,
;;;561               the HAL_UART_MspInit could be implemented in the user file
;;;562       */
;;;563    }
;;;564    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;731      */
;;;732    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;733    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;734      uint16_t* tmp;
;;;735      uint32_t tickstart = 0U;
;;;736      
;;;737      /* Check that a Rx process is not already ongoing */
;;;738      if(huart->RxState == HAL_UART_STATE_READY)
00000c  f894003a          LDRB     r0,[r4,#0x3a]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L29.26|
;;;739      {
;;;740        if((pData == NULL) || (Size == 0U))
;;;741        {
;;;742          return  HAL_ERROR;
;;;743        }
;;;744    
;;;745        /* Process Locked */
;;;746        __HAL_LOCK(huart);
;;;747        
;;;748        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;749        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;750    
;;;751        /* Init tickstart for timeout managment */
;;;752        tickstart = HAL_GetTick();
;;;753    
;;;754        huart->RxXferSize = Size;
;;;755        huart->RxXferCount = Size;
;;;756    
;;;757        /* Check the remain data to be received */
;;;758        while(huart->RxXferCount > 0U)
;;;759        {
;;;760          huart->RxXferCount--;
;;;761          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;762          {
;;;763            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;764            {
;;;765              return HAL_TIMEOUT;
;;;766            }
;;;767            tmp = (uint16_t*)pData;
;;;768            if(huart->Init.Parity == UART_PARITY_NONE)
;;;769            {
;;;770              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;771              pData +=2U;
;;;772            }
;;;773            else
;;;774            {
;;;775              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;776              pData +=1U;
;;;777            }
;;;778    
;;;779          } 
;;;780          else
;;;781          {
;;;782            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;783            {
;;;784              return HAL_TIMEOUT;
;;;785            }
;;;786            if(huart->Init.Parity == UART_PARITY_NONE)
;;;787            {
;;;788              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;789            }
;;;790            else
;;;791            {
;;;792              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;793            }
;;;794    
;;;795          }
;;;796        }
;;;797    
;;;798        /* At end of Rx process, restore huart->RxState to Ready */
;;;799        huart->RxState = HAL_UART_STATE_READY;
;;;800        
;;;801        /* Process Unlocked */
;;;802        __HAL_UNLOCK(huart);
;;;803    
;;;804        return HAL_OK;
;;;805      }
;;;806      else
;;;807      {
;;;808        return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L29.22|
;;;809      }
;;;810    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L29.26|
00001a  b1b5              CBZ      r5,|L29.74|
00001c  f1b90f00          CMP      r9,#0                 ;740
000020  d013              BEQ      |L29.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;746
000026  2801              CMP      r0,#1                 ;746
000028  d011              BEQ      |L29.78|
00002a  2001              MOVS     r0,#1                 ;746
00002c  f8840038          STRB     r0,[r4,#0x38]         ;746
000030  2700              MOVS     r7,#0                 ;748
000032  63e7              STR      r7,[r4,#0x3c]         ;748
000034  2022              MOVS     r0,#0x22              ;749
000036  f884003a          STRB     r0,[r4,#0x3a]         ;749
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;752
000040  f8a4902c          STRH     r9,[r4,#0x2c]         ;754
000044  f8a4902e          STRH     r9,[r4,#0x2e]         ;755
000048  e035              B        |L29.182|
                  |L29.74|
00004a  2001              MOVS     r0,#1                 ;742
00004c  e7e3              B        |L29.22|
                  |L29.78|
00004e  2002              MOVS     r0,#2                 ;746
000050  e7e1              B        |L29.22|
                  |L29.82|
000052  8de0              LDRH     r0,[r4,#0x2e]         ;760
000054  1e40              SUBS     r0,r0,#1              ;760
000056  85e0              STRH     r0,[r4,#0x2e]         ;760
000058  68a0              LDR      r0,[r4,#8]            ;761
00005a  f5b05f80          CMP      r0,#0x1000            ;761
00005e  d009              BEQ      |L29.116|
000060  4643              MOV      r3,r8                 ;782
000062  2200              MOVS     r2,#0                 ;782
000064  2120              MOVS     r1,#0x20              ;782
000066  4620              MOV      r0,r4                 ;782
000068  9600              STR      r6,[sp,#0]            ;782
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1d0              CBZ      r0,|L29.166|
000070  2003              MOVS     r0,#3                 ;784
000072  e7d0              B        |L29.22|
                  |L29.116|
000074  4643              MOV      r3,r8                 ;763
000076  2200              MOVS     r2,#0                 ;763
000078  2120              MOVS     r1,#0x20              ;763
00007a  4620              MOV      r0,r4                 ;763
00007c  9600              STR      r6,[sp,#0]            ;763
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L29.136|
000084  2003              MOVS     r0,#3                 ;765
000086  e7c6              B        |L29.22|
                  |L29.136|
000088  6920              LDR      r0,[r4,#0x10]         ;768
00008a  b128              CBZ      r0,|L29.152|
00008c  6820              LDR      r0,[r4,#0]            ;775
00008e  6840              LDR      r0,[r0,#4]            ;775
000090  b2c1              UXTB     r1,r0                 ;775
000092  8029              STRH     r1,[r5,#0]            ;775
000094  1c6d              ADDS     r5,r5,#1              ;776
000096  e00e              B        |L29.182|
                  |L29.152|
000098  6820              LDR      r0,[r4,#0]            ;770
00009a  6840              LDR      r0,[r0,#4]            ;770
00009c  f3c00108          UBFX     r1,r0,#0,#9           ;770
0000a0  8029              STRH     r1,[r5,#0]            ;770
0000a2  1cad              ADDS     r5,r5,#2              ;771
0000a4  e007              B        |L29.182|
                  |L29.166|
0000a6  6920              LDR      r0,[r4,#0x10]         ;786
0000a8  b170              CBZ      r0,|L29.200|
0000aa  6820              LDR      r0,[r4,#0]            ;792
0000ac  6840              LDR      r0,[r0,#4]            ;792
0000ae  f000007f          AND      r0,r0,#0x7f           ;792
0000b2  f8050b01          STRB     r0,[r5],#1            ;792
                  |L29.182|
0000b6  8de0              LDRH     r0,[r4,#0x2e]         ;758
0000b8  2800              CMP      r0,#0                 ;758
0000ba  d1ca              BNE      |L29.82|
0000bc  2020              MOVS     r0,#0x20              ;799
0000be  3438              ADDS     r4,r4,#0x38           ;799
0000c0  70a0              STRB     r0,[r4,#2]            ;799
0000c2  7027              STRB     r7,[r4,#0]            ;802
0000c4  2000              MOVS     r0,#0                 ;804
0000c6  e7a6              B        |L29.22|
                  |L29.200|
0000c8  6820              LDR      r0,[r4,#0]            ;788
0000ca  6840              LDR      r0,[r0,#4]            ;788
0000cc  f8050b01          STRB     r0,[r5],#1            ;788
0000d0  e7f1              B        |L29.182|
;;;811    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;973      */
;;;974    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;975    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4613              MOV      r3,r2
;;;976      uint32_t *tmp;
;;;977      
;;;978      /* Check that a Rx process is not already ongoing */
;;;979      if(huart->RxState == HAL_UART_STATE_READY) 
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d002              BEQ      |L30.22|
;;;980      {
;;;981        if((pData == NULL) || (Size == 0U))
;;;982        {
;;;983          return HAL_ERROR;
;;;984        }
;;;985    
;;;986        /* Process Locked */
;;;987        __HAL_LOCK(huart);
;;;988    
;;;989        huart->pRxBuffPtr = pData;
;;;990        huart->RxXferSize = Size;
;;;991    
;;;992        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;993        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;994    
;;;995        /* Set the UART DMA transfer complete callback */
;;;996        huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;997    
;;;998        /* Set the UART DMA Half transfer complete callback */
;;;999        huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1000   
;;;1001       /* Set the DMA error callback */
;;;1002       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1003   
;;;1004       /* Set the DMA abort callback */
;;;1005       huart->hdmarx->XferAbortCallback = NULL;
;;;1006   
;;;1007       /* Enable the DMA channel */
;;;1008       tmp = (uint32_t*)&pData;
;;;1009       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1010   
;;;1011       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1012       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1013   
;;;1014       /* Process Unlocked */
;;;1015       __HAL_UNLOCK(huart);
;;;1016   
;;;1017       /* Enable the UART Parity Error Interrupt */
;;;1018       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1019   
;;;1020       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1021       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1022   
;;;1023       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1024       in the UART CR3 register */
;;;1025       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1026   
;;;1027       return HAL_OK;
;;;1028     }
;;;1029     else
;;;1030     {
;;;1031       return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L30.18|
;;;1032     }
;;;1033   }
000012  b005              ADD      sp,sp,#0x14
000014  bd30              POP      {r4,r5,pc}
                  |L30.22|
000016  9a03              LDR      r2,[sp,#0xc]          ;981
000018  b3a2              CBZ      r2,|L30.132|
00001a  b39b              CBZ      r3,|L30.132|
00001c  f8940038          LDRB     r0,[r4,#0x38]         ;987
000020  2801              CMP      r0,#1                 ;987
000022  d032              BEQ      |L30.138|
000024  2001              MOVS     r0,#1                 ;987
000026  f8840038          STRB     r0,[r4,#0x38]         ;987
00002a  62a2              STR      r2,[r4,#0x28]         ;989
00002c  85a3              STRH     r3,[r4,#0x2c]         ;990
00002e  2500              MOVS     r5,#0                 ;992
000030  63e5              STR      r5,[r4,#0x3c]         ;992
000032  2022              MOVS     r0,#0x22              ;993
000034  f884003a          STRB     r0,[r4,#0x3a]         ;993
000038  6b61              LDR      r1,[r4,#0x34]         ;996
00003a  4815              LDR      r0,|L30.144|
00003c  6288              STR      r0,[r1,#0x28]         ;996
00003e  6b61              LDR      r1,[r4,#0x34]         ;999
000040  4814              LDR      r0,|L30.148|
000042  62c8              STR      r0,[r1,#0x2c]         ;999
000044  6b61              LDR      r1,[r4,#0x34]         ;1002
000046  4814              LDR      r0,|L30.152|
000048  6308              STR      r0,[r1,#0x30]         ;1002
00004a  6b60              LDR      r0,[r4,#0x34]         ;1005
00004c  6345              STR      r5,[r0,#0x34]         ;1005
00004e  6821              LDR      r1,[r4,#0]            ;1009
000050  6b60              LDR      r0,[r4,#0x34]         ;1009
000052  1d09              ADDS     r1,r1,#4              ;1009
000054  f7fffffe          BL       HAL_DMA_Start_IT
000058  6820              LDR      r0,[r4,#0]            ;1012
00005a  6801              LDR      r1,[r0,#0]            ;1012
00005c  6841              LDR      r1,[r0,#4]            ;1012
00005e  9101              STR      r1,[sp,#4]            ;1012
000060  f8845038          STRB     r5,[r4,#0x38]         ;1015
000064  68c1              LDR      r1,[r0,#0xc]          ;1018
000066  f4417180          ORR      r1,r1,#0x100          ;1018
00006a  60c1              STR      r1,[r0,#0xc]          ;1018
00006c  6820              LDR      r0,[r4,#0]            ;1021
00006e  6941              LDR      r1,[r0,#0x14]         ;1021
000070  f0410101          ORR      r1,r1,#1              ;1021
000074  6141              STR      r1,[r0,#0x14]         ;1021
000076  6820              LDR      r0,[r4,#0]            ;1025
000078  6941              LDR      r1,[r0,#0x14]         ;1025
00007a  f0410140          ORR      r1,r1,#0x40           ;1025
00007e  6141              STR      r1,[r0,#0x14]         ;1025
000080  2000              MOVS     r0,#0                 ;1027
000082  e7c6              B        |L30.18|
                  |L30.132|
000084  e7ff              B        |L30.134|
                  |L30.134|
000086  2001              MOVS     r0,#1                 ;983
000088  e7c3              B        |L30.18|
                  |L30.138|
00008a  2002              MOVS     r0,#2                 ;987
00008c  e7c1              B        |L30.18|
;;;1034   
                          ENDP

00008e  0000              DCW      0x0000
                  |L30.144|
                          DCD      UART_DMAReceiveCplt
                  |L30.148|
                          DCD      UART_DMARxHalfCplt
                  |L30.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;860      */
;;;861    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f890303a          LDRB     r3,[r0,#0x3a]
;;;862    {
;;;863      /* Check that a Rx process is not already ongoing */
;;;864      if(huart->RxState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L31.12|
;;;865      {
;;;866        if((pData == NULL) || (Size == 0U))
;;;867        {
;;;868          return HAL_ERROR;
;;;869        }
;;;870    
;;;871        /* Process Locked */
;;;872        __HAL_LOCK(huart);
;;;873    
;;;874        huart->pRxBuffPtr = pData;
;;;875        huart->RxXferSize = Size;
;;;876        huart->RxXferCount = Size;
;;;877    
;;;878        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;879        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;880        
;;;881        /* Process Unlocked */
;;;882        __HAL_UNLOCK(huart);
;;;883    
;;;884        /* Enable the UART Parity Error Interrupt */
;;;885        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;886    
;;;887        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;888        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;889    
;;;890        /* Enable the UART Data Register not empty Interrupt */
;;;891        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;892    
;;;893        return HAL_OK;
;;;894      }
;;;895      else
;;;896      {
;;;897        return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;898      }
;;;899    }
00000a  4770              BX       lr
                  |L31.12|
00000c  b1f9              CBZ      r1,|L31.78|
00000e  b1f2              CBZ      r2,|L31.78|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;872
000014  2b01              CMP      r3,#1                 ;872
000016  d01c              BEQ      |L31.82|
000018  6281              STR      r1,[r0,#0x28]         ;874
00001a  8582              STRH     r2,[r0,#0x2c]         ;875
00001c  85c2              STRH     r2,[r0,#0x2e]         ;876
00001e  2100              MOVS     r1,#0                 ;878
000020  63c1              STR      r1,[r0,#0x3c]         ;878
000022  2222              MOVS     r2,#0x22              ;879
000024  f880203a          STRB     r2,[r0,#0x3a]         ;879
000028  f8801038          STRB     r1,[r0,#0x38]         ;882
00002c  6801              LDR      r1,[r0,#0]            ;885
00002e  68ca              LDR      r2,[r1,#0xc]          ;885
000030  f4427280          ORR      r2,r2,#0x100          ;885
000034  60ca              STR      r2,[r1,#0xc]          ;885
000036  6801              LDR      r1,[r0,#0]            ;888
000038  694a              LDR      r2,[r1,#0x14]         ;888
00003a  f0420201          ORR      r2,r2,#1              ;888
00003e  614a              STR      r2,[r1,#0x14]         ;888
000040  6800              LDR      r0,[r0,#0]            ;891
000042  68c1              LDR      r1,[r0,#0xc]          ;891
000044  f0410120          ORR      r1,r1,#0x20           ;891
000048  60c1              STR      r1,[r0,#0xc]          ;891
00004a  2000              MOVS     r0,#0                 ;893
00004c  4770              BX       lr
                  |L31.78|
00004e  2001              MOVS     r0,#1                 ;868
000050  4770              BX       lr
                  |L31.82|
000052  2002              MOVS     r0,#2                 ;872
000054  4770              BX       lr
;;;900    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1718     */
;;;1719   __WEAK void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1720   {
;;;1721     /* Prevent unused argument(s) compilation warning */
;;;1722     UNUSED(huart);
;;;1723     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1724              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;1725      */
;;;1726   }
;;;1727   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1733     */
;;;1734   __WEAK void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1735   {
;;;1736     /* Prevent unused argument(s) compilation warning */
;;;1737     UNUSED(huart);
;;;1738     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1739              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;1740      */
;;;1741   }
;;;1742   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;649      */
;;;650    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;651    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;652      uint16_t* tmp;
;;;653      uint32_t tickstart = 0U;
;;;654      
;;;655      /* Check that a Tx process is not already ongoing */
;;;656      if(huart->gState == HAL_UART_STATE_READY)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L34.26|
;;;657      {
;;;658        if((pData == NULL) || (Size == 0U))
;;;659        {
;;;660          return  HAL_ERROR;
;;;661        }
;;;662    
;;;663        /* Process Locked */
;;;664        __HAL_LOCK(huart);
;;;665    
;;;666        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;667        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;668    
;;;669        /* Init tickstart for timeout managment */
;;;670        tickstart = HAL_GetTick();
;;;671    
;;;672        huart->TxXferSize = Size;
;;;673        huart->TxXferCount = Size;
;;;674        while(huart->TxXferCount > 0U)
;;;675        {
;;;676          huart->TxXferCount--;
;;;677          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;678          {
;;;679            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;680            {
;;;681              return HAL_TIMEOUT;
;;;682            }
;;;683            tmp = (uint16_t*) pData;
;;;684            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;685            if(huart->Init.Parity == UART_PARITY_NONE)
;;;686            {
;;;687              pData +=2U;
;;;688            }
;;;689            else
;;;690            {
;;;691              pData +=1U;
;;;692            }
;;;693          }
;;;694          else
;;;695          {
;;;696            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;697            {
;;;698              return HAL_TIMEOUT;
;;;699            }
;;;700            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;701          }
;;;702        }
;;;703    
;;;704        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;705        {
;;;706          return HAL_TIMEOUT;
;;;707        }
;;;708    
;;;709        /* At end of Tx process, restore huart->gState to Ready */
;;;710        huart->gState = HAL_UART_STATE_READY;
;;;711    
;;;712        /* Process Unlocked */
;;;713        __HAL_UNLOCK(huart);
;;;714    
;;;715        return HAL_OK;
;;;716      }
;;;717      else
;;;718      {
;;;719        return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;720      }
;;;721    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L34.26|
00001a  b1b5              CBZ      r5,|L34.74|
00001c  f1b90f00          CMP      r9,#0                 ;658
000020  d013              BEQ      |L34.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;664
000026  2801              CMP      r0,#1                 ;664
000028  d011              BEQ      |L34.78|
00002a  2001              MOVS     r0,#1                 ;664
00002c  f8840038          STRB     r0,[r4,#0x38]         ;664
000030  2700              MOVS     r7,#0                 ;666
000032  63e7              STR      r7,[r4,#0x3c]         ;666
000034  2021              MOVS     r0,#0x21              ;667
000036  f8840039          STRB     r0,[r4,#0x39]         ;667
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;670
000040  f8a49024          STRH     r9,[r4,#0x24]         ;672
000044  f8a49026          STRH     r9,[r4,#0x26]         ;673
000048  e02d              B        |L34.166|
                  |L34.74|
00004a  2001              MOVS     r0,#1                 ;660
00004c  e7e3              B        |L34.22|
                  |L34.78|
00004e  2002              MOVS     r0,#2                 ;664
000050  e7e1              B        |L34.22|
                  |L34.82|
000052  8ce0              LDRH     r0,[r4,#0x26]         ;676
000054  1e40              SUBS     r0,r0,#1              ;676
000056  84e0              STRH     r0,[r4,#0x26]         ;676
000058  68a0              LDR      r0,[r4,#8]            ;677
00005a  f5b05f80          CMP      r0,#0x1000            ;677
00005e  d009              BEQ      |L34.116|
000060  4643              MOV      r3,r8                 ;696
000062  2200              MOVS     r2,#0                 ;696
000064  2180              MOVS     r1,#0x80              ;696
000066  4620              MOV      r0,r4                 ;696
000068  9600              STR      r6,[sp,#0]            ;696
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1b0              CBZ      r0,|L34.158|
000070  2003              MOVS     r0,#3                 ;698
000072  e7d0              B        |L34.22|
                  |L34.116|
000074  4643              MOV      r3,r8                 ;679
000076  2200              MOVS     r2,#0                 ;679
000078  2180              MOVS     r1,#0x80              ;679
00007a  4620              MOV      r0,r4                 ;679
00007c  9600              STR      r6,[sp,#0]            ;679
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L34.136|
000084  2003              MOVS     r0,#3                 ;681
000086  e7c6              B        |L34.22|
                  |L34.136|
000088  8828              LDRH     r0,[r5,#0]            ;684
00008a  6821              LDR      r1,[r4,#0]            ;684
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;684
000090  6048              STR      r0,[r1,#4]            ;684
000092  6920              LDR      r0,[r4,#0x10]         ;685
000094  b108              CBZ      r0,|L34.154|
000096  1c6d              ADDS     r5,r5,#1              ;691
000098  e005              B        |L34.166|
                  |L34.154|
00009a  1cad              ADDS     r5,r5,#2              ;687
00009c  e003              B        |L34.166|
                  |L34.158|
00009e  6821              LDR      r1,[r4,#0]            ;700
0000a0  f8150b01          LDRB     r0,[r5],#1            ;700
0000a4  6048              STR      r0,[r1,#4]            ;700
                  |L34.166|
0000a6  8ce0              LDRH     r0,[r4,#0x26]         ;674
0000a8  2800              CMP      r0,#0                 ;674
0000aa  d1d2              BNE      |L34.82|
0000ac  4643              MOV      r3,r8                 ;704
0000ae  2200              MOVS     r2,#0                 ;704
0000b0  2140              MOVS     r1,#0x40              ;704
0000b2  4620              MOV      r0,r4                 ;704
0000b4  9600              STR      r6,[sp,#0]            ;704
0000b6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ba  b108              CBZ      r0,|L34.192|
0000bc  2003              MOVS     r0,#3                 ;706
0000be  e7aa              B        |L34.22|
                  |L34.192|
0000c0  2020              MOVS     r0,#0x20              ;710
0000c2  3438              ADDS     r4,r4,#0x38           ;710
0000c4  7060              STRB     r0,[r4,#1]            ;710
0000c6  7027              STRB     r7,[r4,#0]            ;713
0000c8  2000              MOVS     r0,#0                 ;715
0000ca  e7a4              B        |L34.22|
;;;722    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;908      */
;;;909    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;910    {
000002  4604              MOV      r4,r0
;;;911      uint32_t *tmp;
;;;912      
;;;913      /* Check that a Tx process is not already ongoing */
;;;914      if(huart->gState == HAL_UART_STATE_READY)
000004  f8940039          LDRB     r0,[r4,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L35.16|
;;;915      {
;;;916        if((pData == NULL) || (Size == 0U))
;;;917        {
;;;918          return HAL_ERROR;
;;;919        }
;;;920    
;;;921        /* Process Locked */
;;;922        __HAL_LOCK(huart);
;;;923    
;;;924        huart->pTxBuffPtr = pData;
;;;925        huart->TxXferSize = Size;
;;;926        huart->TxXferCount = Size;
;;;927    
;;;928        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;929        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;930    
;;;931        /* Set the UART DMA transfer complete callback */
;;;932        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;933    
;;;934        /* Set the UART DMA Half transfer complete callback */
;;;935        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;936    
;;;937        /* Set the DMA error callback */
;;;938        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;939    
;;;940        /* Set the DMA abort callback */
;;;941        huart->hdmatx->XferAbortCallback = NULL;
;;;942    
;;;943        /* Enable the UART transmit DMA channel */
;;;944        tmp = (uint32_t*)&pData;
;;;945        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;946    
;;;947        /* Clear the TC flag in the SR register by writing 0 to it */
;;;948        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;949    
;;;950        /* Process Unlocked */
;;;951        __HAL_UNLOCK(huart);
;;;952    
;;;953        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;954           in the UART CR3 register */
;;;955        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;956    
;;;957        return HAL_OK;
;;;958      }
;;;959      else
;;;960      {
;;;961        return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;962      }
;;;963    }
00000e  bdfe              POP      {r1-r7,pc}
                  |L35.16|
000010  9901              LDR      r1,[sp,#4]            ;916
000012  b379              CBZ      r1,|L35.116|
000014  b372              CBZ      r2,|L35.116|
000016  f8940038          LDRB     r0,[r4,#0x38]         ;922
00001a  2801              CMP      r0,#1                 ;922
00001c  d02d              BEQ      |L35.122|
00001e  2001              MOVS     r0,#1                 ;922
000020  f8840038          STRB     r0,[r4,#0x38]         ;922
000024  6221              STR      r1,[r4,#0x20]         ;924
000026  84a2              STRH     r2,[r4,#0x24]         ;925
000028  84e2              STRH     r2,[r4,#0x26]         ;926
00002a  2500              MOVS     r5,#0                 ;928
00002c  63e5              STR      r5,[r4,#0x3c]         ;928
00002e  2021              MOVS     r0,#0x21              ;929
000030  f8840039          STRB     r0,[r4,#0x39]         ;929
000034  6b23              LDR      r3,[r4,#0x30]         ;932
000036  4812              LDR      r0,|L35.128|
000038  6298              STR      r0,[r3,#0x28]         ;932
00003a  6b23              LDR      r3,[r4,#0x30]         ;935
00003c  4811              LDR      r0,|L35.132|
00003e  62d8              STR      r0,[r3,#0x2c]         ;935
000040  6b23              LDR      r3,[r4,#0x30]         ;938
000042  4811              LDR      r0,|L35.136|
000044  6318              STR      r0,[r3,#0x30]         ;938
000046  6b20              LDR      r0,[r4,#0x30]         ;941
000048  6345              STR      r5,[r0,#0x34]         ;941
00004a  6820              LDR      r0,[r4,#0]            ;945
00004c  4613              MOV      r3,r2                 ;945
00004e  1d00              ADDS     r0,r0,#4              ;945
000050  6b26              LDR      r6,[r4,#0x30]         ;945
000052  4602              MOV      r2,r0                 ;945
000054  4630              MOV      r0,r6                 ;945
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6821              LDR      r1,[r4,#0]            ;948
00005c  f06f0040          MVN      r0,#0x40              ;948
000060  6008              STR      r0,[r1,#0]            ;948
000062  f8845038          STRB     r5,[r4,#0x38]         ;951
000066  6820              LDR      r0,[r4,#0]            ;955
000068  6941              LDR      r1,[r0,#0x14]         ;955
00006a  f0410180          ORR      r1,r1,#0x80           ;955
00006e  6141              STR      r1,[r0,#0x14]         ;955
000070  2000              MOVS     r0,#0                 ;957
                  |L35.114|
000072  bdfe              POP      {r1-r7,pc}
                  |L35.116|
000074  e7ff              B        |L35.118|
                  |L35.118|
000076  2001              MOVS     r0,#1                 ;918
000078  e7fb              B        |L35.114|
                  |L35.122|
00007a  2002              MOVS     r0,#2                 ;922
00007c  e7f9              B        |L35.114|
;;;964    
                          ENDP

00007e  0000              DCW      0x0000
                  |L35.128|
                          DCD      UART_DMATransmitCplt
                  |L35.132|
                          DCD      UART_DMATxHalfCplt
                  |L35.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;819      */
;;;820    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;821    {
;;;822      /* Check that a Tx process is not already ongoing */
;;;823      if(huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L36.12|
;;;824      {
;;;825        if((pData == NULL) || (Size == 0U)) 
;;;826        {
;;;827          return HAL_ERROR;
;;;828        }
;;;829        /* Process Locked */
;;;830        __HAL_LOCK(huart);
;;;831    
;;;832        huart->pTxBuffPtr = pData;
;;;833        huart->TxXferSize = Size;
;;;834        huart->TxXferCount = Size;
;;;835    
;;;836        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;837        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;838    
;;;839        /* Process Unlocked */
;;;840        __HAL_UNLOCK(huart);
;;;841    
;;;842        /* Enable the UART Transmit data register empty Interrupt */
;;;843        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;844    
;;;845        return HAL_OK;
;;;846      }
;;;847      else
;;;848      {
;;;849        return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;850      }
;;;851    }
00000a  4770              BX       lr
                  |L36.12|
00000c  b1a9              CBZ      r1,|L36.58|
00000e  b1a2              CBZ      r2,|L36.58|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;830
000014  2b01              CMP      r3,#1                 ;830
000016  d012              BEQ      |L36.62|
000018  6201              STR      r1,[r0,#0x20]         ;832
00001a  8482              STRH     r2,[r0,#0x24]         ;833
00001c  84c2              STRH     r2,[r0,#0x26]         ;834
00001e  2100              MOVS     r1,#0                 ;836
000020  63c1              STR      r1,[r0,#0x3c]         ;836
000022  2221              MOVS     r2,#0x21              ;837
000024  f8802039          STRB     r2,[r0,#0x39]         ;837
000028  f8801038          STRB     r1,[r0,#0x38]         ;840
00002c  6800              LDR      r0,[r0,#0]            ;843
00002e  68c1              LDR      r1,[r0,#0xc]          ;843
000030  f0410180          ORR      r1,r1,#0x80           ;843
000034  60c1              STR      r1,[r0,#0xc]          ;843
000036  2000              MOVS     r0,#0                 ;845
000038  4770              BX       lr
                  |L36.58|
00003a  2001              MOVS     r0,#1                 ;827
00003c  4770              BX       lr
                  |L36.62|
00003e  2002              MOVS     r0,#2                 ;830
000040  4770              BX       lr
;;;852    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1688     */
;;;1689    __WEAK void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1690   {
;;;1691     /* Prevent unused argument(s) compilation warning */
;;;1692     UNUSED(huart);
;;;1693     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1694              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1695      */ 
;;;1696   }
;;;1697   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1703     */
;;;1704    __WEAK void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1705   {
;;;1706     /* Prevent unused argument(s) compilation warning */
;;;1707     UNUSED(huart);
;;;1708     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1709              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;1710      */ 
;;;1711   }
;;;1712   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2210     */
;;;2211   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2212   {
;;;2213     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2214     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2215     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2216   
;;;2217     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2218   }
00000e  bd10              POP      {r4,pc}
;;;2219   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2112     */
;;;2113   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2114   {
;;;2115     uint32_t dmarequest = 0x00U;
;;;2116     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;2117   
;;;2118     /* Stop UART DMA Tx request if ongoing */
;;;2119     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f3c010c0          UBFX     r0,r0,#7,#1
;;;2120     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8941039          LDRB     r1,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  2921              CMP      r1,#0x21
000014  d104              BNE      |L40.32|
000016  b118              CBZ      r0,|L40.32|
;;;2121     {
;;;2122       huart->TxXferCount = 0U;
000018  84e5              STRH     r5,[r4,#0x26]
;;;2123       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L40.32|
;;;2124     }
;;;2125   
;;;2126     /* Stop UART DMA Rx request if ongoing */
;;;2127     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f3c01080          UBFX     r0,r0,#6,#1
;;;2128     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000028  f894103a          LDRB     r1,[r4,#0x3a]
00002c  2922              CMP      r1,#0x22
00002e  d104              BNE      |L40.58|
000030  b118              CBZ      r0,|L40.58|
;;;2129     {
;;;2130       huart->RxXferCount = 0U;
000032  85e5              STRH     r5,[r4,#0x2e]
;;;2131       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L40.58|
;;;2132     }
;;;2133   
;;;2134     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400010          ORR      r0,r0,#0x10
000040  63e0              STR      r0,[r4,#0x3c]
;;;2135     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2136   }
000048  bd70              POP      {r4-r6,pc}
;;;2137   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2073     */
;;;2074   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2075   {
000002  4601              MOV      r1,r0
;;;2076     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2077     /* DMA Normal mode*/
;;;2078     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d413              BMI      |L41.54|
;;;2079     {
;;;2080       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;2081     
;;;2082       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2083       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000012  6801              LDR      r1,[r0,#0]
000014  68ca              LDR      r2,[r1,#0xc]
000016  f4227280          BIC      r2,r2,#0x100
00001a  60ca              STR      r2,[r1,#0xc]
;;;2084       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001c  6801              LDR      r1,[r0,#0]
00001e  694a              LDR      r2,[r1,#0x14]
000020  f0220201          BIC      r2,r2,#1
000024  614a              STR      r2,[r1,#0x14]
;;;2085       
;;;2086       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;2087          in the UART CR3 register */
;;;2088       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6801              LDR      r1,[r0,#0]
000028  694a              LDR      r2,[r1,#0x14]
00002a  f0220240          BIC      r2,r2,#0x40
00002e  614a              STR      r2,[r1,#0x14]
;;;2089   
;;;2090       /* At end of Rx process, restore huart->RxState to Ready */
;;;2091       huart->RxState = HAL_UART_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  f880103a          STRB     r1,[r0,#0x3a]
                  |L41.54|
;;;2092     }
;;;2093     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2094   }
00003a  bd10              POP      {r4,pc}
;;;2095   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2265     */
;;;2266   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2267   {
;;;2268     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2269     
;;;2270     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b41              LDR      r1,[r0,#0x34]
000008  634a              STR      r2,[r1,#0x34]
;;;2271   
;;;2272     /* Check if an Abort process is still ongoing */
;;;2273     if(huart->hdmatx != NULL)
00000a  6b01              LDR      r1,[r0,#0x30]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L42.22|
;;;2274     {
;;;2275       if(huart->hdmatx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L42.42|
                  |L42.22|
;;;2276       {
;;;2277         return;
;;;2278       }
;;;2279     }
;;;2280     
;;;2281     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2282     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2283     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2284   
;;;2285     /* Reset ErrorCode */
;;;2286     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2287   
;;;2288     /* Restore huart->gState and huart->RxState to Ready */
;;;2289     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2290     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2291   
;;;2292     /* Call user Abort complete callback */
;;;2293     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L42.42|
;;;2294   }
00002a  bd10              POP      {r4,pc}
;;;2295   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2101     */
;;;2102   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2103   {
;;;2104     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2105     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2106   }
000008  bd10              POP      {r4,pc}
;;;2107   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2324     */
;;;2325   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2326   {
;;;2327     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2328   
;;;2329     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2330   
;;;2331     /* Restore huart->RxState to Ready */
;;;2332     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f880103a          STRB     r1,[r0,#0x3a]
;;;2333   
;;;2334     /* Call user Abort complete callback */
;;;2335     HAL_UART_AbortReceiveCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2336   }
000012  bd10              POP      {r4,pc}
;;;2337   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2032     */
;;;2033   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2034   {
000002  4601              MOV      r1,r0
;;;2035     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2036     /* DMA Normal mode*/
;;;2037     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L45.40|
;;;2038     {
;;;2039       huart->TxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;2040   
;;;2041       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2042          in the UART CR3 register */
;;;2043       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;2044   
;;;2045       /* Enable the UART Transmit Complete Interrupt */
;;;2046       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;2047   
;;;2048     }
;;;2049     /* DMA Circular mode */
;;;2050     else
;;;2051     {
;;;2052       HAL_UART_TxCpltCallback(huart);
;;;2053     }
;;;2054   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;2055   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2227     */
;;;2228   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2229   {
;;;2230     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2231     
;;;2232     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b01              LDR      r1,[r0,#0x30]
000008  634a              STR      r2,[r1,#0x34]
;;;2233   
;;;2234     /* Check if an Abort process is still ongoing */
;;;2235     if(huart->hdmarx != NULL)
00000a  6b41              LDR      r1,[r0,#0x34]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L46.22|
;;;2236     {
;;;2237       if(huart->hdmarx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L46.42|
                  |L46.22|
;;;2238       {
;;;2239         return;
;;;2240       }
;;;2241     }
;;;2242   
;;;2243     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2244     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2245     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2246   
;;;2247     /* Reset ErrorCode */
;;;2248     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2249   
;;;2250     /* Restore huart->gState and huart->RxState to Ready */
;;;2251     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2252     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2253   
;;;2254     /* Call user Abort complete callback */
;;;2255     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L46.42|
;;;2256   }
00002a  bd10              POP      {r4,pc}
;;;2257   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2061     */
;;;2062   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2063   {
;;;2064     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2065   
;;;2066     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2067   }
000008  bd10              POP      {r4,pc}
;;;2068   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2303     */
;;;2304   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2305   {
;;;2306     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2307   
;;;2308     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2309   
;;;2310     /* Restore huart->gState to Ready */
;;;2311     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f8801039          STRB     r1,[r0,#0x39]
;;;2312   
;;;2313     /* Call user Abort complete callback */
;;;2314     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2315   }
000012  bd10              POP      {r4,pc}
;;;2316   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2194     */
;;;2195   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2196   {
;;;2197     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2198     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227290          BIC      r2,r2,#0x120
000008  60ca              STR      r2,[r1,#0xc]
;;;2199     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  694a              LDR      r2,[r1,#0x14]
00000e  f0220201          BIC      r2,r2,#1
000012  614a              STR      r2,[r1,#0x14]
;;;2200   
;;;2201     /* At end of Rx process, restore huart->RxState to Ready */
;;;2202     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f880103a          STRB     r1,[r0,#0x3a]
;;;2203   }
00001a  4770              BX       lr
;;;2204   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2390     */
;;;2391   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2392   {
;;;2393     /* Disable the UART Transmit Complete Interrupt */    
;;;2394     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  f0220240          BIC      r2,r2,#0x40
00000a  60ca              STR      r2,[r1,#0xc]
;;;2395     
;;;2396     /* Tx process is ended, restore huart->gState to Ready */
;;;2397     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2398     HAL_UART_TxCpltCallback(huart);
000012  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2399     
;;;2400     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;2401   }
000018  bd10              POP      {r4,pc}
;;;2402   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2180     */
;;;2181   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2182   {
;;;2183     /* Disable TXEIE and TCIE interrupts */
;;;2184     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  60ca              STR      r2,[r1,#0xc]
;;;2185   
;;;2186     /* At end of Tx process, restore huart->gState to Ready */
;;;2187     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;2188   }
000010  4770              BX       lr
;;;2189   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  UART_Receive_IT PROC
;;;2408     */
;;;2409   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2410   {
;;;2411       
;;;2412       uint32_t tmp_state = 0U;
;;;2413   	uint8_t rec;
;;;2414   
;;;2415       tmp_state = huart->RxState;
000004  f890103a          LDRB     r1,[r0,#0x3a]
;;;2416   	
;;;2417       if ((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
000008  2922              CMP      r1,#0x22
00000a  d004              BEQ      |L52.22|
00000c  2923              CMP      r1,#0x23
00000e  d002              BEQ      |L52.22|
;;;2418       {
;;;2419   		rec = ((uint8_t) (huart->Instance->DR & (uint8_t) 0x00FFU));
;;;2420   		RS485_StartTimer(BYTE_TRANSFER_TIMEOUT);
;;;2421   
;;;2422   		switch (receive_pcnt)
;;;2423   		{
;;;2424   			case 0:
;;;2425   			{
;;;2426   				if ((rec == SOH) || (rec == STX))
;;;2427   				{
;;;2428   					packet_type = rec;
;;;2429   					++receive_pcnt;
;;;2430   				}
;;;2431   				break;
;;;2432   			}
;;;2433   
;;;2434   			case 1:
;;;2435   			{
;;;2436   				rs485_buff[0] = rec;
;;;2437   				++receive_pcnt;
;;;2438   				break;
;;;2439   			}
;;;2440   
;;;2441   			case 2:
;;;2442   			{
;;;2443   				++receive_pcnt;
;;;2444   				
;;;2445   				if ((rs485_buff[0] == rs485_interface_address[0]) && (rec == rs485_interface_address[1]))
;;;2446   				{
;;;2447   					eTransferMode = TRANSFER_P2P;
;;;2448   				}
;;;2449   				else if ((rs485_buff[0] == rs485_group_address[0]) && (rec == rs485_group_address[1]))
;;;2450   				{
;;;2451   					eTransferMode = TRANSFER_GROUP;
;;;2452   				}
;;;2453   				else if ((rs485_buff[0] == rs485_broadcast_address[0]) && (rec == rs485_broadcast_address[1]))
;;;2454   				{
;;;2455   					eTransferMode = TRANSFER_BROADCAST;
;;;2456   				}
;;;2457   				else
;;;2458   				{
;;;2459   					receive_pcnt = 0U;
;;;2460   				}
;;;2461   				break;
;;;2462   			}
;;;2463   
;;;2464   			case 3:
;;;2465   			{
;;;2466   				rs485_buff[0] = rec;
;;;2467   				++receive_pcnt;
;;;2468   				break;
;;;2469   			}
;;;2470   
;;;2471   			case 4:
;;;2472   			{
;;;2473   				rs485_sender_address = (rs485_buff[0] << 8U) + rec;
;;;2474   				++receive_pcnt;
;;;2475   				break;
;;;2476   			}
;;;2477   
;;;2478   			case 5:
;;;2479   			{
;;;2480   				rs485_packet_data_lenght = rec;
;;;2481   				++receive_pcnt;
;;;2482   				break;
;;;2483   			}
;;;2484   
;;;2485   			case 6:
;;;2486   			{
;;;2487   				rs485_buff[rec_bcnt++] = rec;
;;;2488   				
;;;2489   				if (rec_bcnt == (rs485_packet_data_lenght + 3U))
;;;2490   				{
;;;2491   					RS485_StopTimer();
;;;2492   					--rec_bcnt;
;;;2493   					rs485_packet_checksum = 0U;
;;;2494   
;;;2495   					for (uint32_t i = 0U; i != rs485_packet_data_lenght; i++)
;;;2496   					{
;;;2497   						rs485_packet_checksum += rs485_buff[i];
;;;2498   					}
;;;2499   
;;;2500   					if (((rs485_packet_checksum >> 8U) == rs485_buff[rec_bcnt - 2U]) && \
;;;2501   						((rs485_packet_checksum & 0xFFU) == rs485_buff[rec_bcnt - 1U]))
;;;2502   					{
;;;2503   						if (rec == EOT)
;;;2504   						{
;;;2505   							__HAL_UART_DISABLE_IT(&huart1, UART_IT_RXNE);
;;;2506   							huart1.RxState = HAL_UART_STATE_READY;
;;;2507   							huart1.gState = HAL_UART_STATE_READY;
;;;2508   							eComState = COM_PACKET_RECEIVED;
;;;2509   							RS485_StartTimer(RECEIVER_REINIT_TIMEOUT);
;;;2510   						}
;;;2511   						else
;;;2512   						{
;;;2513   							++receiving_errors;
;;;2514   							RS485_Init();
;;;2515   						}
;;;2516   					}
;;;2517   					else
;;;2518   					{
;;;2519   						++receiving_errors;
;;;2520   						RS485_Init();
;;;2521   					}
;;;2522   				}
;;;2523   				break;
;;;2524   			}
;;;2525   
;;;2526   			default:
;;;2527   			{
;;;2528   				RS485_Init();
;;;2529   				break;
;;;2530   			}
;;;2531   		}
;;;2532   		
;;;2533           return HAL_OK;
;;;2534       }
;;;2535       else
;;;2536       {
;;;2537           return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L52.18|
;;;2538       }
;;;2539   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L52.22|
000016  6800              LDR      r0,[r0,#0]            ;2419
000018  6840              LDR      r0,[r0,#4]            ;2419
00001a  b2c0              UXTB     r0,r0                 ;2419
00001c  4d56              LDR      r5,|L52.376|
00001e  2105              MOVS     r1,#5                 ;2420
000020  6029              STR      r1,[r5,#0]            ;2420  ; rs485_timer
000022  4956              LDR      r1,|L52.380|
000024  680b              LDR      r3,[r1,#0]            ;2422  ; receive_pcnt
000026  2602              MOVS     r6,#2                 ;2413
000028  4c55              LDR      r4,|L52.384|
00002a  4a56              LDR      r2,|L52.388|
00002c  f04f0c00          MOV      r12,#0                ;2422
000030  2b07              CMP      r3,#7                 ;2422
000032  d27d              BCS      |L52.304|
000034  e8dff003          TBB      [pc,r3]               ;2422
000038  040e1338          DCB      0x04,0x0e,0x13,0x38
00003c  3d464b00          DCB      0x3d,0x46,0x4b,0x00
000040  2801              CMP      r0,#1                 ;2426
000042  d001              BEQ      |L52.72|
000044  2802              CMP      r0,#2                 ;2426
000046  d104              BNE      |L52.82|
                  |L52.72|
000048  4a4f              LDR      r2,|L52.392|
00004a  6010              STR      r0,[r2,#0]            ;2428  ; packet_type
00004c  6808              LDR      r0,[r1,#0]            ;2429  ; receive_pcnt
00004e  1c40              ADDS     r0,r0,#1              ;2429
000050  6008              STR      r0,[r1,#0]            ;2429  ; receive_pcnt
                  |L52.82|
000052  e08f              B        |L52.372|
000054  7010              STRB     r0,[r2,#0]            ;2436
000056  6808              LDR      r0,[r1,#0]            ;2437  ; receive_pcnt
000058  1c40              ADDS     r0,r0,#1              ;2437
00005a  6008              STR      r0,[r1,#0]            ;2437  ; receive_pcnt
00005c  e08a              B        |L52.372|
00005e  680b              LDR      r3,[r1,#0]            ;2443  ; receive_pcnt
000060  1c5b              ADDS     r3,r3,#1              ;2443
000062  600b              STR      r3,[r1,#0]            ;2443  ; receive_pcnt
000064  4c49              LDR      r4,|L52.396|
000066  7812              LDRB     r2,[r2,#0]            ;2445  ; rs485_buff
000068  4b49              LDR      r3,|L52.400|
00006a  7825              LDRB     r5,[r4,#0]            ;2445  ; rs485_interface_address
00006c  42aa              CMP      r2,r5                 ;2445
00006e  d105              BNE      |L52.124|
000070  7864              LDRB     r4,[r4,#1]            ;2445  ; rs485_interface_address
000072  4284              CMP      r4,r0                 ;2445
000074  d102              BNE      |L52.124|
000076  2001              MOVS     r0,#1                 ;2447
000078  7018              STRB     r0,[r3,#0]            ;2447
00007a  e07b              B        |L52.372|
                  |L52.124|
00007c  4c45              LDR      r4,|L52.404|
00007e  7825              LDRB     r5,[r4,#0]            ;2449  ; rs485_group_address
000080  42aa              CMP      r2,r5                 ;2449
000082  d104              BNE      |L52.142|
000084  7864              LDRB     r4,[r4,#1]            ;2449  ; rs485_group_address
000086  4284              CMP      r4,r0                 ;2449
000088  d101              BNE      |L52.142|
00008a  701e              STRB     r6,[r3,#0]            ;2451
00008c  e072              B        |L52.372|
                  |L52.142|
00008e  4c42              LDR      r4,|L52.408|
000090  7825              LDRB     r5,[r4,#0]            ;2453  ; rs485_broadcast_address
000092  42aa              CMP      r2,r5                 ;2453
000094  d105              BNE      |L52.162|
000096  7862              LDRB     r2,[r4,#1]            ;2453  ; rs485_broadcast_address
000098  4282              CMP      r2,r0                 ;2453
00009a  d102              BNE      |L52.162|
00009c  2003              MOVS     r0,#3                 ;2455
00009e  7018              STRB     r0,[r3,#0]            ;2455
0000a0  e068              B        |L52.372|
                  |L52.162|
0000a2  f8c1c000          STR      r12,[r1,#0]           ;2459  ; receive_pcnt
0000a6  e065              B        |L52.372|
0000a8  7010              STRB     r0,[r2,#0]            ;2466
0000aa  6808              LDR      r0,[r1,#0]            ;2467  ; receive_pcnt
0000ac  1c40              ADDS     r0,r0,#1              ;2467
0000ae  6008              STR      r0,[r1,#0]            ;2467  ; receive_pcnt
0000b0  e060              B        |L52.372|
0000b2  7812              LDRB     r2,[r2,#0]            ;2473  ; rs485_buff
0000b4  eb002002          ADD      r0,r0,r2,LSL #8       ;2473
0000b8  4a38              LDR      r2,|L52.412|
0000ba  6010              STR      r0,[r2,#0]            ;2473  ; rs485_sender_address
0000bc  6808              LDR      r0,[r1,#0]            ;2474  ; receive_pcnt
0000be  1c40              ADDS     r0,r0,#1              ;2474
0000c0  6008              STR      r0,[r1,#0]            ;2474  ; receive_pcnt
0000c2  e057              B        |L52.372|
0000c4  6020              STR      r0,[r4,#0]            ;2480  ; rs485_packet_data_lenght
0000c6  6808              LDR      r0,[r1,#0]            ;2481  ; receive_pcnt
0000c8  1c40              ADDS     r0,r0,#1              ;2481
0000ca  6008              STR      r0,[r1,#0]            ;2481  ; receive_pcnt
0000cc  e052              B        |L52.372|
0000ce  4f34              LDR      r7,|L52.416|
0000d0  6839              LDR      r1,[r7,#0]            ;2487  ; rec_bcnt
0000d2  1c4b              ADDS     r3,r1,#1              ;2487
0000d4  603b              STR      r3,[r7,#0]            ;2487  ; rec_bcnt
0000d6  5450              STRB     r0,[r2,r1]            ;2487
0000d8  683b              LDR      r3,[r7,#0]            ;2489  ; rec_bcnt
0000da  6821              LDR      r1,[r4,#0]            ;2489  ; rs485_packet_data_lenght
0000dc  1cc9              ADDS     r1,r1,#3              ;2489
0000de  428b              CMP      r3,r1                 ;2489
0000e0  d148              BNE      |L52.372|
0000e2  f8c5c000          STR      r12,[r5,#0]           ;2491  ; rs485_timer
0000e6  6839              LDR      r1,[r7,#0]            ;2492  ; rec_bcnt
0000e8  1e49              SUBS     r1,r1,#1              ;2492
0000ea  6039              STR      r1,[r7,#0]            ;2492  ; rec_bcnt
0000ec  4b2d              LDR      r3,|L52.420|
0000ee  f8c3c000          STR      r12,[r3,#0]           ;2493  ; rs485_packet_checksum
0000f2  2100              MOVS     r1,#0                 ;2495
0000f4  e007              B        |L52.262|
                  |L52.246|
0000f6  f812c001          LDRB     r12,[r2,r1]           ;2497
0000fa  f8d38000          LDR      r8,[r3,#0]            ;2497  ; rs485_packet_checksum
0000fe  44c4              ADD      r12,r12,r8            ;2497
000100  f8c3c000          STR      r12,[r3,#0]           ;2497  ; rs485_packet_checksum
000104  1c49              ADDS     r1,r1,#1              ;2495
                  |L52.262|
000106  f8d4c000          LDR      r12,[r4,#0]           ;2495  ; rs485_packet_data_lenght
00010a  4561              CMP      r1,r12                ;2495
00010c  d1f3              BNE      |L52.246|
00010e  6839              LDR      r1,[r7,#0]            ;2500  ; rec_bcnt
000110  f8d38000          LDR      r8,[r3,#0]            ;2500  ; rs485_packet_checksum
000114  4411              ADD      r1,r1,r2              ;2500
000116  f811cc02          LDRB     r12,[r1,#-2]          ;2500
00011a  4c23              LDR      r4,|L52.424|
00011c  6821              LDR      r1,[r4,#0]            ;2513
00011e  1c49              ADDS     r1,r1,#1              ;2513
000120  ebbc2f18          CMP      r12,r8,LSR #8         ;2500
000124  d120              BNE      |L52.360|
000126  681b              LDR      r3,[r3,#0]            ;2501  ; rs485_packet_checksum
000128  683f              LDR      r7,[r7,#0]            ;2501  ; rec_bcnt
00012a  b2db              UXTB     r3,r3                 ;2501
00012c  443a              ADD      r2,r2,r7              ;2501
00012e  e000              B        |L52.306|
                  |L52.304|
000130  e01e              B        |L52.368|
                  |L52.306|
000132  f8122c01          LDRB     r2,[r2,#-1]           ;2501
000136  4293              CMP      r3,r2                 ;2501
000138  d116              BNE      |L52.360|
00013a  2804              CMP      r0,#4                 ;2503
00013c  d003              BEQ      |L52.326|
00013e  6021              STR      r1,[r4,#0]            ;2513  ; receiving_errors
000140  f7fffffe          BL       RS485_Init
000144  e016              B        |L52.372|
                  |L52.326|
000146  4919              LDR      r1,|L52.428|
000148  6808              LDR      r0,[r1,#0]            ;2505  ; huart1
00014a  68c2              LDR      r2,[r0,#0xc]          ;2505
00014c  f0220220          BIC      r2,r2,#0x20           ;2505
000150  60c2              STR      r2,[r0,#0xc]          ;2505
000152  2020              MOVS     r0,#0x20              ;2506
000154  f881003a          STRB     r0,[r1,#0x3a]         ;2506
000158  f8810039          STRB     r0,[r1,#0x39]         ;2507
00015c  4814              LDR      r0,|L52.432|
00015e  7006              STRB     r6,[r0,#0]            ;2508
000160  f241602e          MOV      r0,#0x162e            ;2509
000164  6028              STR      r0,[r5,#0]            ;2509  ; rs485_timer
000166  e005              B        |L52.372|
                  |L52.360|
000168  6021              STR      r1,[r4,#0]            ;2519  ; receiving_errors
00016a  f7fffffe          BL       RS485_Init
00016e  e001              B        |L52.372|
                  |L52.368|
000170  f7fffffe          BL       RS485_Init
                  |L52.372|
000174  2000              MOVS     r0,#0                 ;2533
000176  e74c              B        |L52.18|
;;;2540   
                          ENDP

                  |L52.376|
                          DCD      rs485_timer
                  |L52.380|
                          DCD      receive_pcnt
                  |L52.384|
                          DCD      rs485_packet_data_lenght
                  |L52.388|
                          DCD      rs485_buff
                  |L52.392|
                          DCD      packet_type
                  |L52.396|
                          DCD      rs485_interface_address
                  |L52.400|
                          DCD      eTransferMode
                  |L52.404|
                          DCD      rs485_group_address
                  |L52.408|
                          DCD      rs485_broadcast_address
                  |L52.412|
                          DCD      rs485_sender_address
                  |L52.416|
                          DCD      rec_bcnt
                  |L52.420|
                          DCD      rs485_packet_checksum
                  |L52.424|
                          DCD      receiving_errors
                  |L52.428|
                          DCD      huart1
                  |L52.432|
                          DCD      eComState

                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2546     */
;;;2547   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2548   {
000004  4604              MOV      r4,r0
;;;2549     uint32_t tmpreg = 0x00U;
;;;2550   
;;;2551     /* Check the parameters */
;;;2552     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2553     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2554     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2555     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2556   
;;;2557     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;2558     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;2559      * to huart->Init.StopBits value */
;;;2560     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;2561   
;;;2562     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;2563     /* Configure the UART Word Length, Parity and mode: 
;;;2564        Set the M bits according to huart->Init.WordLength value 
;;;2565        Set PCE and PS bits according to huart->Init.Parity value
;;;2566        Set TE and RE bits according to huart->Init.Mode value
;;;2567        Set OVER8 bit according to huart->Init.OverSampling value */
;;;2568   
;;;2569   #if defined(USART_CR1_OVER8)
;;;2570     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;2571     MODIFY_REG(huart->Instance->CR1, 
;;;2572                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
;;;2573                tmpreg);
;;;2574   #else
;;;2575     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000014  68a1              LDR      r1,[r4,#8]
000016  6920              LDR      r0,[r4,#0x10]
000018  4301              ORRS     r1,r1,r0
00001a  6960              LDR      r0,[r4,#0x14]
00001c  4301              ORRS     r1,r1,r0
;;;2576     MODIFY_REG(huart->Instance->CR1, 
00001e  6820              LDR      r0,[r4,#0]
000020  68c2              LDR      r2,[r0,#0xc]
000022  f241630c          MOV      r3,#0x160c
000026  439a              BICS     r2,r2,r3
000028  430a              ORRS     r2,r2,r1
00002a  60c2              STR      r2,[r0,#0xc]
;;;2577                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;2578                tmpreg);
;;;2579   #endif /* USART_CR1_OVER8 */
;;;2580   
;;;2581     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;2582     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;2583     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  69a2              LDR      r2,[r4,#0x18]
000032  f4217140          BIC      r1,r1,#0x300
000036  4311              ORRS     r1,r1,r2
000038  6141              STR      r1,[r0,#0x14]
;;;2584   
;;;2585   #if defined(USART_CR1_OVER8)
;;;2586     /* Check the Over Sampling */
;;;2587     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;2588     {
;;;2589       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2590       if(huart->Instance == USART1)
;;;2591       {
;;;2592         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2593       }
;;;2594       else
;;;2595       {
;;;2596         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2597       }
;;;2598     }
;;;2599     else
;;;2600     {
;;;2601       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2602       if(huart->Instance == USART1)
;;;2603       {
;;;2604         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2605       }
;;;2606       else
;;;2607       {
;;;2608         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2609       }
;;;2610     }
;;;2611   #else
;;;2612     /*-------------------------- USART BRR Configuration ---------------------*/
;;;2613     if(huart->Instance == USART1)
00003a  4957              LDR      r1,|L53.408|
00003c  6820              LDR      r0,[r4,#0]
;;;2614     {
;;;2615       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00003e  2564              MOVS     r5,#0x64
000040  2632              MOVS     r6,#0x32
000042  4288              CMP      r0,r1                 ;2613
000044  d154              BNE      |L53.240|
000046  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  0089              LSLS     r1,r1,#2
000056  fbb0f7f1          UDIV     r7,r0,r1
00005a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005e  eb0001c0          ADD      r1,r0,r0,LSL #3
000062  eb011000          ADD      r0,r1,r0,LSL #4
000066  6861              LDR      r1,[r4,#4]
000068  0089              LSLS     r1,r1,#2
00006a  fbb0f0f1          UDIV     r0,r0,r1
00006e  fbb0f0f5          UDIV     r0,r0,r5
000072  f06f0118          MVN      r1,#0x18
000076  4348              MULS     r0,r1,r0
000078  eb070080          ADD      r0,r7,r0,LSL #2
00007c  eb061000          ADD      r0,r6,r0,LSL #4
000080  fbb0f0f5          UDIV     r0,r0,r5
000084  f00007f0          AND      r7,r0,#0xf0
000088  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008c  eb0001c0          ADD      r1,r0,r0,LSL #3
000090  eb011000          ADD      r0,r1,r0,LSL #4
000094  6861              LDR      r1,[r4,#4]
000096  0089              LSLS     r1,r1,#2
000098  fbb0f0f1          UDIV     r0,r0,r1
00009c  fbb0f0f5          UDIV     r0,r0,r5
0000a0  eb071700          ADD      r7,r7,r0,LSL #4
0000a4  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000a8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ac  eb011000          ADD      r0,r1,r0,LSL #4
0000b0  6861              LDR      r1,[r4,#4]
0000b2  0089              LSLS     r1,r1,#2
0000b4  fbb0f8f1          UDIV     r8,r0,r1
0000b8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000bc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000c0  eb011000          ADD      r0,r1,r0,LSL #4
0000c4  6861              LDR      r1,[r4,#4]
0000c6  0089              LSLS     r1,r1,#2
0000c8  fbb0f0f1          UDIV     r0,r0,r1
0000cc  fbb0f0f5          UDIV     r0,r0,r5
0000d0  f06f0118          MVN      r1,#0x18
0000d4  4348              MULS     r0,r1,r0
0000d6  eb080080          ADD      r0,r8,r0,LSL #2
0000da  eb061000          ADD      r0,r6,r0,LSL #4
0000de  fbb0f0f5          UDIV     r0,r0,r5
0000e2  6821              LDR      r1,[r4,#0]
0000e4  f000000f          AND      r0,r0,#0xf
0000e8  4438              ADD      r0,r0,r7
0000ea  6088              STR      r0,[r1,#8]
                  |L53.236|
;;;2616     }
;;;2617     else
;;;2618     {
;;;2619       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2620     }
;;;2621   #endif /* USART_CR1_OVER8 */
;;;2622   }
0000ec  e8bd81f0          POP      {r4-r8,pc}
                  |L53.240|
0000f0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000f4  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2619
0000f8  eb011000          ADD      r0,r1,r0,LSL #4       ;2619
0000fc  6861              LDR      r1,[r4,#4]            ;2619
0000fe  0089              LSLS     r1,r1,#2              ;2619
000100  fbb0f7f1          UDIV     r7,r0,r1              ;2619
000104  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000108  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2619
00010c  eb011000          ADD      r0,r1,r0,LSL #4       ;2619
000110  6861              LDR      r1,[r4,#4]            ;2619
000112  0089              LSLS     r1,r1,#2              ;2619
000114  fbb0f0f1          UDIV     r0,r0,r1              ;2619
000118  fbb0f0f5          UDIV     r0,r0,r5              ;2619
00011c  f06f0118          MVN      r1,#0x18              ;2619
000120  4348              MULS     r0,r1,r0              ;2619
000122  eb070080          ADD      r0,r7,r0,LSL #2       ;2619
000126  eb061000          ADD      r0,r6,r0,LSL #4       ;2619
00012a  fbb0f0f5          UDIV     r0,r0,r5              ;2619
00012e  f00007f0          AND      r7,r0,#0xf0           ;2619
000132  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000136  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2619
00013a  eb011000          ADD      r0,r1,r0,LSL #4       ;2619
00013e  6861              LDR      r1,[r4,#4]            ;2619
000140  0089              LSLS     r1,r1,#2              ;2619
000142  fbb0f0f1          UDIV     r0,r0,r1              ;2619
000146  fbb0f0f5          UDIV     r0,r0,r5              ;2619
00014a  eb071700          ADD      r7,r7,r0,LSL #4       ;2619
00014e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000152  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2619
000156  eb011000          ADD      r0,r1,r0,LSL #4       ;2619
00015a  6861              LDR      r1,[r4,#4]            ;2619
00015c  0089              LSLS     r1,r1,#2              ;2619
00015e  fbb0f8f1          UDIV     r8,r0,r1              ;2619
000162  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000166  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2619
00016a  eb011000          ADD      r0,r1,r0,LSL #4       ;2619
00016e  6861              LDR      r1,[r4,#4]            ;2619
000170  0089              LSLS     r1,r1,#2              ;2619
000172  fbb0f0f1          UDIV     r0,r0,r1              ;2619
000176  fbb0f0f5          UDIV     r0,r0,r5              ;2619
00017a  f06f0118          MVN      r1,#0x18              ;2619
00017e  4348              MULS     r0,r1,r0              ;2619
000180  eb080080          ADD      r0,r8,r0,LSL #2       ;2619
000184  eb061000          ADD      r0,r6,r0,LSL #4       ;2619
000188  fbb0f0f5          UDIV     r0,r0,r5              ;2619
00018c  6821              LDR      r1,[r4,#0]            ;2619
00018e  f000000f          AND      r0,r0,#0xf            ;2619
000192  4438              ADD      r0,r0,r7              ;2619
000194  6088              STR      r0,[r1,#8]            ;2619
000196  e7a9              B        |L53.236|
;;;2623   
                          ENDP

                  |L53.408|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2343     */
;;;2344   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;2345   {
;;;2346     uint16_t* tmp;
;;;2347     
;;;2348     /* Check that a Tx process is ongoing */
;;;2349     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d001              BEQ      |L54.12|
;;;2350     {
;;;2351       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2352       {
;;;2353         tmp = (uint16_t*) huart->pTxBuffPtr;
;;;2354         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2355         if(huart->Init.Parity == UART_PARITY_NONE)
;;;2356         {
;;;2357           huart->pTxBuffPtr += 2U;
;;;2358         }
;;;2359         else
;;;2360         {
;;;2361           huart->pTxBuffPtr += 1U;
;;;2362         }
;;;2363       } 
;;;2364       else
;;;2365       {
;;;2366         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2367       }
;;;2368   
;;;2369       if(--huart->TxXferCount == 0U)
;;;2370       {
;;;2371         /* Disable the UART Transmit Complete Interrupt */
;;;2372         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;2373   
;;;2374         /* Enable the UART Transmit Complete Interrupt */    
;;;2375         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;2376       }
;;;2377       return HAL_OK;
;;;2378     }
;;;2379     else
;;;2380     {
;;;2381       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;2382     }
;;;2383   }
00000a  4770              BX       lr
                  |L54.12|
00000c  6881              LDR      r1,[r0,#8]            ;2351
00000e  f5b15f80          CMP      r1,#0x1000            ;2351
000012  d00c              BEQ      |L54.46|
000014  6a01              LDR      r1,[r0,#0x20]         ;2366
000016  1c4a              ADDS     r2,r1,#1              ;2366
000018  6202              STR      r2,[r0,#0x20]         ;2366
00001a  6802              LDR      r2,[r0,#0]            ;2366
00001c  7809              LDRB     r1,[r1,#0]            ;2366
00001e  6051              STR      r1,[r2,#4]            ;2366
                  |L54.32|
000020  8cc1              LDRH     r1,[r0,#0x26]         ;2369
000022  1e49              SUBS     r1,r1,#1              ;2369
000024  0409              LSLS     r1,r1,#16             ;2369
000026  0c09              LSRS     r1,r1,#16             ;2369
000028  84c1              STRH     r1,[r0,#0x26]         ;2369
00002a  d010              BEQ      |L54.78|
00002c  e019              B        |L54.98|
                  |L54.46|
00002e  6a01              LDR      r1,[r0,#0x20]         ;2353
000030  6802              LDR      r2,[r0,#0]            ;2354
000032  8809              LDRH     r1,[r1,#0]            ;2354
000034  f3c10108          UBFX     r1,r1,#0,#9           ;2354
000038  6051              STR      r1,[r2,#4]            ;2354
00003a  6901              LDR      r1,[r0,#0x10]         ;2355
00003c  b119              CBZ      r1,|L54.70|
00003e  6a01              LDR      r1,[r0,#0x20]         ;2361
000040  1c49              ADDS     r1,r1,#1              ;2361
000042  6201              STR      r1,[r0,#0x20]         ;2361
000044  e7ec              B        |L54.32|
                  |L54.70|
000046  6a01              LDR      r1,[r0,#0x20]         ;2357
000048  1c89              ADDS     r1,r1,#2              ;2357
00004a  6201              STR      r1,[r0,#0x20]         ;2357
00004c  e7e8              B        |L54.32|
                  |L54.78|
00004e  6801              LDR      r1,[r0,#0]            ;2372
000050  68ca              LDR      r2,[r1,#0xc]          ;2372
000052  f0220280          BIC      r2,r2,#0x80           ;2372
000056  60ca              STR      r2,[r1,#0xc]          ;2372
000058  6800              LDR      r0,[r0,#0]            ;2375
00005a  68c1              LDR      r1,[r0,#0xc]          ;2375
00005c  f0410140          ORR      r1,r1,#0x40           ;2375
000060  60c1              STR      r1,[r0,#0xc]          ;2375
                  |L54.98|
000062  2000              MOVS     r0,#0                 ;2377
000064  4770              BX       lr
;;;2384   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2147     */
;;;2148   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2149   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;2150     /* Wait until flag is set */
;;;2151     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
;;;2152     {
;;;2153       /* Check for the Timeout */
;;;2154       if(Timeout != HAL_MAX_DELAY)
;;;2155       {
;;;2156         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
;;;2157         {
;;;2158           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2159           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;2160           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2161           
;;;2162           huart->gState  = HAL_UART_STATE_READY;
;;;2163           huart->RxState = HAL_UART_STATE_READY;
;;;2164           
;;;2165           /* Process Unlocked */
;;;2166           __HAL_UNLOCK(huart);
;;;2167           
;;;2168           return HAL_TIMEOUT;
00000e  e01d              B        |L55.76|
                  |L55.16|
000010  1c68              ADDS     r0,r5,#1              ;2154
000012  d01b              BEQ      |L55.76|
000014  b12d              CBZ      r5,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2156
00001e  42a8              CMP      r0,r5                 ;2156
000020  d914              BLS      |L55.76|
                  |L55.34|
000022  6820              LDR      r0,[r4,#0]            ;2159
000024  68c1              LDR      r1,[r0,#0xc]          ;2159
000026  f42171d0          BIC      r1,r1,#0x1a0          ;2159
00002a  60c1              STR      r1,[r0,#0xc]          ;2159
00002c  6820              LDR      r0,[r4,#0]            ;2160
00002e  6941              LDR      r1,[r0,#0x14]         ;2160
000030  f0210101          BIC      r1,r1,#1              ;2160
000034  6141              STR      r1,[r0,#0x14]         ;2160
000036  2020              MOVS     r0,#0x20              ;2162
000038  f8840039          STRB     r0,[r4,#0x39]         ;2162
00003c  f884003a          STRB     r0,[r4,#0x3a]         ;2163
000040  2000              MOVS     r0,#0                 ;2166
000042  f8840038          STRB     r0,[r4,#0x38]         ;2166
000046  2003              MOVS     r0,#3
                  |L55.72|
;;;2169         }
;;;2170       }
;;;2171     }
;;;2172     
;;;2173     return HAL_OK;
;;;2174   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L55.76|
00004c  6820              LDR      r0,[r4,#0]            ;2151
00004e  6800              LDR      r0,[r0,#0]            ;2151
000050  ea360000          BICS     r0,r6,r0              ;2151
000054  d004              BEQ      |L55.96|
000056  2000              MOVS     r0,#0                 ;2151
                  |L55.88|
000058  42b8              CMP      r0,r7                 ;2151
00005a  d0d9              BEQ      |L55.16|
00005c  2000              MOVS     r0,#0                 ;2173
00005e  e7f3              B        |L55.72|
                  |L55.96|
000060  2001              MOVS     r0,#1                 ;2151
000062  e7f9              B        |L55.88|
;;;2175   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 456
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 643
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
