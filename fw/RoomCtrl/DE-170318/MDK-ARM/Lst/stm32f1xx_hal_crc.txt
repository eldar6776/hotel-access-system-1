; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-170318\stm32f1xx_hal_crc.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-170318\stm32f1xx_hal_crc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I.\RTE\_DE-170318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-170318\stm32f1xx_hal_crc.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_crc.c]
                          THUMB

                          AREA ||i.CRC_Calculate16||, CODE, READONLY, ALIGN=2

                  CRC_Calculate16 PROC
;;;350    
;;;351    uint32_t CRC_Calculate16(uint16_t* arr, uint32_t count) {
000000  4a04              LDR      r2,|L1.20|
000002  e002              B        |L1.10|
                  |L1.4|
;;;352    	
;;;353    	
;;;354    	/* Calculate CRC */
;;;355    	while (count--) {
;;;356    		/* Set new value */
;;;357    		CRC->DR = *arr++;
000004  f8303b02          LDRH     r3,[r0],#2
000008  6013              STR      r3,[r2,#0]
                  |L1.10|
00000a  1e49              SUBS     r1,r1,#1              ;355
00000c  1c4b              ADDS     r3,r1,#1              ;355
00000e  d1f9              BNE      |L1.4|
;;;358    	}
;;;359    	
;;;360    	/* Return data */
;;;361    	return CRC->DR;
000010  6810              LDR      r0,[r2,#0]
;;;362    }
000012  4770              BX       lr
;;;363    
                          ENDP

                  |L1.20|
                          DCD      0x40023000

                          AREA ||i.CRC_Calculate32||, CODE, READONLY, ALIGN=2

                  CRC_Calculate32 PROC
;;;363    
;;;364    uint32_t CRC_Calculate32(uint32_t* arr, uint32_t count) {
000000  4a04              LDR      r2,|L2.20|
000002  e001              B        |L2.8|
                  |L2.4|
;;;365    	
;;;366    	
;;;367    	/* Calculate CRC */
;;;368    	while (count--) {
;;;369    		/* Set new value */
;;;370    		CRC->DR = *arr++;
000004  c808              LDM      r0!,{r3}
000006  6013              STR      r3,[r2,#0]
                  |L2.8|
000008  1e49              SUBS     r1,r1,#1              ;368
00000a  1c4b              ADDS     r3,r1,#1              ;368
00000c  d1fa              BNE      |L2.4|
;;;371    	}
;;;372    	
;;;373    	/* Return data */
;;;374    	return CRC->DR;
00000e  6810              LDR      r0,[r2,#0]
;;;375    }
000010  4770              BX       lr
;;;376    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023000

                          AREA ||i.CRC_Calculate8||, CODE, READONLY, ALIGN=2

                  CRC_Calculate8 PROC
;;;339    
;;;340    uint32_t CRC_Calculate8(uint8_t* arr, uint32_t count) {
000000  b510              PUSH     {r4,lr}
;;;341    	
;;;342    	uint32_t index = 0;
000002  2200              MOVS     r2,#0
;;;343      
;;;344    	for(index = 0; index < count; index++)
;;;345    	{
;;;346    		CRC->DR = *arr++;
000004  4b04              LDR      r3,|L3.24|
000006  e003              B        |L3.16|
                  |L3.8|
000008  f8104b01          LDRB     r4,[r0],#1
00000c  601c              STR      r4,[r3,#0]
00000e  1c52              ADDS     r2,r2,#1              ;344
                  |L3.16|
000010  428a              CMP      r2,r1                 ;344
000012  d3f9              BCC      |L3.8|
;;;347    	}
;;;348    	return (CRC->DR);
000014  6818              LDR      r0,[r3,#0]
;;;349    }
000016  bd10              POP      {r4,pc}
;;;350    
                          ENDP

                  |L3.24|
                          DCD      0x40023000

                          AREA ||i.CRC_ResetDR||, CODE, READONLY, ALIGN=2

                  CRC_ResetDR PROC
;;;333      */
;;;334    void CRC_ResetDR(void)
000000  4901              LDR      r1,|L4.8|
;;;335    {
;;;336      /* Reset CRC generator */
;;;337      CRC->CR = CRC_CR_RESET;
000002  2001              MOVS     r0,#1
000004  6088              STR      r0,[r1,#8]
;;;338    }
000006  4770              BX       lr
;;;339    
                          ENDP

                  |L4.8|
                          DCD      0x40023000

                          AREA ||i.HAL_CRC_Accumulate||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Accumulate PROC
;;;237      */
;;;238    uint32_t HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
;;;240      uint32_t index = 0U;
000002  2300              MOVS     r3,#0
;;;241    
;;;242      /* Process Locked */
;;;243      __HAL_LOCK(hcrc);
000004  7904              LDRB     r4,[r0,#4]
000006  2c01              CMP      r4,#1
000008  d004              BEQ      |L5.20|
00000a  2601              MOVS     r6,#1
00000c  7106              STRB     r6,[r0,#4]
;;;244    
;;;245      /* Change CRC peripheral state */
;;;246      hcrc->State = HAL_CRC_STATE_BUSY;
00000e  2402              MOVS     r4,#2
000010  7144              STRB     r4,[r0,#5]
000012  e006              B        |L5.34|
                  |L5.20|
000014  2002              MOVS     r0,#2                 ;243
;;;247    
;;;248      /* Enter Data to the CRC calculator */
;;;249      for(index = 0U; index < BufferLength; index++)
;;;250      {
;;;251        hcrc->Instance->DR = pBuffer[index];
;;;252      }
;;;253    
;;;254      /* Change CRC peripheral state */
;;;255      hcrc->State = HAL_CRC_STATE_READY;
;;;256    
;;;257      /* Process Unlocked */
;;;258      __HAL_UNLOCK(hcrc);
;;;259    
;;;260      /* Return the CRC computed value */
;;;261      return hcrc->Instance->DR;
;;;262    }
000016  bd70              POP      {r4-r6,pc}
                  |L5.24|
000018  6805              LDR      r5,[r0,#0]            ;251
00001a  f8514023          LDR      r4,[r1,r3,LSL #2]     ;251
00001e  602c              STR      r4,[r5,#0]            ;251
000020  1c5b              ADDS     r3,r3,#1              ;249
                  |L5.34|
000022  4293              CMP      r3,r2                 ;249
000024  d3f8              BCC      |L5.24|
000026  7146              STRB     r6,[r0,#5]            ;255
000028  2100              MOVS     r1,#0                 ;258
00002a  7101              STRB     r1,[r0,#4]            ;258
00002c  6800              LDR      r0,[r0,#0]            ;261
00002e  6800              LDR      r0,[r0,#0]            ;261
000030  bd70              POP      {r4-r6,pc}
;;;263    
                          ENDP


                          AREA ||i.HAL_CRC_Calculate||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Calculate PROC
;;;272      */
;;;273    uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
;;;275      uint32_t index = 0U;
000002  2300              MOVS     r3,#0
;;;276    
;;;277      /* Process Locked */
;;;278      __HAL_LOCK(hcrc); 
000004  7904              LDRB     r4,[r0,#4]
000006  2c01              CMP      r4,#1
000008  d009              BEQ      |L6.30|
00000a  2601              MOVS     r6,#1
00000c  7106              STRB     r6,[r0,#4]
;;;279    
;;;280      /* Change CRC peripheral state */
;;;281      hcrc->State = HAL_CRC_STATE_BUSY;
00000e  2402              MOVS     r4,#2
000010  7144              STRB     r4,[r0,#5]
;;;282    
;;;283      /* Reset CRC Calculation Unit */
;;;284      __HAL_CRC_DR_RESET(hcrc);
000012  6804              LDR      r4,[r0,#0]
000014  68a5              LDR      r5,[r4,#8]
000016  f0450501          ORR      r5,r5,#1
00001a  60a5              STR      r5,[r4,#8]
00001c  e006              B        |L6.44|
                  |L6.30|
00001e  2002              MOVS     r0,#2                 ;278
;;;285    
;;;286      /* Enter Data to the CRC calculator */
;;;287      for(index = 0U; index < BufferLength; index++)
;;;288      {
;;;289        hcrc->Instance->DR = pBuffer[index];
;;;290      }
;;;291    
;;;292      /* Change CRC peripheral state */
;;;293      hcrc->State = HAL_CRC_STATE_READY;
;;;294    
;;;295      /* Process Unlocked */
;;;296      __HAL_UNLOCK(hcrc);
;;;297    
;;;298      /* Return the CRC computed value */
;;;299      return hcrc->Instance->DR;
;;;300    }
000020  bd70              POP      {r4-r6,pc}
                  |L6.34|
000022  6805              LDR      r5,[r0,#0]            ;289
000024  f8514023          LDR      r4,[r1,r3,LSL #2]     ;289
000028  602c              STR      r4,[r5,#0]            ;289
00002a  1c5b              ADDS     r3,r3,#1              ;287
                  |L6.44|
00002c  4293              CMP      r3,r2                 ;287
00002e  d3f8              BCC      |L6.34|
000030  7146              STRB     r6,[r0,#5]            ;293
000032  2100              MOVS     r1,#0                 ;296
000034  7101              STRB     r1,[r0,#4]            ;296
000036  6800              LDR      r0,[r0,#0]            ;299
000038  6800              LDR      r0,[r0,#0]            ;299
00003a  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP


                          AREA ||i.HAL_CRC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_DeInit PROC
;;;144      */
;;;145    HAL_StatusTypeDef HAL_CRC_DeInit(CRC_HandleTypeDef *hcrc)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147      /* Check the CRC handle allocation */
;;;148      if(hcrc == NULL)
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L7.44|
;;;149      {
;;;150        return HAL_ERROR;
;;;151      }
;;;152    
;;;153      /* Check the parameters */
;;;154      assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));
;;;155    
;;;156      /* Change CRC peripheral state */
;;;157      hcrc->State = HAL_CRC_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  7160              STRB     r0,[r4,#5]
;;;158    
;;;159      /* DeInit the low level hardware */
;;;160      HAL_CRC_MspDeInit(hcrc);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_CRC_MspDeInit
;;;161    
;;;162      /* Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF */
;;;163      __HAL_CRC_DR_RESET(hcrc);
000012  6820              LDR      r0,[r4,#0]
000014  6881              LDR      r1,[r0,#8]
000016  f0410101          ORR      r1,r1,#1
00001a  6081              STR      r1,[r0,#8]
;;;164    
;;;165      /* Reset IDR register content */
;;;166      CLEAR_BIT(hcrc->Instance->IDR, CRC_IDR_IDR);
00001c  6820              LDR      r0,[r4,#0]
00001e  7901              LDRB     r1,[r0,#4]
000020  2100              MOVS     r1,#0
000022  7101              STRB     r1,[r0,#4]
;;;167    
;;;168      /* Change CRC peripheral state */
;;;169      hcrc->State = HAL_CRC_STATE_RESET;
000024  7161              STRB     r1,[r4,#5]
;;;170    
;;;171      /* Release Lock */
;;;172      __HAL_UNLOCK(hcrc);
000026  7121              STRB     r1,[r4,#4]
;;;173    
;;;174      /* Return function status */
;;;175      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;176    }
00002a  bd10              POP      {r4,pc}
                  |L7.44|
00002c  2001              MOVS     r0,#1                 ;150
00002e  bd10              POP      {r4,pc}
;;;177    
                          ENDP


                          AREA ||i.HAL_CRC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CRC_GetState PROC
;;;325      */
;;;326    HAL_CRC_StateTypeDef HAL_CRC_GetState(CRC_HandleTypeDef *hcrc)
000000  7940              LDRB     r0,[r0,#5]
;;;327    {
;;;328      return hcrc->State;
;;;329    }
000002  4770              BX       lr
;;;330    
                          ENDP


                          AREA ||i.HAL_CRC_Init||, CODE, READONLY, ALIGN=1

                  HAL_CRC_Init PROC
;;;111      */
;;;112    HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
000000  b510              PUSH     {r4,lr}
;;;113    {
000002  4604              MOV      r4,r0
;;;114      /* Check the CRC handle allocation */
;;;115      if(hcrc == NULL)
000004  2c00              CMP      r4,#0
000006  d002              BEQ      |L9.14|
;;;116      {
;;;117        return HAL_ERROR;
;;;118      }
;;;119    
;;;120      /* Check the parameters */
;;;121      assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));
;;;122    
;;;123      if(hcrc->State == HAL_CRC_STATE_RESET)
000008  7960              LDRB     r0,[r4,#5]
00000a  b110              CBZ      r0,|L9.18|
00000c  e006              B        |L9.28|
                  |L9.14|
00000e  2001              MOVS     r0,#1                 ;117
;;;124      {
;;;125        /* Allocate lock resource and initialize it */
;;;126        hcrc->Lock = HAL_UNLOCKED;
;;;127        
;;;128        /* Init the low level hardware */
;;;129        HAL_CRC_MspInit(hcrc);
;;;130      }
;;;131    
;;;132      /* Change CRC peripheral state */
;;;133      hcrc->State = HAL_CRC_STATE_READY;
;;;134      
;;;135      /* Return function status */
;;;136      return HAL_OK;
;;;137    }
000010  bd10              POP      {r4,pc}
                  |L9.18|
000012  2000              MOVS     r0,#0                 ;126
000014  7120              STRB     r0,[r4,#4]            ;126
000016  4620              MOV      r0,r4                 ;129
000018  f7fffffe          BL       HAL_CRC_MspInit
                  |L9.28|
00001c  2001              MOVS     r0,#1                 ;133
00001e  7160              STRB     r0,[r4,#5]            ;133
000020  2000              MOVS     r0,#0                 ;136
000022  bd10              POP      {r4,pc}
;;;138    
                          ENDP


                          AREA ||i.HAL_CRC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_MspDeInit PROC
;;;198      */
;;;199    __WEAK void HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc)
000000  4770              BX       lr
;;;200    {
;;;201      /* Prevent unused argument(s) compilation warning */
;;;202      UNUSED(hcrc);
;;;203      /* NOTE : This function Should not be modified, when the callback is needed,
;;;204                the HAL_CRC_MspDeInit could be implemented in the user file
;;;205       */
;;;206    }
;;;207    
                          ENDP


                          AREA ||i.HAL_CRC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CRC_MspInit PROC
;;;183      */
;;;184    __WEAK void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
000000  4770              BX       lr
;;;185    {
;;;186      /* Prevent unused argument(s) compilation warning */
;;;187      UNUSED(hcrc);
;;;188      /* NOTE : This function Should not be modified, when the callback is needed,
;;;189                the HAL_CRC_MspInit could be implemented in the user file
;;;190       */
;;;191    }
;;;192    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_crc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_crc_c_14c421d9____REV16|
#line 441 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_crc_c_14c421d9____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_crc_c_14c421d9____REVSH|
#line 456
|__asm___19_stm32f1xx_hal_crc_c_14c421d9____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_crc_c_14c421d9____RRX|
#line 643
|__asm___19_stm32f1xx_hal_crc_c_14c421d9____RRX| PROC
#line 644

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
