; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-160318\stm32f1xx_hal_rcc_ex.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-160318\stm32f1xx_hal_rcc_ex.d --feedback=.\DE-160318\DE-160318.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I.\RTE\_DE-160318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-160318\stm32f1xx_hal_rcc_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;293      */
;;;294    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2101              MOVS     r1,#1
;;;295    {
;;;296      uint32_t srcclk = 0;
;;;297      
;;;298      /* Set all possible values for the extended clock type parameter------------*/
;;;299      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
;;;300    
;;;301      /* Get the RTC configuration -----------------------------------------------*/
;;;302      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000002  6001              STR      r1,[r0,#0]
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f4027240          AND      r2,r2,#0x300
;;;303      /* Source clock is LSE or LSI*/
;;;304      PeriphClkInit->RTCClockSelection = srcclk;
;;;305    
;;;306      /* Get the ADC clock configuration -----------------------------------------*/
;;;307      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
00000c  6042              STR      r2,[r0,#4]
00000e  2203              MOVS     r2,#3
;;;308      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000010  6002              STR      r2,[r0,#0]
000012  684a              LDR      r2,[r1,#4]
000014  f4024240          AND      r2,r2,#0xc000
;;;309    
;;;310    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;311      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;312      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;313      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;314    
;;;315      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;316      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;317      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;318    
;;;319    #endif /* STM32F105xC || STM32F107xC */
;;;320    
;;;321    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;322      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;323      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;324      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;325    
;;;326      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;327      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;328      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;329    
;;;330    #endif /* STM32F103xE || STM32F103xG */
;;;331    
;;;332    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;333     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;334     || defined(STM32F105xC) || defined(STM32F107xC)
;;;335      /* Get the USB clock configuration -----------------------------------------*/
;;;336      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
000018  6082              STR      r2,[r0,#8]
00001a  2213              MOVS     r2,#0x13
;;;337      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00001c  6002              STR      r2,[r0,#0]
00001e  6849              LDR      r1,[r1,#4]
000020  f4010180          AND      r1,r1,#0x400000
000024  60c1              STR      r1,[r0,#0xc]
;;;338    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;339    }
000026  4770              BX       lr
;;;340    
                          ENDP

                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;386      */
;;;387    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b510              PUSH     {r4,lr}
;;;388    {
;;;389    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;390     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;391     || defined(STM32F105xC) || defined(STM32F107xC)
;;;392    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;393      const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;394      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;395    #else
;;;396      const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a433              ADR      r4,|L2.208|
000004  4601              MOV      r1,r0                 ;388
000006  cc1d              LDM      r4,{r0,r2-r4}
000008  b086              SUB      sp,sp,#0x18           ;388
00000a  e88d001d          STM      sp,{r0,r2-r4}
;;;397      const uint8_t aPredivFactorTable[2] = { 1, 2};
00000e  a034              ADR      r0,|L2.224|
;;;398    #endif
;;;399    #endif
;;;400      uint32_t temp_reg = 0, frequency = 0;
;;;401    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;402     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;403     || defined(STM32F105xC) || defined(STM32F107xC)
;;;404      uint32_t prediv1 = 0, pllclk = 0, pllmul = 0;
;;;405    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;406    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;407      uint32_t pll2mul = 0, pll3mul = 0, prediv2 = 0;
;;;408    #endif /* STM32F105xC || STM32F107xC */
;;;409    
;;;410      /* Check the parameters */
;;;411      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;412      
;;;413      switch (PeriphClk)
;;;414      {
;;;415    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;416     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;417     || defined(STM32F105xC) || defined(STM32F107xC)
;;;418      case RCC_PERIPHCLK_USB:  
;;;419        {
;;;420          /* Get RCC configuration ------------------------------------------------------*/
;;;421          temp_reg = RCC->CFGR;
000010  4c34              LDR      r4,|L2.228|
000012  6800              LDR      r0,[r0,#0]            ;397
000014  9004              STR      r0,[sp,#0x10]         ;400
000016  2000              MOVS     r0,#0                 ;400
000018  2901              CMP      r1,#1                 ;413
00001a  d031              BEQ      |L2.128|
00001c  2902              CMP      r1,#2                 ;413
00001e  d048              BEQ      |L2.178|
000020  2910              CMP      r1,#0x10              ;413
000022  d12b              BNE      |L2.124|
000024  6861              LDR      r1,[r4,#4]
;;;422      
;;;423          /* Check if PLL is enabled */
;;;424          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
000026  6822              LDR      r2,[r4,#0]
000028  01d2              LSLS     r2,r2,#7
00002a  d527              BPL      |L2.124|
;;;425          {
;;;426            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
00002c  f44f1270          MOV      r2,#0x3c0000
000030  fa92f2a2          RBIT     r2,r2
000034  f4011070          AND      r0,r1,#0x3c0000
000038  fab2f282          CLZ      r2,r2
00003c  40d0              LSRS     r0,r0,r2
;;;427            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
00003e  03c9              LSLS     r1,r1,#15
000040  f81d0000          LDRB     r0,[sp,r0]            ;426
000044  d510              BPL      |L2.104|
;;;428            {
;;;429    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;430     || defined(STM32F100xE)
;;;431              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;432    #else
;;;433              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
000046  6861              LDR      r1,[r4,#4]
000048  f44f3200          MOV      r2,#0x20000
00004c  fa92f2a2          RBIT     r2,r2
000050  f4013100          AND      r1,r1,#0x20000
000054  fab2f282          CLZ      r2,r2
000058  40d1              LSRS     r1,r1,r2
00005a  aa04              ADD      r2,sp,#0x10
00005c  5c51              LDRB     r1,[r2,r1]
;;;434    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;435    
;;;436    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;437              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;438              {
;;;439                /* PLL2 selected as Prediv1 source */
;;;440                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;441                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;442                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;443                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;444              }
;;;445              else
;;;446              {
;;;447                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;448                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;449              }
;;;450              
;;;451              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;452              /* In this case need to divide pllclk by 2 */
;;;453              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;454              {
;;;455                  pllclk = pllclk / 2;
;;;456              }
;;;457    #else
;;;458              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;459              {
;;;460                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;461                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
00005e  4a22              LDR      r2,|L2.232|
000060  fbb2f1f1          UDIV     r1,r2,r1
000064  4348              MULS     r0,r1,r0
000066  e001              B        |L2.108|
                  |L2.104|
;;;462              }
;;;463    #endif /* STM32F105xC || STM32F107xC */
;;;464            }
;;;465            else
;;;466            {
;;;467              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;468              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
000068  4920              LDR      r1,|L2.236|
00006a  4348              MULS     r0,r1,r0
                  |L2.108|
;;;469            }
;;;470    
;;;471            /* Calcul of the USB frequency*/
;;;472    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;473            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;474            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;475            {
;;;476              /* Prescaler of 2 selected for USB */ 
;;;477              frequency = pllclk;
;;;478            }
;;;479            else
;;;480            {
;;;481              /* Prescaler of 3 selected for USB */ 
;;;482              frequency = (2 * pllclk) / 3;
;;;483            }
;;;484    #else
;;;485            /* USBCLK = PLLCLK / USB prescaler */
;;;486            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
00006c  6861              LDR      r1,[r4,#4]
00006e  0249              LSLS     r1,r1,#9
000070  d404              BMI      |L2.124|
;;;487            {
;;;488              /* No prescaler selected for USB */
;;;489              frequency = pllclk;
;;;490            }
;;;491            else
;;;492            {
;;;493              /* Prescaler of 1.5 selected for USB */ 
;;;494              frequency = (pllclk * 2) / 3;
000072  0040              LSLS     r0,r0,#1
000074  f05f0103          MOVS.W   r1,#3
                  |L2.120|
;;;495            }
;;;496    #endif
;;;497          }
;;;498          break;
;;;499        }
;;;500    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;501    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC)\
;;;502     || defined(STM32F107xC)
;;;503      case RCC_PERIPHCLK_I2S2:  
;;;504        {
;;;505    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;506          /* SYSCLK used as source clock for I2S2 */
;;;507          frequency = HAL_RCC_GetSysClockFreq();
;;;508    #else
;;;509          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;510          {
;;;511            /* SYSCLK used as source clock for I2S2 */
;;;512            frequency = HAL_RCC_GetSysClockFreq();
;;;513          }
;;;514          else
;;;515          {
;;;516             /* Check if PLLI2S is enabled */
;;;517            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;518            {
;;;519              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;520              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;521              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;522              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;523            }
;;;524          }
;;;525    #endif /* STM32F103xE || STM32F103xG */
;;;526          break;
;;;527        }
;;;528      case RCC_PERIPHCLK_I2S3:
;;;529        {
;;;530    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;531          /* SYSCLK used as source clock for I2S3 */
;;;532          frequency = HAL_RCC_GetSysClockFreq();
;;;533    #else
;;;534          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;535          {
;;;536            /* SYSCLK used as source clock for I2S3 */
;;;537            frequency = HAL_RCC_GetSysClockFreq();
;;;538          }
;;;539          else
;;;540          {
;;;541             /* Check if PLLI2S is enabled */
;;;542            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;543            {
;;;544              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;545              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;546              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;547              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;548            }
;;;549          }
;;;550    #endif /* STM32F103xE || STM32F103xG */
;;;551          break;
;;;552        }
;;;553    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;554      case RCC_PERIPHCLK_RTC:  
;;;555        {
;;;556          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;557          temp_reg = RCC->BDCR;
;;;558    
;;;559          /* Check if LSE is ready if RTC clock selection is LSE */
;;;560          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
;;;561          {
;;;562            frequency = LSE_VALUE;
;;;563          }
;;;564          /* Check if LSI is ready if RTC clock selection is LSI */
;;;565          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;566          {
;;;567            frequency = LSI_VALUE;
;;;568          }
;;;569          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;570          {
;;;571            frequency = HSE_VALUE / 128;
;;;572          }
;;;573          /* Clock not enabled for RTC*/
;;;574          else
;;;575          {
;;;576            frequency = 0;
;;;577          }
;;;578          break;
;;;579        }
;;;580      case RCC_PERIPHCLK_ADC:  
;;;581        {
;;;582          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> POSITION_VAL(RCC_CFGR_ADCPRE_DIV4)) + 1) * 2);
000078  fbb0f0f1          UDIV     r0,r0,r1
                  |L2.124|
;;;583          break;
;;;584        }
;;;585      default: 
;;;586        {
;;;587          break;
;;;588        }
;;;589      }
;;;590      return(frequency);
;;;591    }
00007c  b006              ADD      sp,sp,#0x18
00007e  bd10              POP      {r4,pc}
                  |L2.128|
000080  6a22              LDR      r2,[r4,#0x20]         ;557
000082  f3c22101          UBFX     r1,r2,#8,#2           ;560
000086  2901              CMP      r1,#1                 ;560
000088  d103              BNE      |L2.146|
00008a  0792              LSLS     r2,r2,#30             ;560
00008c  d501              BPL      |L2.146|
00008e  03c8              LSLS     r0,r1,#15             ;562
000090  e7f4              B        |L2.124|
                  |L2.146|
000092  2902              CMP      r1,#2                 ;565
000094  d105              BNE      |L2.162|
000096  6a62              LDR      r2,[r4,#0x24]         ;565
000098  0792              LSLS     r2,r2,#30             ;565
00009a  d502              BPL      |L2.162|
00009c  f6494040          MOV      r0,#0x9c40            ;567
0000a0  e7ec              B        |L2.124|
                  |L2.162|
0000a2  2903              CMP      r1,#3                 ;569
0000a4  d1ea              BNE      |L2.124|
0000a6  6821              LDR      r1,[r4,#0]            ;569
0000a8  0389              LSLS     r1,r1,#14             ;569
0000aa  d5e7              BPL      |L2.124|
0000ac  f24f4024          MOV      r0,#0xf424            ;571
0000b0  e7e4              B        |L2.124|
                  |L2.178|
0000b2  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000b6  6861              LDR      r1,[r4,#4]            ;582
0000b8  f44f4280          MOV      r2,#0x4000            ;582
0000bc  fa92f2a2          RBIT     r2,r2                 ;582
0000c0  f4014140          AND      r1,r1,#0xc000         ;582
0000c4  fab2f282          CLZ      r2,r2                 ;582
0000c8  40d1              LSRS     r1,r1,r2              ;582
0000ca  1c49              ADDS     r1,r1,#1              ;582
0000cc  0049              LSLS     r1,r1,#1              ;582
0000ce  e7d3              B        |L2.120|
;;;592    
                          ENDP

                  |L2.208|
0000d0  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
0000d4  06070809
0000d8  0a0b0c0d
0000dc  0e0f1010
                  |L2.224|
0000e0  010200            DCB      1,2,0
0000e3  00                DCB      0
                  |L2.228|
                          DCD      0x40021000
                  |L2.232|
                          DCD      0x007a1200
                  |L2.236|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;117      */
;;;118    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;119    {
000004  4605              MOV      r5,r0
;;;120      uint32_t tickstart = 0, temp_reg = 0;
;;;121    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;122      uint32_t  pllactive = 0;
;;;123    #endif /* STM32F105xC || STM32F107xC */
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;129      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
000006  7800              LDRB     r0,[r0,#0]
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133    
;;;134        /* Enable Power Clock*/
;;;135        __HAL_RCC_PWR_CLK_ENABLE();
000008  4c44              LDR      r4,|L3.284|
00000a  07c0              LSLS     r0,r0,#31             ;129
00000c  d071              BEQ      |L3.242|
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  61e0              STR      r0,[r4,#0x1c]
000016  69e0              LDR      r0,[r4,#0x1c]
;;;136        
;;;137        /* Enable write access to Backup domain */
;;;138        SET_BIT(PWR->CR, PWR_CR_DBP);
000018  4e41              LDR      r6,|L3.288|
00001a  f0005080          AND      r0,r0,#0x10000000     ;135
00001e  9000              STR      r0,[sp,#0]
000020  6830              LDR      r0,[r6,#0]
000022  f4407080          ORR      r0,r0,#0x100
000026  6030              STR      r0,[r6,#0]
;;;139        
;;;140        /* Wait for Backup domain Write protection disable */
;;;141        tickstart = HAL_GetTick();
000028  f7fffffe          BL       HAL_GetTick
00002c  4607              MOV      r7,r0
;;;142        
;;;143        while((PWR->CR & PWR_CR_DBP) == RESET)
00002e  e004              B        |L3.58|
                  |L3.48|
;;;144        {
;;;145          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000030  f7fffffe          BL       HAL_GetTick
000034  1bc0              SUBS     r0,r0,r7
000036  2864              CMP      r0,#0x64
000038  d831              BHI      |L3.158|
                  |L3.58|
00003a  6830              LDR      r0,[r6,#0]            ;143
00003c  05c0              LSLS     r0,r0,#23             ;143
00003e  d5f7              BPL      |L3.48|
;;;146          {
;;;147            return HAL_TIMEOUT;
;;;148          }      
;;;149        }
;;;150          
;;;151        /* Reset the Backup domain only if the RTC Clock source selection is modified */ 
;;;152        if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
000040  6a20              LDR      r0,[r4,#0x20]
000042  88a9              LDRH     r1,[r5,#4]
000044  f4007040          AND      r0,r0,#0x300
000048  f4017140          AND      r1,r1,#0x300
00004c  4288              CMP      r0,r1
00004e  d050              BEQ      |L3.242|
;;;153        {
;;;154          /* Store the content of BDCR register before the reset of Backup Domain */
;;;155          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
000050  6a20              LDR      r0,[r4,#0x20]
;;;156          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;157          __HAL_RCC_BACKUPRESET_FORCE();
000052  2601              MOVS     r6,#1
000054  0431              LSLS     r1,r6,#16
000056  fa91f2a1          RBIT     r2,r1
00005a  fab2f282          CLZ      r2,r2
00005e  0093              LSLS     r3,r2,#2
000060  4a30              LDR      r2,|L3.292|
000062  f4207040          BIC      r0,r0,#0x300          ;155
000066  4413              ADD      r3,r3,r2
000068  f8c36400          STR      r6,[r3,#0x400]
;;;158          __HAL_RCC_BACKUPRESET_RELEASE();
00006c  fa91f1a1          RBIT     r1,r1
000070  fab1f181          CLZ      r1,r1
000074  eb020181          ADD      r1,r2,r1,LSL #2
000078  2300              MOVS     r3,#0
00007a  f8c13400          STR      r3,[r1,#0x400]
;;;159          /* Restore the Content of BDCR register */
;;;160          RCC->BDCR = temp_reg;
00007e  6220              STR      r0,[r4,#0x20]
;;;161    
;;;162          /* Wait for LSERDY if LSE was enabled */
;;;163          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
000080  0780              LSLS     r0,r0,#30
000082  d530              BPL      |L3.230|
;;;164          {
;;;165            /* Get timeout */
;;;166            tickstart = HAL_GetTick();
000084  f7fffffe          BL       HAL_GetTick
000088  46b0              MOV      r8,r6                 ;157
00008a  4607              MOV      r7,r0
;;;167          
;;;168            /* Wait till LSE is ready */  
;;;169            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;170            {
;;;171              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
00008c  f2413988          MOV      r9,#0x1388
000090  2602              MOVS     r6,#2                 ;169
000092  e007              B        |L3.164|
                  |L3.148|
000094  f7fffffe          BL       HAL_GetTick
000098  1bc1              SUBS     r1,r0,r7
00009a  4549              CMP      r1,r9
00009c  d902              BLS      |L3.164|
                  |L3.158|
;;;172              {
;;;173                return HAL_TIMEOUT;
00009e  2003              MOVS     r0,#3
                  |L3.160|
;;;174              }      
;;;175            }  
;;;176          }
;;;177          __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;178        }
;;;179      }
;;;180    
;;;181      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;182      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;183      {
;;;184        /* Check the parameters */
;;;185        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;186        
;;;187        /* Configure the ADC clock source */
;;;188        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;189      }
;;;190    
;;;191    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;192      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;193      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;194      {
;;;195        /* Check the parameters */
;;;196        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;197    
;;;198        /* Configure the I2S2 clock source */
;;;199        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;200      }
;;;201    
;;;202      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;203      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;204      {
;;;205        /* Check the parameters */
;;;206        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;207        
;;;208        /* Configure the I2S3 clock source */
;;;209        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;210      }
;;;211    
;;;212      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;213      /* Check that PLLI2S need to be enabled */
;;;214      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;215      {
;;;216        /* Update flag to indicate that PLL I2S should be active */
;;;217        pllactive = 1;
;;;218      }
;;;219    
;;;220      /* Check if PLL I2S need to be enabled */
;;;221      if (pllactive == 1)
;;;222      {
;;;223        /* Enable PLL I2S only if not active */
;;;224        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;225        {
;;;226          /* Check the parameters */
;;;227          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;228          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;229    
;;;230          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;231          /* Return an error only if new value is different from the programmed value */
;;;232          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;233            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;234          {
;;;235            return HAL_ERROR;
;;;236          }
;;;237    
;;;238          /* Configure the HSE prediv2 factor --------------------------------*/
;;;239          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;240    
;;;241          /* Configure the main PLLI2S multiplication factors. */
;;;242          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;243          
;;;244          /* Enable the main PLLI2S. */
;;;245          __HAL_RCC_PLLI2S_ENABLE();
;;;246          
;;;247          /* Get Start Tick*/
;;;248          tickstart = HAL_GetTick();
;;;249          
;;;250          /* Wait till PLLI2S is ready */
;;;251          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;252          {
;;;253            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;254            {
;;;255              return HAL_TIMEOUT;
;;;256            }
;;;257          }
;;;258        }
;;;259        else
;;;260        {
;;;261          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;262          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;263          {
;;;264              return HAL_ERROR;
;;;265          }
;;;266        }
;;;267      }
;;;268    #endif /* STM32F105xC || STM32F107xC */
;;;269    
;;;270    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;271     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;272     || defined(STM32F105xC) || defined(STM32F107xC)
;;;273      /*------------------------------ USB clock Configuration ------------------*/ 
;;;274      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;275      {
;;;276        /* Check the parameters */
;;;277        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;278        
;;;279        /* Configure the USB clock source */
;;;280        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;281      }
;;;282    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;283    
;;;284      return HAL_OK;
;;;285    }
0000a0  e8bd83f8          POP      {r3-r9,pc}
                  |L3.164|
0000a4  fa96f0a6          RBIT     r0,r6                 ;169
0000a8  fab0f080          CLZ      r0,r0                 ;169
0000ac  f0400040          ORR      r0,r0,#0x40           ;169
0000b0  ebb81f50          CMP      r8,r0,LSR #5          ;169
0000b4  d101              BNE      |L3.186|
0000b6  6820              LDR      r0,[r4,#0]            ;169
0000b8  e00b              B        |L3.210|
                  |L3.186|
0000ba  fa96f0a6          RBIT     r0,r6                 ;169
0000be  fab0f080          CLZ      r0,r0                 ;169
0000c2  f0400040          ORR      r0,r0,#0x40           ;169
0000c6  ebb61f50          CMP      r6,r0,LSR #5          ;169
0000ca  d101              BNE      |L3.208|
0000cc  6a20              LDR      r0,[r4,#0x20]         ;169
0000ce  e000              B        |L3.210|
                  |L3.208|
0000d0  6a60              LDR      r0,[r4,#0x24]         ;169
                  |L3.210|
0000d2  fa96f2a6          RBIT     r2,r6                 ;169
0000d6  fab2f282          CLZ      r2,r2                 ;169
0000da  f002021f          AND      r2,r2,#0x1f           ;169
0000de  fa08f102          LSL      r1,r8,r2              ;169
0000e2  4208              TST      r0,r1                 ;169
0000e4  d0d6              BEQ      |L3.148|
                  |L3.230|
0000e6  6a20              LDR      r0,[r4,#0x20]         ;177
0000e8  6869              LDR      r1,[r5,#4]            ;177
0000ea  f4207040          BIC      r0,r0,#0x300          ;177
0000ee  4308              ORRS     r0,r0,r1              ;177
0000f0  6220              STR      r0,[r4,#0x20]         ;177
                  |L3.242|
0000f2  7828              LDRB     r0,[r5,#0]            ;182
0000f4  0780              LSLS     r0,r0,#30             ;182
0000f6  d505              BPL      |L3.260|
0000f8  6860              LDR      r0,[r4,#4]            ;188
0000fa  68a9              LDR      r1,[r5,#8]            ;188
0000fc  f4204040          BIC      r0,r0,#0xc000         ;188
000100  4308              ORRS     r0,r0,r1              ;188
000102  6060              STR      r0,[r4,#4]            ;188
                  |L3.260|
000104  7828              LDRB     r0,[r5,#0]            ;274
000106  06c0              LSLS     r0,r0,#27             ;274
000108  d505              BPL      |L3.278|
00010a  6860              LDR      r0,[r4,#4]            ;280
00010c  68e9              LDR      r1,[r5,#0xc]          ;280
00010e  f4200080          BIC      r0,r0,#0x400000       ;280
000112  4308              ORRS     r0,r0,r1              ;280
000114  6060              STR      r0,[r4,#4]            ;280
                  |L3.278|
000116  2000              MOVS     r0,#0                 ;284
000118  e7c2              B        |L3.160|
;;;286    
                          ENDP

00011a  0000              DCW      0x0000
                  |L3.284|
                          DCD      0x40021000
                  |L3.288|
                          DCD      0x40007000
                  |L3.292|
                          DCD      0x42420000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 463 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 478
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 665
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
