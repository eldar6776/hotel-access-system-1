; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-160318\stm32f1xx_hal_rcc.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-160318\stm32f1xx_hal_rcc.d --feedback=.\DE-160318\DE-160318.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I.\RTE\_DE-160318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-160318\stm32f1xx_hal_rcc.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1331     */
;;;1332   __WEAK void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1333   {
;;;1334     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1335       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1336       */ 
;;;1337   }
;;;1338   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;708      */
;;;709    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;710    {
;;;711      uint32_t tickstart = 0;
;;;712      
;;;713      /* Check the parameters */
;;;714      assert_param(RCC_ClkInitStruct != NULL);
;;;715      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;716      assert_param(IS_FLASH_LATENCY(FLatency));
;;;717    
;;;718      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;719      must be correctly programmed according to the frequency of the CPU clock 
;;;720        (HCLK) of the device. */
;;;721    
;;;722    #if defined(FLASH_ACR_LATENCY)
;;;723      /* Increasing the CPU frequency */
;;;724      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df9278          LDR      r9,|L2.640|
000008  4605              MOV      r5,r0                 ;710
00000a  460e              MOV      r6,r1                 ;710
00000c  f8d90000          LDR      r0,[r9,#0]
;;;725      {    
;;;726        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;727        __HAL_FLASH_SET_LATENCY(FLatency);
;;;728        
;;;729        /* Check that the new number of wait states is taken into account to access the Flash
;;;730        memory by reading the FLASH_ACR register */
;;;731        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;732        {
;;;733          return HAL_ERROR;
;;;734        }
;;;735        
;;;736    #endif /* FLASH_ACR_LATENCY */
;;;737        /*-------------------------- HCLK Configuration --------------------------*/
;;;738        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
;;;739        {
;;;740          assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;741          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
;;;742        }
;;;743    
;;;744        /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;745        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
;;;746        {    
;;;747          assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;748          
;;;749          /* HSE is selected as System Clock Source */
;;;750          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000010  2302              MOVS     r3,#2
000012  f0000707          AND      r7,r0,#7              ;724
000016  2001              MOVS     r0,#1                 ;733
;;;751          {
;;;752            /* Check the HSE ready flag */  
;;;753            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000018  0441              LSLS     r1,r0,#17
;;;754            {
;;;755              return HAL_ERROR;
;;;756            }
;;;757          }
;;;758          /* PLL is selected as System Clock Source */
;;;759          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;760          {
;;;761            /* Check the PLL ready flag */  
;;;762            if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
00001a  0642              LSLS     r2,r0,#25
00001c  4c99              LDR      r4,|L2.644|
;;;763            {
;;;764              return HAL_ERROR;
;;;765            }
;;;766          }
;;;767          /* HSI is selected as System Clock Source */
;;;768          else
;;;769          {
;;;770            /* Check the HSI ready flag */  
;;;771            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;772            {
;;;773              return HAL_ERROR;
;;;774            }
;;;775          }
;;;776          __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
;;;777    
;;;778          /* Get Start Tick */
;;;779          tickstart = HAL_GetTick();
;;;780          
;;;781          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
;;;782          {
;;;783            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;784            {
;;;785              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00001e  f2413888          MOV      r8,#0x1388
000022  42b7              CMP      r7,r6                 ;724
000024  d271              BCS      |L2.266|
000026  f8d9c000          LDR      r12,[r9,#0]           ;727
00002a  f02c0c07          BIC      r12,r12,#7            ;727
00002e  ea4c0c06          ORR      r12,r12,r6            ;727
000032  f8c9c000          STR      r12,[r9,#0]           ;727
000036  f8d97000          LDR      r7,[r9,#0]            ;731
00003a  f0070707          AND      r7,r7,#7              ;731
00003e  42b7              CMP      r7,r6                 ;731
000040  d16f              BNE      |L2.290|
000042  782e              LDRB     r6,[r5,#0]            ;738
000044  07b6              LSLS     r6,r6,#30             ;738
000046  d505              BPL      |L2.84|
000048  6866              LDR      r6,[r4,#4]            ;741
00004a  68af              LDR      r7,[r5,#8]            ;741
00004c  f02606f0          BIC      r6,r6,#0xf0           ;741
000050  433e              ORRS     r6,r6,r7              ;741
000052  6066              STR      r6,[r4,#4]            ;741
                  |L2.84|
000054  782e              LDRB     r6,[r5,#0]            ;745
000056  07f6              LSLS     r6,r6,#31             ;745
000058  d056              BEQ      |L2.264|
00005a  686e              LDR      r6,[r5,#4]            ;750
00005c  2e01              CMP      r6,#1                 ;750
00005e  d00b              BEQ      |L2.120|
000060  2e02              CMP      r6,#2                 ;759
000062  d01e              BEQ      |L2.162|
000064  fa93f1a3          RBIT     r1,r3                 ;771
000068  fab1f181          CLZ      r1,r1                 ;771
00006c  f0410120          ORR      r1,r1,#0x20           ;771
000070  0949              LSRS     r1,r1,#5              ;771
000072  d024              BEQ      |L2.190|
000074  6821              LDR      r1,[r4,#0]            ;771
000076  e023              B        |L2.192|
                  |L2.120|
000078  fa91f2a1          RBIT     r2,r1                 ;753
00007c  fab2f282          CLZ      r2,r2                 ;753
000080  f0420220          ORR      r2,r2,#0x20           ;753
000084  0952              LSRS     r2,r2,#5              ;753
000086  d001              BEQ      |L2.140|
000088  6822              LDR      r2,[r4,#0]            ;753
00008a  e000              B        |L2.142|
                  |L2.140|
00008c  6a62              LDR      r2,[r4,#0x24]         ;753
                  |L2.142|
00008e  fa91f1a1          RBIT     r1,r1                 ;753
000092  fab1f181          CLZ      r1,r1                 ;753
000096  f001011f          AND      r1,r1,#0x1f           ;753
00009a  4088              LSLS     r0,r0,r1              ;753
00009c  4202              TST      r2,r0                 ;753
00009e  d040              BEQ      |L2.290|
0000a0  e017              B        |L2.210|
                  |L2.162|
0000a2  fa92f1a2          RBIT     r1,r2                 ;762
0000a6  fab1f181          CLZ      r1,r1                 ;762
0000aa  f0410120          ORR      r1,r1,#0x20           ;762
0000ae  0949              LSRS     r1,r1,#5              ;762
0000b0  d001              BEQ      |L2.182|
0000b2  6821              LDR      r1,[r4,#0]            ;762
0000b4  e000              B        |L2.184|
                  |L2.182|
0000b6  6a61              LDR      r1,[r4,#0x24]         ;762
                  |L2.184|
0000b8  fa92f2a2          RBIT     r2,r2                 ;762
0000bc  e002              B        |L2.196|
                  |L2.190|
0000be  6a61              LDR      r1,[r4,#0x24]         ;771
                  |L2.192|
0000c0  fa93f2a3          RBIT     r2,r3                 ;771
                  |L2.196|
0000c4  fab2f282          CLZ      r2,r2                 ;771
0000c8  f002021f          AND      r2,r2,#0x1f           ;771
0000cc  4090              LSLS     r0,r0,r2              ;771
0000ce  4201              TST      r1,r0                 ;771
0000d0  d027              BEQ      |L2.290|
                  |L2.210|
0000d2  6860              LDR      r0,[r4,#4]            ;776
0000d4  f0200003          BIC      r0,r0,#3              ;776
0000d8  4330              ORRS     r0,r0,r6              ;776
0000da  6060              STR      r0,[r4,#4]            ;776
0000dc  f7fffffe          BL       HAL_GetTick
0000e0  4606              MOV      r6,r0                 ;779
0000e2  6868              LDR      r0,[r5,#4]            ;781
0000e4  2801              CMP      r0,#1                 ;781
0000e6  d009              BEQ      |L2.252|
;;;786              {
;;;787                return HAL_TIMEOUT;
;;;788              }
;;;789            }
;;;790          }
;;;791          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
0000e8  2802              CMP      r0,#2
0000ea  4647              MOV      r7,r8                 ;785
0000ec  d013              BEQ      |L2.278|
0000ee  e01e              B        |L2.302|
                  |L2.240|
0000f0  f7fffffe          BL       HAL_GetTick
0000f4  1b80              SUBS     r0,r0,r6              ;785
0000f6  42b8              CMP      r0,r7                 ;785
0000f8  d901              BLS      |L2.254|
0000fa  e092              B        |L2.546|
                  |L2.252|
0000fc  4647              MOV      r7,r8                 ;785
                  |L2.254|
0000fe  6860              LDR      r0,[r4,#4]            ;783
000100  f3c00081          UBFX     r0,r0,#2,#2           ;783
000104  2801              CMP      r0,#1                 ;783
000106  d1f3              BNE      |L2.240|
                  |L2.264|
000108  e0a1              B        |L2.590|
                  |L2.266|
00010a  e015              B        |L2.312|
                  |L2.268|
;;;792          {
;;;793            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;794            {
;;;795              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00010c  f7fffffe          BL       HAL_GetTick
000110  1b80              SUBS     r0,r0,r6
000112  42b8              CMP      r0,r7
000114  d873              BHI      |L2.510|
                  |L2.278|
000116  6860              LDR      r0,[r4,#4]            ;793
000118  f3c00081          UBFX     r0,r0,#2,#2           ;793
00011c  2802              CMP      r0,#2                 ;793
00011e  d1f5              BNE      |L2.268|
000120  e095              B        |L2.590|
                  |L2.290|
000122  e092              B        |L2.586|
                  |L2.292|
;;;796              {
;;;797                return HAL_TIMEOUT;
;;;798              }
;;;799            }
;;;800          }
;;;801          else
;;;802          {
;;;803            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
;;;804            {
;;;805              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000124  f7fffffe          BL       HAL_GetTick
000128  1b80              SUBS     r0,r0,r6
00012a  42b8              CMP      r0,r7
00012c  d879              BHI      |L2.546|
                  |L2.302|
00012e  6860              LDR      r0,[r4,#4]            ;803
000130  f0100f0c          TST      r0,#0xc               ;803
000134  d1f6              BNE      |L2.292|
000136  e08a              B        |L2.590|
                  |L2.312|
;;;806              {
;;;807                return HAL_TIMEOUT;
;;;808              }
;;;809            }
;;;810          }      
;;;811        }    
;;;812    #if defined(FLASH_ACR_LATENCY)
;;;813      }
;;;814      /* Decreasing the CPU frequency */
;;;815      else
;;;816      {
;;;817        /*-------------------------- HCLK Configuration --------------------------*/
;;;818        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
000138  782f              LDRB     r7,[r5,#0]
00013a  07bf              LSLS     r7,r7,#30
00013c  d507              BPL      |L2.334|
;;;819        {
;;;820          assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;821          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
00013e  6867              LDR      r7,[r4,#4]
000140  f8d5c008          LDR      r12,[r5,#8]
000144  f02707f0          BIC      r7,r7,#0xf0
000148  ea47070c          ORR      r7,r7,r12
00014c  6067              STR      r7,[r4,#4]
                  |L2.334|
;;;822        }
;;;823        
;;;824        /*------------------------- SYSCLK Configuration -------------------------*/
;;;825        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
00014e  782f              LDRB     r7,[r5,#0]
000150  07ff              LSLS     r7,r7,#31
000152  d06d              BEQ      |L2.560|
;;;826        {    
;;;827          assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;828          
;;;829          /* HSE is selected as System Clock Source */
;;;830          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000154  686f              LDR      r7,[r5,#4]
000156  2f01              CMP      r7,#1
000158  d00b              BEQ      |L2.370|
;;;831          {
;;;832            /* Check the HSE ready flag */  
;;;833            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;834            {
;;;835              return HAL_ERROR;
;;;836            }
;;;837          }
;;;838          /* PLL is selected as System Clock Source */
;;;839          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
00015a  2f02              CMP      r7,#2
00015c  d01e              BEQ      |L2.412|
;;;840          {
;;;841            /* Check the PLL ready flag */  
;;;842            if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;843            {
;;;844              return HAL_ERROR;
;;;845            }
;;;846          }
;;;847          /* HSI is selected as System Clock Source */
;;;848          else
;;;849          {
;;;850            /* Check the HSI ready flag */  
;;;851            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
00015e  fa93f1a3          RBIT     r1,r3
000162  fab1f181          CLZ      r1,r1
000166  f0410120          ORR      r1,r1,#0x20
00016a  0949              LSRS     r1,r1,#5
00016c  d024              BEQ      |L2.440|
00016e  6821              LDR      r1,[r4,#0]
000170  e023              B        |L2.442|
                  |L2.370|
000172  fa91f2a1          RBIT     r2,r1                 ;833
000176  fab2f282          CLZ      r2,r2                 ;833
00017a  f0420220          ORR      r2,r2,#0x20           ;833
00017e  0952              LSRS     r2,r2,#5              ;833
000180  d001              BEQ      |L2.390|
000182  6822              LDR      r2,[r4,#0]            ;833
000184  e000              B        |L2.392|
                  |L2.390|
000186  6a62              LDR      r2,[r4,#0x24]         ;833
                  |L2.392|
000188  fa91f1a1          RBIT     r1,r1                 ;833
00018c  fab1f181          CLZ      r1,r1                 ;833
000190  f001011f          AND      r1,r1,#0x1f           ;833
000194  4088              LSLS     r0,r0,r1              ;833
000196  4202              TST      r2,r0                 ;833
000198  d057              BEQ      |L2.586|
00019a  e017              B        |L2.460|
                  |L2.412|
00019c  fa92f1a2          RBIT     r1,r2                 ;842
0001a0  fab1f181          CLZ      r1,r1                 ;842
0001a4  f0410120          ORR      r1,r1,#0x20           ;842
0001a8  0949              LSRS     r1,r1,#5              ;842
0001aa  d001              BEQ      |L2.432|
0001ac  6821              LDR      r1,[r4,#0]            ;842
0001ae  e000              B        |L2.434|
                  |L2.432|
0001b0  6a61              LDR      r1,[r4,#0x24]         ;842
                  |L2.434|
0001b2  fa92f2a2          RBIT     r2,r2                 ;842
0001b6  e002              B        |L2.446|
                  |L2.440|
0001b8  6a61              LDR      r1,[r4,#0x24]
                  |L2.442|
0001ba  fa93f2a3          RBIT     r2,r3
                  |L2.446|
0001be  fab2f282          CLZ      r2,r2
0001c2  f002021f          AND      r2,r2,#0x1f
0001c6  4090              LSLS     r0,r0,r2
0001c8  4201              TST      r1,r0
0001ca  d03e              BEQ      |L2.586|
                  |L2.460|
;;;852            {
;;;853              return HAL_ERROR;
;;;854            }
;;;855          }
;;;856          __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
0001cc  6860              LDR      r0,[r4,#4]
0001ce  f0200003          BIC      r0,r0,#3
0001d2  4338              ORRS     r0,r0,r7
0001d4  6060              STR      r0,[r4,#4]
;;;857          
;;;858          /* Get Start Tick */
;;;859          tickstart = HAL_GetTick();
0001d6  f7fffffe          BL       HAL_GetTick
0001da  4607              MOV      r7,r0
;;;860          
;;;861          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
0001dc  6868              LDR      r0,[r5,#4]
0001de  2801              CMP      r0,#1
0001e0  d007              BEQ      |L2.498|
;;;862          {
;;;863            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;864            {
;;;865              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;866              {
;;;867                return HAL_TIMEOUT;
;;;868              }
;;;869            }
;;;870          }
;;;871          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
0001e2  2802              CMP      r0,#2
0001e4  d011              BEQ      |L2.522|
0001e6  e01f              B        |L2.552|
                  |L2.488|
0001e8  f7fffffe          BL       HAL_GetTick
0001ec  1bc1              SUBS     r1,r0,r7              ;865
0001ee  4541              CMP      r1,r8                 ;865
0001f0  d817              BHI      |L2.546|
                  |L2.498|
0001f2  6860              LDR      r0,[r4,#4]            ;863
0001f4  f3c00081          UBFX     r0,r0,#2,#2           ;863
0001f8  2801              CMP      r0,#1                 ;863
0001fa  d1f5              BNE      |L2.488|
0001fc  e018              B        |L2.560|
                  |L2.510|
0001fe  e010              B        |L2.546|
                  |L2.512|
;;;872          {
;;;873            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;874            {
;;;875              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000200  f7fffffe          BL       HAL_GetTick
000204  1bc1              SUBS     r1,r0,r7
000206  4541              CMP      r1,r8
000208  d80b              BHI      |L2.546|
                  |L2.522|
00020a  6860              LDR      r0,[r4,#4]            ;873
00020c  f3c00081          UBFX     r0,r0,#2,#2           ;873
000210  2802              CMP      r0,#2                 ;873
000212  d1f5              BNE      |L2.512|
000214  e00c              B        |L2.560|
;;;876              {
;;;877                return HAL_TIMEOUT;
;;;878              }
;;;879            }
;;;880          }
;;;881          else
;;;882          {
;;;883            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
;;;884            {
;;;885              if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000216  bf00              NOP      
                  |L2.536|
000218  f7fffffe          BL       HAL_GetTick
00021c  1bc1              SUBS     r1,r0,r7
00021e  4541              CMP      r1,r8
000220  d902              BLS      |L2.552|
                  |L2.546|
;;;886              {
;;;887                return HAL_TIMEOUT;
000222  2003              MOVS     r0,#3
                  |L2.548|
;;;888              }
;;;889            }
;;;890          }      
;;;891        } 
;;;892        
;;;893        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;894        __HAL_FLASH_SET_LATENCY(FLatency);
;;;895        
;;;896        /* Check that the new number of wait states is taken into account to access the Flash
;;;897        memory by reading the FLASH_ACR register */
;;;898        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;899        {
;;;900          return HAL_ERROR;
;;;901        }
;;;902      }
;;;903    #endif /* FLASH_ACR_LATENCY */
;;;904      
;;;905      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;906      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;907      {
;;;908        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;909        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;910      }
;;;911      
;;;912      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;913      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;914      {
;;;915        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;916        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;917      }
;;;918     
;;;919      /* Configure the source of time base considering new system clocks settings*/
;;;920      HAL_InitTick (TICK_INT_PRIORITY);
;;;921      
;;;922      return HAL_OK;
;;;923    }
000224  e8bd87f0          POP      {r4-r10,pc}
                  |L2.552|
000228  6860              LDR      r0,[r4,#4]            ;883
00022a  f0100f0c          TST      r0,#0xc               ;883
00022e  d1f3              BNE      |L2.536|
                  |L2.560|
000230  f8d91000          LDR      r1,[r9,#0]            ;894
000234  f0210107          BIC      r1,r1,#7              ;894
000238  4331              ORRS     r1,r1,r6              ;894
00023a  f8c91000          STR      r1,[r9,#0]            ;894
00023e  f8d90000          LDR      r0,[r9,#0]            ;898
000242  f0000007          AND      r0,r0,#7              ;898
000246  42b0              CMP      r0,r6                 ;898
000248  d001              BEQ      |L2.590|
                  |L2.586|
00024a  2001              MOVS     r0,#1                 ;900
00024c  e7ea              B        |L2.548|
                  |L2.590|
00024e  7828              LDRB     r0,[r5,#0]            ;906
000250  0740              LSLS     r0,r0,#29             ;906
000252  d505              BPL      |L2.608|
000254  6860              LDR      r0,[r4,#4]            ;909
000256  68e9              LDR      r1,[r5,#0xc]          ;909
000258  f42060e0          BIC      r0,r0,#0x700          ;909
00025c  4308              ORRS     r0,r0,r1              ;909
00025e  6060              STR      r0,[r4,#4]            ;909
                  |L2.608|
000260  7828              LDRB     r0,[r5,#0]            ;913
000262  0700              LSLS     r0,r0,#28             ;913
000264  d506              BPL      |L2.628|
000266  6860              LDR      r0,[r4,#4]            ;916
000268  6929              LDR      r1,[r5,#0x10]         ;916
00026a  f4205060          BIC      r0,r0,#0x3800         ;916
00026e  ea4000c1          ORR      r0,r0,r1,LSL #3       ;916
000272  6060              STR      r0,[r4,#4]            ;916
                  |L2.628|
000274  2000              MOVS     r0,#0                 ;920
000276  f7fffffe          BL       HAL_InitTick
00027a  2000              MOVS     r0,#0                 ;922
00027c  e7d2              B        |L2.548|
;;;924    
                          ENDP

00027e  0000              DCW      0x0000
                  |L2.640|
                          DCD      0x40022000
                  |L2.644|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;213      */
;;;214    void HAL_RCC_DeInit(void)
000000  480e              LDR      r0,|L3.60|
;;;215    {
000002  b510              PUSH     {r4,lr}
;;;216      /* Switch SYSCLK to HSI */
;;;217      CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
000004  6841              LDR      r1,[r0,#4]
000006  f0210103          BIC      r1,r1,#3
00000a  6041              STR      r1,[r0,#4]
;;;218    
;;;219      /* Reset HSEON, CSSON, & PLLON bits */
;;;220      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
00000c  6801              LDR      r1,[r0,#0]
00000e  4a0c              LDR      r2,|L3.64|
000010  4011              ANDS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;221      
;;;222      /* Reset HSEBYP bit */
;;;223      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
000014  6801              LDR      r1,[r0,#0]
000016  f4212180          BIC      r1,r1,#0x40000
00001a  6001              STR      r1,[r0,#0]
;;;224      
;;;225      /* Reset CFGR register */
;;;226      CLEAR_REG(RCC->CFGR);
00001c  2100              MOVS     r1,#0
00001e  6041              STR      r1,[r0,#4]
;;;227      
;;;228      /* Set HSITRIM bits to the reset value */
;;;229      MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_CR_HSITRIM)));
000020  6802              LDR      r2,[r0,#0]
000022  24f8              MOVS     r4,#0xf8
000024  fa94f4a4          RBIT     r4,r4
000028  2310              MOVS     r3,#0x10
00002a  fab4f484          CLZ      r4,r4
00002e  f02202f8          BIC      r2,r2,#0xf8
000032  40a3              LSLS     r3,r3,r4
000034  431a              ORRS     r2,r2,r3
000036  6002              STR      r2,[r0,#0]
;;;230      
;;;231    #if (defined(STM32F105xC) || defined(STM32F107xC) || defined (STM32F100xB) || defined (STM32F100xE))
;;;232      /* Reset CFGR2 register */
;;;233      CLEAR_REG(RCC->CFGR2);
;;;234    
;;;235    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;236      /* Disable all interrupts */
;;;237      CLEAR_REG(RCC->CIR);
000038  6081              STR      r1,[r0,#8]
;;;238    }
00003a  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  |L3.60|
                          DCD      0x40021000
                  |L3.64|
                          DCD      0xfef6ffff

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;1015     */
;;;1016   void HAL_RCC_DisableCSS(void)
000000  f44f2100          MOV      r1,#0x80000
;;;1017   {
;;;1018     *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
000004  fa91f1a1          RBIT     r1,r1
000008  4a03              LDR      r2,|L4.24|
00000a  fab1f181          CLZ      r1,r1
00000e  2000              MOVS     r0,#0
000010  f8420021          STR      r0,[r2,r1,LSL #2]
;;;1019   }
000014  4770              BX       lr
;;;1020   
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;1006     */
;;;1007   void HAL_RCC_EnableCSS(void)
000000  2001              MOVS     r0,#1
;;;1008   {
;;;1009     *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
000002  04c1              LSLS     r1,r0,#19
000004  fa91f1a1          RBIT     r1,r1
000008  4a02              LDR      r2,|L5.20|
00000a  fab1f181          CLZ      r1,r1
00000e  f8420021          STR      r0,[r2,r1,LSL #2]
;;;1010   }
000012  4770              BX       lr
;;;1011   
                          ENDP

                  |L5.20|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1279     */
;;;1280   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1281   {
;;;1282     /* Check the parameters */
;;;1283     assert_param(RCC_ClkInitStruct != NULL);
;;;1284     assert_param(pFLatency != NULL);
;;;1285   
;;;1286     /* Set all possible values for the Clock type parameter --------------------*/
;;;1287     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1288     
;;;1289     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1290     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6853              LDR      r3,[r2,#4]
000008  f0030303          AND      r3,r3,#3
;;;1291     
;;;1292     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1293     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6853              LDR      r3,[r2,#4]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1294     
;;;1295     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1296     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6853              LDR      r3,[r2,#4]
000018  f40363e0          AND      r3,r3,#0x700
;;;1297     
;;;1298     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1299     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6852              LDR      r2,[r2,#4]
;;;1300     
;;;1301   #if   defined(FLASH_ACR_LATENCY)
;;;1302     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1303     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1304   #else
;;;1305     /* For VALUE lines devices, only LATENCY_0 can be set*/
;;;1306     *pFLatency = (uint32_t)FLASH_LATENCY_0; 
;;;1307   #endif
;;;1308   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1303
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1303
00002e  f0000007          AND      r0,r0,#7              ;1303
000032  6008              STR      r0,[r1,#0]            ;1303
000034  4770              BX       lr
;;;1309   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40021000
                  |L6.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1143     */
;;;1144   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  b500              PUSH     {lr}
;;;1145   {
;;;1146     SystemCoreClock = HAL_RCC_GetSysClockFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
000002  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000006  4908              LDR      r1,|L7.40|
000008  6849              LDR      r1,[r1,#4]
00000a  22f0              MOVS     r2,#0xf0
00000c  fa92f2a2          RBIT     r2,r2
000010  f00101f0          AND      r1,r1,#0xf0
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L7.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
000020  4903              LDR      r1,|L7.48|
000022  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;1147     return SystemCoreClock;
;;;1148   }
000024  bd00              POP      {pc}
;;;1149   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40021000
                  |L7.44|
                          DCD      ||.constdata||
                  |L7.48|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1180     */
;;;1181   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;1182   {
;;;1183     /* Check the parameters */
;;;1184     assert_param(RCC_OscInitStruct != NULL);
;;;1185   
;;;1186     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1187     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
000002  210f              MOVS     r1,#0xf
;;;1188                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1189   
;;;1190   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1191     /* Get the Prediv1 source --------------------------------------------------*/
;;;1192     RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
;;;1193   #endif /* RCC_CFGR2_PREDIV1SRC */
;;;1194   
;;;1195     /* Get the HSE configuration -----------------------------------------------*/
;;;1196     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000004  6001              STR      r1,[r0,#0]
000006  4924              LDR      r1,|L8.152|
000008  680a              LDR      r2,[r1,#0]
00000a  0353              LSLS     r3,r2,#13
00000c  f04f0200          MOV      r2,#0
000010  d502              BPL      |L8.24|
;;;1197     {
;;;1198       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f23a0          MOV      r3,#0x50000
000016  e004              B        |L8.34|
                  |L8.24|
;;;1199     }
;;;1200     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
000018  680b              LDR      r3,[r1,#0]
00001a  03db              LSLS     r3,r3,#15
00001c  d503              BPL      |L8.38|
;;;1201     {
;;;1202       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001e  f44f3380          MOV      r3,#0x10000
                  |L8.34|
000022  6043              STR      r3,[r0,#4]
000024  e000              B        |L8.40|
                  |L8.38|
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000026  6042              STR      r2,[r0,#4]
                  |L8.40|
;;;1207     }
;;;1208     RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
000028  684b              LDR      r3,[r1,#4]
00002a  f4033300          AND      r3,r3,#0x20000
;;;1209   
;;;1210     /* Get the HSI configuration -----------------------------------------------*/
;;;1211     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
00002e  6083              STR      r3,[r0,#8]
000030  680b              LDR      r3,[r1,#0]
000032  07dc              LSLS     r4,r3,#31
;;;1212     {
;;;1213       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000034  f04f0301          MOV      r3,#1
000038  d001              BEQ      |L8.62|
00003a  6103              STR      r3,[r0,#0x10]
00003c  e000              B        |L8.64|
                  |L8.62|
;;;1214     }
;;;1215     else
;;;1216     {
;;;1217       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
00003e  6102              STR      r2,[r0,#0x10]
                  |L8.64|
;;;1218     }
;;;1219     
;;;1220     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
000040  680c              LDR      r4,[r1,#0]
000042  25f8              MOVS     r5,#0xf8
000044  fa95f5a5          RBIT     r5,r5
000048  f00404f8          AND      r4,r4,#0xf8
00004c  fab5f585          CLZ      r5,r5
000050  40ec              LSRS     r4,r4,r5
;;;1221     
;;;1222     /* Get the LSE configuration -----------------------------------------------*/
;;;1223     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000052  6144              STR      r4,[r0,#0x14]
000054  6a0c              LDR      r4,[r1,#0x20]
000056  0764              LSLS     r4,r4,#29
000058  d502              BPL      |L8.96|
;;;1224     {
;;;1225       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00005a  2405              MOVS     r4,#5
00005c  60c4              STR      r4,[r0,#0xc]
00005e  e005              B        |L8.108|
                  |L8.96|
;;;1226     }
;;;1227     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000060  6a0c              LDR      r4,[r1,#0x20]
000062  07e4              LSLS     r4,r4,#31
000064  d001              BEQ      |L8.106|
;;;1228     {
;;;1229       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000066  60c3              STR      r3,[r0,#0xc]
000068  e000              B        |L8.108|
                  |L8.106|
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00006a  60c2              STR      r2,[r0,#0xc]
                  |L8.108|
;;;1234     }
;;;1235     
;;;1236     /* Get the LSI configuration -----------------------------------------------*/
;;;1237     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
00006c  6a4c              LDR      r4,[r1,#0x24]
00006e  07e4              LSLS     r4,r4,#31
000070  d001              BEQ      |L8.118|
;;;1238     {
;;;1239       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000072  6183              STR      r3,[r0,#0x18]
000074  e000              B        |L8.120|
                  |L8.118|
;;;1240     }
;;;1241     else
;;;1242     {
;;;1243       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000076  6182              STR      r2,[r0,#0x18]
                  |L8.120|
;;;1244     }
;;;1245     
;;;1246     /* Get the PLL configuration -----------------------------------------------*/
;;;1247     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000078  680a              LDR      r2,[r1,#0]
00007a  01d2              LSLS     r2,r2,#7
00007c  d502              BPL      |L8.132|
;;;1248     {
;;;1249       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00007e  2202              MOVS     r2,#2
000080  61c2              STR      r2,[r0,#0x1c]
000082  e000              B        |L8.134|
                  |L8.132|
;;;1250     }
;;;1251     else
;;;1252     {
;;;1253       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000084  61c3              STR      r3,[r0,#0x1c]
                  |L8.134|
;;;1254     }
;;;1255     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
000086  684a              LDR      r2,[r1,#4]
000088  f4023280          AND      r2,r2,#0x10000
;;;1256     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
00008c  6202              STR      r2,[r0,#0x20]
00008e  6849              LDR      r1,[r1,#4]
000090  f4011170          AND      r1,r1,#0x3c0000
000094  6241              STR      r1,[r0,#0x24]
;;;1257   #if defined(RCC_CR_PLL2ON)
;;;1258     /* Get the PLL2 configuration -----------------------------------------------*/
;;;1259     if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
;;;1260     {
;;;1261       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
;;;1262     }
;;;1263     else
;;;1264     {
;;;1265       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
;;;1266     }
;;;1267     RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
;;;1268     RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
;;;1269   #endif /* RCC_CR_PLL2ON */
;;;1270   }
000096  bd30              POP      {r4,r5,pc}
;;;1271   
                          ENDP

                  |L8.152|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1155     */
;;;1156   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  b500              PUSH     {lr}
;;;1157   {
;;;1158     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1159     return (HAL_RCC_GetHCLKFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4907              LDR      r1,|L9.36|
000008  6849              LDR      r1,[r1,#4]
00000a  f44f62e0          MOV      r2,#0x700
00000e  fa92f2a2          RBIT     r2,r2
000012  f40161e0          AND      r1,r1,#0x700
000016  fab2f282          CLZ      r2,r2
00001a  40d1              LSRS     r1,r1,r2
00001c  4a02              LDR      r2,|L9.40|
00001e  5c51              LDRB     r1,[r2,r1]
000020  40c8              LSRS     r0,r0,r1
;;;1160   }    
000022  bd00              POP      {pc}
;;;1161   
                          ENDP

                  |L9.36|
                          DCD      0x40021000
                  |L9.40|
                          DCD      ||.constdata||

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1167     */
;;;1168   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  b500              PUSH     {lr}
;;;1169   {
;;;1170     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1171     return (HAL_RCC_GetHCLKFreq()>> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4907              LDR      r1,|L10.36|
000008  6849              LDR      r1,[r1,#4]
00000a  f44f5260          MOV      r2,#0x3800
00000e  fa92f2a2          RBIT     r2,r2
000012  f4015160          AND      r1,r1,#0x3800
000016  fab2f282          CLZ      r2,r2
00001a  40d1              LSRS     r1,r1,r2
00001c  4a02              LDR      r2,|L10.40|
00001e  5c51              LDRB     r1,[r2,r1]
000020  40c8              LSRS     r0,r0,r1
;;;1172   } 
000022  bd00              POP      {pc}
;;;1173   
                          ENDP

                  |L10.36|
                          DCD      0x40021000
                  |L10.40|
                          DCD      ||.constdata||

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;1049     */
;;;1050   uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;1051   {
;;;1052   #if   defined(RCC_CFGR2_PREDIV1SRC)
;;;1053     const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;1054     const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;1055   #else
;;;1056     const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a319              ADR      r3,|L11.104|
000004  b085              SUB      sp,sp,#0x14           ;1051
000006  cb0f              LDM      r3,{r0-r3}
000008  e88d000f          STM      sp,{r0-r3}
;;;1057   #if defined(RCC_CFGR2_PREDIV1)
;;;1058     const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;1059   #else
;;;1060     const uint8_t aPredivFactorTable[2] = { 1, 2};
00000c  a01a              ADR      r0,|L11.120|
;;;1061   #endif /*RCC_CFGR2_PREDIV1*/
;;;1062   
;;;1063   #endif
;;;1064     uint32_t tmpreg = 0, prediv = 0, pllclk = 0, pllmul = 0;
;;;1065     uint32_t sysclockfreq = 0;
;;;1066   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1067     uint32_t prediv2 = 0, pll2mul = 0;
;;;1068   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1069     
;;;1070     tmpreg = RCC->CFGR;
00000e  4b1b              LDR      r3,|L11.124|
000010  6800              LDR      r0,[r0,#0]            ;1060
000012  9004              STR      r0,[sp,#0x10]
000014  685a              LDR      r2,[r3,#4]
;;;1071     
;;;1072     /* Get SYSCLK source -------------------------------------------------------*/
;;;1073     switch (tmpreg & RCC_CFGR_SWS)
;;;1074     {
;;;1075       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;1076       {
;;;1077         sysclockfreq = HSE_VALUE;
000016  481a              LDR      r0,|L11.128|
000018  f002010c          AND      r1,r2,#0xc            ;1073
00001c  2904              CMP      r1,#4                 ;1073
00001e  d01d              BEQ      |L11.92|
000020  2908              CMP      r1,#8                 ;1073
000022  d11b              BNE      |L11.92|
;;;1078         break;
;;;1079       }
;;;1080       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;1081       {
;;;1082         pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
000024  f44f1470          MOV      r4,#0x3c0000
000028  fa94f4a4          RBIT     r4,r4
00002c  f4021170          AND      r1,r2,#0x3c0000
000030  fab4f484          CLZ      r4,r4
000034  40e1              LSRS     r1,r1,r4
;;;1083         if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000036  03d2              LSLS     r2,r2,#15
000038  f81d1001          LDRB     r1,[sp,r1]            ;1082
00003c  d510              BPL      |L11.96|
;;;1084         {
;;;1085   #if defined(RCC_CFGR2_PREDIV1)
;;;1086           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;1087   #else
;;;1088           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
00003e  685a              LDR      r2,[r3,#4]
000040  f44f3300          MOV      r3,#0x20000
000044  fa93f3a3          RBIT     r3,r3
000048  f4023200          AND      r2,r2,#0x20000
00004c  fab3f383          CLZ      r3,r3
000050  40da              LSRS     r2,r2,r3
000052  ab04              ADD      r3,sp,#0x10
000054  5c9a              LDRB     r2,[r3,r2]
;;;1089   #endif /*RCC_CFGR2_PREDIV1*/
;;;1090   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1091   
;;;1092           if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;1093           {
;;;1094             /* PLL2 selected as Prediv1 source */
;;;1095             /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;1096             prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;1097             pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;1098             pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv) * pllmul);
;;;1099           }
;;;1100           else
;;;1101           {
;;;1102             /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1103             pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
;;;1104           }
;;;1105           
;;;1106           /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;1107           /* In this case need to divide pllclk by 2 */
;;;1108           if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;1109           {
;;;1110               pllclk = pllclk / 2;
;;;1111           }
;;;1112   #else
;;;1113           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1114           pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
000056  fbb0f0f2          UDIV     r0,r0,r2
00005a  4348              MULS     r0,r1,r0
                  |L11.92|
;;;1115   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1116         }
;;;1117         else
;;;1118         {
;;;1119           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1120           pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;1121         }
;;;1122         sysclockfreq = pllclk;
;;;1123         break;
;;;1124       }
;;;1125       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1126       default: /* HSI used as system clock */
;;;1127       {
;;;1128         sysclockfreq = HSI_VALUE;
;;;1129         break;
;;;1130       }
;;;1131     }
;;;1132     return sysclockfreq;
;;;1133   }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd10              POP      {r4,pc}
                  |L11.96|
000060  4808              LDR      r0,|L11.132|
000062  4348              MULS     r0,r1,r0              ;1120
000064  e7fa              B        |L11.92|
;;;1134   
                          ENDP

000066  0000              DCW      0x0000
                  |L11.104|
000068  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
00006c  06070809
000070  0a0b0c0d
000074  0e0f1010
                  |L11.120|
000078  010200            DCB      1,2,0
00007b  00                DCB      0
                  |L11.124|
                          DCD      0x40021000
                  |L11.128|
                          DCD      0x007a1200
                  |L11.132|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;974      */
;;;975    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b530              PUSH     {r4,r5,lr}
;;;976    {
000002  b085              SUB      sp,sp,#0x14
;;;977      GPIO_InitTypeDef gpio = {0};
;;;978    
;;;979      /* Check the parameters */
;;;980      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;981      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;982      assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;983      
;;;984      /* MCO Clock Enable */
;;;985      MCO1_CLK_ENABLE();
000004  4c0e              LDR      r4,|L12.64|
000006  2000              MOVS     r0,#0                 ;977
000008  9002              STR      r0,[sp,#8]
00000a  69a0              LDR      r0,[r4,#0x18]
00000c  460d              MOV      r5,r1                 ;976
00000e  f0400004          ORR      r0,r0,#4
000012  61a0              STR      r0,[r4,#0x18]
000014  69a0              LDR      r0,[r4,#0x18]
;;;986      
;;;987      /* Configure the MCO1 pin in alternate function mode */
;;;988      gpio.Pin = MCO1_PIN;
;;;989      gpio.Mode = GPIO_MODE_AF_PP;
;;;990      gpio.Speed = GPIO_SPEED_FREQ_HIGH;
;;;991      gpio.Pull = GPIO_NOPULL;
;;;992      HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
000016  4669              MOV      r1,sp
000018  f0000004          AND      r0,r0,#4              ;985
00001c  9004              STR      r0,[sp,#0x10]         ;988
00001e  15a0              ASRS     r0,r4,#22             ;988
000020  9000              STR      r0,[sp,#0]            ;989
000022  2002              MOVS     r0,#2                 ;989
000024  9001              STR      r0,[sp,#4]            ;990
000026  2003              MOVS     r0,#3                 ;990
000028  9003              STR      r0,[sp,#0xc]
00002a  4806              LDR      r0,|L12.68|
00002c  f7fffffe          BL       HAL_GPIO_Init
;;;993      
;;;994      /* Configure the MCO clock source */
;;;995      __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000030  6860              LDR      r0,[r4,#4]
000032  f02060e0          BIC      r0,r0,#0x7000000
000036  4328              ORRS     r0,r0,r5
000038  6060              STR      r0,[r4,#4]
;;;996    }
00003a  b005              ADD      sp,sp,#0x14
00003c  bd30              POP      {r4,r5,pc}
;;;997    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0x40010800

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1314     */
;;;1315   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1316   {
;;;1317     /* Check RCC CSSF flag  */
;;;1318     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L13.20|
000004  68a0              LDR      r0,[r4,#8]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L13.18|
;;;1319     {
;;;1320       /* RCC Clock Security System interrupt user callback */
;;;1321       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1322       
;;;1323       /* Clear RCC CSS pending bit */
;;;1324       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  2080              MOVS     r0,#0x80
000010  72a0              STRB     r0,[r4,#0xa]
                  |L13.18|
;;;1325     }
;;;1326   }
000012  bd10              POP      {r4,pc}
;;;1327   
                          ENDP

                  |L13.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;248      */
;;;249    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;250    {
000004  4605              MOV      r5,r0
;;;251       uint32_t tickstart = 0;
;;;252      
;;;253      /* Check the parameters */
;;;254      assert_param(RCC_OscInitStruct != NULL);
;;;255      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;256      
;;;257      /*------------------------------- HSE Configuration ------------------------*/ 
;;;258      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;259      {
;;;260        /* Check the parameters */
;;;261        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;262            
;;;263        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;264        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000008  4efa              LDR      r6,|L14.1012|
00000a  07c0              LSLS     r0,r0,#31             ;258
;;;265           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
;;;266        {
;;;267          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
00000c  f04f0401          MOV      r4,#1
000010  d025              BEQ      |L14.94|
000012  6870              LDR      r0,[r6,#4]            ;264
000014  0467              LSLS     r7,r4,#17
000016  f3c00081          UBFX     r0,r0,#2,#2           ;264
00001a  2801              CMP      r0,#1                 ;264
00001c  d007              BEQ      |L14.46|
00001e  6870              LDR      r0,[r6,#4]            ;265
000020  f3c00081          UBFX     r0,r0,#2,#2           ;265
000024  2802              CMP      r0,#2                 ;265
000026  d11b              BNE      |L14.96|
000028  6870              LDR      r0,[r6,#4]            ;265
00002a  03c0              LSLS     r0,r0,#15             ;265
00002c  d518              BPL      |L14.96|
                  |L14.46|
00002e  fa97f0a7          RBIT     r0,r7
000032  fab0f080          CLZ      r0,r0
000036  f0400020          ORR      r0,r0,#0x20
00003a  0940              LSRS     r0,r0,#5
00003c  d001              BEQ      |L14.66|
00003e  6830              LDR      r0,[r6,#0]
000040  e000              B        |L14.68|
                  |L14.66|
000042  6a70              LDR      r0,[r6,#0x24]
                  |L14.68|
000044  fa97f1a7          RBIT     r1,r7
000048  fab1f181          CLZ      r1,r1
00004c  f001011f          AND      r1,r1,#0x1f
000050  fa04f101          LSL      r1,r4,r1
000054  4208              TST      r0,r1
000056  d002              BEQ      |L14.94|
000058  6868              LDR      r0,[r5,#4]
00005a  2800              CMP      r0,#0
00005c  d076              BEQ      |L14.332|
                  |L14.94|
00005e  e081              B        |L14.356|
                  |L14.96|
;;;268          {
;;;269            return HAL_ERROR;
;;;270          }
;;;271        }
;;;272        else
;;;273        {
;;;274          /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
;;;275          __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
000060  6830              LDR      r0,[r6,#0]
000062  f4203080          BIC      r0,r0,#0x10000
000066  6030              STR      r0,[r6,#0]
000068  6830              LDR      r0,[r6,#0]
00006a  f4202080          BIC      r0,r0,#0x40000
00006e  6030              STR      r0,[r6,#0]
;;;276          
;;;277          /* Get Start Tick */
;;;278          tickstart = HAL_GetTick();
000070  f7fffffe          BL       HAL_GetTick
000074  4680              MOV      r8,r0
;;;279          
;;;280          /* Wait till HSE is disabled */  
;;;281          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
000076  e005              B        |L14.132|
                  |L14.120|
;;;282          {
;;;283            if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
000078  f7fffffe          BL       HAL_GetTick
00007c  eba00008          SUB      r0,r0,r8
000080  2864              CMP      r0,#0x64
                  |L14.130|
000082  d87c              BHI      |L14.382|
                  |L14.132|
000084  fa97f0a7          RBIT     r0,r7                 ;281
000088  fab0f080          CLZ      r0,r0                 ;281
00008c  f0400020          ORR      r0,r0,#0x20           ;281
000090  0940              LSRS     r0,r0,#5              ;281
000092  d001              BEQ      |L14.152|
000094  6830              LDR      r0,[r6,#0]            ;281
000096  e000              B        |L14.154|
                  |L14.152|
000098  6a70              LDR      r0,[r6,#0x24]         ;281
                  |L14.154|
00009a  fa97f1a7          RBIT     r1,r7                 ;281
00009e  fab1f181          CLZ      r1,r1                 ;281
0000a2  f001011f          AND      r1,r1,#0x1f           ;281
0000a6  fa04f101          LSL      r1,r4,r1              ;281
0000aa  4208              TST      r0,r1                 ;281
0000ac  d1e4              BNE      |L14.120|
;;;284            {
;;;285              return HAL_TIMEOUT;
;;;286            }
;;;287          }
;;;288          
;;;289          /* Set the new HSE configuration ---------------------------------------*/
;;;290          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
0000ae  6868              LDR      r0,[r5,#4]
0000b0  f5b03f80          CMP      r0,#0x10000
0000b4  d00b              BEQ      |L14.206|
0000b6  b110              CBZ      r0,|L14.190|
0000b8  f5b02fa0          CMP      r0,#0x50000
0000bc  d011              BEQ      |L14.226|
                  |L14.190|
0000be  6830              LDR      r0,[r6,#0]
0000c0  f4203080          BIC      r0,r0,#0x10000
0000c4  6030              STR      r0,[r6,#0]
0000c6  6830              LDR      r0,[r6,#0]
0000c8  f4202080          BIC      r0,r0,#0x40000
0000cc  e002              B        |L14.212|
                  |L14.206|
0000ce  6830              LDR      r0,[r6,#0]
0000d0  f4403080          ORR      r0,r0,#0x10000
                  |L14.212|
0000d4  6030              STR      r0,[r6,#0]
;;;291          
;;;292    
;;;293           /* Check the HSE State */
;;;294          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
0000d6  6868              LDR      r0,[r5,#4]
0000d8  b320              CBZ      r0,|L14.292|
;;;295          {
;;;296            /* Get Start Tick */
;;;297            tickstart = HAL_GetTick();
0000da  f7fffffe          BL       HAL_GetTick
0000de  4680              MOV      r8,r0
;;;298            
;;;299            /* Wait till HSE is ready */
;;;300            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
0000e0  e00a              B        |L14.248|
                  |L14.226|
0000e2  6830              LDR      r0,[r6,#0]            ;290
0000e4  f4402080          ORR      r0,r0,#0x40000        ;290
0000e8  6030              STR      r0,[r6,#0]            ;290
0000ea  e7f0              B        |L14.206|
                  |L14.236|
;;;301            {
;;;302              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000ec  f7fffffe          BL       HAL_GetTick
0000f0  eba00008          SUB      r0,r0,r8
0000f4  2864              CMP      r0,#0x64
                  |L14.246|
0000f6  d8c4              BHI      |L14.130|
                  |L14.248|
0000f8  fa97f0a7          RBIT     r0,r7                 ;300
0000fc  fab0f080          CLZ      r0,r0                 ;300
000100  f0400020          ORR      r0,r0,#0x20           ;300
000104  0940              LSRS     r0,r0,#5              ;300
000106  d001              BEQ      |L14.268|
000108  6830              LDR      r0,[r6,#0]            ;300
00010a  e000              B        |L14.270|
                  |L14.268|
00010c  6a70              LDR      r0,[r6,#0x24]         ;300
                  |L14.270|
00010e  fa97f1a7          RBIT     r1,r7                 ;300
000112  fab1f181          CLZ      r1,r1                 ;300
000116  f001011f          AND      r1,r1,#0x1f           ;300
00011a  fa04f101          LSL      r1,r4,r1              ;300
00011e  4208              TST      r0,r1                 ;300
000120  d0e4              BEQ      |L14.236|
000122  e01f              B        |L14.356|
                  |L14.292|
;;;303              {
;;;304                return HAL_TIMEOUT;
;;;305              }
;;;306            }
;;;307          }
;;;308          else
;;;309          {
;;;310            /* Get Start Tick */
;;;311            tickstart = HAL_GetTick();
000124  f7fffffe          BL       HAL_GetTick
000128  4680              MOV      r8,r0
;;;312            
;;;313            /* Wait till HSE is bypassed or disabled */
;;;314            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
00012a  e005              B        |L14.312|
                  |L14.300|
;;;315            {
;;;316               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00012c  f7fffffe          BL       HAL_GetTick
000130  eba00008          SUB      r0,r0,r8
000134  2864              CMP      r0,#0x64
000136  d8a4              BHI      |L14.130|
                  |L14.312|
000138  fa97f0a7          RBIT     r0,r7                 ;314
00013c  fab0f080          CLZ      r0,r0                 ;314
000140  f0400020          ORR      r0,r0,#0x20           ;314
000144  0940              LSRS     r0,r0,#5              ;314
000146  d002              BEQ      |L14.334|
000148  6830              LDR      r0,[r6,#0]            ;314
00014a  e001              B        |L14.336|
                  |L14.332|
00014c  e0b7              B        |L14.702|
                  |L14.334|
00014e  6a70              LDR      r0,[r6,#0x24]         ;314
                  |L14.336|
000150  fa97f1a7          RBIT     r1,r7                 ;314
000154  fab1f181          CLZ      r1,r1                 ;314
000158  f001011f          AND      r1,r1,#0x1f           ;314
00015c  fa04f101          LSL      r1,r4,r1              ;314
000160  4208              TST      r0,r1                 ;314
000162  d1e3              BNE      |L14.300|
                  |L14.356|
;;;317              {
;;;318                return HAL_TIMEOUT;
;;;319              }
;;;320            }
;;;321          }
;;;322        }
;;;323      }
;;;324      /*----------------------------- HSI Configuration --------------------------*/ 
;;;325      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
000164  7828              LDRB     r0,[r5,#0]
;;;326      {
;;;327        /* Check the parameters */
;;;328        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;329        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;330        
;;;331        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;332        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
;;;333           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
;;;334        {
;;;335          /* When HSI is used as system clock it will not disabled */
;;;336          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;337          {
;;;338            return HAL_ERROR;
;;;339          }
;;;340          /* Otherwise, just the calibration is allowed */
;;;341          else
;;;342          {
;;;343            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;344            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;345          }
;;;346        }
;;;347        else
;;;348        {
;;;349          /* Check the HSI State */
;;;350          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;351          {
;;;352           /* Enable the Internal High Speed oscillator (HSI). */
;;;353            __HAL_RCC_HSI_ENABLE();
000166  f8df8290          LDR      r8,|L14.1016|
00016a  0780              LSLS     r0,r0,#30             ;325
00016c  f04f0900          MOV      r9,#0                 ;325
000170  f04f0702          MOV      r7,#2                 ;336
000174  d55a              BPL      |L14.556|
000176  6870              LDR      r0,[r6,#4]            ;332
000178  f0100f0c          TST      r0,#0xc               ;332
00017c  e000              B        |L14.384|
                  |L14.382|
00017e  e17a              B        |L14.1142|
                  |L14.384|
000180  f04f0bf8          MOV      r11,#0xf8             ;344
000184  d007              BEQ      |L14.406|
000186  6870              LDR      r0,[r6,#4]            ;333
000188  f3c00081          UBFX     r0,r0,#2,#2           ;333
00018c  2802              CMP      r0,#2                 ;333
00018e  d11b              BNE      |L14.456|
000190  6870              LDR      r0,[r6,#4]            ;333
000192  03c0              LSLS     r0,r0,#15             ;333
000194  d418              BMI      |L14.456|
                  |L14.406|
000196  fa97f0a7          RBIT     r0,r7                 ;336
00019a  fab0f080          CLZ      r0,r0                 ;336
00019e  f0400020          ORR      r0,r0,#0x20           ;336
0001a2  0940              LSRS     r0,r0,#5              ;336
0001a4  d001              BEQ      |L14.426|
0001a6  6830              LDR      r0,[r6,#0]            ;336
0001a8  e000              B        |L14.428|
                  |L14.426|
0001aa  6a70              LDR      r0,[r6,#0x24]         ;336
                  |L14.428|
0001ac  fa97f1a7          RBIT     r1,r7                 ;336
0001b0  fab1f181          CLZ      r1,r1                 ;336
0001b4  f001011f          AND      r1,r1,#0x1f           ;336
0001b8  fa04f101          LSL      r1,r4,r1              ;336
0001bc  4208              TST      r0,r1                 ;336
0001be  d02a              BEQ      |L14.534|
0001c0  6928              LDR      r0,[r5,#0x10]         ;336
0001c2  2801              CMP      r0,#1                 ;336
0001c4  d17b              BNE      |L14.702|
0001c6  e026              B        |L14.534|
                  |L14.456|
0001c8  6928              LDR      r0,[r5,#0x10]         ;350
0001ca  b380              CBZ      r0,|L14.558|
0001cc  fa94f0a4          RBIT     r0,r4
0001d0  fab0f080          CLZ      r0,r0
0001d4  f8484020          STR      r4,[r8,r0,LSL #2]
;;;354            
;;;355            /* Get Start Tick */
;;;356            tickstart = HAL_GetTick();
0001d8  f7fffffe          BL       HAL_GetTick
0001dc  4682              MOV      r10,r0
;;;357            
;;;358            /* Wait till HSI is ready */
;;;359            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
0001de  e005              B        |L14.492|
                  |L14.480|
;;;360            {
;;;361              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
0001e0  f7fffffe          BL       HAL_GetTick
0001e4  eba0000a          SUB      r0,r0,r10
0001e8  2864              CMP      r0,#0x64
                  |L14.490|
0001ea  d884              BHI      |L14.246|
                  |L14.492|
0001ec  fa97f0a7          RBIT     r0,r7                 ;359
0001f0  fab0f080          CLZ      r0,r0                 ;359
0001f4  f0400020          ORR      r0,r0,#0x20           ;359
0001f8  0940              LSRS     r0,r0,#5              ;359
0001fa  d001              BEQ      |L14.512|
0001fc  6830              LDR      r0,[r6,#0]            ;359
0001fe  e000              B        |L14.514|
                  |L14.512|
000200  6a70              LDR      r0,[r6,#0x24]         ;359
                  |L14.514|
000202  fa97f1a7          RBIT     r1,r7                 ;359
000206  fab1f181          CLZ      r1,r1                 ;359
00020a  f001011f          AND      r1,r1,#0x1f           ;359
00020e  fa04f101          LSL      r1,r4,r1              ;359
000212  4208              TST      r0,r1                 ;359
000214  d0e4              BEQ      |L14.480|
                  |L14.534|
;;;362              {
;;;363                return HAL_TIMEOUT;
;;;364              }
;;;365            }
;;;366                    
;;;367            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;368            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
000216  6830              LDR      r0,[r6,#0]
000218  fa9bf2ab          RBIT     r2,r11
00021c  6969              LDR      r1,[r5,#0x14]
00021e  fab2f282          CLZ      r2,r2
000222  f02000f8          BIC      r0,r0,#0xf8
000226  4091              LSLS     r1,r1,r2
000228  4308              ORRS     r0,r0,r1
00022a  6030              STR      r0,[r6,#0]
                  |L14.556|
00022c  e025              B        |L14.634|
                  |L14.558|
00022e  e7ff              B        |L14.560|
                  |L14.560|
;;;369          }
;;;370          else
;;;371          {
;;;372            /* Disable the Internal High Speed oscillator (HSI). */
;;;373            __HAL_RCC_HSI_DISABLE();
000230  fa94f1a4          RBIT     r1,r4
000234  fab1f181          CLZ      r1,r1
000238  f8489021          STR      r9,[r8,r1,LSL #2]
;;;374            
;;;375            /* Get Start Tick */
;;;376            tickstart = HAL_GetTick();
00023c  f7fffffe          BL       HAL_GetTick
000240  4682              MOV      r10,r0
;;;377            
;;;378            /* Wait till HSI is disabled */
;;;379            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
000242  e005              B        |L14.592|
                  |L14.580|
;;;380            {
;;;381              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000244  f7fffffe          BL       HAL_GetTick
000248  eba0000a          SUB      r0,r0,r10
00024c  2864              CMP      r0,#0x64
                  |L14.590|
00024e  d8cc              BHI      |L14.490|
                  |L14.592|
000250  fa97f0a7          RBIT     r0,r7                 ;379
000254  fab0f080          CLZ      r0,r0                 ;379
000258  f0400020          ORR      r0,r0,#0x20           ;379
00025c  0940              LSRS     r0,r0,#5              ;379
00025e  d001              BEQ      |L14.612|
000260  6830              LDR      r0,[r6,#0]            ;379
000262  e000              B        |L14.614|
                  |L14.612|
000264  6a70              LDR      r0,[r6,#0x24]         ;379
                  |L14.614|
000266  fa97f1a7          RBIT     r1,r7                 ;379
00026a  fab1f181          CLZ      r1,r1                 ;379
00026e  f001011f          AND      r1,r1,#0x1f           ;379
000272  fa04f101          LSL      r1,r4,r1              ;379
000276  4208              TST      r0,r1                 ;379
000278  d1e4              BNE      |L14.580|
                  |L14.634|
;;;382              {
;;;383                return HAL_TIMEOUT;
;;;384              }
;;;385            }
;;;386          }
;;;387        }
;;;388      }
;;;389      /*------------------------------ LSI Configuration -------------------------*/ 
;;;390      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
00027a  7828              LDRB     r0,[r5,#0]
00027c  0700              LSLS     r0,r0,#28
00027e  d56e              BPL      |L14.862|
;;;391      {
;;;392        /* Check the parameters */
;;;393        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;394        
;;;395        /* Check the LSI State */
;;;396        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
000280  69a8              LDR      r0,[r5,#0x18]
000282  b3b8              CBZ      r0,|L14.756|
;;;397        {
;;;398          /* Enable the Internal Low Speed oscillator (LSI). */
;;;399          __HAL_RCC_LSI_ENABLE();
000284  fa94f0a4          RBIT     r0,r4
000288  fab0f080          CLZ      r0,r0
00028c  eb080080          ADD      r0,r8,r0,LSL #2
000290  f8c04480          STR      r4,[r0,#0x480]
;;;400          
;;;401          /* Get Start Tick */
;;;402          tickstart = HAL_GetTick();
000294  f7fffffe          BL       HAL_GetTick
000298  4682              MOV      r10,r0
;;;403          
;;;404          /* Wait till LSI is ready */  
;;;405          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
00029a  e005              B        |L14.680|
                  |L14.668|
;;;406          {
;;;407            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
00029c  f7fffffe          BL       HAL_GetTick
0002a0  eba0000a          SUB      r0,r0,r10
0002a4  2802              CMP      r0,#2
0002a6  d8a0              BHI      |L14.490|
                  |L14.680|
0002a8  fa97f0a7          RBIT     r0,r7                 ;405
0002ac  fab0f080          CLZ      r0,r0                 ;405
0002b0  f0400060          ORR      r0,r0,#0x60           ;405
0002b4  ebb41f50          CMP      r4,r0,LSR #5          ;405
0002b8  d102              BNE      |L14.704|
0002ba  6830              LDR      r0,[r6,#0]            ;405
0002bc  e00c              B        |L14.728|
                  |L14.702|
0002be  e196              B        |L14.1518|
                  |L14.704|
0002c0  fa97f0a7          RBIT     r0,r7                 ;405
0002c4  fab0f080          CLZ      r0,r0                 ;405
0002c8  f0400060          ORR      r0,r0,#0x60           ;405
0002cc  ebb71f50          CMP      r7,r0,LSR #5          ;405
0002d0  d101              BNE      |L14.726|
0002d2  6a30              LDR      r0,[r6,#0x20]         ;405
0002d4  e000              B        |L14.728|
                  |L14.726|
0002d6  6a70              LDR      r0,[r6,#0x24]         ;405
                  |L14.728|
0002d8  fa97f1a7          RBIT     r1,r7                 ;405
0002dc  fab1f181          CLZ      r1,r1                 ;405
0002e0  f001011f          AND      r1,r1,#0x1f           ;405
0002e4  fa04f201          LSL      r2,r4,r1              ;405
0002e8  4210              TST      r0,r2                 ;405
0002ea  d0d7              BEQ      |L14.668|
;;;408            {
;;;409              return HAL_TIMEOUT;
;;;410            }
;;;411          }
;;;412          /*  To have a fully stabilized clock in the specified range, a software temporization of 1ms 
;;;413              should be added.*/
;;;414          HAL_Delay(1);
0002ec  2001              MOVS     r0,#1
0002ee  f7fffffe          BL       HAL_Delay
0002f2  e034              B        |L14.862|
                  |L14.756|
0002f4  e7ff              B        |L14.758|
                  |L14.758|
;;;415        }
;;;416        else
;;;417        {
;;;418          /* Disable the Internal Low Speed oscillator (LSI). */
;;;419          __HAL_RCC_LSI_DISABLE();
0002f6  fa94f1a4          RBIT     r1,r4
0002fa  fab1f181          CLZ      r1,r1
0002fe  eb080181          ADD      r1,r8,r1,LSL #2
000302  f8c19480          STR      r9,[r1,#0x480]
;;;420          
;;;421          /* Get Start Tick */
;;;422          tickstart = HAL_GetTick();
000306  f7fffffe          BL       HAL_GetTick
00030a  4682              MOV      r10,r0
;;;423          
;;;424          /* Wait till LSI is disabled */  
;;;425          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
00030c  e006              B        |L14.796|
;;;426          {
;;;427            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
00030e  bf00              NOP      
                  |L14.784|
000310  f7fffffe          BL       HAL_GetTick
000314  eba0000a          SUB      r0,r0,r10
000318  2802              CMP      r0,#2
00031a  d898              BHI      |L14.590|
                  |L14.796|
00031c  fa97f0a7          RBIT     r0,r7                 ;425
000320  fab0f080          CLZ      r0,r0                 ;425
000324  f0400060          ORR      r0,r0,#0x60           ;425
000328  ebb41f50          CMP      r4,r0,LSR #5          ;425
00032c  d101              BNE      |L14.818|
00032e  6830              LDR      r0,[r6,#0]            ;425
000330  e00b              B        |L14.842|
                  |L14.818|
000332  fa97f0a7          RBIT     r0,r7                 ;425
000336  fab0f080          CLZ      r0,r0                 ;425
00033a  f0400060          ORR      r0,r0,#0x60           ;425
00033e  ebb71f50          CMP      r7,r0,LSR #5          ;425
000342  d101              BNE      |L14.840|
000344  6a30              LDR      r0,[r6,#0x20]         ;425
000346  e000              B        |L14.842|
                  |L14.840|
000348  6a70              LDR      r0,[r6,#0x24]         ;425
                  |L14.842|
00034a  fa97f1a7          RBIT     r1,r7                 ;425
00034e  fab1f181          CLZ      r1,r1                 ;425
000352  f001011f          AND      r1,r1,#0x1f           ;425
000356  fa04f201          LSL      r2,r4,r1              ;425
00035a  4210              TST      r0,r2                 ;425
00035c  d1d8              BNE      |L14.784|
                  |L14.862|
;;;428            {
;;;429              return HAL_TIMEOUT;
;;;430            }
;;;431          }
;;;432        }
;;;433      }
;;;434      /*------------------------------ LSE Configuration -------------------------*/ 
;;;435      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
00035e  7828              LDRB     r0,[r5,#0]
000360  0740              LSLS     r0,r0,#29
000362  d570              BPL      |L14.1094|
;;;436      {
;;;437        /* Check the parameters */
;;;438        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;439        
;;;440        /* Enable Power Clock*/
;;;441        __HAL_RCC_PWR_CLK_ENABLE();
000364  69f0              LDR      r0,[r6,#0x1c]
000366  f0405080          ORR      r0,r0,#0x10000000
00036a  61f0              STR      r0,[r6,#0x1c]
00036c  69f0              LDR      r0,[r6,#0x1c]
;;;442        
;;;443        /* Enable write access to Backup domain */
;;;444        SET_BIT(PWR->CR, PWR_CR_DBP);
00036e  f8dfb08c          LDR      r11,|L14.1020|
000372  f0005080          AND      r0,r0,#0x10000000     ;441
000376  9000              STR      r0,[sp,#0]
000378  f8db1000          LDR      r1,[r11,#0]
00037c  f4417180          ORR      r1,r1,#0x100
000380  f8cb1000          STR      r1,[r11,#0]
;;;445    
;;;446        /* Wait for Backup domain Write protection disable */
;;;447        tickstart = HAL_GetTick();
000384  f7fffffe          BL       HAL_GetTick
000388  4682              MOV      r10,r0
;;;448        
;;;449        while((PWR->CR & PWR_CR_DBP) == RESET)
00038a  e005              B        |L14.920|
                  |L14.908|
;;;450        {
;;;451          if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
00038c  f7fffffe          BL       HAL_GetTick
000390  eba0000a          SUB      r0,r0,r10
000394  2864              CMP      r0,#0x64
000396  d86e              BHI      |L14.1142|
                  |L14.920|
000398  f8db0000          LDR      r0,[r11,#0]           ;449
00039c  05c0              LSLS     r0,r0,#23             ;449
00039e  d5f5              BPL      |L14.908|
;;;452          {
;;;453            return HAL_TIMEOUT;
;;;454          }      
;;;455        }
;;;456        
;;;457        /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
;;;458        __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
0003a0  6a30              LDR      r0,[r6,#0x20]
0003a2  f0200001          BIC      r0,r0,#1
0003a6  6230              STR      r0,[r6,#0x20]
0003a8  6a30              LDR      r0,[r6,#0x20]
0003aa  f0200004          BIC      r0,r0,#4
0003ae  6230              STR      r0,[r6,#0x20]
;;;459        
;;;460        /* Get Start Tick */
;;;461        tickstart = HAL_GetTick();
0003b0  f7fffffe          BL       HAL_GetTick
0003b4  4683              MOV      r11,r0
;;;462        
;;;463        /* Wait till LSE is disabled */  
;;;464        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
;;;465        {
;;;466          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0003b6  f2413a88          MOV      r10,#0x1388
0003ba  e005              B        |L14.968|
                  |L14.956|
0003bc  f7fffffe          BL       HAL_GetTick
0003c0  eba0010b          SUB      r1,r0,r11
0003c4  4551              CMP      r1,r10
0003c6  d856              BHI      |L14.1142|
                  |L14.968|
0003c8  fa97f0a7          RBIT     r0,r7                 ;464
0003cc  fab0f080          CLZ      r0,r0                 ;464
0003d0  f0400040          ORR      r0,r0,#0x40           ;464
0003d4  ebb41f50          CMP      r4,r0,LSR #5          ;464
0003d8  d101              BNE      |L14.990|
0003da  6830              LDR      r0,[r6,#0]            ;464
0003dc  e011              B        |L14.1026|
                  |L14.990|
0003de  fa97f0a7          RBIT     r0,r7                 ;464
0003e2  fab0f080          CLZ      r0,r0                 ;464
0003e6  f0400040          ORR      r0,r0,#0x40           ;464
0003ea  ebb71f50          CMP      r7,r0,LSR #5          ;464
0003ee  d107              BNE      |L14.1024|
0003f0  6a30              LDR      r0,[r6,#0x20]         ;464
0003f2  e006              B        |L14.1026|
                  |L14.1012|
                          DCD      0x40021000
                  |L14.1016|
                          DCD      0x42420000
                  |L14.1020|
                          DCD      0x40007000
                  |L14.1024|
000400  6a70              LDR      r0,[r6,#0x24]         ;464
                  |L14.1026|
000402  fa97f1a7          RBIT     r1,r7                 ;464
000406  fab1f181          CLZ      r1,r1                 ;464
00040a  f001011f          AND      r1,r1,#0x1f           ;464
00040e  fa04f101          LSL      r1,r4,r1              ;464
000412  4208              TST      r0,r1                 ;464
000414  d1d2              BNE      |L14.956|
;;;467          {
;;;468            return HAL_TIMEOUT;
;;;469          }
;;;470        }
;;;471        
;;;472        /* Set the new LSE configuration -----------------------------------------*/
;;;473        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
000416  68e8              LDR      r0,[r5,#0xc]
000418  2801              CMP      r0,#1
00041a  d00a              BEQ      |L14.1074|
00041c  b108              CBZ      r0,|L14.1058|
00041e  2805              CMP      r0,#5
000420  d012              BEQ      |L14.1096|
                  |L14.1058|
000422  6a30              LDR      r0,[r6,#0x20]
000424  f0200001          BIC      r0,r0,#1
000428  6230              STR      r0,[r6,#0x20]
00042a  6a30              LDR      r0,[r6,#0x20]
00042c  f0200004          BIC      r0,r0,#4
000430  e002              B        |L14.1080|
                  |L14.1074|
000432  6a30              LDR      r0,[r6,#0x20]
000434  f0400001          ORR      r0,r0,#1
                  |L14.1080|
000438  6230              STR      r0,[r6,#0x20]
;;;474        /* Check the LSE State */
;;;475        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
00043a  68e8              LDR      r0,[r5,#0xc]
00043c  b398              CBZ      r0,|L14.1190|
;;;476        {
;;;477          /* Get Start Tick */
;;;478          tickstart = HAL_GetTick();
00043e  f7fffffe          BL       HAL_GetTick
000442  4683              MOV      r11,r0
;;;479          
;;;480          /* Wait till LSE is ready */  
;;;481          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
000444  e00c              B        |L14.1120|
                  |L14.1094|
000446  e05a              B        |L14.1278|
                  |L14.1096|
000448  6a30              LDR      r0,[r6,#0x20]         ;473
00044a  f0400004          ORR      r0,r0,#4              ;473
00044e  6230              STR      r0,[r6,#0x20]         ;473
000450  e7ef              B        |L14.1074|
;;;482          {
;;;483            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000452  bf00              NOP      
                  |L14.1108|
000454  f7fffffe          BL       HAL_GetTick
000458  eba0010b          SUB      r1,r0,r11
00045c  4551              CMP      r1,r10
00045e  d80a              BHI      |L14.1142|
                  |L14.1120|
000460  fa97f0a7          RBIT     r0,r7                 ;481
000464  fab0f080          CLZ      r0,r0                 ;481
000468  f0400040          ORR      r0,r0,#0x40           ;481
00046c  ebb41f50          CMP      r4,r0,LSR #5          ;481
000470  d102              BNE      |L14.1144|
000472  6830              LDR      r0,[r6,#0]            ;481
000474  e00c              B        |L14.1168|
                  |L14.1142|
000476  e09d              B        |L14.1460|
                  |L14.1144|
000478  fa97f0a7          RBIT     r0,r7                 ;481
00047c  fab0f080          CLZ      r0,r0                 ;481
000480  f0400040          ORR      r0,r0,#0x40           ;481
000484  ebb71f50          CMP      r7,r0,LSR #5          ;481
000488  d101              BNE      |L14.1166|
00048a  6a30              LDR      r0,[r6,#0x20]         ;481
00048c  e000              B        |L14.1168|
                  |L14.1166|
00048e  6a70              LDR      r0,[r6,#0x24]         ;481
                  |L14.1168|
000490  fa97f1a7          RBIT     r1,r7                 ;481
000494  fab1f181          CLZ      r1,r1                 ;481
000498  f001021f          AND      r2,r1,#0x1f           ;481
00049c  fa04f102          LSL      r1,r4,r2              ;481
0004a0  4208              TST      r0,r1                 ;481
0004a2  d0d7              BEQ      |L14.1108|
0004a4  e02b              B        |L14.1278|
                  |L14.1190|
0004a6  e7ff              B        |L14.1192|
                  |L14.1192|
;;;484            {
;;;485              return HAL_TIMEOUT;
;;;486            }
;;;487          }
;;;488        }
;;;489        else
;;;490        {
;;;491          /* Get Start Tick */
;;;492          tickstart = HAL_GetTick();
0004a8  f7fffffe          BL       HAL_GetTick
0004ac  4683              MOV      r11,r0
;;;493          
;;;494          /* Wait till LSE is disabled */  
;;;495          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0004ae  e005              B        |L14.1212|
                  |L14.1200|
;;;496          {
;;;497            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0004b0  f7fffffe          BL       HAL_GetTick
0004b4  eba0010b          SUB      r1,r0,r11
0004b8  4551              CMP      r1,r10
0004ba  d87b              BHI      |L14.1460|
                  |L14.1212|
0004bc  fa97f0a7          RBIT     r0,r7                 ;495
0004c0  fab0f080          CLZ      r0,r0                 ;495
0004c4  f0400040          ORR      r0,r0,#0x40           ;495
0004c8  ebb41f50          CMP      r4,r0,LSR #5          ;495
0004cc  d101              BNE      |L14.1234|
0004ce  6830              LDR      r0,[r6,#0]            ;495
0004d0  e00b              B        |L14.1258|
                  |L14.1234|
0004d2  fa97f0a7          RBIT     r0,r7                 ;495
0004d6  fab0f080          CLZ      r0,r0                 ;495
0004da  f0400040          ORR      r0,r0,#0x40           ;495
0004de  ebb71f50          CMP      r7,r0,LSR #5          ;495
0004e2  d101              BNE      |L14.1256|
0004e4  6a30              LDR      r0,[r6,#0x20]         ;495
0004e6  e000              B        |L14.1258|
                  |L14.1256|
0004e8  6a70              LDR      r0,[r6,#0x24]         ;495
                  |L14.1258|
0004ea  fa97f1a7          RBIT     r1,r7                 ;495
0004ee  fab1f181          CLZ      r1,r1                 ;495
0004f2  f001021f          AND      r2,r1,#0x1f           ;495
0004f6  fa04f102          LSL      r1,r4,r2              ;495
0004fa  4208              TST      r0,r1                 ;495
0004fc  d1d8              BNE      |L14.1200|
                  |L14.1278|
;;;498            {
;;;499              return HAL_TIMEOUT;
;;;500            }
;;;501          }
;;;502        }
;;;503      }
;;;504    
;;;505    #if defined(RCC_CR_PLL2ON)
;;;506      /*-------------------------------- PLL2 Configuration -----------------------*/
;;;507      /* Check the parameters */
;;;508      assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
;;;509      if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
;;;510      {
;;;511        /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
;;;512          clock (i.e. it is used as PLL clock entry that is used as system clock). */
;;;513        if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
;;;514            (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
;;;515            ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
;;;516        {
;;;517          return HAL_ERROR;
;;;518        }
;;;519        else
;;;520        {
;;;521          if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
;;;522          {
;;;523            /* Check the parameters */
;;;524            assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
;;;525            assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
;;;526    
;;;527            /* Prediv2 can be written only when the PLLI2S is disabled. */
;;;528            /* Return an error only if new value is different from the programmed value */
;;;529            if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
;;;530              (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
;;;531            {
;;;532              return HAL_ERROR;
;;;533            }
;;;534            
;;;535            /* Disable the main PLL2. */
;;;536            __HAL_RCC_PLL2_DISABLE();
;;;537            
;;;538            /* Get Start Tick */
;;;539            tickstart = HAL_GetTick();
;;;540            
;;;541            /* Wait till PLL2 is disabled */
;;;542            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
;;;543            {
;;;544              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;545              {
;;;546                return HAL_TIMEOUT;
;;;547              }
;;;548            }
;;;549            
;;;550            /* Configure the HSE prediv2 factor --------------------------------*/
;;;551            __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
;;;552    
;;;553            /* Configure the main PLL2 multiplication factors. */
;;;554            __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
;;;555            
;;;556            /* Enable the main PLL2. */
;;;557            __HAL_RCC_PLL2_ENABLE();
;;;558            
;;;559            /* Get Start Tick */
;;;560            tickstart = HAL_GetTick();
;;;561            
;;;562            /* Wait till PLL2 is ready */
;;;563            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
;;;564            {
;;;565              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;566              {
;;;567                return HAL_TIMEOUT;
;;;568              }
;;;569            }
;;;570          }
;;;571          else
;;;572          {
;;;573           /* Set PREDIV1 source to HSE */
;;;574            CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
;;;575    
;;;576            /* Disable the main PLL2. */
;;;577            __HAL_RCC_PLL2_DISABLE();
;;;578     
;;;579            /* Get Start Tick */
;;;580            tickstart = HAL_GetTick();
;;;581            
;;;582            /* Wait till PLL2 is disabled */  
;;;583            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
;;;584            {
;;;585              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;586              {
;;;587                return HAL_TIMEOUT;
;;;588              }
;;;589            }
;;;590          }
;;;591        }
;;;592      }
;;;593    
;;;594    #endif /* RCC_CR_PLL2ON */
;;;595      /*-------------------------------- PLL Configuration -----------------------*/
;;;596      /* Check the parameters */
;;;597      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;598      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
0004fe  69e8              LDR      r0,[r5,#0x1c]
000500  b380              CBZ      r0,|L14.1380|
;;;599      {
;;;600        /* Check if the PLL is used as system clock or not */
;;;601        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
000502  6871              LDR      r1,[r6,#4]
000504  f3c10181          UBFX     r1,r1,#2,#2
000508  2902              CMP      r1,#2
00050a  d070              BEQ      |L14.1518|
;;;602        { 
;;;603          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
;;;604          {
;;;605            /* Check the parameters */
;;;606            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;607            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;608      
;;;609            /* Disable the main PLL. */
;;;610            __HAL_RCC_PLL_DISABLE();
00050c  f04f7180          MOV      r1,#0x1000000
;;;611            
;;;612            /* Get Start Tick */
;;;613            tickstart = HAL_GetTick();
;;;614            
;;;615            /* Wait till PLL is disabled */
;;;616            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
000510  004f              LSLS     r7,r1,#1
000512  2802              CMP      r0,#2                 ;603
;;;617            {
;;;618              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;619              {
;;;620                return HAL_TIMEOUT;
;;;621              }
;;;622            }
;;;623    
;;;624            /* Configure the HSE prediv factor --------------------------------*/
;;;625            /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
;;;626            if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
;;;627            {
;;;628              /* Check the parameter */
;;;629              assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
;;;630    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;631              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
;;;632              
;;;633              /* Set PREDIV1 source */
;;;634              SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
;;;635    #endif /* RCC_CFGR2_PREDIV1SRC */
;;;636    
;;;637              /* Set PREDIV1 Value */
;;;638              __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
;;;639            }
;;;640    
;;;641            /* Configure the main PLL clock source and multiplication factors. */
;;;642            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;643                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;644            /* Enable the main PLL. */
;;;645            __HAL_RCC_PLL_ENABLE();
;;;646            
;;;647            /* Get Start Tick */
;;;648            tickstart = HAL_GetTick();
;;;649            
;;;650            /* Wait till PLL is ready */
;;;651            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;652            {
;;;653              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;654              {
;;;655                return HAL_TIMEOUT;
;;;656              }
;;;657            }
;;;658          }
;;;659          else
;;;660          {
;;;661            /* Disable the main PLL. */
;;;662            __HAL_RCC_PLL_DISABLE();
000514  4648              MOV      r0,r9
000516  d009              BEQ      |L14.1324|
000518  fa91f1a1          RBIT     r1,r1
00051c  fab1f181          CLZ      r1,r1
000520  f8480021          STR      r0,[r8,r1,LSL #2]
;;;663     
;;;664            /* Get Start Tick */
;;;665            tickstart = HAL_GetTick();
000524  f7fffffe          BL       HAL_GetTick
000528  4605              MOV      r5,r0
;;;666            
;;;667            /* Wait till PLL is disabled */  
;;;668            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
00052a  e069              B        |L14.1536|
                  |L14.1324|
00052c  4689              MOV      r9,r1                 ;610
00052e  fa91f1a1          RBIT     r1,r1                 ;610
000532  fab1f181          CLZ      r1,r1                 ;610
000536  46c2              MOV      r10,r8                ;610
000538  f8480021          STR      r0,[r8,r1,LSL #2]     ;610
00053c  f7fffffe          BL       HAL_GetTick
000540  4680              MOV      r8,r0                 ;613
000542  e005              B        |L14.1360|
                  |L14.1348|
000544  f7fffffe          BL       HAL_GetTick
000548  eba00008          SUB      r0,r0,r8              ;618
00054c  2802              CMP      r0,#2                 ;618
00054e  d854              BHI      |L14.1530|
                  |L14.1360|
000550  fa97f0a7          RBIT     r0,r7                 ;616
000554  fab0f080          CLZ      r0,r0                 ;616
000558  f0400020          ORR      r0,r0,#0x20           ;616
00055c  0940              LSRS     r0,r0,#5              ;616
00055e  d002              BEQ      |L14.1382|
000560  6830              LDR      r0,[r6,#0]            ;616
000562  e001              B        |L14.1384|
                  |L14.1380|
000564  e061              B        |L14.1578|
                  |L14.1382|
000566  6a70              LDR      r0,[r6,#0x24]         ;616
                  |L14.1384|
000568  fa97f1a7          RBIT     r1,r7                 ;616
00056c  fab1f181          CLZ      r1,r1                 ;616
000570  f001011f          AND      r1,r1,#0x1f           ;616
000574  fa04f101          LSL      r1,r4,r1              ;616
000578  4208              TST      r0,r1                 ;616
00057a  d1e3              BNE      |L14.1348|
00057c  6a28              LDR      r0,[r5,#0x20]         ;626
00057e  f5b03f80          CMP      r0,#0x10000           ;626
000582  d105              BNE      |L14.1424|
000584  6870              LDR      r0,[r6,#4]            ;638
000586  68a9              LDR      r1,[r5,#8]            ;638
000588  f4203000          BIC      r0,r0,#0x20000        ;638
00058c  4308              ORRS     r0,r0,r1              ;638
00058e  6070              STR      r0,[r6,#4]            ;638
                  |L14.1424|
000590  e9d50108          LDRD     r0,r1,[r5,#0x20]      ;638
000594  4308              ORRS     r0,r0,r1              ;642
000596  6871              LDR      r1,[r6,#4]            ;642
000598  f4211174          BIC      r1,r1,#0x3d0000       ;642
00059c  4308              ORRS     r0,r0,r1              ;642
00059e  6070              STR      r0,[r6,#4]            ;642
0005a0  fa99f0a9          RBIT     r0,r9                 ;645
0005a4  fab0f080          CLZ      r0,r0                 ;645
0005a8  f84a4020          STR      r4,[r10,r0,LSL #2]    ;645
0005ac  f7fffffe          BL       HAL_GetTick
0005b0  4605              MOV      r5,r0                 ;648
0005b2  e006              B        |L14.1474|
                  |L14.1460|
0005b4  e021              B        |L14.1530|
0005b6  bf00              NOP                            ;653
                  |L14.1464|
0005b8  f7fffffe          BL       HAL_GetTick
0005bc  1b40              SUBS     r0,r0,r5              ;653
0005be  2802              CMP      r0,#2                 ;653
0005c0  d81b              BHI      |L14.1530|
                  |L14.1474|
0005c2  fa97f0a7          RBIT     r0,r7                 ;651
0005c6  fab0f080          CLZ      r0,r0                 ;651
0005ca  f0400020          ORR      r0,r0,#0x20           ;651
0005ce  0940              LSRS     r0,r0,#5              ;651
0005d0  d001              BEQ      |L14.1494|
0005d2  6830              LDR      r0,[r6,#0]            ;651
0005d4  e000              B        |L14.1496|
                  |L14.1494|
0005d6  6a70              LDR      r0,[r6,#0x24]         ;651
                  |L14.1496|
0005d8  fa97f1a7          RBIT     r1,r7                 ;651
0005dc  fab1f181          CLZ      r1,r1                 ;651
0005e0  f001011f          AND      r1,r1,#0x1f           ;651
0005e4  fa04f101          LSL      r1,r4,r1              ;651
0005e8  4208              TST      r0,r1                 ;651
0005ea  d0e5              BEQ      |L14.1464|
0005ec  e01d              B        |L14.1578|
                  |L14.1518|
0005ee  e01e              B        |L14.1582|
                  |L14.1520|
;;;669            {
;;;670              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
0005f0  f7fffffe          BL       HAL_GetTick
0005f4  1b40              SUBS     r0,r0,r5
0005f6  2802              CMP      r0,#2
0005f8  d902              BLS      |L14.1536|
                  |L14.1530|
;;;671              {
;;;672                return HAL_TIMEOUT;
0005fa  2003              MOVS     r0,#3
                  |L14.1532|
;;;673              }
;;;674            }
;;;675          }
;;;676        }
;;;677        else
;;;678        {
;;;679          return HAL_ERROR;
;;;680        }
;;;681      }
;;;682      
;;;683      return HAL_OK;
;;;684    }
0005fc  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.1536|
000600  fa97f0a7          RBIT     r0,r7                 ;668
000604  fab0f080          CLZ      r0,r0                 ;668
000608  f0400020          ORR      r0,r0,#0x20           ;668
00060c  0940              LSRS     r0,r0,#5              ;668
00060e  d001              BEQ      |L14.1556|
000610  6830              LDR      r0,[r6,#0]            ;668
000612  e000              B        |L14.1558|
                  |L14.1556|
000614  6a70              LDR      r0,[r6,#0x24]         ;668
                  |L14.1558|
000616  fa97f1a7          RBIT     r1,r7                 ;668
00061a  fab1f181          CLZ      r1,r1                 ;668
00061e  f001011f          AND      r1,r1,#0x1f           ;668
000622  fa04f101          LSL      r1,r4,r1              ;668
000626  4208              TST      r0,r1                 ;668
000628  d1e2              BNE      |L14.1520|
                  |L14.1578|
00062a  2000              MOVS     r0,#0                 ;683
00062c  e7e6              B        |L14.1532|
                  |L14.1582|
00062e  2001              MOVS     r0,#1                 ;679
000630  e7e4              B        |L14.1532|
;;;685    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aAPBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_16c4d722____REV16|
#line 463 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rcc_c_16c4d722____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_16c4d722____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_rcc_c_16c4d722____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_16c4d722____RRX|
#line 665
|__asm___19_stm32f1xx_hal_rcc_c_16c4d722____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
