; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-160318\stm32f1xx_hal_iwdg.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-160318\stm32f1xx_hal_iwdg.d --feedback=.\DE-160318\DE-160318.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I.\RTE\_DE-160318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-160318\stm32f1xx_hal_iwdg.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_iwdg.c]
                          THUMB

                          AREA ||i.HAL_IWDG_GetState||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_GetState PROC
;;;337      */
;;;338    HAL_IWDG_StateTypeDef HAL_IWDG_GetState(IWDG_HandleTypeDef *hiwdg)
000000  7b40              LDRB     r0,[r0,#0xd]
;;;339    {
;;;340      return hiwdg->State;
;;;341    }
000002  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.HAL_IWDG_Init||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_Init PROC
;;;156      */
;;;157    HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
000000  b510              PUSH     {r4,lr}
;;;158    {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L2.24|
;;;159      /* Check the IWDG handle allocation */
;;;160      if(hiwdg == NULL)
;;;161      {
;;;162        return HAL_ERROR;
;;;163      }
;;;164    
;;;165      /* Check the parameters */
;;;166      assert_param(IS_IWDG_ALL_INSTANCE(hiwdg->Instance));
;;;167      assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
;;;168      assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload)); 
;;;169      
;;;170      /* Check pending flag, if previous update not done, return error */
;;;171      if((__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_PVU) != RESET)
000006  6820              LDR      r0,[r4,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  43c9              MVNS     r1,r1
00000c  07c9              LSLS     r1,r1,#31
00000e  d105              BNE      |L2.28|
;;;172         &&(__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_RVU) != RESET))
000010  68c0              LDR      r0,[r0,#0xc]
000012  43c0              MVNS     r0,r0
000014  0780              LSLS     r0,r0,#30
000016  d401              BMI      |L2.28|
                  |L2.24|
;;;173      {
;;;174        return HAL_ERROR;
000018  2001              MOVS     r0,#1
;;;175      }
;;;176        
;;;177      if(hiwdg->State == HAL_IWDG_STATE_RESET)
;;;178      {  
;;;179        /* Allocate lock resource and initialize it */
;;;180        hiwdg->Lock = HAL_UNLOCKED;
;;;181        
;;;182        /* Init the low level hardware */
;;;183        HAL_IWDG_MspInit(hiwdg);
;;;184      }
;;;185      
;;;186      /* Change IWDG peripheral state */
;;;187      hiwdg->State = HAL_IWDG_STATE_BUSY;  
;;;188      
;;;189      /* Enable write access to IWDG_PR and IWDG_RLR registers */  
;;;190      IWDG_ENABLE_WRITE_ACCESS(hiwdg);
;;;191      
;;;192      /* Write to IWDG registers the IWDG_Prescaler & IWDG_Reload values to work with */
;;;193      MODIFY_REG(hiwdg->Instance->PR, IWDG_PR_PR, hiwdg->Init.Prescaler);
;;;194      MODIFY_REG(hiwdg->Instance->RLR, IWDG_RLR_RL, hiwdg->Init.Reload);
;;;195     
;;;196      /* Change IWDG peripheral state */
;;;197      hiwdg->State = HAL_IWDG_STATE_READY;
;;;198      
;;;199      /* Return function status */
;;;200      return HAL_OK;
;;;201    }
00001a  bd10              POP      {r4,pc}
                  |L2.28|
00001c  7b60              LDRB     r0,[r4,#0xd]          ;177
00001e  b920              CBNZ     r0,|L2.42|
000020  2000              MOVS     r0,#0                 ;180
000022  7320              STRB     r0,[r4,#0xc]          ;180
000024  4620              MOV      r0,r4                 ;183
000026  f7fffffe          BL       HAL_IWDG_MspInit
                  |L2.42|
00002a  2002              MOVS     r0,#2                 ;187
00002c  7360              STRB     r0,[r4,#0xd]          ;187
00002e  6821              LDR      r1,[r4,#0]            ;190
000030  f2455055          MOV      r0,#0x5555            ;190
000034  6008              STR      r0,[r1,#0]            ;190
000036  6820              LDR      r0,[r4,#0]            ;193
000038  6841              LDR      r1,[r0,#4]            ;193
00003a  6862              LDR      r2,[r4,#4]            ;193
00003c  f0210107          BIC      r1,r1,#7              ;193
000040  4311              ORRS     r1,r1,r2              ;193
000042  6041              STR      r1,[r0,#4]            ;193
000044  6820              LDR      r0,[r4,#0]            ;194
000046  6881              LDR      r1,[r0,#8]            ;194
000048  68a2              LDR      r2,[r4,#8]            ;194
00004a  f36f010b          BFC      r1,#0,#12             ;194
00004e  4311              ORRS     r1,r1,r2              ;194
000050  6081              STR      r1,[r0,#8]            ;194
000052  2001              MOVS     r0,#1                 ;197
000054  7360              STRB     r0,[r4,#0xd]          ;197
000056  2000              MOVS     r0,#0                 ;200
000058  bd10              POP      {r4,pc}
;;;202    
                          ENDP


                          AREA ||i.HAL_IWDG_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_MspInit PROC
;;;208      */
;;;209    __WEAK void HAL_IWDG_MspInit(IWDG_HandleTypeDef *hiwdg)
000000  4770              BX       lr
;;;210    {
;;;211      /* Prevent unused argument(s) compilation warning */
;;;212      UNUSED(hiwdg);
;;;213      /* NOTE : This function Should not be modified, when the callback is needed,
;;;214                the HAL_IWDG_MspInit could be implemented in the user file
;;;215       */
;;;216    }
;;;217    
                          ENDP


                          AREA ||i.HAL_IWDG_Refresh||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_Refresh PROC
;;;272      */
;;;273    HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;274    {
000004  4604              MOV      r4,r0
;;;275      uint32_t tickstart = 0;
;;;276    
;;;277      /* Process Locked */
;;;278      __HAL_LOCK(hiwdg);
000006  7b00              LDRB     r0,[r0,#0xc]
000008  2801              CMP      r0,#1
00000a  d00a              BEQ      |L4.34|
00000c  2601              MOVS     r6,#1
00000e  7326              STRB     r6,[r4,#0xc]
;;;279    
;;;280        /* Change IWDG peripheral state */
;;;281      hiwdg->State = HAL_IWDG_STATE_BUSY;
000010  2002              MOVS     r0,#2
000012  7360              STRB     r0,[r4,#0xd]
;;;282    
;;;283      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  4605              MOV      r5,r0
00001a  2700              MOVS     r7,#0
;;;284    
;;;285      /* Wait until RVU flag is RESET */
;;;286      while(__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_RVU) != RESET)
;;;287      {
;;;288        if((HAL_GetTick() - tickstart ) > IWDG_DEFAULT_TIMEOUT)
00001c  f44f787a          MOV      r8,#0x3e8
000020  e00b              B        |L4.58|
                  |L4.34|
000022  2002              MOVS     r0,#2                 ;278
                  |L4.36|
;;;289        {
;;;290          /* Set IWDG state */
;;;291          hiwdg->State = HAL_IWDG_STATE_TIMEOUT;
;;;292    
;;;293           /* Process unlocked */
;;;294          __HAL_UNLOCK(hiwdg);
;;;295    
;;;296          return HAL_TIMEOUT;
;;;297        }
;;;298      }
;;;299      
;;;300      /* Reload IWDG counter with value defined in the reload register */
;;;301      __HAL_IWDG_RELOAD_COUNTER(hiwdg);
;;;302        
;;;303      /* Change IWDG peripheral state */    
;;;304      hiwdg->State = HAL_IWDG_STATE_READY; 
;;;305      
;;;306      /* Process Unlocked */
;;;307      __HAL_UNLOCK(hiwdg);
;;;308      
;;;309      /* Return function status */
;;;310      return HAL_OK;
;;;311    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L4.40|
000028  f7fffffe          BL       HAL_GetTick
00002c  1b40              SUBS     r0,r0,r5              ;288
00002e  4540              CMP      r0,r8                 ;288
000030  d903              BLS      |L4.58|
000032  2003              MOVS     r0,#3                 ;291
000034  7360              STRB     r0,[r4,#0xd]          ;291
000036  7327              STRB     r7,[r4,#0xc]          ;294
000038  e7f4              B        |L4.36|
                  |L4.58|
00003a  6820              LDR      r0,[r4,#0]            ;286
00003c  68c0              LDR      r0,[r0,#0xc]          ;286
00003e  43c0              MVNS     r0,r0                 ;286
000040  0780              LSLS     r0,r0,#30             ;286
000042  d5f1              BPL      |L4.40|
000044  6821              LDR      r1,[r4,#0]            ;301
000046  f64a20aa          MOV      r0,#0xaaaa            ;301
00004a  6008              STR      r0,[r1,#0]            ;301
00004c  7366              STRB     r6,[r4,#0xd]          ;304
00004e  7327              STRB     r7,[r4,#0xc]          ;307
000050  2000              MOVS     r0,#0                 ;310
000052  e7e7              B        |L4.36|
;;;312    
                          ENDP


                          AREA ||i.HAL_IWDG_Start||, CODE, READONLY, ALIGN=1

                  HAL_IWDG_Start PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_IWDG_Start(IWDG_HandleTypeDef *hiwdg)
000000  7b01              LDRB     r1,[r0,#0xc]
;;;244    {
;;;245      /* Process Locked */
;;;246      __HAL_LOCK(hiwdg); 
000002  2901              CMP      r1,#1
000004  d00f              BEQ      |L5.38|
000006  2101              MOVS     r1,#1
;;;247      
;;;248        /* Change IWDG peripheral state */  
;;;249      hiwdg->State = HAL_IWDG_STATE_BUSY;
000008  2202              MOVS     r2,#2
00000a  7342              STRB     r2,[r0,#0xd]
;;;250    
;;;251      /* Start the IWDG peripheral */
;;;252      __HAL_IWDG_START(hiwdg);
00000c  6803              LDR      r3,[r0,#0]
00000e  f64c42cc          MOV      r2,#0xcccc
000012  601a              STR      r2,[r3,#0]
;;;253      
;;;254        /* Reload IWDG counter with value defined in the RLR register */
;;;255      __HAL_IWDG_RELOAD_COUNTER(hiwdg);
000014  6803              LDR      r3,[r0,#0]
000016  f64a22aa          MOV      r2,#0xaaaa
00001a  601a              STR      r2,[r3,#0]
;;;256      
;;;257      /* Change IWDG peripheral state */    
;;;258      hiwdg->State = HAL_IWDG_STATE_READY; 
00001c  7341              STRB     r1,[r0,#0xd]
;;;259      
;;;260      /* Process Unlocked */
;;;261      __HAL_UNLOCK(hiwdg);
00001e  2100              MOVS     r1,#0
000020  7301              STRB     r1,[r0,#0xc]
;;;262      
;;;263      /* Return function status */
;;;264      return HAL_OK;
000022  4608              MOV      r0,r1
;;;265    }
000024  4770              BX       lr
                  |L5.38|
000026  2002              MOVS     r0,#2                 ;246
000028  4770              BX       lr
;;;266    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_iwdg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REV16|
#line 463 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REVSH|
#line 478
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____RRX|
#line 665
|__asm___20_stm32f1xx_hal_iwdg_c_a5fb4147____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
