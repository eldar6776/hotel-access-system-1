; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\de-160318\stm32f1xx_hal_i2c.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\de-160318\stm32f1xx_hal_i2c.d --feedback=.\DE-160318\DE-160318.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I.\RTE\_DE-160318 -IC:\Keil\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=.\de-160318\stm32f1xx_hal_i2c.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;401    {
000002  0004              MOVS     r4,r0
000004  d013              BEQ      |L1.46|
;;;402      /* Check the I2C handle allocation */
;;;403      if(hi2c == NULL)
;;;404      {
;;;405        return HAL_ERROR;
;;;406      }
;;;407    
;;;408      /* Check the parameters */
;;;409      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;410    
;;;411      hi2c->State = HAL_I2C_STATE_BUSY;
000006  2024              MOVS     r0,#0x24
000008  f8840035          STRB     r0,[r4,#0x35]
;;;412    
;;;413      /* Disable the I2C Peripheral Clock */
;;;414      __HAL_I2C_DISABLE(hi2c);
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0210101          BIC      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;415    
;;;416      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;417      HAL_I2C_MspDeInit(hi2c);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_I2C_MspDeInit
;;;418    
;;;419      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
00001c  2000              MOVS     r0,#0
00001e  63a0              STR      r0,[r4,#0x38]
;;;420      hi2c->State = HAL_I2C_STATE_RESET;
000020  f8840035          STRB     r0,[r4,#0x35]
;;;421      hi2c->Mode = HAL_I2C_MODE_NONE;
000024  f8840036          STRB     r0,[r4,#0x36]
;;;422    
;;;423      /* Release Lock */
;;;424      __HAL_UNLOCK(hi2c);
000028  f8840034          STRB     r0,[r4,#0x34]
;;;425    
;;;426      return HAL_OK;
;;;427    }
00002c  bd10              POP      {r4,pc}
                  |L1.46|
00002e  2001              MOVS     r0,#1                 ;405
000030  bd10              POP      {r4,pc}
;;;428    
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;2681     */
;;;2682   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;2683   {
000002  4604              MOV      r4,r0
;;;2684     uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
;;;2685   
;;;2686     tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f3c12200          UBFX     r2,r1,#8,#1
;;;2687     tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
00000c  6841              LDR      r1,[r0,#4]
00000e  f3c12100          UBFX     r1,r1,#8,#1
000012  b16a              CBZ      r2,|L2.48|
;;;2688     /* I2C Bus error interrupt occurred ----------------------------------------*/
;;;2689     if((tmp1 == SET) && (tmp2 == SET))
000014  b161              CBZ      r1,|L2.48|
;;;2690     {
;;;2691       hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
000016  6ba1              LDR      r1,[r4,#0x38]
000018  f0410101          ORR      r1,r1,#1
00001c  63a1              STR      r1,[r4,#0x38]
;;;2692   
;;;2693       /* Clear BERR flag */
;;;2694       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
00001e  6941              LDR      r1,[r0,#0x14]
000020  f4217180          BIC      r1,r1,#0x100
000024  6141              STR      r1,[r0,#0x14]
;;;2695       
;;;2696       /* Workaround: Start cannot be generated after a misplaced Stop */
;;;2697       SET_BIT(hi2c->Instance->CR1, I2C_CR1_SWRST);
000026  6820              LDR      r0,[r4,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  f4414100          ORR      r1,r1,#0x8000
00002e  6001              STR      r1,[r0,#0]
                  |L2.48|
;;;2698     }
;;;2699   
;;;2700     tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO);
000030  6820              LDR      r0,[r4,#0]
000032  6941              LDR      r1,[r0,#0x14]
;;;2701     tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
000034  6842              LDR      r2,[r0,#4]
000036  f3c12140          UBFX     r1,r1,#9,#1           ;2700
00003a  f3c22200          UBFX     r2,r2,#8,#1
;;;2702     /* I2C Arbitration Loss error interrupt occurred ---------------------------*/
;;;2703     if((tmp1 == SET) && (tmp2 == SET))
00003e  b141              CBZ      r1,|L2.82|
000040  b13a              CBZ      r2,|L2.82|
;;;2704     {
;;;2705       hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
000042  6ba1              LDR      r1,[r4,#0x38]
000044  f0410102          ORR      r1,r1,#2
000048  63a1              STR      r1,[r4,#0x38]
;;;2706   
;;;2707       /* Clear ARLO flag */
;;;2708       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
00004a  6941              LDR      r1,[r0,#0x14]
00004c  f4217100          BIC      r1,r1,#0x200
000050  6141              STR      r1,[r0,#0x14]
                  |L2.82|
;;;2709     }
;;;2710   
;;;2711     tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
000052  6821              LDR      r1,[r4,#0]
000054  6948              LDR      r0,[r1,#0x14]
;;;2712     tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
000056  684a              LDR      r2,[r1,#4]
000058  f3c02080          UBFX     r0,r0,#10,#1          ;2711
00005c  f3c22200          UBFX     r2,r2,#8,#1
000060  2520              MOVS     r5,#0x20              ;2684
;;;2713     /* I2C Acknowledge failure error interrupt occurred ------------------------*/
;;;2714     if((tmp1 == SET) && (tmp2 == SET))
000062  b1b8              CBZ      r0,|L2.148|
000064  b1b2              CBZ      r2,|L2.148|
;;;2715     {
;;;2716       tmp1 = hi2c->Mode;
000066  f8942036          LDRB     r2,[r4,#0x36]
;;;2717       tmp2 = hi2c->XferCount;
00006a  8d63              LDRH     r3,[r4,#0x2a]
;;;2718       tmp3 = hi2c->State;
00006c  f8940035          LDRB     r0,[r4,#0x35]
;;;2719       if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0) && \
000070  2a20              CMP      r2,#0x20
000072  d102              BNE      |L2.122|
000074  b90b              CBNZ     r3,|L2.122|
;;;2720          (tmp3 == HAL_I2C_STATE_BUSY_TX))
000076  2821              CMP      r0,#0x21
000078  d02b              BEQ      |L2.210|
                  |L2.122|
;;;2721       {
;;;2722         I2C_Slave_AF(hi2c);
;;;2723       }
;;;2724       else
;;;2725       {
;;;2726         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  f0400004          ORR      r0,r0,#4
000080  63a0              STR      r0,[r4,#0x38]
;;;2727     
;;;2728         /* Generate Stop */
;;;2729         SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
000082  6808              LDR      r0,[r1,#0]
000084  f4407000          ORR      r0,r0,#0x200
000088  6008              STR      r0,[r1,#0]
;;;2730     
;;;2731         /* Clear AF flag */
;;;2732         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00008a  6820              LDR      r0,[r4,#0]
00008c  6941              LDR      r1,[r0,#0x14]
00008e  f4216180          BIC      r1,r1,#0x400
000092  6141              STR      r1,[r0,#0x14]
                  |L2.148|
;;;2733       }
;;;2734     }
;;;2735   
;;;2736     tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR);
000094  6820              LDR      r0,[r4,#0]
000096  6941              LDR      r1,[r0,#0x14]
;;;2737     tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
000098  6842              LDR      r2,[r0,#4]
00009a  f3c121c0          UBFX     r1,r1,#11,#1          ;2736
00009e  f3c22200          UBFX     r2,r2,#8,#1
;;;2738     /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
;;;2739     if((tmp1 == SET) && (tmp2 == SET))
0000a2  b141              CBZ      r1,|L2.182|
0000a4  b13a              CBZ      r2,|L2.182|
;;;2740     {
;;;2741       hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
0000a6  6ba1              LDR      r1,[r4,#0x38]
0000a8  f0410108          ORR      r1,r1,#8
0000ac  63a1              STR      r1,[r4,#0x38]
;;;2742       /* Clear OVR flag */
;;;2743       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
0000ae  6941              LDR      r1,[r0,#0x14]
0000b0  f4216100          BIC      r1,r1,#0x800
0000b4  6141              STR      r1,[r0,#0x14]
                  |L2.182|
;;;2744     }
;;;2745   
;;;2746     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000b6  6ba0              LDR      r0,[r4,#0x38]
0000b8  2800              CMP      r0,#0
0000ba  d009              BEQ      |L2.208|
;;;2747     {
;;;2748       hi2c->State = HAL_I2C_STATE_READY;
0000bc  f8845035          STRB     r5,[r4,#0x35]
;;;2749       
;;;2750       /* Disable Pos bit in I2C CR1 when error occured in Master/Mem Receive IT Process */
;;;2751       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6801              LDR      r1,[r0,#0]
0000c4  f4216100          BIC      r1,r1,#0x800
0000c8  6001              STR      r1,[r0,#0]
;;;2752       
;;;2753       HAL_I2C_ErrorCallback(hi2c);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L2.208|
;;;2754     }
;;;2755   }
0000d0  bd70              POP      {r4-r6,pc}
                  |L2.210|
0000d2  684a              LDR      r2,[r1,#4]
0000d4  4620              MOV      r0,r4                 ;2722
0000d6  f42262e0          BIC      r2,r2,#0x700          ;2722
0000da  604a              STR      r2,[r1,#4]            ;2722
0000dc  6821              LDR      r1,[r4,#0]            ;2722
0000de  694a              LDR      r2,[r1,#0x14]         ;2722
0000e0  f4226280          BIC      r2,r2,#0x400          ;2722
0000e4  614a              STR      r2,[r1,#0x14]         ;2722
0000e6  6821              LDR      r1,[r4,#0]            ;2722
0000e8  680a              LDR      r2,[r1,#0]            ;2722
0000ea  f4226280          BIC      r2,r2,#0x400          ;2722
0000ee  600a              STR      r2,[r1,#0]            ;2722
0000f0  f8845035          STRB     r5,[r4,#0x35]         ;2722
0000f4  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
0000f8  e7cc              B        |L2.148|
;;;2756   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;2575     */
;;;2576   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2577   {
;;;2578     uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0, tmp4 = 0;
;;;2579     /* Master or Memory mode selected */
;;;2580     if((hi2c->Mode == HAL_I2C_MODE_MASTER) || \
000002  f8903036          LDRB     r3,[r0,#0x36]
000006  2220              MOVS     r2,#0x20
000008  6801              LDR      r1,[r0,#0]
00000a  2b10              CMP      r3,#0x10
00000c  d017              BEQ      |L3.62|
;;;2581        (hi2c->Mode == HAL_I2C_MODE_MEM))
00000e  f8903036          LDRB     r3,[r0,#0x36]
000012  2b40              CMP      r3,#0x40
000014  d013              BEQ      |L3.62|
;;;2582     {
;;;2583       /* I2C in mode Transmitter -----------------------------------------------*/
;;;2584       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == SET)
;;;2585       {
;;;2586         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE);
;;;2587         tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
;;;2588         tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
;;;2589         tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
;;;2590         /* TXE set and BTF reset -----------------------------------------------*/
;;;2591         if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
;;;2592         {
;;;2593           I2C_MasterTransmit_TXE(hi2c);
;;;2594         }
;;;2595         /* BTF set -------------------------------------------------------------*/
;;;2596         else if((tmp3 == SET) && (tmp4 == SET))
;;;2597         {
;;;2598           I2C_MasterTransmit_BTF(hi2c);
;;;2599         }
;;;2600       }
;;;2601       /* I2C in mode Receiver --------------------------------------------------*/
;;;2602       else
;;;2603       {
;;;2604         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE);
;;;2605         tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
;;;2606         tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
;;;2607         tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
;;;2608         /* RXNE set and BTF reset -----------------------------------------------*/
;;;2609         if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
;;;2610         {
;;;2611           I2C_MasterReceive_RXNE(hi2c);
;;;2612         }
;;;2613         /* BTF set -------------------------------------------------------------*/
;;;2614         else if((tmp3 == SET) && (tmp4 == SET))
;;;2615         {
;;;2616           I2C_MasterReceive_BTF(hi2c);
;;;2617         }
;;;2618       }
;;;2619     }
;;;2620     /* Slave mode selected */
;;;2621     else
;;;2622     {
;;;2623       tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
000016  694b              LDR      r3,[r1,#0x14]
000018  f3c30440          UBFX     r4,r3,#1,#1
;;;2624       tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_EVT));
00001c  684b              LDR      r3,[r1,#4]
;;;2625       tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
00001e  694d              LDR      r5,[r1,#0x14]
000020  f3c32340          UBFX     r3,r3,#9,#1           ;2624
;;;2626       tmp4 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA);
000024  698e              LDR      r6,[r1,#0x18]
000026  f3c51500          UBFX     r5,r5,#4,#1           ;2625
00002a  f3c60680          UBFX     r6,r6,#2,#1
;;;2627       /* ADDR set --------------------------------------------------------------*/
;;;2628       if((tmp1 == SET) && (tmp2 == SET))
00002e  2c00              CMP      r4,#0
000030  d05d              BEQ      |L3.238|
000032  2b00              CMP      r3,#0
000034  d05b              BEQ      |L3.238|
000036  6948              LDR      r0,[r1,#0x14]
000038  6988              LDR      r0,[r1,#0x18]
;;;2629       {
;;;2630         I2C_Slave_ADDR(hi2c);
00003a  9000              STR      r0,[sp,#0]
                  |L3.60|
;;;2631       }
;;;2632       /* STOPF set --------------------------------------------------------------*/
;;;2633       else if((tmp3 == SET) && (tmp2 == SET))
;;;2634       {
;;;2635         I2C_Slave_STOPF(hi2c);
;;;2636       }
;;;2637       /* I2C in mode Transmitter -----------------------------------------------*/
;;;2638       else if(tmp4 == SET)
;;;2639       {
;;;2640         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE);
;;;2641         tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
;;;2642         tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
;;;2643         tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
;;;2644         /* TXE set and BTF reset -----------------------------------------------*/
;;;2645         if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
;;;2646         {
;;;2647           I2C_SlaveTransmit_TXE(hi2c);
;;;2648         }
;;;2649         /* BTF set -------------------------------------------------------------*/
;;;2650         else if((tmp3 == SET) && (tmp4 == SET))
;;;2651         {
;;;2652           I2C_SlaveTransmit_BTF(hi2c);
;;;2653         }
;;;2654       }
;;;2655       /* I2C in mode Receiver --------------------------------------------------*/
;;;2656       else
;;;2657       {
;;;2658         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE);
;;;2659         tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
;;;2660         tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
;;;2661         tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
;;;2662         /* RXNE set and BTF reset ----------------------------------------------*/
;;;2663         if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
;;;2664         {
;;;2665           I2C_SlaveReceive_RXNE(hi2c);
;;;2666         }
;;;2667         /* BTF set -------------------------------------------------------------*/
;;;2668         else if((tmp3 == SET) && (tmp4 == SET))
;;;2669         {
;;;2670           I2C_SlaveReceive_BTF(hi2c);
;;;2671         }
;;;2672       }
;;;2673     }
;;;2674   }
00003c  bdf8              POP      {r3-r7,pc}
                  |L3.62|
00003e  698b              LDR      r3,[r1,#0x18]         ;2584
000040  43db              MVNS     r3,r3                 ;2584
000042  075b              LSLS     r3,r3,#29             ;2584
000044  d438              BMI      |L3.184|
000046  694b              LDR      r3,[r1,#0x14]         ;2586
000048  f3c316c0          UBFX     r6,r3,#7,#1           ;2586
00004c  684b              LDR      r3,[r1,#4]            ;2587
00004e  f3c32480          UBFX     r4,r3,#10,#1          ;2587
000052  694b              LDR      r3,[r1,#0x14]         ;2588
000054  684d              LDR      r5,[r1,#4]            ;2589
000056  f3c30380          UBFX     r3,r3,#2,#1           ;2588
00005a  f3c52540          UBFX     r5,r5,#9,#1           ;2589
00005e  b10e              CBZ      r6,|L3.100|
000060  b104              CBZ      r4,|L3.100|
000062  b133              CBZ      r3,|L3.114|
                  |L3.100|
000064  2b00              CMP      r3,#0                 ;2596
000066  d0e9              BEQ      |L3.60|
000068  2d00              CMP      r5,#0                 ;2596
00006a  d0e7              BEQ      |L3.60|
00006c  8d43              LDRH     r3,[r0,#0x2a]         ;2596
00006e  b93b              CBNZ     r3,|L3.128|
000070  e00d              B        |L3.142|
                  |L3.114|
000072  8d42              LDRH     r2,[r0,#0x2a]         ;2596
000074  b922              CBNZ     r2,|L3.128|
000076  6848              LDR      r0,[r1,#4]            ;2596
000078  f4206080          BIC      r0,r0,#0x400          ;2596
00007c  6048              STR      r0,[r1,#4]            ;2596
00007e  bdf8              POP      {r3-r7,pc}
                  |L3.128|
000080  6a41              LDR      r1,[r0,#0x24]
000082  1c4a              ADDS     r2,r1,#1
000084  6242              STR      r2,[r0,#0x24]
000086  6802              LDR      r2,[r0,#0]
000088  7809              LDRB     r1,[r1,#0]
00008a  6111              STR      r1,[r2,#0x10]
00008c  e078              B        |L3.384|
                  |L3.142|
00008e  684b              LDR      r3,[r1,#4]
000090  f42363e0          BIC      r3,r3,#0x700
000094  604b              STR      r3,[r1,#4]
000096  6801              LDR      r1,[r0,#0]
000098  680b              LDR      r3,[r1,#0]
00009a  f4437300          ORR      r3,r3,#0x200
00009e  600b              STR      r3,[r1,#0]
0000a0  f8901036          LDRB     r1,[r0,#0x36]
0000a4  f8802035          STRB     r2,[r0,#0x35]
0000a8  2940              CMP      r1,#0x40
0000aa  d002              BEQ      |L3.178|
0000ac  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
0000b0  bdf8              POP      {r3-r7,pc}
                  |L3.178|
0000b2  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
                  |L3.182|
0000b6  bdf8              POP      {r3-r7,pc}
                  |L3.184|
0000b8  694a              LDR      r2,[r1,#0x14]         ;2604
0000ba  f3c21380          UBFX     r3,r2,#6,#1           ;2604
0000be  684a              LDR      r2,[r1,#4]            ;2605
0000c0  f3c22480          UBFX     r4,r2,#10,#1          ;2605
0000c4  694a              LDR      r2,[r1,#0x14]         ;2606
0000c6  6849              LDR      r1,[r1,#4]            ;2607
0000c8  f3c20280          UBFX     r2,r2,#2,#1           ;2606
0000cc  f3c12140          UBFX     r1,r1,#9,#1           ;2607
0000d0  b10b              CBZ      r3,|L3.214|
0000d2  b104              CBZ      r4,|L3.214|
0000d4  b13a              CBZ      r2,|L3.230|
                  |L3.214|
0000d6  2a00              CMP      r2,#0                 ;2614
0000d8  d0ed              BEQ      |L3.182|
0000da  2900              CMP      r1,#0                 ;2614
0000dc  d0eb              BEQ      |L3.182|
0000de  e8bd40f8          POP      {r3-r7,lr}            ;2616
0000e2  f7ffbffe          B.W      I2C_MasterReceive_BTF
                  |L3.230|
0000e6  e8bd40f8          POP      {r3-r7,lr}            ;2611
0000ea  f7ffbffe          B.W      I2C_MasterReceive_RXNE
                  |L3.238|
0000ee  b1ad              CBZ      r5,|L3.284|
0000f0  b1a3              CBZ      r3,|L3.284|
0000f2  684b              LDR      r3,[r1,#4]            ;2633
0000f4  f42363e0          BIC      r3,r3,#0x700          ;2633
0000f8  604b              STR      r3,[r1,#4]            ;2633
0000fa  6801              LDR      r1,[r0,#0]            ;2633
0000fc  694b              LDR      r3,[r1,#0x14]         ;2633
0000fe  680b              LDR      r3,[r1,#0]            ;2633
000100  f0430301          ORR      r3,r3,#1              ;2633
000104  600b              STR      r3,[r1,#0]            ;2633
000106  9300              STR      r3,[sp,#0]            ;2633
000108  6801              LDR      r1,[r0,#0]            ;2633
00010a  680b              LDR      r3,[r1,#0]            ;2633
00010c  f4236380          BIC      r3,r3,#0x400          ;2633
000110  600b              STR      r3,[r1,#0]            ;2633
000112  f8802035          STRB     r2,[r0,#0x35]         ;2633
000116  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L3.282|
00011a  bdf8              POP      {r3-r7,pc}
                  |L3.284|
00011c  694a              LDR      r2,[r1,#0x14]         ;2658
00011e  b1ae              CBZ      r6,|L3.332|
000120  f3c213c0          UBFX     r3,r2,#7,#1           ;2640
000124  684a              LDR      r2,[r1,#4]            ;2641
000126  f3c22480          UBFX     r4,r2,#10,#1          ;2641
00012a  694a              LDR      r2,[r1,#0x14]         ;2642
00012c  6849              LDR      r1,[r1,#4]            ;2643
00012e  f3c20280          UBFX     r2,r2,#2,#1           ;2642
000132  f3c12140          UBFX     r1,r1,#9,#1           ;2643
000136  b10b              CBZ      r3,|L3.316|
000138  b104              CBZ      r4,|L3.316|
00013a  b11a              CBZ      r2,|L3.324|
                  |L3.316|
00013c  2a00              CMP      r2,#0                 ;2650
00013e  d0ec              BEQ      |L3.282|
000140  2900              CMP      r1,#0                 ;2650
000142  d0ea              BEQ      |L3.282|
                  |L3.324|
000144  8d41              LDRH     r1,[r0,#0x2a]         ;2650
000146  2900              CMP      r1,#0                 ;2650
000148  d19a              BNE      |L3.128|
                  |L3.330|
00014a  bdf8              POP      {r3-r7,pc}
                  |L3.332|
00014c  f3c21580          UBFX     r5,r2,#6,#1           ;2658
000150  684a              LDR      r2,[r1,#4]            ;2659
000152  f3c22380          UBFX     r3,r2,#10,#1          ;2659
000156  694a              LDR      r2,[r1,#0x14]         ;2660
000158  684c              LDR      r4,[r1,#4]            ;2661
00015a  f3c20280          UBFX     r2,r2,#2,#1           ;2660
00015e  f3c42440          UBFX     r4,r4,#9,#1           ;2661
000162  b10d              CBZ      r5,|L3.360|
000164  b103              CBZ      r3,|L3.360|
000166  b11a              CBZ      r2,|L3.368|
                  |L3.360|
000168  2a00              CMP      r2,#0                 ;2668
00016a  d0ee              BEQ      |L3.330|
00016c  2c00              CMP      r4,#0                 ;2668
00016e  d0ec              BEQ      |L3.330|
                  |L3.368|
000170  8d42              LDRH     r2,[r0,#0x2a]         ;2668
000172  2a00              CMP      r2,#0                 ;2668
000174  d0e9              BEQ      |L3.330|
000176  690a              LDR      r2,[r1,#0x10]         ;2668
000178  6a41              LDR      r1,[r0,#0x24]         ;2668
00017a  1c4b              ADDS     r3,r1,#1              ;2668
00017c  6243              STR      r3,[r0,#0x24]         ;2668
00017e  700a              STRB     r2,[r1,#0]            ;2668
                  |L3.384|
000180  8d41              LDRH     r1,[r0,#0x2a]         ;2668
000182  1e49              SUBS     r1,r1,#1              ;2668
000184  8541              STRH     r1,[r0,#0x2a]         ;2668
000186  bdf8              POP      {r3-r7,pc}
;;;2675   
                          ENDP


                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;2851     */
;;;2852    __WEAK void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2853   {
;;;2854     /* Prevent unused argument(s) compilation warning */
;;;2855     UNUSED(hi2c);
;;;2856     /* NOTE : This function should not be modified, when the callback is needed,
;;;2857               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;2858      */
;;;2859   }
;;;2860   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;2898   */
;;;2899   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  6b80              LDR      r0,[r0,#0x38]
;;;2900   {
;;;2901     return hi2c->ErrorCode;
;;;2902   }
000002  4770              BX       lr
;;;2903   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;2886     */
;;;2887   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  f8900035          LDRB     r0,[r0,#0x35]
;;;2888   {
;;;2889     /* Return I2C handle state */
;;;2890     return hi2c->State;
;;;2891   }
000004  4770              BX       lr
;;;2892   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;317      */
;;;318    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;319    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L7.16|
;;;320      uint32_t freqrange = 0;
;;;321      uint32_t pclk1 = 0;
;;;322    
;;;323      /* Check the I2C handle allocation */
;;;324      if(hi2c == NULL)
;;;325      {
;;;326        return HAL_ERROR;
;;;327      }
;;;328    
;;;329      /* Check the parameters */
;;;330      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;331      assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
;;;332      assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
;;;333      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;334      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;335      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;336      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;337      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;338      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;339    
;;;340      if(hi2c->State == HAL_I2C_STATE_RESET)
000006  f8940035          LDRB     r0,[r4,#0x35]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L7.20|
00000e  e006              B        |L7.30|
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;326
;;;341      {
;;;342        /* Allocate lock resource and initialize it */
;;;343        hi2c->Lock = HAL_UNLOCKED;
;;;344        
;;;345        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;346        HAL_I2C_MspInit(hi2c);
;;;347      }
;;;348    
;;;349      hi2c->State = HAL_I2C_STATE_BUSY;
;;;350    
;;;351      /* Disable the selected I2C peripheral */
;;;352      __HAL_I2C_DISABLE(hi2c);
;;;353    
;;;354      /* Get PCLK1 frequency */
;;;355      pclk1 = HAL_RCC_GetPCLK1Freq();
;;;356    
;;;357      /* Calculate frequency range */
;;;358      freqrange = I2C_FREQ_RANGE(pclk1);
;;;359    
;;;360      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;361      /* Configure I2Cx: Frequency range */
;;;362      hi2c->Instance->CR2 = freqrange;
;;;363    
;;;364      /*---------------------------- I2Cx TRISE Configuration --------------------*/
;;;365      /* Configure I2Cx: Rise Time */
;;;366      hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
;;;367    
;;;368      /*---------------------------- I2Cx CCR Configuration ----------------------*/
;;;369      /* Configure I2Cx: Speed */
;;;370      hi2c->Instance->CCR = I2C_Configure_Speed(hi2c, pclk1);
;;;371    
;;;372      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;373      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;374      hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
;;;375    
;;;376      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;377      /* Configure I2Cx: Own Address1 and addressing mode */
;;;378      hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
;;;379    
;;;380      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;381      /* Configure I2Cx: Dual mode and Own Address2 */
;;;382      hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
;;;383    
;;;384      /* Enable the selected I2C peripheral */
;;;385      __HAL_I2C_ENABLE(hi2c);
;;;386    
;;;387      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;388      hi2c->State = HAL_I2C_STATE_READY;
;;;389      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;390    
;;;391      return HAL_OK;
;;;392    }
000012  bd70              POP      {r4-r6,pc}
                  |L7.20|
000014  f8845034          STRB     r5,[r4,#0x34]         ;343
000018  4620              MOV      r0,r4                 ;346
00001a  f7fffffe          BL       HAL_I2C_MspInit
                  |L7.30|
00001e  2024              MOVS     r0,#0x24              ;349
000020  f8840035          STRB     r0,[r4,#0x35]         ;349
000024  6820              LDR      r0,[r4,#0]            ;352
000026  6801              LDR      r1,[r0,#0]            ;352
000028  f0210101          BIC      r1,r1,#1              ;352
00002c  6001              STR      r1,[r0,#0]            ;352
00002e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000032  4601              MOV      r1,r0                 ;355
000034  4828              LDR      r0,|L7.216|
000036  6822              LDR      r2,[r4,#0]            ;362
000038  fbb1f0f0          UDIV     r0,r1,r0              ;358
00003c  6050              STR      r0,[r2,#4]            ;362
00003e  4a27              LDR      r2,|L7.220|
000040  6863              LDR      r3,[r4,#4]            ;366
000042  4293              CMP      r3,r2                 ;366
000044  d906              BLS      |L7.84|
000046  f44f7396          MOV      r3,#0x12c             ;366
00004a  4358              MULS     r0,r3,r0              ;366
00004c  f44f737a          MOV      r3,#0x3e8             ;366
000050  fbb0f0f3          UDIV     r0,r0,r3              ;366
                  |L7.84|
000054  6823              LDR      r3,[r4,#0]            ;366
000056  1c40              ADDS     r0,r0,#1              ;366
000058  6218              STR      r0,[r3,#0x20]         ;366
00005a  6860              LDR      r0,[r4,#4]            ;366
00005c  4290              CMP      r0,r2                 ;366
00005e  d808              BHI      |L7.114|
000060  0040              LSLS     r0,r0,#1              ;366
000062  fbb1f0f0          UDIV     r0,r1,r0              ;366
000066  f3c0010b          UBFX     r1,r0,#0,#12          ;366
00006a  2904              CMP      r1,#4                 ;366
00006c  d216              BCS      |L7.156|
00006e  2004              MOVS     r0,#4                 ;366
000070  e014              B        |L7.156|
                  |L7.114|
000072  68a2              LDR      r2,[r4,#8]            ;366
000074  b152              CBZ      r2,|L7.140|
000076  eb0002c0          ADD      r2,r0,r0,LSL #3       ;366
00007a  eb021000          ADD      r0,r2,r0,LSL #4       ;366
00007e  fbb1f0f0          UDIV     r0,r1,r0              ;366
000082  f4404040          ORR      r0,r0,#0xc000         ;366
                  |L7.134|
000086  0501              LSLS     r1,r0,#20             ;366
000088  d007              BEQ      |L7.154|
00008a  e007              B        |L7.156|
                  |L7.140|
00008c  eb000040          ADD      r0,r0,r0,LSL #1       ;366
000090  fbb1f0f0          UDIV     r0,r1,r0              ;366
000094  f4404000          ORR      r0,r0,#0x8000         ;366
000098  e7f5              B        |L7.134|
                  |L7.154|
00009a  2001              MOVS     r0,#1                 ;366
                  |L7.156|
00009c  6821              LDR      r1,[r4,#0]            ;370
00009e  61c8              STR      r0,[r1,#0x1c]         ;370
0000a0  e9d40107          LDRD     r0,r1,[r4,#0x1c]      ;370
0000a4  4308              ORRS     r0,r0,r1              ;374
0000a6  6821              LDR      r1,[r4,#0]            ;374
0000a8  6008              STR      r0,[r1,#0]            ;374
0000aa  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;374
0000ae  4308              ORRS     r0,r0,r1              ;378
0000b0  6821              LDR      r1,[r4,#0]            ;378
0000b2  6088              STR      r0,[r1,#8]            ;378
0000b4  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;378
0000b8  4308              ORRS     r0,r0,r1              ;382
0000ba  6821              LDR      r1,[r4,#0]            ;382
0000bc  60c8              STR      r0,[r1,#0xc]          ;382
0000be  6820              LDR      r0,[r4,#0]            ;385
0000c0  6801              LDR      r1,[r0,#0]            ;385
0000c2  f0410101          ORR      r1,r1,#1              ;385
0000c6  6001              STR      r1,[r0,#0]            ;385
0000c8  63a5              STR      r5,[r4,#0x38]         ;387
0000ca  2020              MOVS     r0,#0x20              ;388
0000cc  f8840035          STRB     r0,[r4,#0x35]         ;388
0000d0  f8845036          STRB     r5,[r4,#0x36]         ;389
0000d4  2000              MOVS     r0,#0                 ;391
0000d6  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP

                  |L7.216|
                          DCD      0x000f4240
                  |L7.220|
                          DCD      0x000186a0

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=2

                  HAL_I2C_IsDeviceReady PROC
;;;2456     */
;;;2457   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2458   {
000004  4604              MOV      r4,r0
;;;2459     uint32_t tickstart = 0, tmp1 = 0, tmp2 = 0, tmp3 = 0, I2C_Trials = 1;
;;;2460   
;;;2461     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  b081              SUB      sp,sp,#4              ;2458
00000c  4699              MOV      r9,r3                 ;2458
00000e  468b              MOV      r11,r1                ;2458
000010  2501              MOVS     r5,#1                 ;2459
000012  2820              CMP      r0,#0x20
000014  d173              BNE      |L8.254|
;;;2462     {
;;;2463       /* Wait until BUSY flag is reset */
;;;2464       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000016  f2427310          MOV      r3,#0x2710
00001a  2201              MOVS     r2,#1
00001c  4948              LDR      r1,|L8.320|
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000024  2800              CMP      r0,#0
000026  d16a              BNE      |L8.254|
;;;2465       {
;;;2466         return HAL_BUSY;
;;;2467       }
;;;2468   
;;;2469       /* Process Locked */
;;;2470       __HAL_LOCK(hi2c);
000028  f8940034          LDRB     r0,[r4,#0x34]
00002c  2801              CMP      r0,#1
00002e  d066              BEQ      |L8.254|
000030  2001              MOVS     r0,#1
000032  f8840034          STRB     r0,[r4,#0x34]
;;;2471   
;;;2472       /* Disable Pos */
;;;2473       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000036  6820              LDR      r0,[r4,#0]
000038  6801              LDR      r1,[r0,#0]
00003a  f4216100          BIC      r1,r1,#0x800
00003e  6001              STR      r1,[r0,#0]
;;;2474   
;;;2475       hi2c->State = HAL_I2C_STATE_BUSY;
000040  2024              MOVS     r0,#0x24
000042  f8840035          STRB     r0,[r4,#0x35]
;;;2476       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000046  2600              MOVS     r6,#0
000048  63a6              STR      r6,[r4,#0x38]
;;;2477   
;;;2478       do
;;;2479       {
;;;2480         /* Generate Start */
;;;2481         SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;2482   
;;;2483         /* Wait until SB flag is set */
;;;2484         if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
;;;2485         {
;;;2486           return HAL_TIMEOUT;
;;;2487         }
;;;2488   
;;;2489         /* Send slave address */
;;;2490         hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;2491          
;;;2492         /* Wait until ADDR or AF flag are set */
;;;2493         /* Get tick */
;;;2494         tickstart = HAL_GetTick();
;;;2495   
;;;2496         tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;2497         tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;2498         tmp3 = hi2c->State;
;;;2499         while((tmp1 == RESET) && (tmp2 == RESET) && (tmp3 != HAL_I2C_STATE_TIMEOUT))
;;;2500         {
;;;2501           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;2502           {
;;;2503             hi2c->State = HAL_I2C_STATE_TIMEOUT;
;;;2504           }
;;;2505           tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
;;;2506           tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
;;;2507           tmp3 = hi2c->State;
;;;2508         }
;;;2509   
;;;2510         hi2c->State = HAL_I2C_STATE_READY;
00004a  2720              MOVS     r7,#0x20
                  |L8.76|
00004c  6820              LDR      r0,[r4,#0]            ;2481
00004e  6801              LDR      r1,[r0,#0]            ;2481
000050  f4417180          ORR      r1,r1,#0x100          ;2481
000054  6001              STR      r1,[r0,#0]            ;2481
000056  464b              MOV      r3,r9                 ;2484
000058  2200              MOVS     r2,#0                 ;2484
00005a  f04f1101          MOV      r1,#0x10001           ;2484
00005e  4620              MOV      r0,r4                 ;2484
000060  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000064  2800              CMP      r0,#0                 ;2484
000066  d15c              BNE      |L8.290|
000068  6821              LDR      r1,[r4,#0]            ;2490
00006a  f00b00fe          AND      r0,r11,#0xfe          ;2490
00006e  6108              STR      r0,[r1,#0x10]         ;2490
000070  f7fffffe          BL       HAL_GetTick
000074  6821              LDR      r1,[r4,#0]            ;2496
000076  4680              MOV      r8,r0                 ;2494
000078  6948              LDR      r0,[r1,#0x14]         ;2496
00007a  6949              LDR      r1,[r1,#0x14]         ;2497
00007c  f3c00040          UBFX     r0,r0,#1,#1           ;2496
000080  f8942035          LDRB     r2,[r4,#0x35]         ;2498
000084  f3c12180          UBFX     r1,r1,#10,#1          ;2497
000088  f04f0aa0          MOV      r10,#0xa0             ;2503
00008c  e014              B        |L8.184|
00008e  bf00              NOP                            ;2501
                  |L8.144|
000090  f1b90f00          CMP      r9,#0                 ;2501
000094  d005              BEQ      |L8.162|
000096  f7fffffe          BL       HAL_GetTick
00009a  eba00108          SUB      r1,r0,r8              ;2501
00009e  4549              CMP      r1,r9                 ;2501
0000a0  d901              BLS      |L8.166|
                  |L8.162|
0000a2  f884a035          STRB     r10,[r4,#0x35]        ;2503
                  |L8.166|
0000a6  6821              LDR      r1,[r4,#0]            ;2505
0000a8  6948              LDR      r0,[r1,#0x14]         ;2505
0000aa  6949              LDR      r1,[r1,#0x14]         ;2506
0000ac  f3c00040          UBFX     r0,r0,#1,#1           ;2505
0000b0  f8942035          LDRB     r2,[r4,#0x35]         ;2507
0000b4  f3c12180          UBFX     r1,r1,#10,#1          ;2506
                  |L8.184|
0000b8  4308              ORRS     r0,r0,r1              ;2499
0000ba  d101              BNE      |L8.192|
0000bc  2aa0              CMP      r2,#0xa0              ;2499
0000be  d1e7              BNE      |L8.144|
                  |L8.192|
0000c0  f8847035          STRB     r7,[r4,#0x35]
;;;2511   
;;;2512         /* Check if the ADDR flag has been set */
;;;2513         if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
0000c4  6820              LDR      r0,[r4,#0]
0000c6  6941              LDR      r1,[r0,#0x14]
0000c8  43c9              MVNS     r1,r1
0000ca  0789              LSLS     r1,r1,#30
0000cc  d418              BMI      |L8.256|
;;;2514         {
;;;2515           /* Generate Stop */
;;;2516           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
0000ce  6801              LDR      r1,[r0,#0]
0000d0  f4417100          ORR      r1,r1,#0x200
0000d4  6001              STR      r1,[r0,#0]
;;;2517   
;;;2518           /* Clear ADDR Flag */
;;;2519           __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
0000d6  6820              LDR      r0,[r4,#0]
0000d8  6941              LDR      r1,[r0,#0x14]
0000da  6980              LDR      r0,[r0,#0x18]
;;;2520   
;;;2521           /* Wait until BUSY flag is reset */
;;;2522           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
0000dc  9000              STR      r0,[sp,#0]
0000de  f2427310          MOV      r3,#0x2710
0000e2  2201              MOVS     r2,#1
0000e4  4916              LDR      r1,|L8.320|
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000ec  b9c8              CBNZ     r0,|L8.290|
;;;2523           {
;;;2524             return HAL_TIMEOUT;
;;;2525           }
;;;2526   
;;;2527           hi2c->State = HAL_I2C_STATE_READY;
0000ee  f8847035          STRB     r7,[r4,#0x35]
;;;2528   
;;;2529           /* Process Unlocked */
;;;2530           __HAL_UNLOCK(hi2c);
0000f2  f8846034          STRB     r6,[r4,#0x34]
;;;2531   
;;;2532           return HAL_OK;
0000f6  2000              MOVS     r0,#0
                  |L8.248|
;;;2533         }
;;;2534         else
;;;2535         {
;;;2536           /* Generate Stop */
;;;2537           SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2538   
;;;2539           /* Clear AF Flag */
;;;2540           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;2541   
;;;2542           /* Wait until BUSY flag is reset */
;;;2543           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
;;;2544           {
;;;2545             return HAL_TIMEOUT;
;;;2546           }
;;;2547         }
;;;2548       }while(I2C_Trials++ < Trials);
;;;2549   
;;;2550       hi2c->State = HAL_I2C_STATE_READY;
;;;2551   
;;;2552       /* Process Unlocked */
;;;2553       __HAL_UNLOCK(hi2c);
;;;2554   
;;;2555       return HAL_ERROR;
;;;2556     }
;;;2557     else
;;;2558     {
;;;2559       return HAL_BUSY;
;;;2560     }
;;;2561   }
0000f8  b005              ADD      sp,sp,#0x14
0000fa  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.254|
0000fe  e01d              B        |L8.316|
                  |L8.256|
000100  6801              LDR      r1,[r0,#0]            ;2537
000102  f4417100          ORR      r1,r1,#0x200          ;2537
000106  6001              STR      r1,[r0,#0]            ;2537
000108  6820              LDR      r0,[r4,#0]            ;2540
00010a  6941              LDR      r1,[r0,#0x14]         ;2540
00010c  f4216180          BIC      r1,r1,#0x400          ;2540
000110  6141              STR      r1,[r0,#0x14]         ;2540
000112  f2427310          MOV      r3,#0x2710            ;2543
000116  2201              MOVS     r2,#1                 ;2543
000118  4909              LDR      r1,|L8.320|
00011a  4620              MOV      r0,r4                 ;2543
00011c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000120  b108              CBZ      r0,|L8.294|
                  |L8.290|
000122  2003              MOVS     r0,#3                 ;2545
000124  e7e8              B        |L8.248|
                  |L8.294|
000126  4628              MOV      r0,r5                 ;2548
000128  9903              LDR      r1,[sp,#0xc]          ;2548
00012a  1c6d              ADDS     r5,r5,#1              ;2548
00012c  4288              CMP      r0,r1                 ;2548
00012e  d38d              BCC      |L8.76|
000130  f8847035          STRB     r7,[r4,#0x35]         ;2550
000134  f8846034          STRB     r6,[r4,#0x34]         ;2553
000138  2001              MOVS     r0,#1                 ;2555
00013a  e7dd              B        |L8.248|
                  |L8.316|
00013c  2002              MOVS     r0,#2                 ;2559
00013e  e7db              B        |L8.248|
;;;2562   /**
                          ENDP

                  |L8.320|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;2777     */
;;;2778   __WEAK void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2779   {
;;;2780     /* Prevent unused argument(s) compilation warning */
;;;2781     UNUSED(hi2c);
;;;2782     /* NOTE : This function should not be modified, when the callback is needed,
;;;2783               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2784      */
;;;2785   }
;;;2786   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;2762     */
;;;2763    __WEAK void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2764   {
;;;2765     /* Prevent unused argument(s) compilation warning */
;;;2766     UNUSED(hi2c);
;;;2767     /* NOTE : This function should not be modified, when the callback is needed,
;;;2768               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2769      */
;;;2770   }
;;;2771   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;646      */
;;;647    HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;648    {
000004  4604              MOV      r4,r0
;;;649      if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  f8dd9020          LDR      r9,[sp,#0x20]
00000e  461e              MOV      r6,r3                 ;648
000010  4615              MOV      r5,r2                 ;648
000012  4688              MOV      r8,r1                 ;648
000014  2820              CMP      r0,#0x20
                  |L11.22|
000016  d178              BNE      |L11.266|
;;;650      {
;;;651        if((pData == NULL) || (Size == 0))
000018  2d00              CMP      r5,#0
00001a  d05e              BEQ      |L11.218|
00001c  2e00              CMP      r6,#0
00001e  d05c              BEQ      |L11.218|
;;;652        {
;;;653          return  HAL_ERROR;
;;;654        }
;;;655    
;;;656        /* Wait until BUSY flag is reset */
;;;657        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000020  f2427310          MOV      r3,#0x2710
000024  2201              MOVS     r2,#1
000026  4968              LDR      r1,|L11.456|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  2800              CMP      r0,#0
000030  d1f1              BNE      |L11.22|
;;;658        {
;;;659          return HAL_BUSY;
;;;660        }
;;;661    
;;;662        /* Process Locked */
;;;663        __HAL_LOCK(hi2c);
000032  f8940034          LDRB     r0,[r4,#0x34]
000036  2801              CMP      r0,#1
000038  d067              BEQ      |L11.266|
00003a  2001              MOVS     r0,#1
00003c  f8840034          STRB     r0,[r4,#0x34]
;;;664    
;;;665        /* Disable Pos */
;;;666        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000040  6820              LDR      r0,[r4,#0]
000042  6801              LDR      r1,[r0,#0]
000044  f4216100          BIC      r1,r1,#0x800
000048  6001              STR      r1,[r0,#0]
;;;667    
;;;668        hi2c->State = HAL_I2C_STATE_BUSY_RX;
00004a  2022              MOVS     r0,#0x22
00004c  f8840035          STRB     r0,[r4,#0x35]
;;;669        hi2c->Mode = HAL_I2C_MODE_MASTER;
000050  2010              MOVS     r0,#0x10
000052  f8840036          STRB     r0,[r4,#0x36]
;;;670        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000056  2700              MOVS     r7,#0
000058  63a7              STR      r7,[r4,#0x38]
;;;671    
;;;672        /* Send Slave Address */
;;;673        if(I2C_MasterRequestRead(hi2c, DevAddress, Timeout) != HAL_OK)
00005a  464a              MOV      r2,r9
00005c  4641              MOV      r1,r8
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_MasterRequestRead
000064  b128              CBZ      r0,|L11.114|
;;;674        {
;;;675          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000066  6ba0              LDR      r0,[r4,#0x38]
;;;676          {
;;;677            /* Process Unlocked */
;;;678            __HAL_UNLOCK(hi2c);
;;;679            return HAL_ERROR;
;;;680          }
;;;681          else
;;;682          {
;;;683            /* Process Unlocked */
;;;684            __HAL_UNLOCK(hi2c);
000068  f8847034          STRB     r7,[r4,#0x34]
00006c  2804              CMP      r0,#4                 ;675
00006e  d034              BEQ      |L11.218|
000070  e072              B        |L11.344|
                  |L11.114|
;;;685            return HAL_TIMEOUT;
;;;686          }
;;;687        }
;;;688    
;;;689        if(Size == 1)
000072  2e01              CMP      r6,#1
000074  d01a              BEQ      |L11.172|
;;;690        {
;;;691          /* Disable Acknowledge */
;;;692          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;693    
;;;694          /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;695             software sequence must complete before the current byte end of transfer */
;;;696          __disable_irq();
;;;697    
;;;698          /* Clear ADDR flag */
;;;699          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;700    
;;;701          /* Generate Stop */
;;;702          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;703    	  
;;;704          /* Re-enable IRQs */
;;;705          __enable_irq(); 
;;;706        }
;;;707        else if(Size == 2)
;;;708        {
;;;709          /* Enable Pos */
;;;710          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;711    
;;;712          /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;713             software sequence must complete before the current byte end of transfer */
;;;714          __disable_irq();
;;;715    
;;;716          /* Clear ADDR flag */
;;;717          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;718    
;;;719          /* Disable Acknowledge */
;;;720          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;721    
;;;722           /* Re-enable IRQs */
;;;723           __enable_irq(); 
;;;724        }
;;;725        else
;;;726        {
;;;727          /* Enable Acknowledge */
;;;728          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000076  6820              LDR      r0,[r4,#0]
;;;729    
;;;730          /* Clear ADDR flag */
;;;731          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;732        }
;;;733    
;;;734        while(Size > 0)
;;;735        {
;;;736          if(Size <= 3)
;;;737          {
;;;738            /* One byte */
;;;739            if(Size == 1)
;;;740            {
;;;741              /* Wait until RXNE flag is set */
;;;742              if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
;;;743              {
;;;744                if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;745                {
;;;746                  return HAL_TIMEOUT;
;;;747                }
;;;748                else
;;;749                {
;;;750                  return HAL_ERROR;
;;;751                }
;;;752              }
;;;753    
;;;754              /* Read data from DR */
;;;755              (*pData++) = hi2c->Instance->DR;
;;;756              Size--;
;;;757            }
;;;758            /* Two bytes */
;;;759            else if(Size == 2)
;;;760            {
;;;761              /* Wait until BTF flag is set */
;;;762              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
000078  f8df8150          LDR      r8,|L11.460|
00007c  2e02              CMP      r6,#2                 ;707
00007e  6801              LDR      r1,[r0,#0]            ;728
000080  d02e              BEQ      |L11.224|
000082  f4416180          ORR      r1,r1,#0x400          ;728
000086  6001              STR      r1,[r0,#0]            ;728
000088  6820              LDR      r0,[r4,#0]            ;731
00008a  6941              LDR      r1,[r0,#0x14]         ;731
00008c  6980              LDR      r0,[r0,#0x18]         ;731
00008e  9000              STR      r0,[sp,#0]            ;731
                  |L11.144|
000090  2e03              CMP      r6,#3                 ;736
000092  d874              BHI      |L11.382|
000094  2e01              CMP      r6,#1                 ;739
000096  d018              BEQ      |L11.202|
000098  2e02              CMP      r6,#2                 ;759
00009a  d02e              BEQ      |L11.250|
;;;763              {
;;;764                return HAL_TIMEOUT;
;;;765              }
;;;766    
;;;767              /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;768                 software sequence must complete before the current byte end of transfer */
;;;769               __disable_irq();
;;;770    
;;;771              /* Generate Stop */
;;;772              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;773    
;;;774              /* Read data from DR */
;;;775              (*pData++) = hi2c->Instance->DR;
;;;776              Size--;
;;;777    
;;;778              /* Re-enable IRQs */
;;;779              __enable_irq();
;;;780    
;;;781              /* Read data from DR */
;;;782              (*pData++) = hi2c->Instance->DR;
;;;783              Size--;
;;;784            }
;;;785            /* 3 Last bytes */
;;;786            else
;;;787            {
;;;788              /* Wait until BTF flag is set */
;;;789              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
00009c  464b              MOV      r3,r9
00009e  2200              MOVS     r2,#0
0000a0  4641              MOV      r1,r8
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000a8  bb80              CBNZ     r0,|L11.268|
0000aa  e042              B        |L11.306|
                  |L11.172|
0000ac  6820              LDR      r0,[r4,#0]            ;692
0000ae  6801              LDR      r1,[r0,#0]            ;692
0000b0  f4216180          BIC      r1,r1,#0x400          ;692
0000b4  6001              STR      r1,[r0,#0]            ;692
0000b6  b672              CPSID    i                     ;696
0000b8  6820              LDR      r0,[r4,#0]            ;699
0000ba  6941              LDR      r1,[r0,#0x14]         ;699
0000bc  6981              LDR      r1,[r0,#0x18]         ;699
0000be  9100              STR      r1,[sp,#0]            ;702
0000c0  6801              LDR      r1,[r0,#0]            ;702
0000c2  f4417100          ORR      r1,r1,#0x200          ;702
0000c6  6001              STR      r1,[r0,#0]            ;702
0000c8  b662              CPSIE    i                     ;705
                  |L11.202|
0000ca  4649              MOV      r1,r9                 ;742
0000cc  4620              MOV      r0,r4                 ;742
0000ce  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000d2  b1e0              CBZ      r0,|L11.270|
                  |L11.212|
0000d4  6ba0              LDR      r0,[r4,#0x38]         ;744
0000d6  2820              CMP      r0,#0x20              ;744
0000d8  d03e              BEQ      |L11.344|
                  |L11.218|
;;;790              {
;;;791                return HAL_TIMEOUT;
;;;792              }
;;;793    
;;;794              /* Disable Acknowledge */
;;;795              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;796    
;;;797              /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;798                 software sequence must complete before the current byte end of transfer */
;;;799              __disable_irq();
;;;800    
;;;801              /* Read data from DR */
;;;802              (*pData++) = hi2c->Instance->DR;
;;;803              Size--;
;;;804    
;;;805              /* Wait until BTF flag is set */
;;;806              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
;;;807              {
;;;808                return HAL_TIMEOUT;
;;;809              }
;;;810    
;;;811              /* Generate Stop */
;;;812              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;813    
;;;814              /* Read data from DR */
;;;815              (*pData++) = hi2c->Instance->DR;
;;;816              Size--;
;;;817    	  
;;;818              /* Re-enable IRQs */
;;;819              __enable_irq(); 
;;;820    
;;;821              /* Read data from DR */
;;;822              (*pData++) = hi2c->Instance->DR;
;;;823              Size--;
;;;824            }
;;;825          }
;;;826          else
;;;827          {
;;;828            /* Wait until RXNE flag is set */
;;;829            if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
;;;830            {
;;;831              if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;832              {
;;;833                return HAL_TIMEOUT;
;;;834              }
;;;835              else
;;;836              {
;;;837                return HAL_ERROR;
0000da  2001              MOVS     r0,#1
                  |L11.220|
;;;838              }
;;;839            }
;;;840    
;;;841            /* Read data from DR */
;;;842            (*pData++) = hi2c->Instance->DR;
;;;843            Size--;
;;;844    
;;;845            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;846            {
;;;847              /* Read data from DR */
;;;848              (*pData++) = hi2c->Instance->DR;
;;;849              Size--;
;;;850            }
;;;851          }
;;;852        }
;;;853    
;;;854        hi2c->State = HAL_I2C_STATE_READY;
;;;855        hi2c->Mode = HAL_I2C_MODE_NONE;
;;;856    
;;;857        /* Process Unlocked */
;;;858        __HAL_UNLOCK(hi2c);
;;;859    
;;;860        return HAL_OK;
;;;861      }
;;;862      else
;;;863      {
;;;864        return HAL_BUSY;
;;;865      }
;;;866    }
0000dc  e8bd83f8          POP      {r3-r9,pc}
                  |L11.224|
0000e0  f4416100          ORR      r1,r1,#0x800          ;710
0000e4  6001              STR      r1,[r0,#0]            ;710
0000e6  b672              CPSID    i                     ;714
0000e8  6820              LDR      r0,[r4,#0]            ;717
0000ea  6941              LDR      r1,[r0,#0x14]         ;717
0000ec  6981              LDR      r1,[r0,#0x18]         ;717
0000ee  9100              STR      r1,[sp,#0]            ;720
0000f0  6801              LDR      r1,[r0,#0]            ;720
0000f2  f4216180          BIC      r1,r1,#0x400          ;720
0000f6  6001              STR      r1,[r0,#0]            ;720
0000f8  b662              CPSIE    i                     ;723
                  |L11.250|
0000fa  464b              MOV      r3,r9                 ;762
0000fc  2200              MOVS     r2,#0                 ;762
0000fe  4641              MOV      r1,r8                 ;762
000100  4620              MOV      r0,r4                 ;762
000102  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000106  b908              CBNZ     r0,|L11.268|
000108  e005              B        |L11.278|
                  |L11.266|
00010a  e05a              B        |L11.450|
                  |L11.268|
00010c  e024              B        |L11.344|
                  |L11.270|
00010e  6820              LDR      r0,[r4,#0]            ;755
000110  6900              LDR      r0,[r0,#0x10]         ;755
000112  7028              STRB     r0,[r5,#0]            ;755
000114  e04c              B        |L11.432|
                  |L11.278|
000116  b672              CPSID    i                     ;769
000118  6820              LDR      r0,[r4,#0]            ;772
00011a  6801              LDR      r1,[r0,#0]            ;772
00011c  f4417100          ORR      r1,r1,#0x200          ;772
000120  6001              STR      r1,[r0,#0]            ;772
000122  6820              LDR      r0,[r4,#0]            ;775
000124  6900              LDR      r0,[r0,#0x10]         ;775
000126  7028              STRB     r0,[r5,#0]            ;775
000128  b662              CPSIE    i                     ;779
00012a  6820              LDR      r0,[r4,#0]            ;782
00012c  6900              LDR      r0,[r0,#0x10]         ;782
00012e  7068              STRB     r0,[r5,#1]            ;782
000130  e03e              B        |L11.432|
                  |L11.306|
000132  6820              LDR      r0,[r4,#0]            ;795
000134  6801              LDR      r1,[r0,#0]            ;795
000136  f4216180          BIC      r1,r1,#0x400          ;795
00013a  6001              STR      r1,[r0,#0]            ;795
00013c  b672              CPSID    i                     ;799
00013e  6820              LDR      r0,[r4,#0]            ;802
000140  6900              LDR      r0,[r0,#0x10]         ;802
000142  f8050b01          STRB     r0,[r5],#1            ;802
000146  1e76              SUBS     r6,r6,#1              ;802
000148  b2b6              UXTH     r6,r6                 ;803
00014a  464b              MOV      r3,r9                 ;806
00014c  2200              MOVS     r2,#0                 ;806
00014e  4641              MOV      r1,r8                 ;806
000150  4620              MOV      r0,r4                 ;806
000152  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000156  b108              CBZ      r0,|L11.348|
                  |L11.344|
000158  2003              MOVS     r0,#3                 ;833
00015a  e7bf              B        |L11.220|
                  |L11.348|
00015c  6820              LDR      r0,[r4,#0]            ;812
00015e  6801              LDR      r1,[r0,#0]            ;812
000160  f4417100          ORR      r1,r1,#0x200          ;812
000164  6001              STR      r1,[r0,#0]            ;812
000166  6820              LDR      r0,[r4,#0]            ;815
000168  6900              LDR      r0,[r0,#0x10]         ;815
00016a  f8050b01          STRB     r0,[r5],#1            ;815
00016e  b662              CPSIE    i                     ;819
000170  6820              LDR      r0,[r4,#0]            ;822
000172  6900              LDR      r0,[r0,#0x10]         ;822
000174  f8050b01          STRB     r0,[r5],#1            ;822
000178  1eb6              SUBS     r6,r6,#2              ;822
00017a  e015              B        |L11.424|
00017c  e7ff              B        |L11.382|
                  |L11.382|
00017e  4649              MOV      r1,r9                 ;829
000180  4620              MOV      r0,r4                 ;829
000182  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000186  2800              CMP      r0,#0                 ;829
000188  d1a4              BNE      |L11.212|
00018a  6820              LDR      r0,[r4,#0]            ;842
00018c  6900              LDR      r0,[r0,#0x10]         ;842
00018e  f8050b01          STRB     r0,[r5],#1            ;842
000192  6821              LDR      r1,[r4,#0]            ;845
000194  1e76              SUBS     r6,r6,#1              ;842
000196  b2b6              UXTH     r6,r6                 ;843
000198  6948              LDR      r0,[r1,#0x14]         ;845
00019a  43c0              MVNS     r0,r0                 ;845
00019c  0740              LSLS     r0,r0,#29             ;845
00019e  d404              BMI      |L11.426|
0001a0  6908              LDR      r0,[r1,#0x10]         ;848
0001a2  f8050b01          STRB     r0,[r5],#1            ;848
0001a6  1e76              SUBS     r6,r6,#1              ;848
                  |L11.424|
0001a8  b2b6              UXTH     r6,r6                 ;849
                  |L11.426|
0001aa  2e00              CMP      r6,#0                 ;734
0001ac  f47faf70          BNE      |L11.144|
                  |L11.432|
0001b0  2020              MOVS     r0,#0x20              ;854
0001b2  f8840035          STRB     r0,[r4,#0x35]         ;854
0001b6  f8847036          STRB     r7,[r4,#0x36]         ;855
0001ba  f8847034          STRB     r7,[r4,#0x34]         ;858
0001be  2000              MOVS     r0,#0                 ;860
0001c0  e78c              B        |L11.220|
                  |L11.450|
0001c2  2002              MOVS     r0,#2                 ;864
0001c4  e78a              B        |L11.220|
;;;867    
                          ENDP

0001c6  0000              DCW      0x0000
                  |L11.456|
                          DCD      0x00100002
                  |L11.460|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;1478     */
;;;1479   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1480   {
000004  4604              MOV      r4,r0
;;;1481     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  461d              MOV      r5,r3                 ;1480
00000c  4617              MOV      r7,r2                 ;1480
00000e  4688              MOV      r8,r1                 ;1480
000010  2820              CMP      r0,#0x20
000012  d158              BNE      |L12.198|
;;;1482     {
;;;1483       if((pData == NULL) || (Size == 0))
000014  b14f              CBZ      r7,|L12.42|
000016  b145              CBZ      r5,|L12.42|
;;;1484       {
;;;1485         return  HAL_ERROR;
;;;1486       }
;;;1487   
;;;1488       /* Wait until BUSY flag is reset */
;;;1489       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000018  f2427310          MOV      r3,#0x2710
00001c  2201              MOVS     r2,#1
00001e  492b              LDR      r1,|L12.204|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  bba0              CBNZ     r0,|L12.146|
000028  e002              B        |L12.48|
                  |L12.42|
00002a  2001              MOVS     r0,#1                 ;1485
                  |L12.44|
;;;1490       {
;;;1491         return HAL_BUSY;
;;;1492       }
;;;1493   
;;;1494       /* Process Locked */
;;;1495       __HAL_LOCK(hi2c);
;;;1496   
;;;1497       /* Disable Pos */
;;;1498       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1499   
;;;1500       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;1501       hi2c->Mode = HAL_I2C_MODE_MASTER;
;;;1502       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1503   
;;;1504       hi2c->pBuffPtr = pData;
;;;1505       hi2c->XferSize = Size;
;;;1506       hi2c->XferCount = Size;
;;;1507   
;;;1508       /* Set the I2C DMA transfert complete callback */
;;;1509       hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;1510   
;;;1511       /* Set the DMA error callback */
;;;1512       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;1513   
;;;1514       /* Enable the DMA channel */
;;;1515       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
;;;1516   
;;;1517       /* Send Slave Address */
;;;1518       if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;1519       {
;;;1520         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1521         {
;;;1522           /* Process Unlocked */
;;;1523           __HAL_UNLOCK(hi2c);
;;;1524           return HAL_ERROR;
;;;1525         }
;;;1526         else
;;;1527         {
;;;1528           /* Process Unlocked */
;;;1529           __HAL_UNLOCK(hi2c);
;;;1530           return HAL_TIMEOUT;
;;;1531         }
;;;1532       }
;;;1533   
;;;1534       if(Size == 1)
;;;1535       {
;;;1536         /* Disable Acknowledge */
;;;1537         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1538       }
;;;1539       else
;;;1540       {
;;;1541         /* Enable Last DMA bit */
;;;1542         SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;1543       }
;;;1544   
;;;1545       /* Enable DMA Request */
;;;1546       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;1547   
;;;1548       /* Clear ADDR flag */
;;;1549       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1550   
;;;1551       /* Process Unlocked */
;;;1552       __HAL_UNLOCK(hi2c);
;;;1553   
;;;1554       return HAL_OK;
;;;1555     }
;;;1556     else
;;;1557     {
;;;1558       return HAL_BUSY;
;;;1559     }
;;;1560   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L12.48|
000030  f8940034          LDRB     r0,[r4,#0x34]         ;1495
000034  2801              CMP      r0,#1                 ;1495
000036  d046              BEQ      |L12.198|
000038  2001              MOVS     r0,#1                 ;1495
00003a  f8840034          STRB     r0,[r4,#0x34]         ;1495
00003e  6820              LDR      r0,[r4,#0]            ;1498
000040  6801              LDR      r1,[r0,#0]            ;1498
000042  f4216100          BIC      r1,r1,#0x800          ;1498
000046  6001              STR      r1,[r0,#0]            ;1498
000048  2022              MOVS     r0,#0x22              ;1500
00004a  f8840035          STRB     r0,[r4,#0x35]         ;1500
00004e  2010              MOVS     r0,#0x10              ;1501
000050  f8840036          STRB     r0,[r4,#0x36]         ;1501
000054  2600              MOVS     r6,#0                 ;1502
000056  63a6              STR      r6,[r4,#0x38]         ;1502
000058  6267              STR      r7,[r4,#0x24]         ;1505
00005a  8525              STRH     r5,[r4,#0x28]         ;1505
00005c  8565              STRH     r5,[r4,#0x2a]         ;1506
00005e  6b21              LDR      r1,[r4,#0x30]         ;1509
000060  481b              LDR      r0,|L12.208|
000062  462b              MOV      r3,r5                 ;1515
000064  6288              STR      r0,[r1,#0x28]         ;1512
000066  6b21              LDR      r1,[r4,#0x30]         ;1512
000068  481a              LDR      r0,|L12.212|
00006a  463a              MOV      r2,r7                 ;1515
00006c  6308              STR      r0,[r1,#0x30]         ;1515
00006e  6821              LDR      r1,[r4,#0]            ;1515
000070  6b20              LDR      r0,[r4,#0x30]         ;1515
000072  3110              ADDS     r1,r1,#0x10           ;1515
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  2223              MOVS     r2,#0x23              ;1518
00007a  4641              MOV      r1,r8                 ;1518
00007c  4620              MOV      r0,r4                 ;1518
00007e  f7fffffe          BL       I2C_MasterRequestRead
000082  b138              CBZ      r0,|L12.148|
000084  6ba0              LDR      r0,[r4,#0x38]         ;1520
000086  f8846034          STRB     r6,[r4,#0x34]         ;1529
00008a  2804              CMP      r0,#4                 ;1520
00008c  d0cd              BEQ      |L12.42|
00008e  2003              MOVS     r0,#3                 ;1530
000090  e7cc              B        |L12.44|
                  |L12.146|
000092  e018              B        |L12.198|
                  |L12.148|
000094  6820              LDR      r0,[r4,#0]            ;1534
000096  2d01              CMP      r5,#1                 ;1534
000098  d010              BEQ      |L12.188|
00009a  6841              LDR      r1,[r0,#4]            ;1542
00009c  f4415180          ORR      r1,r1,#0x1000         ;1542
0000a0  6041              STR      r1,[r0,#4]            ;1542
                  |L12.162|
0000a2  6820              LDR      r0,[r4,#0]            ;1546
0000a4  6841              LDR      r1,[r0,#4]            ;1546
0000a6  f4416100          ORR      r1,r1,#0x800          ;1546
0000aa  6041              STR      r1,[r0,#4]            ;1546
0000ac  6820              LDR      r0,[r4,#0]            ;1549
0000ae  6941              LDR      r1,[r0,#0x14]         ;1549
0000b0  6980              LDR      r0,[r0,#0x18]         ;1549
0000b2  9000              STR      r0,[sp,#0]            ;1552
0000b4  f8846034          STRB     r6,[r4,#0x34]         ;1552
0000b8  2000              MOVS     r0,#0                 ;1554
0000ba  e7b7              B        |L12.44|
                  |L12.188|
0000bc  6801              LDR      r1,[r0,#0]            ;1537
0000be  f4216180          BIC      r1,r1,#0x400          ;1537
0000c2  6001              STR      r1,[r0,#0]            ;1537
0000c4  e7ed              B        |L12.162|
                  |L12.198|
0000c6  2002              MOVS     r0,#2                 ;1558
0000c8  e7b0              B        |L12.44|
;;;1561   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L12.204|
                          DCD      0x00100002
                  |L12.208|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L12.212|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1177     */
;;;1178   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1179   {
000004  4604              MOV      r4,r0
;;;1180     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  461e              MOV      r6,r3                 ;1179
00000c  4617              MOV      r7,r2                 ;1179
00000e  4688              MOV      r8,r1                 ;1179
000010  2820              CMP      r0,#0x20
000012  d165              BNE      |L13.224|
;;;1181     {
;;;1182       if((pData == NULL) || (Size == 0))
000014  b14f              CBZ      r7,|L13.42|
000016  b146              CBZ      r6,|L13.42|
;;;1183       {
;;;1184         return  HAL_ERROR;
;;;1185       }
;;;1186   
;;;1187       /* Wait until BUSY flag is reset */
;;;1188       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000018  f2427310          MOV      r3,#0x2710
00001c  2201              MOVS     r2,#1
00001e  4931              LDR      r1,|L13.228|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  bbe0              CBNZ     r0,|L13.162|
000028  e002              B        |L13.48|
                  |L13.42|
00002a  2001              MOVS     r0,#1                 ;1184
                  |L13.44|
;;;1189       {
;;;1190         return HAL_BUSY;
;;;1191       }
;;;1192   
;;;1193       /* Process Locked */
;;;1194       __HAL_LOCK(hi2c);
;;;1195   
;;;1196       /* Disable Pos */
;;;1197       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1198   
;;;1199       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;1200       hi2c->Mode = HAL_I2C_MODE_MASTER;
;;;1201       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1202   
;;;1203       hi2c->pBuffPtr = pData;
;;;1204       hi2c->XferSize = Size;
;;;1205       hi2c->XferCount = Size;
;;;1206   
;;;1207       /* Send Slave Address */
;;;1208       if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;1209       {
;;;1210         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1211         {
;;;1212           /* Process Unlocked */
;;;1213           __HAL_UNLOCK(hi2c);
;;;1214           return HAL_ERROR;
;;;1215         }
;;;1216         else
;;;1217         {
;;;1218           /* Process Unlocked */
;;;1219           __HAL_UNLOCK(hi2c);
;;;1220           return HAL_TIMEOUT;
;;;1221         }
;;;1222       }
;;;1223   
;;;1224       if(hi2c->XferCount == 1)
;;;1225       {
;;;1226         /* Disable Acknowledge */
;;;1227         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1228   
;;;1229         /* Clear ADDR flag */
;;;1230         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1231   
;;;1232         /* Generate Stop */
;;;1233         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1234       }
;;;1235       else if(hi2c->XferCount == 2)
;;;1236       {
;;;1237         /* Enable Pos */
;;;1238         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1239   
;;;1240         /* Clear ADDR flag */
;;;1241         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1242   
;;;1243         /* Disable Acknowledge */
;;;1244         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1245       }
;;;1246       else
;;;1247       {
;;;1248         /* Enable Acknowledge */
;;;1249         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1250   
;;;1251         /* Clear ADDR flag */
;;;1252         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1253       }
;;;1254   
;;;1255       /* Process Unlocked */
;;;1256       __HAL_UNLOCK(hi2c);
;;;1257   
;;;1258       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1259                 to avoid the risk of I2C interrupt handle execution before current
;;;1260                 process unlock */
;;;1261   
;;;1262       /* Enable EVT, BUF and ERR interrupt */
;;;1263       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1264   
;;;1265       return HAL_OK;
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       return HAL_BUSY;
;;;1270     }
;;;1271   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L13.48|
000030  f8940034          LDRB     r0,[r4,#0x34]         ;1194
000034  2801              CMP      r0,#1                 ;1194
000036  d053              BEQ      |L13.224|
000038  2001              MOVS     r0,#1                 ;1194
00003a  f8840034          STRB     r0,[r4,#0x34]         ;1194
00003e  6820              LDR      r0,[r4,#0]            ;1197
000040  6801              LDR      r1,[r0,#0]            ;1197
000042  f4216100          BIC      r1,r1,#0x800          ;1197
000046  6001              STR      r1,[r0,#0]            ;1197
000048  2022              MOVS     r0,#0x22              ;1199
00004a  f8840035          STRB     r0,[r4,#0x35]         ;1199
00004e  2010              MOVS     r0,#0x10              ;1200
000050  f8840036          STRB     r0,[r4,#0x36]         ;1200
000054  2500              MOVS     r5,#0                 ;1201
000056  63a5              STR      r5,[r4,#0x38]         ;1201
000058  6267              STR      r7,[r4,#0x24]         ;1204
00005a  8526              STRH     r6,[r4,#0x28]         ;1204
00005c  8566              STRH     r6,[r4,#0x2a]         ;1205
00005e  2223              MOVS     r2,#0x23              ;1208
000060  4641              MOV      r1,r8                 ;1208
000062  4620              MOV      r0,r4                 ;1208
000064  f7fffffe          BL       I2C_MasterRequestRead
000068  b130              CBZ      r0,|L13.120|
00006a  6ba0              LDR      r0,[r4,#0x38]         ;1210
00006c  f8845034          STRB     r5,[r4,#0x34]         ;1219
000070  2804              CMP      r0,#4                 ;1210
000072  d0da              BEQ      |L13.42|
000074  2003              MOVS     r0,#3                 ;1220
000076  e7d9              B        |L13.44|
                  |L13.120|
000078  8d60              LDRH     r0,[r4,#0x2a]         ;1224
00007a  2801              CMP      r0,#1                 ;1224
00007c  d017              BEQ      |L13.174|
00007e  8d60              LDRH     r0,[r4,#0x2a]         ;1235
000080  2802              CMP      r0,#2                 ;1235
000082  6820              LDR      r0,[r4,#0]            ;1249
000084  6801              LDR      r1,[r0,#0]            ;1249
000086  d01f              BEQ      |L13.200|
000088  f4416180          ORR      r1,r1,#0x400          ;1249
00008c  6001              STR      r1,[r0,#0]            ;1249
00008e  6820              LDR      r0,[r4,#0]            ;1252
000090  6941              LDR      r1,[r0,#0x14]         ;1252
000092  6980              LDR      r0,[r0,#0x18]         ;1252
000094  f8cd0000          STR.W    r0,[sp,#0]            ;1252
                  |L13.152|
000098  f8845034          STRB     r5,[r4,#0x34]         ;1256
00009c  6820              LDR      r0,[r4,#0]            ;1263
00009e  6841              LDR      r1,[r0,#4]            ;1263
0000a0  e000              B        |L13.164|
                  |L13.162|
0000a2  e01d              B        |L13.224|
                  |L13.164|
0000a4  f44161e0          ORR      r1,r1,#0x700          ;1263
0000a8  6041              STR      r1,[r0,#4]            ;1263
0000aa  2000              MOVS     r0,#0                 ;1265
0000ac  e7be              B        |L13.44|
                  |L13.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1227
0000b0  6801              LDR      r1,[r0,#0]            ;1227
0000b2  f4216180          BIC      r1,r1,#0x400          ;1227
0000b6  6001              STR      r1,[r0,#0]            ;1227
0000b8  6820              LDR      r0,[r4,#0]            ;1230
0000ba  6941              LDR      r1,[r0,#0x14]         ;1230
0000bc  6981              LDR      r1,[r0,#0x18]         ;1230
0000be  9100              STR      r1,[sp,#0]            ;1233
0000c0  6801              LDR      r1,[r0,#0]            ;1233
0000c2  f4417100          ORR      r1,r1,#0x200          ;1233
0000c6  e009              B        |L13.220|
                  |L13.200|
0000c8  f4416100          ORR      r1,r1,#0x800          ;1238
0000cc  6001              STR      r1,[r0,#0]            ;1238
0000ce  6820              LDR      r0,[r4,#0]            ;1241
0000d0  6941              LDR      r1,[r0,#0x14]         ;1241
0000d2  6981              LDR      r1,[r0,#0x18]         ;1241
0000d4  9100              STR      r1,[sp,#0]            ;1244
0000d6  6801              LDR      r1,[r0,#0]            ;1244
0000d8  f4216180          BIC      r1,r1,#0x400          ;1244
                  |L13.220|
0000dc  6001              STR      r1,[r0,#0]            ;1244
0000de  e7db              B        |L13.152|
                  |L13.224|
0000e0  2002              MOVS     r0,#2                 ;1269
0000e2  e7a3              B        |L13.44|
;;;1272   
                          ENDP

                  |L13.228|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;531      */
;;;532    HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;533    {
000004  4604              MOV      r4,r0
;;;534      if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  f8dd8020          LDR      r8,[sp,#0x20]
00000e  461d              MOV      r5,r3                 ;533
000010  4617              MOV      r7,r2                 ;533
000012  4689              MOV      r9,r1                 ;533
000014  2820              CMP      r0,#0x20
000016  d17b              BNE      |L14.272|
;;;535      {
;;;536        if((pData == NULL) || (Size == 0))
000018  2f00              CMP      r7,#0
00001a  d07a              BEQ      |L14.274|
00001c  2d00              CMP      r5,#0
00001e  d07e              BEQ      |L14.286|
;;;537        {
;;;538          return  HAL_ERROR;
;;;539        }
;;;540    
;;;541        /* Wait until BUSY flag is reset */
;;;542        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000020  f2427310          MOV      r3,#0x2710
000024  2201              MOVS     r2,#1
000026  4940              LDR      r1,|L14.296|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  2800              CMP      r0,#0
000030  d177              BNE      |L14.290|
;;;543        {
;;;544          return HAL_BUSY;
;;;545        }
;;;546    
;;;547        /* Process Locked */
;;;548        __HAL_LOCK(hi2c);
000032  f8940034          LDRB     r0,[r4,#0x34]
000036  2801              CMP      r0,#1
000038  d073              BEQ      |L14.290|
00003a  2001              MOVS     r0,#1
00003c  f8840034          STRB     r0,[r4,#0x34]
;;;549    
;;;550        /* Disable Pos */
;;;551        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000040  6820              LDR      r0,[r4,#0]
000042  6801              LDR      r1,[r0,#0]
000044  f4216100          BIC      r1,r1,#0x800
000048  6001              STR      r1,[r0,#0]
;;;552    
;;;553        hi2c->State = HAL_I2C_STATE_BUSY_TX;
00004a  2021              MOVS     r0,#0x21
00004c  f8840035          STRB     r0,[r4,#0x35]
;;;554        hi2c->Mode = HAL_I2C_MODE_MASTER;
000050  2010              MOVS     r0,#0x10
000052  f8840036          STRB     r0,[r4,#0x36]
;;;555        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000056  2600              MOVS     r6,#0
000058  63a6              STR      r6,[r4,#0x38]
;;;556    
;;;557        /* Send Slave Address */
;;;558        if(I2C_MasterRequestWrite(hi2c, DevAddress, Timeout) != HAL_OK)
00005a  4642              MOV      r2,r8
00005c  4649              MOV      r1,r9
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_MasterRequestWrite
000064  b128              CBZ      r0,|L14.114|
;;;559        {
;;;560          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000066  6ba0              LDR      r0,[r4,#0x38]
;;;561          {
;;;562            /* Process Unlocked */
;;;563            __HAL_UNLOCK(hi2c);
;;;564            return HAL_ERROR;
;;;565          }
;;;566          else
;;;567          {
;;;568            /* Process Unlocked */
;;;569            __HAL_UNLOCK(hi2c);
000068  f8846034          STRB     r6,[r4,#0x34]
00006c  2804              CMP      r0,#4                 ;560
00006e  d056              BEQ      |L14.286|
000070  e00b              B        |L14.138|
                  |L14.114|
;;;570            return HAL_TIMEOUT;
;;;571          }
;;;572        }
;;;573    
;;;574        /* Clear ADDR flag */
;;;575        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000072  6820              LDR      r0,[r4,#0]
000074  6941              LDR      r1,[r0,#0x14]
000076  6980              LDR      r0,[r0,#0x18]
000078  9000              STR      r0,[sp,#0]
                  |L14.122|
;;;576    
;;;577        while(Size > 0)
;;;578        {
;;;579          /* Wait until TXE flag is set */
;;;580          if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
00007a  4641              MOV      r1,r8
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000082  b128              CBZ      r0,|L14.144|
                  |L14.132|
;;;581          {
;;;582            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000084  6ba0              LDR      r0,[r4,#0x38]
000086  2804              CMP      r0,#4
000088  d044              BEQ      |L14.276|
                  |L14.138|
;;;583            {
;;;584              /* Generate Stop */
;;;585              SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;586              return HAL_ERROR;
;;;587            }
;;;588            else
;;;589            {
;;;590              return HAL_TIMEOUT;
;;;591            }
;;;592          }
;;;593    
;;;594          /* Write data to DR */
;;;595          hi2c->Instance->DR = (*pData++);
;;;596          Size--;
;;;597    
;;;598          if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
;;;599          {
;;;600            /* Write data to DR */
;;;601            hi2c->Instance->DR = (*pData++);
;;;602            Size--;
;;;603          }
;;;604        }
;;;605    
;;;606        /* Wait until BTF flag is set */
;;;607        if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;608        {
;;;609          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;610          {
;;;611            /* Generate Stop */
;;;612            SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;613            return HAL_ERROR;
;;;614          }
;;;615          else
;;;616          {
;;;617            return HAL_TIMEOUT;
00008a  2003              MOVS     r0,#3
                  |L14.140|
;;;618          }
;;;619        }
;;;620    
;;;621        /* Generate Stop */
;;;622        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;623    
;;;624        hi2c->State = HAL_I2C_STATE_READY;
;;;625    
;;;626        /* Process Unlocked */
;;;627        __HAL_UNLOCK(hi2c);
;;;628    
;;;629        return HAL_OK;
;;;630      }
;;;631      else
;;;632      {
;;;633        return HAL_BUSY;
;;;634      }
;;;635    }
00008c  e8bd83f8          POP      {r3-r9,pc}
                  |L14.144|
000090  6821              LDR      r1,[r4,#0]            ;595
000092  f8170b01          LDRB     r0,[r7],#1            ;595
000096  6108              STR      r0,[r1,#0x10]         ;595
000098  6820              LDR      r0,[r4,#0]            ;598
00009a  1e6d              SUBS     r5,r5,#1              ;595
00009c  b2ad              UXTH     r5,r5                 ;596
00009e  6941              LDR      r1,[r0,#0x14]         ;598
0000a0  43c9              MVNS     r1,r1                 ;598
0000a2  0749              LSLS     r1,r1,#29             ;598
0000a4  d405              BMI      |L14.178|
0000a6  b135              CBZ      r5,|L14.182|
0000a8  f8171b01          LDRB     r1,[r7],#1            ;601
0000ac  6101              STR      r1,[r0,#0x10]         ;601
0000ae  1e6d              SUBS     r5,r5,#1              ;601
0000b0  b2ad              UXTH     r5,r5                 ;602
                  |L14.178|
0000b2  2d00              CMP      r5,#0                 ;577
0000b4  d1e1              BNE      |L14.122|
                  |L14.182|
0000b6  4645              MOV      r5,r8                 ;607
0000b8  f7fffffe          BL       HAL_GetTick
0000bc  4680              MOV      r8,r0                 ;607
0000be  2720              MOVS     r7,#0x20              ;607
0000c0  e016              B        |L14.240|
                  |L14.194|
0000c2  4620              MOV      r0,r4                 ;607
0000c4  f7fffffe          BL       I2C_IsAcknowledgeFailed
0000c8  2800              CMP      r0,#0                 ;607
0000ca  d1db              BNE      |L14.132|
0000cc  1c68              ADDS     r0,r5,#1              ;607
0000ce  d00f              BEQ      |L14.240|
0000d0  b12d              CBZ      r5,|L14.222|
0000d2  f7fffffe          BL       HAL_GetTick
0000d6  eba00008          SUB      r0,r0,r8              ;607
0000da  42a8              CMP      r0,r5                 ;607
0000dc  d908              BLS      |L14.240|
                  |L14.222|
0000de  6ba0              LDR      r0,[r4,#0x38]         ;607
0000e0  f0400120          ORR      r1,r0,#0x20           ;607
0000e4  63a1              STR      r1,[r4,#0x38]         ;607
0000e6  f8847035          STRB     r7,[r4,#0x35]         ;607
0000ea  f8846034          STRB     r6,[r4,#0x34]         ;607
0000ee  e7c9              B        |L14.132|
                  |L14.240|
0000f0  6820              LDR      r0,[r4,#0]            ;607
0000f2  6940              LDR      r0,[r0,#0x14]         ;607
0000f4  43c0              MVNS     r0,r0                 ;607
0000f6  0740              LSLS     r0,r0,#29             ;607
0000f8  d4e3              BMI      |L14.194|
0000fa  6820              LDR      r0,[r4,#0]            ;622
0000fc  6801              LDR      r1,[r0,#0]            ;622
0000fe  f4417100          ORR      r1,r1,#0x200          ;622
000102  6001              STR      r1,[r0,#0]            ;622
000104  f8847035          STRB     r7,[r4,#0x35]         ;624
000108  f8846034          STRB     r6,[r4,#0x34]         ;627
00010c  2000              MOVS     r0,#0                 ;629
00010e  e7bd              B        |L14.140|
                  |L14.272|
000110  e007              B        |L14.290|
                  |L14.274|
000112  e004              B        |L14.286|
                  |L14.276|
000114  6820              LDR      r0,[r4,#0]            ;612
000116  6801              LDR      r1,[r0,#0]            ;612
000118  f4417100          ORR      r1,r1,#0x200          ;612
00011c  6001              STR      r1,[r0,#0]            ;612
                  |L14.286|
00011e  2001              MOVS     r0,#1                 ;613
000120  e7b4              B        |L14.140|
                  |L14.290|
000122  2002              MOVS     r0,#2                 ;633
000124  e7b2              B        |L14.140|
;;;636    
                          ENDP

000126  0000              DCW      0x0000
                  |L14.296|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1397     */
;;;1398   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1399   {
000004  4604              MOV      r4,r0
;;;1400     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  461d              MOV      r5,r3                 ;1399
00000c  4617              MOV      r7,r2                 ;1399
00000e  4688              MOV      r8,r1                 ;1399
000010  2820              CMP      r0,#0x20
000012  d14c              BNE      |L15.174|
;;;1401     {
;;;1402       if((pData == NULL) || (Size == 0))
000014  b14f              CBZ      r7,|L15.42|
000016  b145              CBZ      r5,|L15.42|
;;;1403       {
;;;1404         return  HAL_ERROR;
;;;1405       }
;;;1406   
;;;1407       /* Wait until BUSY flag is reset */
;;;1408       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000018  f2427310          MOV      r3,#0x2710
00001c  2201              MOVS     r2,#1
00001e  4925              LDR      r1,|L15.180|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  bba0              CBNZ     r0,|L15.146|
000028  e002              B        |L15.48|
                  |L15.42|
00002a  2001              MOVS     r0,#1                 ;1404
                  |L15.44|
;;;1409       {
;;;1410         return HAL_BUSY;
;;;1411       }
;;;1412   
;;;1413       /* Process Locked */
;;;1414       __HAL_LOCK(hi2c);
;;;1415   
;;;1416       /* Disable Pos */
;;;1417       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1418   
;;;1419       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;1420       hi2c->Mode = HAL_I2C_MODE_MASTER;
;;;1421       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1422   
;;;1423       hi2c->pBuffPtr = pData;
;;;1424       hi2c->XferSize = Size;
;;;1425       hi2c->XferCount = Size;
;;;1426   
;;;1427       /* Set the I2C DMA transfert complete callback */
;;;1428       hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;1429   
;;;1430       /* Set the DMA error callback */
;;;1431       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1432   
;;;1433       /* Enable the DMA channel */
;;;1434       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
;;;1435   
;;;1436       /* Send Slave Address */
;;;1437       if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;1438       {
;;;1439         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1440         {
;;;1441           /* Process Unlocked */
;;;1442           __HAL_UNLOCK(hi2c);
;;;1443           return HAL_ERROR;
;;;1444         }
;;;1445         else
;;;1446         {
;;;1447           /* Process Unlocked */
;;;1448           __HAL_UNLOCK(hi2c);
;;;1449           return HAL_TIMEOUT;
;;;1450         }
;;;1451       }
;;;1452   
;;;1453       /* Enable DMA Request */
;;;1454       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;1455   
;;;1456       /* Clear ADDR flag */
;;;1457       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1458   
;;;1459       /* Process Unlocked */
;;;1460       __HAL_UNLOCK(hi2c);
;;;1461   
;;;1462       return HAL_OK;
;;;1463     }
;;;1464     else
;;;1465     {
;;;1466       return HAL_BUSY;
;;;1467     }
;;;1468   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L15.48|
000030  f8940034          LDRB     r0,[r4,#0x34]         ;1414
000034  2801              CMP      r0,#1                 ;1414
000036  d03a              BEQ      |L15.174|
000038  2001              MOVS     r0,#1                 ;1414
00003a  f8840034          STRB     r0,[r4,#0x34]         ;1414
00003e  6820              LDR      r0,[r4,#0]            ;1417
000040  6801              LDR      r1,[r0,#0]            ;1417
000042  f4216100          BIC      r1,r1,#0x800          ;1417
000046  6001              STR      r1,[r0,#0]            ;1417
000048  2021              MOVS     r0,#0x21              ;1419
00004a  f8840035          STRB     r0,[r4,#0x35]         ;1419
00004e  2010              MOVS     r0,#0x10              ;1420
000050  f8840036          STRB     r0,[r4,#0x36]         ;1420
000054  2600              MOVS     r6,#0                 ;1421
000056  63a6              STR      r6,[r4,#0x38]         ;1421
000058  6267              STR      r7,[r4,#0x24]         ;1424
00005a  8525              STRH     r5,[r4,#0x28]         ;1424
00005c  8565              STRH     r5,[r4,#0x2a]         ;1425
00005e  6ae1              LDR      r1,[r4,#0x2c]         ;1428
000060  4815              LDR      r0,|L15.184|
000062  462b              MOV      r3,r5                 ;1434
000064  6288              STR      r0,[r1,#0x28]         ;1431
000066  6ae1              LDR      r1,[r4,#0x2c]         ;1431
000068  4814              LDR      r0,|L15.188|
00006a  6308              STR      r0,[r1,#0x30]         ;1434
00006c  6822              LDR      r2,[r4,#0]            ;1434
00006e  4639              MOV      r1,r7                 ;1434
000070  3210              ADDS     r2,r2,#0x10           ;1434
000072  6ae0              LDR      r0,[r4,#0x2c]         ;1434
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  2223              MOVS     r2,#0x23              ;1437
00007a  4641              MOV      r1,r8                 ;1437
00007c  4620              MOV      r0,r4                 ;1437
00007e  f7fffffe          BL       I2C_MasterRequestWrite
000082  b138              CBZ      r0,|L15.148|
000084  6ba0              LDR      r0,[r4,#0x38]         ;1439
000086  f8846034          STRB     r6,[r4,#0x34]         ;1448
00008a  2804              CMP      r0,#4                 ;1439
00008c  d0cd              BEQ      |L15.42|
00008e  2003              MOVS     r0,#3                 ;1449
000090  e7cc              B        |L15.44|
                  |L15.146|
000092  e00c              B        |L15.174|
                  |L15.148|
000094  6820              LDR      r0,[r4,#0]            ;1454
000096  6841              LDR      r1,[r0,#4]            ;1454
000098  f4416100          ORR      r1,r1,#0x800          ;1454
00009c  6041              STR      r1,[r0,#4]            ;1454
00009e  6820              LDR      r0,[r4,#0]            ;1457
0000a0  6941              LDR      r1,[r0,#0x14]         ;1457
0000a2  6980              LDR      r0,[r0,#0x18]         ;1457
0000a4  9000              STR      r0,[sp,#0]            ;1460
0000a6  f8846034          STRB     r6,[r4,#0x34]         ;1460
0000aa  2000              MOVS     r0,#0                 ;1462
0000ac  e7be              B        |L15.44|
                  |L15.174|
0000ae  2002              MOVS     r0,#2                 ;1466
0000b0  e7bc              B        |L15.44|
;;;1469   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L15.180|
                          DCD      0x00100002
                  |L15.184|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L15.188|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1101     */
;;;1102   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1103   {
000004  4604              MOV      r4,r0
;;;1104     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  461e              MOV      r6,r3                 ;1103
00000c  4617              MOV      r7,r2                 ;1103
00000e  4688              MOV      r8,r1                 ;1103
000010  2820              CMP      r0,#0x20
000012  d13e              BNE      |L16.146|
;;;1105     {
;;;1106       if((pData == NULL) || (Size == 0))
000014  b14f              CBZ      r7,|L16.42|
000016  b146              CBZ      r6,|L16.42|
;;;1107       {
;;;1108         return  HAL_ERROR;
;;;1109       }
;;;1110   
;;;1111       /* Wait until BUSY flag is reset */
;;;1112       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000018  f2427310          MOV      r3,#0x2710
00001c  2201              MOVS     r2,#1
00001e  491e              LDR      r1,|L16.152|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  bb98              CBNZ     r0,|L16.144|
000028  e002              B        |L16.48|
                  |L16.42|
00002a  2001              MOVS     r0,#1                 ;1108
                  |L16.44|
;;;1113       {
;;;1114         return HAL_BUSY;
;;;1115       }
;;;1116   
;;;1117       /* Process Locked */
;;;1118       __HAL_LOCK(hi2c);
;;;1119   
;;;1120       /* Disable Pos */
;;;1121       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1122   
;;;1123       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;1124       hi2c->Mode = HAL_I2C_MODE_MASTER;
;;;1125       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1126   
;;;1127       hi2c->pBuffPtr = pData;
;;;1128       hi2c->XferSize = Size;
;;;1129       hi2c->XferCount = Size;
;;;1130   
;;;1131       /* Send Slave Address */
;;;1132       if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;1133       {
;;;1134         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1135         {
;;;1136           /* Process Unlocked */
;;;1137           __HAL_UNLOCK(hi2c);
;;;1138           return HAL_ERROR;
;;;1139         }
;;;1140         else
;;;1141         {
;;;1142           /* Process Unlocked */
;;;1143           __HAL_UNLOCK(hi2c);
;;;1144           return HAL_TIMEOUT;
;;;1145         }
;;;1146       }
;;;1147   
;;;1148       /* Clear ADDR flag */
;;;1149       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1150   
;;;1151       /* Process Unlocked */
;;;1152       __HAL_UNLOCK(hi2c);
;;;1153   
;;;1154       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1155                 to avoid the risk of I2C interrupt handle execution before current
;;;1156                 process unlock */
;;;1157   
;;;1158       /* Enable EVT, BUF and ERR interrupt */
;;;1159       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1160   
;;;1161       return HAL_OK;
;;;1162     }
;;;1163     else
;;;1164     {
;;;1165       return HAL_BUSY;
;;;1166     }
;;;1167   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L16.48|
000030  f8940034          LDRB     r0,[r4,#0x34]         ;1118
000034  2801              CMP      r0,#1                 ;1118
000036  d02c              BEQ      |L16.146|
000038  2001              MOVS     r0,#1                 ;1118
00003a  f8840034          STRB     r0,[r4,#0x34]         ;1118
00003e  6820              LDR      r0,[r4,#0]            ;1121
000040  6801              LDR      r1,[r0,#0]            ;1121
000042  f4216100          BIC      r1,r1,#0x800          ;1121
000046  6001              STR      r1,[r0,#0]            ;1121
000048  2021              MOVS     r0,#0x21              ;1123
00004a  f8840035          STRB     r0,[r4,#0x35]         ;1123
00004e  2010              MOVS     r0,#0x10              ;1124
000050  f8840036          STRB     r0,[r4,#0x36]         ;1124
000054  2500              MOVS     r5,#0                 ;1125
000056  63a5              STR      r5,[r4,#0x38]         ;1125
000058  6267              STR      r7,[r4,#0x24]         ;1128
00005a  8526              STRH     r6,[r4,#0x28]         ;1128
00005c  8566              STRH     r6,[r4,#0x2a]         ;1129
00005e  2223              MOVS     r2,#0x23              ;1132
000060  4641              MOV      r1,r8                 ;1132
000062  4620              MOV      r0,r4                 ;1132
000064  f7fffffe          BL       I2C_MasterRequestWrite
000068  b130              CBZ      r0,|L16.120|
00006a  6ba0              LDR      r0,[r4,#0x38]         ;1134
00006c  f8845034          STRB     r5,[r4,#0x34]         ;1143
000070  2804              CMP      r0,#4                 ;1134
000072  d0da              BEQ      |L16.42|
000074  2003              MOVS     r0,#3                 ;1144
000076  e7d9              B        |L16.44|
                  |L16.120|
000078  6820              LDR      r0,[r4,#0]            ;1149
00007a  6941              LDR      r1,[r0,#0x14]         ;1149
00007c  6981              LDR      r1,[r0,#0x18]         ;1149
00007e  9100              STR      r1,[sp,#0]            ;1152
000080  f8845034          STRB     r5,[r4,#0x34]         ;1152
000084  6841              LDR      r1,[r0,#4]            ;1159
000086  f44161e0          ORR      r1,r1,#0x700          ;1159
00008a  6041              STR      r1,[r0,#4]            ;1159
00008c  2000              MOVS     r0,#0                 ;1161
00008e  e7cd              B        |L16.44|
                  |L16.144|
000090  e7ff              B        |L16.146|
                  |L16.146|
000092  2002              MOVS     r0,#2                 ;1165
000094  e7ca              B        |L16.44|
;;;1168   
                          ENDP

000096  0000              DCW      0x0000
                  |L16.152|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;2836     */
;;;2837   __WEAK void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2838   {
;;;2839     /* Prevent unused argument(s) compilation warning */
;;;2840     UNUSED(hi2c);
;;;2841     /* NOTE : This function should not be modified, when the callback is needed,
;;;2842               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2843      */
;;;2844   }
;;;2845   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;2821     */
;;;2822    __WEAK void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2823   {
;;;2824     /* Prevent unused argument(s) compilation warning */
;;;2825     UNUSED(hi2c);
;;;2826     /* NOTE : This function should not be modified, when the callback is needed,
;;;2827               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2828      */
;;;2829   }
;;;2830   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;1853     */
;;;1854   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1855   {
000004  4604              MOV      r4,r0
000006  a80a              ADD      r0,sp,#0x28
000008  4698              MOV      r8,r3
00000a  e8900260          LDM      r0,{r5,r6,r9}
;;;1856     /* Check the parameters */
;;;1857     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;1858   
;;;1859     if(hi2c->State == HAL_I2C_STATE_READY)
00000e  f8940035          LDRB     r0,[r4,#0x35]
000012  4692              MOV      r10,r2                ;1855
000014  468b              MOV      r11,r1                ;1855
000016  2820              CMP      r0,#0x20
                  |L19.24|
000018  d17b              BNE      |L19.274|
;;;1860     {
;;;1861       if((pData == NULL) || (Size == 0))
00001a  2d00              CMP      r5,#0
00001c  d061              BEQ      |L19.226|
00001e  2e00              CMP      r6,#0
000020  d05f              BEQ      |L19.226|
;;;1862       {
;;;1863         return  HAL_ERROR;
;;;1864       }
;;;1865   
;;;1866       /* Wait until BUSY flag is reset */
;;;1867       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000022  f2427310          MOV      r3,#0x2710
000026  2201              MOVS     r2,#1
000028  4969              LDR      r1,|L19.464|
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000030  2800              CMP      r0,#0
000032  d1f1              BNE      |L19.24|
;;;1868       {
;;;1869         return HAL_BUSY;
;;;1870       }
;;;1871   
;;;1872       /* Process Locked */
;;;1873       __HAL_LOCK(hi2c);
000034  f8940034          LDRB     r0,[r4,#0x34]
000038  2801              CMP      r0,#1
00003a  d06a              BEQ      |L19.274|
00003c  2001              MOVS     r0,#1
00003e  f8840034          STRB     r0,[r4,#0x34]
;;;1874   
;;;1875       /* Disable Pos */
;;;1876       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f4216100          BIC      r1,r1,#0x800
00004a  6001              STR      r1,[r0,#0]
;;;1877   
;;;1878       hi2c->State = HAL_I2C_STATE_BUSY_RX;
00004c  2022              MOVS     r0,#0x22
00004e  f8840035          STRB     r0,[r4,#0x35]
;;;1879       hi2c->Mode = HAL_I2C_MODE_MEM;
000052  2040              MOVS     r0,#0x40
000054  f8840036          STRB     r0,[r4,#0x36]
;;;1880       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000058  2700              MOVS     r7,#0
00005a  63a7              STR      r7,[r4,#0x38]
;;;1881   
;;;1882       /* Send Slave Address and Memory Address */
;;;1883       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
00005c  4643              MOV      r3,r8
00005e  4652              MOV      r2,r10
000060  4659              MOV      r1,r11
000062  4620              MOV      r0,r4
000064  f8cd9000          STR      r9,[sp,#0]
000068  f7fffffe          BL       I2C_RequestMemoryRead
00006c  b128              CBZ      r0,|L19.122|
;;;1884       {
;;;1885         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00006e  6ba0              LDR      r0,[r4,#0x38]
;;;1886         {
;;;1887           /* Process Unlocked */
;;;1888           __HAL_UNLOCK(hi2c);
;;;1889           return HAL_ERROR;
;;;1890         }
;;;1891         else
;;;1892         {
;;;1893           /* Process Unlocked */
;;;1894           __HAL_UNLOCK(hi2c);
000070  f8847034          STRB     r7,[r4,#0x34]
000074  2804              CMP      r0,#4                 ;1885
000076  d034              BEQ      |L19.226|
000078  e072              B        |L19.352|
                  |L19.122|
;;;1895           return HAL_TIMEOUT;
;;;1896         }
;;;1897       }
;;;1898   
;;;1899       if(Size == 1)
00007a  2e01              CMP      r6,#1
00007c  d01a              BEQ      |L19.180|
;;;1900       {
;;;1901         /* Disable Acknowledge */
;;;1902         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1903   
;;;1904         /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;1905            software sequence must complete before the current byte end of transfer */
;;;1906         __disable_irq();
;;;1907   
;;;1908         /* Clear ADDR flag */
;;;1909         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1910   
;;;1911         /* Generate Stop */
;;;1912         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1913   
;;;1914         /* Re-enable IRQs */
;;;1915         __enable_irq(); 
;;;1916       }
;;;1917       else if(Size == 2)
;;;1918       {
;;;1919         /* Enable Pos */
;;;1920         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1921   
;;;1922         /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;1923            software sequence must complete before the current byte end of transfer */
;;;1924         __disable_irq();
;;;1925   
;;;1926         /* Clear ADDR flag */
;;;1927         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1928   
;;;1929         /* Disable Acknowledge */
;;;1930         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1931   
;;;1932          /* Re-enable IRQs */
;;;1933          __enable_irq(); 
;;;1934       }
;;;1935       else
;;;1936       {
;;;1937         /* Enable Acknowledge */
;;;1938         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
00007e  6820              LDR      r0,[r4,#0]
;;;1939   
;;;1940         /* Clear ADDR flag */
;;;1941         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1942       }
;;;1943   
;;;1944       while(Size > 0)
;;;1945       {
;;;1946         if(Size <= 3)
;;;1947         {
;;;1948           /* One byte */
;;;1949           if(Size== 1)
;;;1950           {
;;;1951             /* Wait until RXNE flag is set */
;;;1952             if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
;;;1953             {
;;;1954               if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;1955               {
;;;1956                 return HAL_TIMEOUT;
;;;1957               }
;;;1958               else
;;;1959               {
;;;1960                 return HAL_ERROR;
;;;1961               }
;;;1962             }
;;;1963   
;;;1964             /* Read data from DR */
;;;1965             (*pData++) = hi2c->Instance->DR;
;;;1966             Size--;
;;;1967           }
;;;1968           /* Two bytes */
;;;1969           else if(Size == 2)
;;;1970           {
;;;1971             /* Wait until BTF flag is set */
;;;1972             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
000080  f8df8150          LDR      r8,|L19.468|
000084  2e02              CMP      r6,#2                 ;1917
000086  6801              LDR      r1,[r0,#0]            ;1938
000088  d02e              BEQ      |L19.232|
00008a  f4416180          ORR      r1,r1,#0x400          ;1938
00008e  6001              STR      r1,[r0,#0]            ;1938
000090  6820              LDR      r0,[r4,#0]            ;1941
000092  6941              LDR      r1,[r0,#0x14]         ;1941
000094  6980              LDR      r0,[r0,#0x18]         ;1941
000096  9000              STR      r0,[sp,#0]            ;1941
                  |L19.152|
000098  2e03              CMP      r6,#3                 ;1946
00009a  d874              BHI      |L19.390|
00009c  2e01              CMP      r6,#1                 ;1949
00009e  d018              BEQ      |L19.210|
0000a0  2e02              CMP      r6,#2                 ;1969
0000a2  d02e              BEQ      |L19.258|
;;;1973             {
;;;1974               return HAL_TIMEOUT;
;;;1975             }
;;;1976   
;;;1977             /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;1978                software sequence must complete before the current byte end of transfer */
;;;1979              __disable_irq();
;;;1980   
;;;1981             /* Generate Stop */
;;;1982             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1983   
;;;1984             /* Read data from DR */
;;;1985             (*pData++) = hi2c->Instance->DR;
;;;1986             Size--;
;;;1987   
;;;1988             /* Re-enable IRQs */
;;;1989             __enable_irq();
;;;1990   
;;;1991             /* Read data from DR */
;;;1992             (*pData++) = hi2c->Instance->DR;
;;;1993             Size--;
;;;1994           }
;;;1995           /* 3 Last bytes */
;;;1996           else
;;;1997           {
;;;1998             /* Wait until BTF flag is set */
;;;1999             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
0000a4  464b              MOV      r3,r9
0000a6  2200              MOVS     r2,#0
0000a8  4641              MOV      r1,r8
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000b0  bb80              CBNZ     r0,|L19.276|
0000b2  e042              B        |L19.314|
                  |L19.180|
0000b4  6820              LDR      r0,[r4,#0]            ;1902
0000b6  6801              LDR      r1,[r0,#0]            ;1902
0000b8  f4216180          BIC      r1,r1,#0x400          ;1902
0000bc  6001              STR      r1,[r0,#0]            ;1902
0000be  b672              CPSID    i                     ;1906
0000c0  6820              LDR      r0,[r4,#0]            ;1909
0000c2  6941              LDR      r1,[r0,#0x14]         ;1909
0000c4  6981              LDR      r1,[r0,#0x18]         ;1909
0000c6  9100              STR      r1,[sp,#0]            ;1912
0000c8  6801              LDR      r1,[r0,#0]            ;1912
0000ca  f4417100          ORR      r1,r1,#0x200          ;1912
0000ce  6001              STR      r1,[r0,#0]            ;1912
0000d0  b662              CPSIE    i                     ;1915
                  |L19.210|
0000d2  4649              MOV      r1,r9                 ;1952
0000d4  4620              MOV      r0,r4                 ;1952
0000d6  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000da  b1e0              CBZ      r0,|L19.278|
                  |L19.220|
0000dc  6ba0              LDR      r0,[r4,#0x38]         ;1954
0000de  2820              CMP      r0,#0x20              ;1954
0000e0  d03e              BEQ      |L19.352|
                  |L19.226|
;;;2000             {
;;;2001               return HAL_TIMEOUT;
;;;2002             }
;;;2003   
;;;2004             /* Disable Acknowledge */
;;;2005             CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2006   
;;;2007             /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
;;;2008                software sequence must complete before the current byte end of transfer */
;;;2009             __disable_irq();
;;;2010   
;;;2011             /* Read data from DR */
;;;2012             (*pData++) = hi2c->Instance->DR;
;;;2013             Size--;
;;;2014   
;;;2015             /* Wait until BTF flag is set */
;;;2016             if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
;;;2017             {
;;;2018               return HAL_TIMEOUT;
;;;2019             }
;;;2020   
;;;2021             /* Generate Stop */
;;;2022             SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2023   
;;;2024             /* Read data from DR */
;;;2025             (*pData++) = hi2c->Instance->DR;
;;;2026             Size--;
;;;2027   
;;;2028             /* Re-enable IRQs */
;;;2029             __enable_irq(); 
;;;2030   
;;;2031             /* Read data from DR */
;;;2032             (*pData++) = hi2c->Instance->DR;
;;;2033             Size--;
;;;2034           }
;;;2035         }
;;;2036         else
;;;2037         {
;;;2038           /* Wait until RXNE flag is set */
;;;2039           if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
;;;2040           {
;;;2041             if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;2042             {
;;;2043               return HAL_TIMEOUT;
;;;2044             }
;;;2045             else
;;;2046             {
;;;2047               return HAL_ERROR;
0000e2  2001              MOVS     r0,#1
                  |L19.228|
;;;2048             }
;;;2049           }
;;;2050   
;;;2051           /* Read data from DR */
;;;2052           (*pData++) = hi2c->Instance->DR;
;;;2053           Size--;
;;;2054   
;;;2055           if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
;;;2056           {
;;;2057             /* Read data from DR */
;;;2058             (*pData++) = hi2c->Instance->DR;
;;;2059             Size--;
;;;2060           }
;;;2061         }
;;;2062       }
;;;2063   
;;;2064       hi2c->State = HAL_I2C_STATE_READY;
;;;2065       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;2066   
;;;2067       /* Process Unlocked */
;;;2068       __HAL_UNLOCK(hi2c);
;;;2069   
;;;2070       return HAL_OK;
;;;2071     }
;;;2072     else
;;;2073     {
;;;2074       return HAL_BUSY;
;;;2075     }
;;;2076   }
0000e4  e8bd8ff8          POP      {r3-r11,pc}
                  |L19.232|
0000e8  f4416100          ORR      r1,r1,#0x800          ;1920
0000ec  6001              STR      r1,[r0,#0]            ;1920
0000ee  b672              CPSID    i                     ;1924
0000f0  6820              LDR      r0,[r4,#0]            ;1927
0000f2  6941              LDR      r1,[r0,#0x14]         ;1927
0000f4  6981              LDR      r1,[r0,#0x18]         ;1927
0000f6  9100              STR      r1,[sp,#0]            ;1930
0000f8  6801              LDR      r1,[r0,#0]            ;1930
0000fa  f4216180          BIC      r1,r1,#0x400          ;1930
0000fe  6001              STR      r1,[r0,#0]            ;1930
000100  b662              CPSIE    i                     ;1933
                  |L19.258|
000102  464b              MOV      r3,r9                 ;1972
000104  2200              MOVS     r2,#0                 ;1972
000106  4641              MOV      r1,r8                 ;1972
000108  4620              MOV      r0,r4                 ;1972
00010a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00010e  b908              CBNZ     r0,|L19.276|
000110  e005              B        |L19.286|
                  |L19.274|
000112  e05a              B        |L19.458|
                  |L19.276|
000114  e024              B        |L19.352|
                  |L19.278|
000116  6820              LDR      r0,[r4,#0]            ;1965
000118  6900              LDR      r0,[r0,#0x10]         ;1965
00011a  7028              STRB     r0,[r5,#0]            ;1965
00011c  e04c              B        |L19.440|
                  |L19.286|
00011e  b672              CPSID    i                     ;1979
000120  6820              LDR      r0,[r4,#0]            ;1982
000122  6801              LDR      r1,[r0,#0]            ;1982
000124  f4417100          ORR      r1,r1,#0x200          ;1982
000128  6001              STR      r1,[r0,#0]            ;1982
00012a  6820              LDR      r0,[r4,#0]            ;1985
00012c  6900              LDR      r0,[r0,#0x10]         ;1985
00012e  7028              STRB     r0,[r5,#0]            ;1985
000130  b662              CPSIE    i                     ;1989
000132  6820              LDR      r0,[r4,#0]            ;1992
000134  6900              LDR      r0,[r0,#0x10]         ;1992
000136  7068              STRB     r0,[r5,#1]            ;1992
000138  e03e              B        |L19.440|
                  |L19.314|
00013a  6820              LDR      r0,[r4,#0]            ;2005
00013c  6801              LDR      r1,[r0,#0]            ;2005
00013e  f4216180          BIC      r1,r1,#0x400          ;2005
000142  6001              STR      r1,[r0,#0]            ;2005
000144  b672              CPSID    i                     ;2009
000146  6820              LDR      r0,[r4,#0]            ;2012
000148  6900              LDR      r0,[r0,#0x10]         ;2012
00014a  f8050b01          STRB     r0,[r5],#1            ;2012
00014e  1e76              SUBS     r6,r6,#1              ;2012
000150  b2b6              UXTH     r6,r6                 ;2013
000152  464b              MOV      r3,r9                 ;2016
000154  2200              MOVS     r2,#0                 ;2016
000156  4641              MOV      r1,r8                 ;2016
000158  4620              MOV      r0,r4                 ;2016
00015a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00015e  b108              CBZ      r0,|L19.356|
                  |L19.352|
000160  2003              MOVS     r0,#3                 ;2043
000162  e7bf              B        |L19.228|
                  |L19.356|
000164  6820              LDR      r0,[r4,#0]            ;2022
000166  6801              LDR      r1,[r0,#0]            ;2022
000168  f4417100          ORR      r1,r1,#0x200          ;2022
00016c  6001              STR      r1,[r0,#0]            ;2022
00016e  6820              LDR      r0,[r4,#0]            ;2025
000170  6900              LDR      r0,[r0,#0x10]         ;2025
000172  f8050b01          STRB     r0,[r5],#1            ;2025
000176  b662              CPSIE    i                     ;2029
000178  6820              LDR      r0,[r4,#0]            ;2032
00017a  6900              LDR      r0,[r0,#0x10]         ;2032
00017c  f8050b01          STRB     r0,[r5],#1            ;2032
000180  1eb6              SUBS     r6,r6,#2              ;2032
000182  e015              B        |L19.432|
000184  e7ff              B        |L19.390|
                  |L19.390|
000186  4649              MOV      r1,r9                 ;2039
000188  4620              MOV      r0,r4                 ;2039
00018a  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
00018e  2800              CMP      r0,#0                 ;2039
000190  d1a4              BNE      |L19.220|
000192  6820              LDR      r0,[r4,#0]            ;2052
000194  6900              LDR      r0,[r0,#0x10]         ;2052
000196  f8050b01          STRB     r0,[r5],#1            ;2052
00019a  6820              LDR      r0,[r4,#0]            ;2055
00019c  1e76              SUBS     r6,r6,#1              ;2052
00019e  b2b6              UXTH     r6,r6                 ;2053
0001a0  6941              LDR      r1,[r0,#0x14]         ;2055
0001a2  43c9              MVNS     r1,r1                 ;2055
0001a4  0749              LSLS     r1,r1,#29             ;2055
0001a6  d404              BMI      |L19.434|
0001a8  6900              LDR      r0,[r0,#0x10]         ;2058
0001aa  f8050b01          STRB     r0,[r5],#1            ;2058
0001ae  1e76              SUBS     r6,r6,#1              ;2058
                  |L19.432|
0001b0  b2b6              UXTH     r6,r6                 ;2059
                  |L19.434|
0001b2  2e00              CMP      r6,#0                 ;1944
0001b4  f47faf70          BNE      |L19.152|
                  |L19.440|
0001b8  2020              MOVS     r0,#0x20              ;2064
0001ba  f8840035          STRB     r0,[r4,#0x35]         ;2064
0001be  f8847036          STRB     r7,[r4,#0x36]         ;2065
0001c2  f8847034          STRB     r7,[r4,#0x34]         ;2068
0001c6  2000              MOVS     r0,#0                 ;2070
0001c8  e78c              B        |L19.228|
                  |L19.458|
0001ca  2002              MOVS     r0,#2                 ;2074
0001cc  e78a              B        |L19.228|
;;;2077   
                          ENDP

0001ce  0000              DCW      0x0000
                  |L19.464|
                          DCD      0x00100002
                  |L19.468|
                          DCD      0x00010004

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;2359     */
;;;2360   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2361   {
000004  4604              MOV      r4,r0
000006  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;2362     /* Check the parameters */
;;;2363     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2364   
;;;2365     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f8900035          LDRB     r0,[r0,#0x35]
00000e  4698              MOV      r8,r3                 ;2361
000010  4691              MOV      r9,r2                 ;2361
000012  468a              MOV      r10,r1                ;2361
000014  2820              CMP      r0,#0x20
000016  d15b              BNE      |L20.208|
;;;2366     {
;;;2367       if((pData == NULL) || (Size == 0))
000018  b14f              CBZ      r7,|L20.46|
00001a  b145              CBZ      r5,|L20.46|
;;;2368       {
;;;2369         return  HAL_ERROR;
;;;2370       }
;;;2371   
;;;2372       /* Wait until BUSY flag is reset */
;;;2373       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
00001c  f2427310          MOV      r3,#0x2710
000020  2201              MOVS     r2,#1
000022  492c              LDR      r1,|L20.212|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  bbb8              CBNZ     r0,|L20.156|
00002c  e002              B        |L20.52|
                  |L20.46|
00002e  2001              MOVS     r0,#1                 ;2369
                  |L20.48|
;;;2374       {
;;;2375         return HAL_BUSY;
;;;2376       }
;;;2377   
;;;2378       /* Process Locked */
;;;2379       __HAL_LOCK(hi2c);
;;;2380   
;;;2381       /* Disable Pos */
;;;2382       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2383   
;;;2384       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;2385       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2386       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2387   
;;;2388       hi2c->pBuffPtr = pData;
;;;2389       hi2c->XferSize = Size;
;;;2390       hi2c->XferCount = Size;
;;;2391   
;;;2392       /* Set the I2C DMA transfert complete callback */
;;;2393       hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
;;;2394   
;;;2395       /* Set the DMA error callback */
;;;2396       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2397   
;;;2398       /* Enable the DMA channel */
;;;2399       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
;;;2400   
;;;2401       /* Send Slave Address and Memory Address */
;;;2402       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;2403       {
;;;2404         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2405         {
;;;2406           /* Process Unlocked */
;;;2407           __HAL_UNLOCK(hi2c);
;;;2408           return HAL_ERROR;
;;;2409         }
;;;2410         else
;;;2411         {
;;;2412           /* Process Unlocked */
;;;2413           __HAL_UNLOCK(hi2c);
;;;2414           return HAL_TIMEOUT;
;;;2415         }
;;;2416       }
;;;2417   
;;;2418       if(Size == 1)
;;;2419       {
;;;2420         /* Disable Acknowledge */
;;;2421         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2422       }
;;;2423       else
;;;2424       {
;;;2425         /* Enable Last DMA bit */
;;;2426         SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
;;;2427       }
;;;2428   
;;;2429       /* Enable DMA Request */
;;;2430       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2431   
;;;2432       /* Clear ADDR flag */
;;;2433       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2434   
;;;2435       /* Process Unlocked */
;;;2436       __HAL_UNLOCK(hi2c);
;;;2437   
;;;2438       return HAL_OK;
;;;2439     }
;;;2440     else
;;;2441     {
;;;2442       return HAL_BUSY;
;;;2443     }
;;;2444   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.52|
000034  f8940034          LDRB     r0,[r4,#0x34]         ;2379
000038  2801              CMP      r0,#1                 ;2379
00003a  d049              BEQ      |L20.208|
00003c  2001              MOVS     r0,#1                 ;2379
00003e  f8840034          STRB     r0,[r4,#0x34]         ;2379
000042  6820              LDR      r0,[r4,#0]            ;2382
000044  6801              LDR      r1,[r0,#0]            ;2382
000046  f4216100          BIC      r1,r1,#0x800          ;2382
00004a  6001              STR      r1,[r0,#0]            ;2382
00004c  2022              MOVS     r0,#0x22              ;2384
00004e  f8840035          STRB     r0,[r4,#0x35]         ;2384
000052  2040              MOVS     r0,#0x40              ;2385
000054  f8840036          STRB     r0,[r4,#0x36]         ;2385
000058  2600              MOVS     r6,#0                 ;2386
00005a  63a6              STR      r6,[r4,#0x38]         ;2386
00005c  6267              STR      r7,[r4,#0x24]         ;2389
00005e  8525              STRH     r5,[r4,#0x28]         ;2389
000060  8565              STRH     r5,[r4,#0x2a]         ;2390
000062  6b21              LDR      r1,[r4,#0x30]         ;2393
000064  481c              LDR      r0,|L20.216|
000066  462b              MOV      r3,r5                 ;2399
000068  6288              STR      r0,[r1,#0x28]         ;2396
00006a  6b21              LDR      r1,[r4,#0x30]         ;2396
00006c  481b              LDR      r0,|L20.220|
00006e  463a              MOV      r2,r7                 ;2399
000070  6308              STR      r0,[r1,#0x30]         ;2399
000072  6821              LDR      r1,[r4,#0]            ;2399
000074  6b20              LDR      r0,[r4,#0x30]         ;2399
000076  3110              ADDS     r1,r1,#0x10           ;2399
000078  f7fffffe          BL       HAL_DMA_Start_IT
00007c  2023              MOVS     r0,#0x23              ;2402
00007e  9000              STR      r0,[sp,#0]            ;2402
000080  4643              MOV      r3,r8                 ;2402
000082  464a              MOV      r2,r9                 ;2402
000084  4651              MOV      r1,r10                ;2402
000086  4620              MOV      r0,r4                 ;2402
000088  f7fffffe          BL       I2C_RequestMemoryRead
00008c  b138              CBZ      r0,|L20.158|
00008e  6ba0              LDR      r0,[r4,#0x38]         ;2404
000090  f8846034          STRB     r6,[r4,#0x34]         ;2413
000094  2804              CMP      r0,#4                 ;2404
000096  d0ca              BEQ      |L20.46|
000098  2003              MOVS     r0,#3                 ;2414
00009a  e7c9              B        |L20.48|
                  |L20.156|
00009c  e018              B        |L20.208|
                  |L20.158|
00009e  6820              LDR      r0,[r4,#0]            ;2418
0000a0  2d01              CMP      r5,#1                 ;2418
0000a2  d010              BEQ      |L20.198|
0000a4  6841              LDR      r1,[r0,#4]            ;2426
0000a6  f4415180          ORR      r1,r1,#0x1000         ;2426
0000aa  6041              STR      r1,[r0,#4]            ;2426
                  |L20.172|
0000ac  6820              LDR      r0,[r4,#0]            ;2430
0000ae  6841              LDR      r1,[r0,#4]            ;2430
0000b0  f4416100          ORR      r1,r1,#0x800          ;2430
0000b4  6041              STR      r1,[r0,#4]            ;2430
0000b6  6820              LDR      r0,[r4,#0]            ;2433
0000b8  6941              LDR      r1,[r0,#0x14]         ;2433
0000ba  6980              LDR      r0,[r0,#0x18]         ;2433
0000bc  9000              STR      r0,[sp,#0]            ;2436
0000be  f8846034          STRB     r6,[r4,#0x34]         ;2436
0000c2  2000              MOVS     r0,#0                 ;2438
0000c4  e7b4              B        |L20.48|
                  |L20.198|
0000c6  6801              LDR      r1,[r0,#0]            ;2421
0000c8  f4216180          BIC      r1,r1,#0x400          ;2421
0000cc  6001              STR      r1,[r0,#0]            ;2421
0000ce  e7ed              B        |L20.172|
                  |L20.208|
0000d0  2002              MOVS     r0,#2                 ;2442
0000d2  e7ad              B        |L20.48|
;;;2445   
                          ENDP

                  |L20.212|
                          DCD      0x00100002
                  |L20.216|
                          DCD      I2C_DMAMemReceiveCplt
                  |L20.220|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2166     */
;;;2167   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2168   {
000004  4604              MOV      r4,r0
000006  e9dd760a          LDRD     r7,r6,[sp,#0x28]
;;;2169     /* Check the parameters */
;;;2170     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2171   
;;;2172     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f8900035          LDRB     r0,[r0,#0x35]
00000e  4698              MOV      r8,r3                 ;2168
000010  4691              MOV      r9,r2                 ;2168
000012  468a              MOV      r10,r1                ;2168
000014  2820              CMP      r0,#0x20
000016  d167              BNE      |L21.232|
;;;2173     {
;;;2174       if((pData == NULL) || (Size == 0))
000018  b157              CBZ      r7,|L21.48|
00001a  b14e              CBZ      r6,|L21.48|
;;;2175       {
;;;2176         return  HAL_ERROR;
;;;2177       }
;;;2178   
;;;2179       /* Wait until BUSY flag is reset */
;;;2180       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
00001c  f2427310          MOV      r3,#0x2710
000020  2201              MOVS     r2,#1
000022  4932              LDR      r1,|L21.236|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  2800              CMP      r0,#0
00002c  d15c              BNE      |L21.232|
00002e  e002              B        |L21.54|
                  |L21.48|
000030  2001              MOVS     r0,#1                 ;2176
                  |L21.50|
;;;2181       {
;;;2182         return HAL_BUSY;
;;;2183       }
;;;2184   
;;;2185       /* Process Locked */
;;;2186       __HAL_LOCK(hi2c);
;;;2187   
;;;2188       /* Disable Pos */
;;;2189       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2190   
;;;2191       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;2192       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2193       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2194   
;;;2195       hi2c->pBuffPtr = pData;
;;;2196       hi2c->XferSize = Size;
;;;2197       hi2c->XferCount = Size;
;;;2198   
;;;2199       /* Send Slave Address and Memory Address */
;;;2200       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;2201       {
;;;2202         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2203         {
;;;2204           /* Process Unlocked */
;;;2205           __HAL_UNLOCK(hi2c);
;;;2206           return HAL_ERROR;
;;;2207         }
;;;2208         else
;;;2209         {
;;;2210           /* Process Unlocked */
;;;2211           __HAL_UNLOCK(hi2c);
;;;2212           return HAL_TIMEOUT;
;;;2213         }
;;;2214       }
;;;2215   
;;;2216       if(hi2c->XferCount == 1)
;;;2217       {
;;;2218         /* Disable Acknowledge */
;;;2219         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2220   
;;;2221         /* Clear ADDR flag */
;;;2222         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2223   
;;;2224         /* Generate Stop */
;;;2225         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;2226       }
;;;2227       else if(hi2c->XferCount == 2)
;;;2228       {
;;;2229         /* Enable Pos */
;;;2230         SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2231   
;;;2232         /* Clear ADDR flag */
;;;2233         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2234   
;;;2235         /* Disable Acknowledge */
;;;2236         CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2237       }
;;;2238       else
;;;2239       {
;;;2240         /* Enable Acknowledge */
;;;2241         SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;2242   
;;;2243         /* Clear ADDR flag */
;;;2244         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;2245       }
;;;2246   
;;;2247       /* Process Unlocked */
;;;2248       __HAL_UNLOCK(hi2c);
;;;2249   
;;;2250       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2251                 to avoid the risk of I2C interrupt handle execution before current
;;;2252                 process unlock */
;;;2253   
;;;2254       /* Enable EVT, BUF and ERR interrupt */
;;;2255       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2256   
;;;2257       return HAL_OK;
;;;2258     }
;;;2259     else
;;;2260     {
;;;2261       return HAL_BUSY;
;;;2262     }
;;;2263   }
000032  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.54|
000036  f8940034          LDRB     r0,[r4,#0x34]         ;2186
00003a  2801              CMP      r0,#1                 ;2186
00003c  d054              BEQ      |L21.232|
00003e  2001              MOVS     r0,#1                 ;2186
000040  f8840034          STRB     r0,[r4,#0x34]         ;2186
000044  6820              LDR      r0,[r4,#0]            ;2189
000046  6801              LDR      r1,[r0,#0]            ;2189
000048  f4216100          BIC      r1,r1,#0x800          ;2189
00004c  6001              STR      r1,[r0,#0]            ;2189
00004e  2022              MOVS     r0,#0x22              ;2191
000050  f8840035          STRB     r0,[r4,#0x35]         ;2191
000054  2040              MOVS     r0,#0x40              ;2192
000056  f8840036          STRB     r0,[r4,#0x36]         ;2192
00005a  2500              MOVS     r5,#0                 ;2193
00005c  63a5              STR      r5,[r4,#0x38]         ;2193
00005e  6267              STR      r7,[r4,#0x24]         ;2196
000060  8526              STRH     r6,[r4,#0x28]         ;2196
000062  8566              STRH     r6,[r4,#0x2a]         ;2197
000064  2023              MOVS     r0,#0x23              ;2200
000066  9000              STR      r0,[sp,#0]            ;2200
000068  4643              MOV      r3,r8                 ;2200
00006a  464a              MOV      r2,r9                 ;2200
00006c  4651              MOV      r1,r10                ;2200
00006e  4620              MOV      r0,r4                 ;2200
000070  f7fffffe          BL       I2C_RequestMemoryRead
000074  b130              CBZ      r0,|L21.132|
000076  6ba0              LDR      r0,[r4,#0x38]         ;2202
000078  f8845034          STRB     r5,[r4,#0x34]         ;2211
00007c  2804              CMP      r0,#4                 ;2202
00007e  d0d7              BEQ      |L21.48|
000080  2003              MOVS     r0,#3                 ;2212
000082  e7d6              B        |L21.50|
                  |L21.132|
000084  8d60              LDRH     r0,[r4,#0x2a]         ;2216
000086  2801              CMP      r0,#1                 ;2216
000088  d015              BEQ      |L21.182|
00008a  8d60              LDRH     r0,[r4,#0x2a]         ;2227
00008c  2802              CMP      r0,#2                 ;2227
00008e  6820              LDR      r0,[r4,#0]            ;2241
000090  6801              LDR      r1,[r0,#0]            ;2241
000092  d01d              BEQ      |L21.208|
000094  f4416180          ORR      r1,r1,#0x400          ;2241
000098  6001              STR      r1,[r0,#0]            ;2241
00009a  6820              LDR      r0,[r4,#0]            ;2244
00009c  6941              LDR      r1,[r0,#0x14]         ;2244
00009e  6980              LDR      r0,[r0,#0x18]         ;2244
0000a0  f8cd0000          STR.W    r0,[sp,#0]            ;2244
                  |L21.164|
0000a4  f8845034          STRB     r5,[r4,#0x34]         ;2248
0000a8  6820              LDR      r0,[r4,#0]            ;2255
0000aa  6841              LDR      r1,[r0,#4]            ;2255
0000ac  f44161e0          ORR      r1,r1,#0x700          ;2255
0000b0  6041              STR      r1,[r0,#4]            ;2255
0000b2  2000              MOVS     r0,#0                 ;2257
0000b4  e7bd              B        |L21.50|
                  |L21.182|
0000b6  6820              LDR      r0,[r4,#0]            ;2219
0000b8  6801              LDR      r1,[r0,#0]            ;2219
0000ba  f4216180          BIC      r1,r1,#0x400          ;2219
0000be  6001              STR      r1,[r0,#0]            ;2219
0000c0  6820              LDR      r0,[r4,#0]            ;2222
0000c2  6941              LDR      r1,[r0,#0x14]         ;2222
0000c4  6981              LDR      r1,[r0,#0x18]         ;2222
0000c6  9100              STR      r1,[sp,#0]            ;2225
0000c8  6801              LDR      r1,[r0,#0]            ;2225
0000ca  f4417100          ORR      r1,r1,#0x200          ;2225
0000ce  e009              B        |L21.228|
                  |L21.208|
0000d0  f4416100          ORR      r1,r1,#0x800          ;2230
0000d4  6001              STR      r1,[r0,#0]            ;2230
0000d6  6820              LDR      r0,[r4,#0]            ;2233
0000d8  6941              LDR      r1,[r0,#0x14]         ;2233
0000da  6981              LDR      r1,[r0,#0x18]         ;2233
0000dc  9100              STR      r1,[sp,#0]            ;2236
0000de  6801              LDR      r1,[r0,#0]            ;2236
0000e0  f4216180          BIC      r1,r1,#0x400          ;2236
                  |L21.228|
0000e4  6001              STR      r1,[r0,#0]            ;2236
0000e6  e7dd              B        |L21.164|
                  |L21.232|
0000e8  2002              MOVS     r0,#2                 ;2261
0000ea  e7a2              B        |L21.50|
;;;2264   
                          ENDP

                  |L21.236|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;1735     */
;;;1736   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1737   {
000004  4604              MOV      r4,r0
000006  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;1738     /* Check the parameters */
;;;1739     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;1740   
;;;1741     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f8900035          LDRB     r0,[r0,#0x35]
00000e  f8dd8030          LDR      r8,[sp,#0x30]
000012  4699              MOV      r9,r3                 ;1737
000014  4692              MOV      r10,r2                ;1737
000016  468b              MOV      r11,r1                ;1737
000018  2820              CMP      r0,#0x20
00001a  d168              BNE      |L22.238|
;;;1742     {
;;;1743       if((pData == NULL) || (Size == 0))
00001c  2e00              CMP      r6,#0
00001e  d064              BEQ      |L22.234|
000020  2d00              CMP      r5,#0
000022  d062              BEQ      |L22.234|
;;;1744       {
;;;1745         return  HAL_ERROR;
;;;1746       }
;;;1747   
;;;1748       /* Wait until BUSY flag is reset */
;;;1749       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000024  f2427310          MOV      r3,#0x2710
000028  2201              MOVS     r2,#1
00002a  4932              LDR      r1,|L22.244|
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000032  bbe8              CBNZ     r0,|L22.176|
;;;1750       {
;;;1751         return HAL_BUSY;
;;;1752       }
;;;1753   
;;;1754       /* Process Locked */
;;;1755       __HAL_LOCK(hi2c);
000034  f8940034          LDRB     r0,[r4,#0x34]
000038  2801              CMP      r0,#1
00003a  d058              BEQ      |L22.238|
00003c  2001              MOVS     r0,#1
00003e  f8840034          STRB     r0,[r4,#0x34]
;;;1756   
;;;1757       /* Disable Pos */
;;;1758       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f4216100          BIC      r1,r1,#0x800
00004a  6001              STR      r1,[r0,#0]
;;;1759   
;;;1760       hi2c->State = HAL_I2C_STATE_BUSY_TX;
00004c  2021              MOVS     r0,#0x21
00004e  f8840035          STRB     r0,[r4,#0x35]
;;;1761       hi2c->Mode = HAL_I2C_MODE_MEM;
000052  2040              MOVS     r0,#0x40
000054  f8840036          STRB     r0,[r4,#0x36]
;;;1762       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000058  2700              MOVS     r7,#0
00005a  63a7              STR      r7,[r4,#0x38]
;;;1763   
;;;1764       /* Send Slave Address and Memory Address */
;;;1765       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
00005c  464b              MOV      r3,r9
00005e  4652              MOV      r2,r10
000060  4659              MOV      r1,r11
000062  4620              MOV      r0,r4
000064  f8cd8000          STR      r8,[sp,#0]
000068  f7fffffe          BL       I2C_RequestMemoryWrite
00006c  b128              CBZ      r0,|L22.122|
;;;1766       {
;;;1767         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00006e  6ba0              LDR      r0,[r4,#0x38]
;;;1768         {
;;;1769           /* Process Unlocked */
;;;1770           __HAL_UNLOCK(hi2c);
;;;1771           return HAL_ERROR;
;;;1772         }
;;;1773         else
;;;1774         {
;;;1775           /* Process Unlocked */
;;;1776           __HAL_UNLOCK(hi2c);
000070  f8847034          STRB     r7,[r4,#0x34]
000074  2804              CMP      r0,#4                 ;1767
000076  d038              BEQ      |L22.234|
000078  e007              B        |L22.138|
                  |L22.122|
;;;1777           return HAL_TIMEOUT;
;;;1778         }
;;;1779       }
;;;1780   
;;;1781       while(Size > 0)
;;;1782       {
;;;1783         /* Wait until TXE flag is set */
;;;1784         if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
00007a  4641              MOV      r1,r8
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000082  b128              CBZ      r0,|L22.144|
                  |L22.132|
;;;1785         {
;;;1786           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000084  6ba0              LDR      r0,[r4,#0x38]
000086  2804              CMP      r0,#4
000088  d02a              BEQ      |L22.224|
                  |L22.138|
;;;1787           {
;;;1788             /* Generate Stop */
;;;1789             SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;1790             return HAL_ERROR;
;;;1791           }
;;;1792           else
;;;1793           {
;;;1794             return HAL_TIMEOUT;
;;;1795           }
;;;1796         }
;;;1797   
;;;1798         /* Write data to DR */
;;;1799         hi2c->Instance->DR = (*pData++);
;;;1800         Size--;
;;;1801   
;;;1802         if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
;;;1803         {
;;;1804           /* Write data to DR */
;;;1805           hi2c->Instance->DR = (*pData++);
;;;1806           Size--;
;;;1807         }
;;;1808       }
;;;1809   
;;;1810       /* Wait until TXE flag is set */
;;;1811       if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;1812       {
;;;1813         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1814         {
;;;1815           /* Generate Stop */
;;;1816           SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;1817           return HAL_ERROR;
;;;1818         }
;;;1819         else
;;;1820         {
;;;1821           return HAL_TIMEOUT;
00008a  2003              MOVS     r0,#3
                  |L22.140|
;;;1822         }
;;;1823       }
;;;1824   
;;;1825       /* Generate Stop */
;;;1826       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;1827   
;;;1828       hi2c->State = HAL_I2C_STATE_READY;
;;;1829       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1830   
;;;1831       /* Process Unlocked */
;;;1832       __HAL_UNLOCK(hi2c);
;;;1833   
;;;1834       return HAL_OK;
;;;1835     }
;;;1836     else
;;;1837     {
;;;1838       return HAL_BUSY;
;;;1839     }
;;;1840   }
00008c  e8bd8ff8          POP      {r3-r11,pc}
                  |L22.144|
000090  6821              LDR      r1,[r4,#0]            ;1799
000092  f8160b01          LDRB     r0,[r6],#1            ;1799
000096  6108              STR      r0,[r1,#0x10]         ;1799
000098  6820              LDR      r0,[r4,#0]            ;1802
00009a  1e6d              SUBS     r5,r5,#1              ;1799
00009c  b2ad              UXTH     r5,r5                 ;1800
00009e  6941              LDR      r1,[r0,#0x14]         ;1802
0000a0  43c9              MVNS     r1,r1                 ;1802
0000a2  0749              LSLS     r1,r1,#29             ;1802
0000a4  d407              BMI      |L22.182|
0000a6  b145              CBZ      r5,|L22.186|
0000a8  f8161b01          LDRB     r1,[r6],#1            ;1805
0000ac  6101              STR      r1,[r0,#0x10]         ;1805
0000ae  e000              B        |L22.178|
                  |L22.176|
0000b0  e01d              B        |L22.238|
                  |L22.178|
0000b2  1e6d              SUBS     r5,r5,#1              ;1805
0000b4  b2ad              UXTH     r5,r5                 ;1806
                  |L22.182|
0000b6  2d00              CMP      r5,#0                 ;1781
0000b8  d1df              BNE      |L22.122|
                  |L22.186|
0000ba  4641              MOV      r1,r8                 ;1811
0000bc  4620              MOV      r0,r4                 ;1811
0000be  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000c2  2800              CMP      r0,#0                 ;1811
0000c4  d1de              BNE      |L22.132|
0000c6  f8540b35          LDR      r0,[r4],#0x35         ;1826
0000ca  6801              LDR      r1,[r0,#0]            ;1826
0000cc  f4417100          ORR      r1,r1,#0x200          ;1826
0000d0  6001              STR      r1,[r0,#0]            ;1826
0000d2  2020              MOVS     r0,#0x20              ;1828
0000d4  f804091e          STRB     r0,[r4],#-0x1e        ;1828
0000d8  77e7              STRB     r7,[r4,#0x1f]         ;1829
0000da  7767              STRB     r7,[r4,#0x1d]         ;1832
0000dc  2000              MOVS     r0,#0                 ;1834
0000de  e7d5              B        |L22.140|
                  |L22.224|
0000e0  6820              LDR      r0,[r4,#0]            ;1816
0000e2  6801              LDR      r1,[r0,#0]            ;1816
0000e4  f4417100          ORR      r1,r1,#0x200          ;1816
0000e8  6001              STR      r1,[r0,#0]            ;1816
                  |L22.234|
0000ea  2001              MOVS     r0,#1                 ;1817
0000ec  e7ce              B        |L22.140|
                  |L22.238|
0000ee  2002              MOVS     r0,#2                 ;1838
0000f0  e7cc              B        |L22.140|
;;;1841   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L22.244|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;2276     */
;;;2277   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2278   {
000004  4604              MOV      r4,r0
000006  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2281   
;;;2282     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f8900035          LDRB     r0,[r0,#0x35]
00000e  4698              MOV      r8,r3                 ;2278
000010  4691              MOV      r9,r2                 ;2278
000012  468a              MOV      r10,r1                ;2278
000014  2820              CMP      r0,#0x20
000016  d14b              BNE      |L23.176|
;;;2283     {
;;;2284       if((pData == NULL) || (Size == 0))
000018  b14f              CBZ      r7,|L23.46|
00001a  b145              CBZ      r5,|L23.46|
;;;2285       {
;;;2286         return  HAL_ERROR;
;;;2287       }
;;;2288   
;;;2289       /* Wait until BUSY flag is reset */
;;;2290       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
00001c  f2427310          MOV      r3,#0x2710
000020  2201              MOVS     r2,#1
000022  4924              LDR      r1,|L23.180|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  bbb8              CBNZ     r0,|L23.156|
00002c  e002              B        |L23.52|
                  |L23.46|
00002e  2001              MOVS     r0,#1                 ;2286
                  |L23.48|
;;;2291       {
;;;2292         return HAL_BUSY;
;;;2293       }
;;;2294   
;;;2295       /* Process Locked */
;;;2296       __HAL_LOCK(hi2c);
;;;2297   
;;;2298       /* Disable Pos */
;;;2299       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2300   
;;;2301       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;2302       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2303       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2304   
;;;2305       hi2c->pBuffPtr = pData;
;;;2306       hi2c->XferSize = Size;
;;;2307       hi2c->XferCount = Size;
;;;2308   
;;;2309       /* Set the I2C DMA transfert complete callback */
;;;2310       hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
;;;2311   
;;;2312       /* Set the DMA error callback */
;;;2313       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2314   
;;;2315       /* Enable the DMA channel */
;;;2316       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
;;;2317   
;;;2318       /* Send Slave Address and Memory Address */
;;;2319       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;2320       {
;;;2321         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2322         {
;;;2323           /* Process Unlocked */
;;;2324           __HAL_UNLOCK(hi2c);
;;;2325           return HAL_ERROR;
;;;2326         }
;;;2327         else
;;;2328         {
;;;2329           /* Process Unlocked */
;;;2330           __HAL_UNLOCK(hi2c);
;;;2331           return HAL_TIMEOUT;
;;;2332         }
;;;2333       }
;;;2334   
;;;2335       /* Enable DMA Request */
;;;2336       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;2337   
;;;2338       /* Process Unlocked */
;;;2339       __HAL_UNLOCK(hi2c);
;;;2340   
;;;2341       return HAL_OK;
;;;2342     }
;;;2343     else
;;;2344     {
;;;2345       return HAL_BUSY;
;;;2346     }
;;;2347   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.52|
000034  f8940034          LDRB     r0,[r4,#0x34]         ;2296
000038  2801              CMP      r0,#1                 ;2296
00003a  d039              BEQ      |L23.176|
00003c  2001              MOVS     r0,#1                 ;2296
00003e  f8840034          STRB     r0,[r4,#0x34]         ;2296
000042  6820              LDR      r0,[r4,#0]            ;2299
000044  6801              LDR      r1,[r0,#0]            ;2299
000046  f4216100          BIC      r1,r1,#0x800          ;2299
00004a  6001              STR      r1,[r0,#0]            ;2299
00004c  2021              MOVS     r0,#0x21              ;2301
00004e  f8840035          STRB     r0,[r4,#0x35]         ;2301
000052  2040              MOVS     r0,#0x40              ;2302
000054  f8840036          STRB     r0,[r4,#0x36]         ;2302
000058  2600              MOVS     r6,#0                 ;2303
00005a  63a6              STR      r6,[r4,#0x38]         ;2303
00005c  6267              STR      r7,[r4,#0x24]         ;2306
00005e  8525              STRH     r5,[r4,#0x28]         ;2306
000060  8565              STRH     r5,[r4,#0x2a]         ;2307
000062  6ae1              LDR      r1,[r4,#0x2c]         ;2310
000064  4814              LDR      r0,|L23.184|
000066  462b              MOV      r3,r5                 ;2316
000068  6288              STR      r0,[r1,#0x28]         ;2313
00006a  6ae1              LDR      r1,[r4,#0x2c]         ;2313
00006c  4813              LDR      r0,|L23.188|
00006e  6308              STR      r0,[r1,#0x30]         ;2316
000070  6822              LDR      r2,[r4,#0]            ;2316
000072  4639              MOV      r1,r7                 ;2316
000074  3210              ADDS     r2,r2,#0x10           ;2316
000076  6ae0              LDR      r0,[r4,#0x2c]         ;2316
000078  f7fffffe          BL       HAL_DMA_Start_IT
00007c  2023              MOVS     r0,#0x23              ;2319
00007e  9000              STR      r0,[sp,#0]            ;2319
000080  4643              MOV      r3,r8                 ;2319
000082  464a              MOV      r2,r9                 ;2319
000084  4651              MOV      r1,r10                ;2319
000086  4620              MOV      r0,r4                 ;2319
000088  f7fffffe          BL       I2C_RequestMemoryWrite
00008c  b138              CBZ      r0,|L23.158|
00008e  6ba0              LDR      r0,[r4,#0x38]         ;2321
000090  f8846034          STRB     r6,[r4,#0x34]         ;2330
000094  2804              CMP      r0,#4                 ;2321
000096  d0ca              BEQ      |L23.46|
000098  2003              MOVS     r0,#3                 ;2331
00009a  e7c9              B        |L23.48|
                  |L23.156|
00009c  e008              B        |L23.176|
                  |L23.158|
00009e  6820              LDR      r0,[r4,#0]            ;2336
0000a0  6841              LDR      r1,[r0,#4]            ;2336
0000a2  f4416100          ORR      r1,r1,#0x800          ;2336
0000a6  6041              STR      r1,[r0,#4]            ;2336
0000a8  f8846034          STRB     r6,[r4,#0x34]         ;2339
0000ac  2000              MOVS     r0,#0                 ;2341
0000ae  e7bf              B        |L23.48|
                  |L23.176|
0000b0  2002              MOVS     r0,#2                 ;2345
0000b2  e7bd              B        |L23.48|
;;;2348   
                          ENDP

                  |L23.180|
                          DCD      0x00100002
                  |L23.184|
                          DCD      I2C_DMAMemTransmitCplt
                  |L23.188|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2088     */
;;;2089   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2090   {
000004  4604              MOV      r4,r0
000006  e9dd760a          LDRD     r7,r6,[sp,#0x28]
;;;2091     /* Check the parameters */
;;;2092     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2093   
;;;2094     if(hi2c->State == HAL_I2C_STATE_READY)
00000a  f8900035          LDRB     r0,[r0,#0x35]
00000e  4698              MOV      r8,r3                 ;2090
000010  4691              MOV      r9,r2                 ;2090
000012  468a              MOV      r10,r1                ;2090
000014  2820              CMP      r0,#0x20
000016  d13e              BNE      |L24.150|
;;;2095     {
;;;2096       if((pData == NULL) || (Size == 0))
000018  b14f              CBZ      r7,|L24.46|
00001a  b146              CBZ      r6,|L24.46|
;;;2097       {
;;;2098         return  HAL_ERROR;
;;;2099       }
;;;2100   
;;;2101       /* Wait until BUSY flag is reset */
;;;2102       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
00001c  f2427310          MOV      r3,#0x2710
000020  2201              MOVS     r2,#1
000022  491e              LDR      r1,|L24.156|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  bb98              CBNZ     r0,|L24.148|
00002c  e002              B        |L24.52|
                  |L24.46|
00002e  2001              MOVS     r0,#1                 ;2098
                  |L24.48|
;;;2103       {
;;;2104         return HAL_BUSY;
;;;2105       }
;;;2106   
;;;2107       /* Process Locked */
;;;2108       __HAL_LOCK(hi2c);
;;;2109   
;;;2110       /* Disable Pos */
;;;2111       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;2112   
;;;2113       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;2114       hi2c->Mode = HAL_I2C_MODE_MEM;
;;;2115       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2116   
;;;2117       hi2c->pBuffPtr = pData;
;;;2118       hi2c->XferSize = Size;
;;;2119       hi2c->XferCount = Size;
;;;2120   
;;;2121       /* Send Slave Address and Memory Address */
;;;2122       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
;;;2123       {
;;;2124         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2125         {
;;;2126           /* Process Unlocked */
;;;2127           __HAL_UNLOCK(hi2c);
;;;2128           return HAL_ERROR;
;;;2129         }
;;;2130         else
;;;2131         {
;;;2132           /* Process Unlocked */
;;;2133           __HAL_UNLOCK(hi2c);
;;;2134           return HAL_TIMEOUT;
;;;2135         }
;;;2136       }
;;;2137   
;;;2138       /* Process Unlocked */
;;;2139       __HAL_UNLOCK(hi2c);
;;;2140   
;;;2141       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2142                 to avoid the risk of I2C interrupt handle execution before current
;;;2143                 process unlock */
;;;2144   
;;;2145       /* Enable EVT, BUF and ERR interrupt */
;;;2146       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;2147   
;;;2148       return HAL_OK;
;;;2149     }
;;;2150     else
;;;2151     {
;;;2152       return HAL_BUSY;
;;;2153     }
;;;2154   }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L24.52|
000034  f8940034          LDRB     r0,[r4,#0x34]         ;2108
000038  2801              CMP      r0,#1                 ;2108
00003a  d02c              BEQ      |L24.150|
00003c  2001              MOVS     r0,#1                 ;2108
00003e  f8840034          STRB     r0,[r4,#0x34]         ;2108
000042  6820              LDR      r0,[r4,#0]            ;2111
000044  6801              LDR      r1,[r0,#0]            ;2111
000046  f4216100          BIC      r1,r1,#0x800          ;2111
00004a  6001              STR      r1,[r0,#0]            ;2111
00004c  2021              MOVS     r0,#0x21              ;2113
00004e  f8840035          STRB     r0,[r4,#0x35]         ;2113
000052  2040              MOVS     r0,#0x40              ;2114
000054  f8840036          STRB     r0,[r4,#0x36]         ;2114
000058  2500              MOVS     r5,#0                 ;2115
00005a  63a5              STR      r5,[r4,#0x38]         ;2115
00005c  6267              STR      r7,[r4,#0x24]         ;2118
00005e  8526              STRH     r6,[r4,#0x28]         ;2118
000060  8566              STRH     r6,[r4,#0x2a]         ;2119
000062  2023              MOVS     r0,#0x23              ;2122
000064  9000              STR      r0,[sp,#0]            ;2122
000066  4643              MOV      r3,r8                 ;2122
000068  464a              MOV      r2,r9                 ;2122
00006a  4651              MOV      r1,r10                ;2122
00006c  4620              MOV      r0,r4                 ;2122
00006e  f7fffffe          BL       I2C_RequestMemoryWrite
000072  b130              CBZ      r0,|L24.130|
000074  6ba0              LDR      r0,[r4,#0x38]         ;2124
000076  f8845034          STRB     r5,[r4,#0x34]         ;2133
00007a  2804              CMP      r0,#4                 ;2124
00007c  d0d7              BEQ      |L24.46|
00007e  2003              MOVS     r0,#3                 ;2134
000080  e7d6              B        |L24.48|
                  |L24.130|
000082  f8845034          STRB     r5,[r4,#0x34]         ;2139
000086  6820              LDR      r0,[r4,#0]            ;2146
000088  6841              LDR      r1,[r0,#4]            ;2146
00008a  f44161e0          ORR      r1,r1,#0x700          ;2146
00008e  6041              STR      r1,[r0,#4]            ;2146
000090  2000              MOVS     r0,#0                 ;2148
000092  e7cd              B        |L24.48|
                  |L24.148|
000094  e7ff              B        |L24.150|
                  |L24.150|
000096  2002              MOVS     r0,#2                 ;2152
000098  e7ca              B        |L24.48|
;;;2155   
                          ENDP

00009a  0000              DCW      0x0000
                  |L24.156|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;449      */
;;;450     __WEAK void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;451    {
;;;452      /* Prevent unused argument(s) compilation warning */
;;;453      UNUSED(hi2c);
;;;454      /* NOTE : This function should not be modified, when the callback is needed,
;;;455                the HAL_I2C_MspDeInit could be implemented in the user file
;;;456       */
;;;457    }
;;;458    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;434      */
;;;435     __WEAK void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;436    {
;;;437      /* Prevent unused argument(s) compilation warning */
;;;438      UNUSED(hi2c);
;;;439      /* NOTE : This function should not be modified, when the callback is needed,
;;;440                the HAL_I2C_MspInit could be implemented in the user file
;;;441       */
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;2806     */
;;;2807   __WEAK void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2808   {
;;;2809     /* Prevent unused argument(s) compilation warning */
;;;2810     UNUSED(hi2c);
;;;2811     /* NOTE : This function should not be modified, when the callback is needed,
;;;2812               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2813      */
;;;2814   }
;;;2815   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;2791     */
;;;2792    __WEAK void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;2793   {
;;;2794     /* Prevent unused argument(s) compilation warning */
;;;2795     UNUSED(hi2c);
;;;2796     /* NOTE : This function should not be modified, when the callback is needed,
;;;2797               the HAL_I2C_TxCpltCallback could be implemented in the user file
;;;2798      */
;;;2799   }
;;;2800   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive PROC
;;;990      */
;;;991    HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;992    {
000004  4604              MOV      r4,r0
;;;993      if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  4699              MOV      r9,r3                 ;992
00000c  4615              MOV      r5,r2                 ;992
00000e  460e              MOV      r6,r1                 ;992
000010  2820              CMP      r0,#0x20
000012  d179              BNE      |L29.264|
;;;994      {
;;;995        if((pData == NULL) || (Size == 0))
000014  2e00              CMP      r6,#0
000016  d061              BEQ      |L29.220|
000018  2d00              CMP      r5,#0
00001a  d05f              BEQ      |L29.220|
;;;996        {
;;;997          return  HAL_ERROR;
;;;998        }
;;;999    
;;;1000       /* Wait until BUSY flag is reset */
;;;1001       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
00001c  f2427310          MOV      r3,#0x2710
000020  2201              MOVS     r2,#1
000022  493a              LDR      r1,|L29.268|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002a  2800              CMP      r0,#0
00002c  d16c              BNE      |L29.264|
;;;1002       {
;;;1003         return HAL_BUSY;
;;;1004       }
;;;1005   
;;;1006       /* Process Locked */
;;;1007       __HAL_LOCK(hi2c);
00002e  f8940034          LDRB     r0,[r4,#0x34]
000032  2801              CMP      r0,#1
000034  d068              BEQ      |L29.264|
000036  2001              MOVS     r0,#1
000038  f8840034          STRB     r0,[r4,#0x34]
;;;1008   
;;;1009       /* Disable Pos */
;;;1010       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
00003c  6820              LDR      r0,[r4,#0]
00003e  6801              LDR      r1,[r0,#0]
000040  f4216100          BIC      r1,r1,#0x800
000044  6001              STR      r1,[r0,#0]
;;;1011   
;;;1012       hi2c->State = HAL_I2C_STATE_BUSY_RX;
000046  2022              MOVS     r0,#0x22
000048  f8840035          STRB     r0,[r4,#0x35]
;;;1013       hi2c->Mode = HAL_I2C_MODE_SLAVE;
00004c  f04f0820          MOV      r8,#0x20
000050  f8848036          STRB     r8,[r4,#0x36]
;;;1014       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000054  2700              MOVS     r7,#0
000056  63a7              STR      r7,[r4,#0x38]
;;;1015   
;;;1016       /* Enable Address Acknowledge */
;;;1017       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000058  6820              LDR      r0,[r4,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  f4416180          ORR      r1,r1,#0x400
000060  6001              STR      r1,[r0,#0]
;;;1018   
;;;1019       /* Wait until ADDR flag is set */
;;;1020       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
000062  464b              MOV      r3,r9
000064  463a              MOV      r2,r7
000066  492a              LDR      r1,|L29.272|
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006e  bb90              CBNZ     r0,|L29.214|
;;;1021       {
;;;1022         return HAL_TIMEOUT;
;;;1023       }
;;;1024   
;;;1025       /* Clear ADDR flag */
;;;1026       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000070  6820              LDR      r0,[r4,#0]
000072  6941              LDR      r1,[r0,#0x14]
000074  6980              LDR      r0,[r0,#0x18]
000076  9000              STR      r0,[sp,#0]
                  |L29.120|
;;;1027   
;;;1028       while(Size > 0)
;;;1029       {
;;;1030         /* Wait until RXNE flag is set */
;;;1031         if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
000078  4649              MOV      r1,r9
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
000080  2800              CMP      r0,#0
000082  6820              LDR      r0,[r4,#0]
000084  d007              BEQ      |L29.150|
;;;1032         {
;;;1033           /* Disable Address Acknowledge */
;;;1034           hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
000086  6801              LDR      r1,[r0,#0]
000088  f4216180          BIC      r1,r1,#0x400
00008c  6001              STR      r1,[r0,#0]
;;;1035           if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  2820              CMP      r0,#0x20
000092  d020              BEQ      |L29.214|
000094  e022              B        |L29.220|
                  |L29.150|
;;;1036           {
;;;1037             return HAL_TIMEOUT;
;;;1038           }
;;;1039           else
;;;1040           {
;;;1041             return HAL_ERROR;
;;;1042           }
;;;1043         }
;;;1044   
;;;1045         /* Read data from DR */
;;;1046         (*pData++) = hi2c->Instance->DR;
000096  6900              LDR      r0,[r0,#0x10]
000098  f8060b01          STRB     r0,[r6],#1
;;;1047         Size--;
;;;1048   
;;;1049         if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
00009c  6820              LDR      r0,[r4,#0]
00009e  1e6d              SUBS     r5,r5,#1              ;1046
0000a0  b2ad              UXTH     r5,r5                 ;1047
0000a2  6941              LDR      r1,[r0,#0x14]
0000a4  43c9              MVNS     r1,r1
0000a6  0749              LSLS     r1,r1,#29
0000a8  d405              BMI      |L29.182|
0000aa  b135              CBZ      r5,|L29.186|
;;;1050         {
;;;1051           /* Read data from DR */
;;;1052           (*pData++) = hi2c->Instance->DR;
0000ac  6900              LDR      r0,[r0,#0x10]
0000ae  1e6d              SUBS     r5,r5,#1
0000b0  f8060b01          STRB     r0,[r6],#1
;;;1053           Size--;
0000b4  b2ad              UXTH     r5,r5
                  |L29.182|
0000b6  2d00              CMP      r5,#0                 ;1028
0000b8  d1de              BNE      |L29.120|
                  |L29.186|
;;;1054         }
;;;1055       }
;;;1056   
;;;1057       /* Wait until STOP flag is set */
;;;1058       if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
0000ba  2123              MOVS     r1,#0x23
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
0000c2  2800              CMP      r0,#0
0000c4  6820              LDR      r0,[r4,#0]
0000c6  d00b              BEQ      |L29.224|
;;;1059       {
;;;1060         /* Disable Address Acknowledge */
;;;1061         hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
0000c8  6801              LDR      r1,[r0,#0]
0000ca  f4216180          BIC      r1,r1,#0x400
0000ce  6001              STR      r1,[r0,#0]
;;;1062   
;;;1063         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
0000d0  6ba0              LDR      r0,[r4,#0x38]
0000d2  2804              CMP      r0,#4
0000d4  d002              BEQ      |L29.220|
                  |L29.214|
;;;1064         {
;;;1065           return HAL_ERROR;
;;;1066         }
;;;1067         else
;;;1068         {
;;;1069           return HAL_TIMEOUT;
0000d6  2003              MOVS     r0,#3
                  |L29.216|
;;;1070         }
;;;1071       }
;;;1072   
;;;1073       /* Clear STOP flag */
;;;1074       __HAL_I2C_CLEAR_STOPFLAG(hi2c);
;;;1075   
;;;1076       /* Disable Address Acknowledge */
;;;1077       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1078   
;;;1079       hi2c->State = HAL_I2C_STATE_READY;
;;;1080       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;1081   
;;;1082       /* Process Unlocked */
;;;1083       __HAL_UNLOCK(hi2c);
;;;1084   
;;;1085       return HAL_OK;
;;;1086     }
;;;1087     else
;;;1088     {
;;;1089       return HAL_BUSY;
;;;1090     }
;;;1091   }
0000d8  e8bd83f8          POP      {r3-r9,pc}
                  |L29.220|
0000dc  2001              MOVS     r0,#1                 ;1065
0000de  e7fb              B        |L29.216|
                  |L29.224|
0000e0  6941              LDR      r1,[r0,#0x14]         ;1074
0000e2  6801              LDR      r1,[r0,#0]            ;1074
0000e4  f0410101          ORR      r1,r1,#1              ;1074
0000e8  6001              STR      r1,[r0,#0]            ;1074
0000ea  9100              STR      r1,[sp,#0]            ;1077
0000ec  6820              LDR      r0,[r4,#0]            ;1077
0000ee  6801              LDR      r1,[r0,#0]            ;1077
0000f0  f4216180          BIC      r1,r1,#0x400          ;1077
0000f4  6001              STR      r1,[r0,#0]            ;1077
0000f6  f8848035          STRB     r8,[r4,#0x35]         ;1079
0000fa  f8847036          STRB     r7,[r4,#0x36]         ;1080
0000fe  f8847034          STRB     r7,[r4,#0x34]         ;1083
000102  2000              MOVS     r0,#0                 ;1085
000104  e7e8              B        |L29.216|
000106  e7ff              B        |L29.264|
                  |L29.264|
000108  2002              MOVS     r0,#2                 ;1089
00010a  e7e5              B        |L29.216|
;;;1092   
                          ENDP

                  |L29.268|
                          DCD      0x00100002
                  |L29.272|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;1659     */
;;;1660   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1661   {
000004  4604              MOV      r4,r0
;;;1662     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  4615              MOV      r5,r2                 ;1661
00000c  460e              MOV      r6,r1                 ;1661
00000e  2820              CMP      r0,#0x20
000010  d14e              BNE      |L30.176|
;;;1663     {
;;;1664       if((pData == NULL) || (Size == 0))
000012  b156              CBZ      r6,|L30.42|
000014  b14d              CBZ      r5,|L30.42|
;;;1665       {
;;;1666         return  HAL_ERROR;
;;;1667       }
;;;1668   
;;;1669       /* Wait until BUSY flag is reset */
;;;1670       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000016  f2427810          MOV      r8,#0x2710
00001a  4643              MOV      r3,r8
00001c  2201              MOVS     r2,#1
00001e  4925              LDR      r1,|L30.180|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  bbd0              CBNZ     r0,|L30.158|
000028  e002              B        |L30.48|
                  |L30.42|
00002a  2001              MOVS     r0,#1                 ;1666
                  |L30.44|
;;;1671       {
;;;1672         return HAL_BUSY;
;;;1673       }
;;;1674   
;;;1675       /* Process Locked */
;;;1676       __HAL_LOCK(hi2c);
;;;1677   
;;;1678       /* Disable Pos */
;;;1679       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1680   
;;;1681       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;1682       hi2c->Mode = HAL_I2C_MODE_SLAVE;
;;;1683       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1684   
;;;1685       hi2c->pBuffPtr = pData;
;;;1686       hi2c->XferSize = Size;
;;;1687       hi2c->XferCount = Size;
;;;1688   
;;;1689       /* Set the I2C DMA transfer complete callback */
;;;1690       hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
;;;1691   
;;;1692       /* Set the DMA error callback */
;;;1693       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;1694   
;;;1695       /* Enable the DMA channel */
;;;1696       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
;;;1697   
;;;1698       /* Enable DMA Request */
;;;1699       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;1700   
;;;1701       /* Enable Address Acknowledge */
;;;1702       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1703   
;;;1704       /* Wait until ADDR flag is set */
;;;1705       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
;;;1706       {
;;;1707         return HAL_TIMEOUT;
;;;1708       }
;;;1709   
;;;1710       /* Clear ADDR flag */
;;;1711       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1712   
;;;1713       /* Process Unlocked */
;;;1714       __HAL_UNLOCK(hi2c);
;;;1715   
;;;1716       return HAL_OK;
;;;1717     }
;;;1718     else
;;;1719     {
;;;1720       return HAL_BUSY;
;;;1721     }
;;;1722   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L30.48|
000030  f8940034          LDRB     r0,[r4,#0x34]         ;1676
000034  2801              CMP      r0,#1                 ;1676
000036  d03b              BEQ      |L30.176|
000038  2001              MOVS     r0,#1                 ;1676
00003a  f8840034          STRB     r0,[r4,#0x34]         ;1676
00003e  6820              LDR      r0,[r4,#0]            ;1679
000040  6801              LDR      r1,[r0,#0]            ;1679
000042  f4216100          BIC      r1,r1,#0x800          ;1679
000046  6001              STR      r1,[r0,#0]            ;1679
000048  2022              MOVS     r0,#0x22              ;1681
00004a  f8840035          STRB     r0,[r4,#0x35]         ;1681
00004e  2020              MOVS     r0,#0x20              ;1682
000050  f8840036          STRB     r0,[r4,#0x36]         ;1682
000054  2700              MOVS     r7,#0                 ;1683
000056  63a7              STR      r7,[r4,#0x38]         ;1683
000058  6266              STR      r6,[r4,#0x24]         ;1686
00005a  8525              STRH     r5,[r4,#0x28]         ;1686
00005c  8565              STRH     r5,[r4,#0x2a]         ;1687
00005e  6b21              LDR      r1,[r4,#0x30]         ;1690
000060  4815              LDR      r0,|L30.184|
000062  462b              MOV      r3,r5                 ;1696
000064  6288              STR      r0,[r1,#0x28]         ;1693
000066  6b21              LDR      r1,[r4,#0x30]         ;1693
000068  4814              LDR      r0,|L30.188|
00006a  4632              MOV      r2,r6                 ;1696
00006c  6308              STR      r0,[r1,#0x30]         ;1696
00006e  6821              LDR      r1,[r4,#0]            ;1696
000070  6b20              LDR      r0,[r4,#0x30]         ;1696
000072  3110              ADDS     r1,r1,#0x10           ;1696
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  6820              LDR      r0,[r4,#0]            ;1699
00007a  6841              LDR      r1,[r0,#4]            ;1699
00007c  f4416100          ORR      r1,r1,#0x800          ;1699
000080  6041              STR      r1,[r0,#4]            ;1699
000082  6820              LDR      r0,[r4,#0]            ;1702
000084  6801              LDR      r1,[r0,#0]            ;1702
000086  f4416180          ORR      r1,r1,#0x400          ;1702
00008a  6001              STR      r1,[r0,#0]            ;1702
00008c  4643              MOV      r3,r8                 ;1705
00008e  2200              MOVS     r2,#0                 ;1705
000090  490b              LDR      r1,|L30.192|
000092  4620              MOV      r0,r4                 ;1705
000094  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000098  b110              CBZ      r0,|L30.160|
00009a  2003              MOVS     r0,#3                 ;1707
00009c  e7c6              B        |L30.44|
                  |L30.158|
00009e  e007              B        |L30.176|
                  |L30.160|
0000a0  6820              LDR      r0,[r4,#0]            ;1711
0000a2  6941              LDR      r1,[r0,#0x14]         ;1711
0000a4  6980              LDR      r0,[r0,#0x18]         ;1711
0000a6  9000              STR      r0,[sp,#0]            ;1714
0000a8  f8847034          STRB     r7,[r4,#0x34]         ;1714
0000ac  2000              MOVS     r0,#0                 ;1716
0000ae  e7bd              B        |L30.44|
                  |L30.176|
0000b0  2002              MOVS     r0,#2                 ;1720
0000b2  e7bb              B        |L30.44|
;;;1723   
                          ENDP

                  |L30.180|
                          DCD      0x00100002
                  |L30.184|
                          DCD      I2C_DMASlaveReceiveCplt
                  |L30.188|
                          DCD      I2C_DMAError
                  |L30.192|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1338     */
;;;1339   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1340   {
000002  4604              MOV      r4,r0
;;;1341     if(hi2c->State == HAL_I2C_STATE_READY)
000004  f8900035          LDRB     r0,[r0,#0x35]
000008  4615              MOV      r5,r2                 ;1340
00000a  460e              MOV      r6,r1                 ;1340
00000c  2820              CMP      r0,#0x20
00000e  d131              BNE      |L31.116|
;;;1342     {
;;;1343       if((pData == NULL) || (Size == 0))
000010  b14e              CBZ      r6,|L31.38|
000012  b145              CBZ      r5,|L31.38|
;;;1344       {
;;;1345         return  HAL_ERROR;
;;;1346       }
;;;1347   
;;;1348       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000014  f2427310          MOV      r3,#0x2710
000018  2201              MOVS     r2,#1
00001a  4917              LDR      r1,|L31.120|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000022  bb38              CBNZ     r0,|L31.116|
000024  e001              B        |L31.42|
                  |L31.38|
000026  2001              MOVS     r0,#1                 ;1345
;;;1349       {
;;;1350         return HAL_BUSY;
;;;1351       }
;;;1352   
;;;1353       /* Process Locked */
;;;1354       __HAL_LOCK(hi2c);
;;;1355   
;;;1356       /* Disable Pos */
;;;1357       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1358   
;;;1359       hi2c->State = HAL_I2C_STATE_BUSY_RX;
;;;1360       hi2c->Mode = HAL_I2C_MODE_SLAVE;
;;;1361       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1362   
;;;1363       hi2c->pBuffPtr = pData;
;;;1364       hi2c->XferSize = Size;
;;;1365       hi2c->XferCount = Size;
;;;1366   
;;;1367       /* Enable Address Acknowledge */
;;;1368       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1369   
;;;1370       /* Process Unlocked */
;;;1371       __HAL_UNLOCK(hi2c);
;;;1372   
;;;1373       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1374                 to avoid the risk of I2C interrupt handle execution before current
;;;1375                 process unlock */
;;;1376   
;;;1377       /* Enable EVT, BUF and ERR interrupt */
;;;1378       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1379   
;;;1380       return HAL_OK;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       return HAL_BUSY;
;;;1385     }
;;;1386   }
000028  bd70              POP      {r4-r6,pc}
                  |L31.42|
00002a  f8940034          LDRB     r0,[r4,#0x34]         ;1354
00002e  2801              CMP      r0,#1                 ;1354
000030  d020              BEQ      |L31.116|
000032  2001              MOVS     r0,#1                 ;1354
000034  f8840034          STRB     r0,[r4,#0x34]         ;1354
000038  6820              LDR      r0,[r4,#0]            ;1357
00003a  6801              LDR      r1,[r0,#0]            ;1357
00003c  f4216100          BIC      r1,r1,#0x800          ;1357
000040  6001              STR      r1,[r0,#0]            ;1357
000042  2022              MOVS     r0,#0x22              ;1359
000044  f8840035          STRB     r0,[r4,#0x35]         ;1359
000048  2020              MOVS     r0,#0x20              ;1360
00004a  f8840036          STRB     r0,[r4,#0x36]         ;1360
00004e  2000              MOVS     r0,#0                 ;1361
000050  63a0              STR      r0,[r4,#0x38]         ;1361
000052  6266              STR      r6,[r4,#0x24]         ;1364
000054  8525              STRH     r5,[r4,#0x28]         ;1364
000056  8565              STRH     r5,[r4,#0x2a]         ;1365
000058  6821              LDR      r1,[r4,#0]            ;1368
00005a  680a              LDR      r2,[r1,#0]            ;1368
00005c  f4426280          ORR      r2,r2,#0x400          ;1368
000060  600a              STR      r2,[r1,#0]            ;1368
000062  f8840034          STRB     r0,[r4,#0x34]         ;1371
000066  6820              LDR      r0,[r4,#0]            ;1378
000068  6841              LDR      r1,[r0,#4]            ;1378
00006a  f44161e0          ORR      r1,r1,#0x700          ;1378
00006e  6041              STR      r1,[r0,#4]            ;1378
000070  2000              MOVS     r0,#0                 ;1380
000072  bd70              POP      {r4-r6,pc}
                  |L31.116|
000074  2002              MOVS     r0,#2                 ;1384
000076  bd70              POP      {r4-r6,pc}
;;;1387   
                          ENDP

                  |L31.120|
                          DCD      0x00100002

                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit PROC
;;;876      */
;;;877    HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;878    {
000004  4604              MOV      r4,r0
;;;879      if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  469a              MOV      r10,r3                ;878
00000c  4615              MOV      r5,r2                 ;878
00000e  460e              MOV      r6,r1                 ;878
000010  2820              CMP      r0,#0x20
000012  d16c              BNE      |L32.238|
;;;880      {
;;;881        if((pData == NULL) || (Size == 0))
000014  b3f6              CBZ      r6,|L32.148|
000016  b3ed              CBZ      r5,|L32.148|
;;;882        {
;;;883          return  HAL_ERROR;
;;;884        }
;;;885    
;;;886        /* Wait until BUSY flag is reset */
;;;887        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000018  f2427310          MOV      r3,#0x2710
00001c  2201              MOVS     r2,#1
00001e  4941              LDR      r1,|L32.292|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  2800              CMP      r0,#0
000028  d179              BNE      |L32.286|
;;;888        {
;;;889          return HAL_BUSY;
;;;890        }
;;;891    
;;;892        /* Process Locked */
;;;893        __HAL_LOCK(hi2c);
00002a  f8940034          LDRB     r0,[r4,#0x34]
00002e  2801              CMP      r0,#1
000030  d075              BEQ      |L32.286|
000032  2001              MOVS     r0,#1
000034  f8840034          STRB     r0,[r4,#0x34]
;;;894    
;;;895        /* Disable Pos */
;;;896        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
000038  6820              LDR      r0,[r4,#0]
00003a  6801              LDR      r1,[r0,#0]
00003c  f4216100          BIC      r1,r1,#0x800
000040  6001              STR      r1,[r0,#0]
;;;897    
;;;898        hi2c->State = HAL_I2C_STATE_BUSY_TX;
000042  2021              MOVS     r0,#0x21
000044  f8840035          STRB     r0,[r4,#0x35]
;;;899        hi2c->Mode = HAL_I2C_MODE_SLAVE;
000048  f04f0820          MOV      r8,#0x20
00004c  f8848036          STRB     r8,[r4,#0x36]
;;;900        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
000050  2700              MOVS     r7,#0
000052  63a7              STR      r7,[r4,#0x38]
;;;901    
;;;902        /* Enable Address Acknowledge */
;;;903        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000054  6820              LDR      r0,[r4,#0]
000056  6801              LDR      r1,[r0,#0]
000058  f4416180          ORR      r1,r1,#0x400
00005c  6001              STR      r1,[r0,#0]
;;;904    
;;;905        /* Wait until ADDR flag is set */
;;;906        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
00005e  f8df90c8          LDR      r9,|L32.296|
000062  4653              MOV      r3,r10
000064  463a              MOV      r2,r7
000066  4649              MOV      r1,r9
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006e  bbe8              CBNZ     r0,|L32.236|
;;;907        {
;;;908          return HAL_TIMEOUT;
;;;909        }
;;;910    
;;;911        /* Clear ADDR flag */
;;;912        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000070  6820              LDR      r0,[r4,#0]
000072  6941              LDR      r1,[r0,#0x14]
000074  6980              LDR      r0,[r0,#0x18]
;;;913    
;;;914        /* If 10bit addressing mode is selected */
;;;915        if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
000076  9000              STR      r0,[sp,#0]
000078  6920              LDR      r0,[r4,#0x10]
00007a  f5b04f40          CMP      r0,#0xc000
00007e  d10c              BNE      |L32.154|
;;;916        {
;;;917          /* Wait until ADDR flag is set */
;;;918          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
000080  4653              MOV      r3,r10
000082  2200              MOVS     r2,#0
000084  4649              MOV      r1,r9
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00008c  bb70              CBNZ     r0,|L32.236|
;;;919          {
;;;920            return HAL_TIMEOUT;
;;;921          }
;;;922    
;;;923          /* Clear ADDR flag */
;;;924          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00008e  6820              LDR      r0,[r4,#0]
000090  6941              LDR      r1,[r0,#0x14]
000092  e000              B        |L32.150|
                  |L32.148|
000094  e00e              B        |L32.180|
                  |L32.150|
000096  6980              LDR      r0,[r0,#0x18]
000098  9000              STR      r0,[sp,#0]
                  |L32.154|
;;;925        }
;;;926    
;;;927        while(Size > 0)
;;;928        {
;;;929          /* Wait until TXE flag is set */
;;;930          if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
00009a  4651              MOV      r1,r10
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000a2  b150              CBZ      r0,|L32.186|
;;;931          {
;;;932            /* Disable Address Acknowledge */
;;;933            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6801              LDR      r1,[r0,#0]
0000a8  f4216180          BIC      r1,r1,#0x400
0000ac  6001              STR      r1,[r0,#0]
;;;934            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
0000ae  6ba0              LDR      r0,[r4,#0x38]
0000b0  2804              CMP      r0,#4
0000b2  d120              BNE      |L32.246|
                  |L32.180|
;;;935            {
;;;936              return HAL_ERROR;
0000b4  2001              MOVS     r0,#1
                  |L32.182|
;;;937            }
;;;938            else
;;;939            {
;;;940              return HAL_TIMEOUT;
;;;941            }
;;;942          }
;;;943    
;;;944          /* Write data to DR */
;;;945          hi2c->Instance->DR = (*pData++);
;;;946          Size--;
;;;947    
;;;948          if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
;;;949          {
;;;950            /* Write data to DR */
;;;951            hi2c->Instance->DR = (*pData++);
;;;952            Size--;
;;;953          }
;;;954        }
;;;955    
;;;956        /* Wait until AF flag is set */
;;;957        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout) != HAL_OK)
;;;958        {
;;;959          return HAL_TIMEOUT;
;;;960        }
;;;961    
;;;962        /* Clear AF flag */
;;;963        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;964    
;;;965        /* Disable Address Acknowledge */
;;;966        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;967    
;;;968        hi2c->State = HAL_I2C_STATE_READY;
;;;969        hi2c->Mode = HAL_I2C_MODE_NONE;
;;;970    
;;;971        /* Process Unlocked */
;;;972        __HAL_UNLOCK(hi2c);
;;;973    
;;;974        return HAL_OK;
;;;975      }
;;;976      else
;;;977      {
;;;978        return HAL_BUSY;
;;;979      }
;;;980    }
0000b6  e8bd8ff8          POP      {r3-r11,pc}
                  |L32.186|
0000ba  6821              LDR      r1,[r4,#0]            ;945
0000bc  f8160b01          LDRB     r0,[r6],#1            ;945
0000c0  6108              STR      r0,[r1,#0x10]         ;945
0000c2  6820              LDR      r0,[r4,#0]            ;948
0000c4  1e6d              SUBS     r5,r5,#1              ;945
0000c6  b2ad              UXTH     r5,r5                 ;946
0000c8  6941              LDR      r1,[r0,#0x14]         ;948
0000ca  43c9              MVNS     r1,r1                 ;948
0000cc  0749              LSLS     r1,r1,#29             ;948
0000ce  d405              BMI      |L32.220|
0000d0  b135              CBZ      r5,|L32.224|
0000d2  f8161b01          LDRB     r1,[r6],#1            ;951
0000d6  6101              STR      r1,[r0,#0x10]         ;951
0000d8  1e6d              SUBS     r5,r5,#1              ;951
0000da  b2ad              UXTH     r5,r5                 ;952
                  |L32.220|
0000dc  2d00              CMP      r5,#0                 ;927
0000de  d1dc              BNE      |L32.154|
                  |L32.224|
0000e0  4653              MOV      r3,r10                ;957
0000e2  2200              MOVS     r2,#0                 ;957
0000e4  f44f3182          MOV      r1,#0x10400           ;957
0000e8  4620              MOV      r0,r4                 ;957
0000ea  e001              B        |L32.240|
                  |L32.236|
0000ec  e003              B        |L32.246|
                  |L32.238|
0000ee  e016              B        |L32.286|
                  |L32.240|
0000f0  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f4  b108              CBZ      r0,|L32.250|
                  |L32.246|
0000f6  2003              MOVS     r0,#3                 ;959
0000f8  e7dd              B        |L32.182|
                  |L32.250|
0000fa  6820              LDR      r0,[r4,#0]            ;963
0000fc  6941              LDR      r1,[r0,#0x14]         ;963
0000fe  f4216180          BIC      r1,r1,#0x400          ;963
000102  6141              STR      r1,[r0,#0x14]         ;963
000104  6820              LDR      r0,[r4,#0]            ;966
000106  6801              LDR      r1,[r0,#0]            ;966
000108  f4216180          BIC      r1,r1,#0x400          ;966
00010c  6001              STR      r1,[r0,#0]            ;966
00010e  f8848035          STRB     r8,[r4,#0x35]         ;968
000112  f8847036          STRB     r7,[r4,#0x36]         ;969
000116  f8847034          STRB     r7,[r4,#0x34]         ;972
00011a  2000              MOVS     r0,#0                 ;974
00011c  e7cb              B        |L32.182|
                  |L32.286|
00011e  2002              MOVS     r0,#2                 ;978
000120  e7c9              B        |L32.182|
;;;981    
                          ENDP

000122  0000              DCW      0x0000
                  |L32.292|
                          DCD      0x00100002
                  |L32.296|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;1569     */
;;;1570   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1571   {
000004  4604              MOV      r4,r0
;;;1572     if(hi2c->State == HAL_I2C_STATE_READY)
000006  f8900035          LDRB     r0,[r0,#0x35]
00000a  4615              MOV      r5,r2                 ;1571
00000c  460e              MOV      r6,r1                 ;1571
00000e  2820              CMP      r0,#0x20
000010  d15f              BNE      |L33.210|
;;;1573     {
;;;1574       if((pData == NULL) || (Size == 0))
000012  b15e              CBZ      r6,|L33.44|
000014  b155              CBZ      r5,|L33.44|
;;;1575       {
;;;1576         return  HAL_ERROR;
;;;1577       }
;;;1578   
;;;1579       /* Wait until BUSY flag is reset */
;;;1580       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000016  f2427810          MOV      r8,#0x2710
00001a  4643              MOV      r3,r8
00001c  2201              MOVS     r2,#1
00001e  492e              LDR      r1,|L33.216|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000026  2800              CMP      r0,#0
000028  d153              BNE      |L33.210|
00002a  e002              B        |L33.50|
                  |L33.44|
00002c  2001              MOVS     r0,#1                 ;1576
                  |L33.46|
;;;1581       {
;;;1582         return HAL_BUSY;
;;;1583       }
;;;1584   
;;;1585       /* Process Locked */
;;;1586       __HAL_LOCK(hi2c);
;;;1587   
;;;1588       /* Disable Pos */
;;;1589       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1590   
;;;1591       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;1592       hi2c->Mode = HAL_I2C_MODE_SLAVE;
;;;1593       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1594   
;;;1595       hi2c->pBuffPtr = pData;
;;;1596       hi2c->XferSize = Size;
;;;1597       hi2c->XferCount = Size;
;;;1598   
;;;1599       /* Set the I2C DMA transfert complete callback */
;;;1600       hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
;;;1601   
;;;1602       /* Set the DMA error callback */
;;;1603       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1604   
;;;1605       /* Enable the DMA channel */
;;;1606       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
;;;1607   
;;;1608       /* Enable DMA Request */
;;;1609       SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
;;;1610   
;;;1611       /* Enable Address Acknowledge */
;;;1612       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1613   
;;;1614       /* Wait until ADDR flag is set */
;;;1615       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
;;;1616       {
;;;1617         return HAL_TIMEOUT;
;;;1618       }
;;;1619   
;;;1620       /* If 7bit addressing mode is selected */
;;;1621       if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;1622       {
;;;1623         /* Clear ADDR flag */
;;;1624         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1625       }
;;;1626       else
;;;1627       {
;;;1628         /* Clear ADDR flag */
;;;1629         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1630   
;;;1631         /* Wait until ADDR flag is set */
;;;1632         if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
;;;1633         {
;;;1634           return HAL_TIMEOUT;
;;;1635         }
;;;1636   
;;;1637         /* Clear ADDR flag */
;;;1638         __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;1639       }
;;;1640   
;;;1641       /* Process Unlocked */
;;;1642       __HAL_UNLOCK(hi2c);
;;;1643   
;;;1644       return HAL_OK;
;;;1645     }
;;;1646     else
;;;1647     {
;;;1648       return HAL_BUSY;
;;;1649     }
;;;1650   }
00002e  e8bd83f8          POP      {r3-r9,pc}
                  |L33.50|
000032  f8940034          LDRB     r0,[r4,#0x34]         ;1586
000036  2801              CMP      r0,#1                 ;1586
000038  d04b              BEQ      |L33.210|
00003a  2001              MOVS     r0,#1                 ;1586
00003c  f8840034          STRB     r0,[r4,#0x34]         ;1586
000040  6820              LDR      r0,[r4,#0]            ;1589
000042  6801              LDR      r1,[r0,#0]            ;1589
000044  f4216100          BIC      r1,r1,#0x800          ;1589
000048  6001              STR      r1,[r0,#0]            ;1589
00004a  2021              MOVS     r0,#0x21              ;1591
00004c  f8840035          STRB     r0,[r4,#0x35]         ;1591
000050  2020              MOVS     r0,#0x20              ;1592
000052  f8840036          STRB     r0,[r4,#0x36]         ;1592
000056  2700              MOVS     r7,#0                 ;1593
000058  63a7              STR      r7,[r4,#0x38]         ;1593
00005a  6266              STR      r6,[r4,#0x24]         ;1596
00005c  8525              STRH     r5,[r4,#0x28]         ;1596
00005e  8565              STRH     r5,[r4,#0x2a]         ;1597
000060  6ae1              LDR      r1,[r4,#0x2c]         ;1600
000062  481e              LDR      r0,|L33.220|
000064  462b              MOV      r3,r5                 ;1606
000066  6288              STR      r0,[r1,#0x28]         ;1603
000068  6ae1              LDR      r1,[r4,#0x2c]         ;1603
00006a  481d              LDR      r0,|L33.224|
00006c  6308              STR      r0,[r1,#0x30]         ;1606
00006e  6822              LDR      r2,[r4,#0]            ;1606
000070  4631              MOV      r1,r6                 ;1606
000072  3210              ADDS     r2,r2,#0x10           ;1606
000074  6ae0              LDR      r0,[r4,#0x2c]         ;1606
000076  f7fffffe          BL       HAL_DMA_Start_IT
00007a  6820              LDR      r0,[r4,#0]            ;1609
00007c  6841              LDR      r1,[r0,#4]            ;1609
00007e  f4416100          ORR      r1,r1,#0x800          ;1609
000082  6041              STR      r1,[r0,#4]            ;1609
000084  6820              LDR      r0,[r4,#0]            ;1612
000086  6801              LDR      r1,[r0,#0]            ;1612
000088  f4416180          ORR      r1,r1,#0x400          ;1612
00008c  6001              STR      r1,[r0,#0]            ;1612
00008e  4e15              LDR      r6,|L33.228|
000090  4645              MOV      r5,r8                 ;1615
000092  4643              MOV      r3,r8                 ;1615
000094  2200              MOVS     r2,#0                 ;1615
000096  4631              MOV      r1,r6                 ;1615
000098  4620              MOV      r0,r4                 ;1615
00009a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00009e  b970              CBNZ     r0,|L33.190|
0000a0  6920              LDR      r0,[r4,#0x10]         ;1621
0000a2  f5b04f80          CMP      r0,#0x4000            ;1621
0000a6  d00c              BEQ      |L33.194|
0000a8  6820              LDR      r0,[r4,#0]            ;1629
0000aa  6941              LDR      r1,[r0,#0x14]         ;1629
0000ac  6980              LDR      r0,[r0,#0x18]         ;1629
0000ae  9000              STR      r0,[sp,#0]            ;1632
0000b0  462b              MOV      r3,r5                 ;1632
0000b2  2200              MOVS     r2,#0                 ;1632
0000b4  4631              MOV      r1,r6                 ;1632
0000b6  4620              MOV      r0,r4                 ;1632
0000b8  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000bc  b108              CBZ      r0,|L33.194|
                  |L33.190|
0000be  2003              MOVS     r0,#3                 ;1634
0000c0  e7b5              B        |L33.46|
                  |L33.194|
0000c2  6820              LDR      r0,[r4,#0]            ;1638
0000c4  6941              LDR      r1,[r0,#0x14]         ;1638
0000c6  6980              LDR      r0,[r0,#0x18]         ;1638
0000c8  9000              STR      r0,[sp,#0]            ;1642
0000ca  f8847034          STRB     r7,[r4,#0x34]         ;1642
0000ce  2000              MOVS     r0,#0                 ;1644
0000d0  e7ad              B        |L33.46|
                  |L33.210|
0000d2  2002              MOVS     r0,#2                 ;1648
0000d4  e7ab              B        |L33.46|
;;;1651   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L33.216|
                          DCD      0x00100002
                  |L33.220|
                          DCD      I2C_DMASlaveTransmitCplt
                  |L33.224|
                          DCD      I2C_DMAError
                  |L33.228|
                          DCD      0x00010002

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1280     */
;;;1281   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1282   {
000002  4604              MOV      r4,r0
;;;1283     if(hi2c->State == HAL_I2C_STATE_READY)
000004  f8900035          LDRB     r0,[r0,#0x35]
000008  4615              MOV      r5,r2                 ;1282
00000a  460e              MOV      r6,r1                 ;1282
00000c  2820              CMP      r0,#0x20
00000e  d131              BNE      |L34.116|
;;;1284     {
;;;1285       if((pData == NULL) || (Size == 0))
000010  b14e              CBZ      r6,|L34.38|
000012  b145              CBZ      r5,|L34.38|
;;;1286       {
;;;1287         return  HAL_ERROR;
;;;1288       }
;;;1289   
;;;1290       /* Wait until BUSY flag is reset */
;;;1291       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
000014  f2427310          MOV      r3,#0x2710
000018  2201              MOVS     r2,#1
00001a  4917              LDR      r1,|L34.120|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000022  bb38              CBNZ     r0,|L34.116|
000024  e001              B        |L34.42|
                  |L34.38|
000026  2001              MOVS     r0,#1                 ;1287
;;;1292       {
;;;1293         return HAL_BUSY;
;;;1294       }
;;;1295   
;;;1296       /* Process Locked */
;;;1297       __HAL_LOCK(hi2c);
;;;1298   
;;;1299       /* Disable Pos */
;;;1300       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
;;;1301   
;;;1302       hi2c->State = HAL_I2C_STATE_BUSY_TX;
;;;1303       hi2c->Mode = HAL_I2C_MODE_SLAVE;
;;;1304       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1305   
;;;1306       hi2c->pBuffPtr = pData;
;;;1307       hi2c->XferSize = Size;
;;;1308       hi2c->XferCount = Size;
;;;1309   
;;;1310       /* Enable Address Acknowledge */
;;;1311       SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;1312   
;;;1313       /* Process Unlocked */
;;;1314       __HAL_UNLOCK(hi2c);
;;;1315   
;;;1316       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1317                 to avoid the risk of I2C interrupt handle execution before current
;;;1318                 process unlock */
;;;1319   
;;;1320       /* Enable EVT, BUF and ERR interrupt */
;;;1321       __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
;;;1322   
;;;1323       return HAL_OK;
;;;1324     }
;;;1325     else
;;;1326     {
;;;1327       return HAL_BUSY;
;;;1328     }
;;;1329   }
000028  bd70              POP      {r4-r6,pc}
                  |L34.42|
00002a  f8940034          LDRB     r0,[r4,#0x34]         ;1297
00002e  2801              CMP      r0,#1                 ;1297
000030  d020              BEQ      |L34.116|
000032  2001              MOVS     r0,#1                 ;1297
000034  f8840034          STRB     r0,[r4,#0x34]         ;1297
000038  6820              LDR      r0,[r4,#0]            ;1300
00003a  6801              LDR      r1,[r0,#0]            ;1300
00003c  f4216100          BIC      r1,r1,#0x800          ;1300
000040  6001              STR      r1,[r0,#0]            ;1300
000042  2021              MOVS     r0,#0x21              ;1302
000044  f8840035          STRB     r0,[r4,#0x35]         ;1302
000048  2020              MOVS     r0,#0x20              ;1303
00004a  f8840036          STRB     r0,[r4,#0x36]         ;1303
00004e  2000              MOVS     r0,#0                 ;1304
000050  63a0              STR      r0,[r4,#0x38]         ;1304
000052  6266              STR      r6,[r4,#0x24]         ;1307
000054  8525              STRH     r5,[r4,#0x28]         ;1307
000056  8565              STRH     r5,[r4,#0x2a]         ;1308
000058  6821              LDR      r1,[r4,#0]            ;1311
00005a  680a              LDR      r2,[r1,#0]            ;1311
00005c  f4426280          ORR      r2,r2,#0x400          ;1311
000060  600a              STR      r2,[r1,#0]            ;1311
000062  f8840034          STRB     r0,[r4,#0x34]         ;1314
000066  6820              LDR      r0,[r4,#0]            ;1321
000068  6841              LDR      r1,[r0,#4]            ;1321
00006a  f44161e0          ORR      r1,r1,#0x700          ;1321
00006e  6041              STR      r1,[r0,#4]            ;1321
000070  2000              MOVS     r0,#0                 ;1323
000072  bd70              POP      {r4-r6,pc}
                  |L34.116|
000074  2002              MOVS     r0,#2                 ;1327
000076  bd70              POP      {r4-r6,pc}
;;;1330   
                          ENDP

                  |L34.120|
                          DCD      0x00100002

                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;3879     */
;;;3880   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3881   {
;;;3882     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;3883   
;;;3884     /* Disable Acknowledge */
;;;3885     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f4226280          BIC      r2,r2,#0x400
00000c  600a              STR      r2,[r1,#0]
;;;3886   
;;;3887     hi2c->XferCount = 0;
00000e  2100              MOVS     r1,#0
000010  8541              STRH     r1,[r0,#0x2a]
;;;3888   
;;;3889     hi2c->State = HAL_I2C_STATE_READY;
000012  2220              MOVS     r2,#0x20
000014  f8802035          STRB     r2,[r0,#0x35]
;;;3890     hi2c->Mode = HAL_I2C_MODE_NONE;
000018  f8801036          STRB     r1,[r0,#0x36]
;;;3891   
;;;3892     hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
00001c  6b81              LDR      r1,[r0,#0x38]
00001e  f0410110          ORR      r1,r1,#0x10
000022  6381              STR      r1,[r0,#0x38]
;;;3893   
;;;3894     HAL_I2C_ErrorCallback(hi2c);
000024  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3895   }
000028  bd10              POP      {r4,pc}
;;;3896   
                          ENDP


                          AREA ||i.I2C_DMAMasterReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMasterReceiveCplt PROC
;;;3667     */
;;;3668   static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3669   {
;;;3670     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;3671   
;;;3672     /* Disable Acknowledge */
;;;3673     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f4226280          BIC      r2,r2,#0x400
00000c  600a              STR      r2,[r1,#0]
;;;3674   
;;;3675     /* Generate Stop */
;;;3676     SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f4427200          ORR      r2,r2,#0x200
000016  600a              STR      r2,[r1,#0]
;;;3677   
;;;3678     /* Disable Last DMA */
;;;3679     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
000018  6801              LDR      r1,[r0,#0]
00001a  684a              LDR      r2,[r1,#4]
00001c  f4225280          BIC      r2,r2,#0x1000
000020  604a              STR      r2,[r1,#4]
;;;3680   
;;;3681     /* Disable DMA Request */
;;;3682     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f4226200          BIC      r2,r2,#0x800
00002a  604a              STR      r2,[r1,#4]
;;;3683   
;;;3684     hi2c->XferCount = 0;
00002c  2100              MOVS     r1,#0
00002e  8541              STRH     r1,[r0,#0x2a]
;;;3685   
;;;3686     hi2c->State = HAL_I2C_STATE_READY;
000030  2220              MOVS     r2,#0x20
000032  f8802035          STRB     r2,[r0,#0x35]
;;;3687     hi2c->Mode = HAL_I2C_MODE_NONE;
000036  f8801036          STRB     r1,[r0,#0x36]
;;;3688   
;;;3689     /* Check if Errors has been detected during transfer */
;;;3690     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00003a  6b81              LDR      r1,[r0,#0x38]
00003c  b111              CBZ      r1,|L36.68|
;;;3691     {
;;;3692       HAL_I2C_ErrorCallback(hi2c);
00003e  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3693     }
;;;3694     else
;;;3695     {
;;;3696       HAL_I2C_MasterRxCpltCallback(hi2c);
;;;3697     }
;;;3698   }
000042  bd10              POP      {r4,pc}
                  |L36.68|
000044  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
000048  bd10              POP      {r4,pc}
;;;3699   
                          ENDP


                          AREA ||i.I2C_DMAMasterTransmitCplt||, CODE, READONLY, ALIGN=2

                  I2C_DMAMasterTransmitCplt PROC
;;;3590     */
;;;3591   static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3592   {
;;;3593     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
;;;3594   
;;;3595     /* Wait until BTF flag is reset */
;;;3596     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
000002  6a44              LDR      r4,[r0,#0x24]
000004  2323              MOVS     r3,#0x23
000006  2200              MOVS     r2,#0
000008  4911              LDR      r1,|L37.80|
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000010  b118              CBZ      r0,|L37.26|
;;;3597     {
;;;3598       hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000012  6ba0              LDR      r0,[r4,#0x38]
000014  f0400020          ORR      r0,r0,#0x20
000018  63a0              STR      r0,[r4,#0x38]
                  |L37.26|
;;;3599     }
;;;3600   
;;;3601     /* Generate Stop */
;;;3602     SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f4417100          ORR      r1,r1,#0x200
000022  6001              STR      r1,[r0,#0]
;;;3603   
;;;3604     /* Disable DMA Request */
;;;3605     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6841              LDR      r1,[r0,#4]
000028  f4216100          BIC      r1,r1,#0x800
00002c  6041              STR      r1,[r0,#4]
;;;3606   
;;;3607     hi2c->XferCount = 0;
00002e  2000              MOVS     r0,#0
000030  8560              STRH     r0,[r4,#0x2a]
;;;3608   
;;;3609     hi2c->State = HAL_I2C_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  f8841035          STRB     r1,[r4,#0x35]
;;;3610     hi2c->Mode = HAL_I2C_MODE_NONE;
000038  f8840036          STRB     r0,[r4,#0x36]
;;;3611   
;;;3612     /* Check if Errors has been detected during transfer */
;;;3613     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00003c  6ba0              LDR      r0,[r4,#0x38]
00003e  2800              CMP      r0,#0
;;;3614     {
;;;3615       HAL_I2C_ErrorCallback(hi2c);
;;;3616     }
;;;3617     else
;;;3618     {
;;;3619       HAL_I2C_MasterTxCpltCallback(hi2c);
000040  4620              MOV      r0,r4
000042  d002              BEQ      |L37.74|
000044  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3620     }
;;;3621   }
000048  bd10              POP      {r4,pc}
                  |L37.74|
00004a  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
00004e  bd10              POP      {r4,pc}
;;;3622   
                          ENDP

                  |L37.80|
                          DCD      0x00010004

                          AREA ||i.I2C_DMAMemReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMemReceiveCplt PROC
;;;3788     */
;;;3789   static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3790   {
;;;3791     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;3792   
;;;3793     /* Disable Acknowledge */
;;;3794     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f4226280          BIC      r2,r2,#0x400
00000c  600a              STR      r2,[r1,#0]
;;;3795   
;;;3796     /* Generate Stop */
;;;3797     SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00000e  6801              LDR      r1,[r0,#0]
000010  680a              LDR      r2,[r1,#0]
000012  f4427200          ORR      r2,r2,#0x200
000016  600a              STR      r2,[r1,#0]
;;;3798   
;;;3799     /* Disable Last DMA */
;;;3800     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
000018  6801              LDR      r1,[r0,#0]
00001a  684a              LDR      r2,[r1,#4]
00001c  f4225280          BIC      r2,r2,#0x1000
000020  604a              STR      r2,[r1,#4]
;;;3801   
;;;3802     /* Disable DMA Request */
;;;3803     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f4226200          BIC      r2,r2,#0x800
00002a  604a              STR      r2,[r1,#4]
;;;3804   
;;;3805     hi2c->XferCount = 0;
00002c  2100              MOVS     r1,#0
00002e  8541              STRH     r1,[r0,#0x2a]
;;;3806   
;;;3807     hi2c->State = HAL_I2C_STATE_READY;
000030  2220              MOVS     r2,#0x20
000032  f8802035          STRB     r2,[r0,#0x35]
;;;3808     hi2c->Mode = HAL_I2C_MODE_NONE;
000036  f8801036          STRB     r1,[r0,#0x36]
;;;3809   
;;;3810     /* Check if Errors has been detected during transfer */
;;;3811     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00003a  6b81              LDR      r1,[r0,#0x38]
00003c  b111              CBZ      r1,|L38.68|
;;;3812     {
;;;3813       HAL_I2C_ErrorCallback(hi2c);
00003e  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3814     }
;;;3815     else
;;;3816     {
;;;3817       HAL_I2C_MemRxCpltCallback(hi2c);
;;;3818     }
;;;3819   }
000042  bd10              POP      {r4,pc}
                  |L38.68|
000044  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000048  bd10              POP      {r4,pc}
;;;3820   
                          ENDP


                          AREA ||i.I2C_DMAMemTransmitCplt||, CODE, READONLY, ALIGN=2

                  I2C_DMAMemTransmitCplt PROC
;;;3751     */
;;;3752   static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3753   {
;;;3754     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
;;;3755   
;;;3756     /* Wait until BTF flag is reset */
;;;3757     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
000002  6a44              LDR      r4,[r0,#0x24]
000004  2323              MOVS     r3,#0x23
000006  2200              MOVS     r2,#0
000008  4911              LDR      r1,|L39.80|
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000010  b118              CBZ      r0,|L39.26|
;;;3758     {
;;;3759       hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000012  6ba0              LDR      r0,[r4,#0x38]
000014  f0400020          ORR      r0,r0,#0x20
000018  63a0              STR      r0,[r4,#0x38]
                  |L39.26|
;;;3760     }
;;;3761   
;;;3762     /* Generate Stop */
;;;3763     SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f4417100          ORR      r1,r1,#0x200
000022  6001              STR      r1,[r0,#0]
;;;3764   
;;;3765     /* Disable DMA Request */
;;;3766     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6841              LDR      r1,[r0,#4]
000028  f4216100          BIC      r1,r1,#0x800
00002c  6041              STR      r1,[r0,#4]
;;;3767   
;;;3768     hi2c->XferCount = 0;
00002e  2000              MOVS     r0,#0
000030  8560              STRH     r0,[r4,#0x2a]
;;;3769   
;;;3770     hi2c->State = HAL_I2C_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  f8841035          STRB     r1,[r4,#0x35]
;;;3771     hi2c->Mode = HAL_I2C_MODE_NONE;
000038  f8840036          STRB     r0,[r4,#0x36]
;;;3772   
;;;3773     /* Check if Errors has been detected during transfer */
;;;3774     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00003c  6ba0              LDR      r0,[r4,#0x38]
00003e  2800              CMP      r0,#0
;;;3775     {
;;;3776       HAL_I2C_ErrorCallback(hi2c);
;;;3777     }
;;;3778     else
;;;3779     {
;;;3780       HAL_I2C_MemTxCpltCallback(hi2c);
000040  4620              MOV      r0,r4
000042  d002              BEQ      |L39.74|
000044  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3781     }
;;;3782   }
000048  bd10              POP      {r4,pc}
                  |L39.74|
00004a  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
00004e  bd10              POP      {r4,pc}
;;;3783   
                          ENDP

                  |L39.80|
                          DCD      0x00010004

                          AREA ||i.I2C_DMASlaveReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveReceiveCplt PROC
;;;3704     */
;;;3705   static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b538              PUSH     {r3-r5,lr}
;;;3706   {
;;;3707     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
;;;3708   
;;;3709     /* Wait until STOPF flag is reset */
;;;3710     if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
000002  6a44              LDR      r4,[r0,#0x24]
000004  2123              MOVS     r1,#0x23
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00000c  b130              CBZ      r0,|L40.28|
;;;3711     {
;;;3712       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  2804              CMP      r0,#4
;;;3713       {
;;;3714         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;3715       }
;;;3716       else
;;;3717       {
;;;3718         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000012  6ba0              LDR      r0,[r4,#0x38]
000014  d021              BEQ      |L40.90|
000016  f0400020          ORR      r0,r0,#0x20
                  |L40.26|
00001a  63a0              STR      r0,[r4,#0x38]         ;3714
                  |L40.28|
;;;3719       }
;;;3720     }
;;;3721   
;;;3722     /* Clear STOPF flag */
;;;3723     __HAL_I2C_CLEAR_STOPFLAG(hi2c);
00001c  6820              LDR      r0,[r4,#0]
00001e  6941              LDR      r1,[r0,#0x14]
000020  6801              LDR      r1,[r0,#0]
000022  f0410101          ORR      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
;;;3724   
;;;3725     /* Disable Address Acknowledge */
;;;3726     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000028  9100              STR      r1,[sp,#0]
00002a  6820              LDR      r0,[r4,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  f4216180          BIC      r1,r1,#0x400
000032  6001              STR      r1,[r0,#0]
;;;3727   
;;;3728     /* Disable DMA Request */
;;;3729     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000034  6820              LDR      r0,[r4,#0]
000036  6841              LDR      r1,[r0,#4]
000038  f4216100          BIC      r1,r1,#0x800
00003c  6041              STR      r1,[r0,#4]
;;;3730   
;;;3731     hi2c->XferCount = 0;
00003e  2000              MOVS     r0,#0
000040  8560              STRH     r0,[r4,#0x2a]
;;;3732   
;;;3733     hi2c->State = HAL_I2C_STATE_READY;
000042  2120              MOVS     r1,#0x20
000044  f8841035          STRB     r1,[r4,#0x35]
;;;3734     hi2c->Mode = HAL_I2C_MODE_NONE;
000048  f8840036          STRB     r0,[r4,#0x36]
;;;3735   
;;;3736     /* Check if Errors has been detected during transfer */
;;;3737     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  2800              CMP      r0,#0
;;;3738     {
;;;3739       HAL_I2C_ErrorCallback(hi2c);
;;;3740     }
;;;3741     else
;;;3742     {
;;;3743       HAL_I2C_SlaveRxCpltCallback(hi2c);
000050  4620              MOV      r0,r4
000052  d005              BEQ      |L40.96|
000054  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3744     }
;;;3745   }
000058  bd38              POP      {r3-r5,pc}
                  |L40.90|
00005a  f0400004          ORR      r0,r0,#4              ;3714
00005e  e7dc              B        |L40.26|
                  |L40.96|
000060  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
000064  bd38              POP      {r3-r5,pc}
;;;3746   
                          ENDP


                          AREA ||i.I2C_DMASlaveTransmitCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveTransmitCplt PROC
;;;3627     */
;;;3628   static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3629   {
;;;3630     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
;;;3631   
;;;3632     /* Wait until AF flag is reset */
;;;3633     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
000002  6a44              LDR      r4,[r0,#0x24]
000004  2323              MOVS     r3,#0x23
000006  2200              MOVS     r2,#0
000008  f44f3182          MOV      r1,#0x10400
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000012  b118              CBZ      r0,|L41.28|
;;;3634     {
;;;3635       hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
000014  6ba0              LDR      r0,[r4,#0x38]
000016  f0400020          ORR      r0,r0,#0x20
00001a  63a0              STR      r0,[r4,#0x38]
                  |L41.28|
;;;3636     }
;;;3637   
;;;3638     /* Clear AF flag */
;;;3639     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00001c  6820              LDR      r0,[r4,#0]
00001e  6941              LDR      r1,[r0,#0x14]
000020  f4216180          BIC      r1,r1,#0x400
000024  6141              STR      r1,[r0,#0x14]
;;;3640   
;;;3641     /* Disable Address Acknowledge */
;;;3642     CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000026  6820              LDR      r0,[r4,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  f4216180          BIC      r1,r1,#0x400
00002e  6001              STR      r1,[r0,#0]
;;;3643   
;;;3644     /* Disable DMA Request */
;;;3645     CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
000030  6820              LDR      r0,[r4,#0]
000032  6841              LDR      r1,[r0,#4]
000034  f4216100          BIC      r1,r1,#0x800
000038  6041              STR      r1,[r0,#4]
;;;3646   
;;;3647     hi2c->XferCount = 0;
00003a  2000              MOVS     r0,#0
00003c  8560              STRH     r0,[r4,#0x2a]
;;;3648   
;;;3649     hi2c->State = HAL_I2C_STATE_READY;
00003e  2120              MOVS     r1,#0x20
000040  f8841035          STRB     r1,[r4,#0x35]
;;;3650     hi2c->Mode = HAL_I2C_MODE_NONE;
000044  f8840036          STRB     r0,[r4,#0x36]
;;;3651   
;;;3652     /* Check if Errors has been detected during transfer */
;;;3653     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
000048  6ba0              LDR      r0,[r4,#0x38]
00004a  2800              CMP      r0,#0
;;;3654     {
;;;3655       HAL_I2C_ErrorCallback(hi2c);
;;;3656     }
;;;3657     else
;;;3658     {
;;;3659       HAL_I2C_SlaveTxCpltCallback(hi2c);
00004c  4620              MOV      r0,r4
00004e  d002              BEQ      |L41.86|
000050  f7fffffe          BL       HAL_I2C_ErrorCallback
;;;3660     }
;;;3661   }
000054  bd10              POP      {r4,pc}
                  |L41.86|
000056  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
00005a  bd10              POP      {r4,pc}
;;;3662   
                          ENDP


                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=1

                  I2C_IsAcknowledgeFailed PROC
;;;4164     */
;;;4165   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
000000  6801              LDR      r1,[r0,#0]
;;;4166   {
;;;4167     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000002  694a              LDR      r2,[r1,#0x14]
000004  43d2              MVNS     r2,r2
000006  0552              LSLS     r2,r2,#21
000008  d40d              BMI      |L42.38|
;;;4168     {
;;;4169       /* Clear NACKF Flag */
;;;4170       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00000a  694a              LDR      r2,[r1,#0x14]
00000c  f4226280          BIC      r2,r2,#0x400
000010  614a              STR      r2,[r1,#0x14]
;;;4171   
;;;4172       hi2c->ErrorCode = HAL_I2C_ERROR_AF;
000012  2104              MOVS     r1,#4
000014  6381              STR      r1,[r0,#0x38]
;;;4173       hi2c->State= HAL_I2C_STATE_READY;
000016  2120              MOVS     r1,#0x20
000018  f8801035          STRB     r1,[r0,#0x35]
;;;4174   
;;;4175       /* Process Unlocked */
;;;4176       __HAL_UNLOCK(hi2c);
00001c  2100              MOVS     r1,#0
00001e  f8801034          STRB     r1,[r0,#0x34]
;;;4177   
;;;4178       return HAL_ERROR;
000022  2001              MOVS     r0,#1
;;;4179     }
;;;4180     return HAL_OK;
;;;4181   }
000024  4770              BX       lr
                  |L42.38|
000026  2000              MOVS     r0,#0                 ;4180
000028  4770              BX       lr
;;;4182   /**
                          ENDP


                          AREA ||i.I2C_MasterReceive_BTF||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_BTF PROC
;;;3029     */
;;;3030   static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3031   {
;;;3032     if(hi2c->XferCount == 3)
000002  8d42              LDRH     r2,[r0,#0x2a]
000004  6801              LDR      r1,[r0,#0]
000006  2a03              CMP      r2,#3
000008  d003              BEQ      |L43.18|
;;;3033     {
;;;3034       /* Disable Acknowledge */
;;;3035       CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
;;;3036   
;;;3037       /* Read data from DR */
;;;3038       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;3039       hi2c->XferCount--;
;;;3040     }
;;;3041     else if(hi2c->XferCount == 2)
00000a  8d42              LDRH     r2,[r0,#0x2a]
00000c  2a02              CMP      r2,#2
00000e  d00f              BEQ      |L43.48|
000010  e004              B        |L43.28|
                  |L43.18|
000012  680a              LDR      r2,[r1,#0]            ;3035
000014  f4226280          BIC      r2,r2,#0x400          ;3035
000018  600a              STR      r2,[r1,#0]            ;3035
00001a  6801              LDR      r1,[r0,#0]            ;3038
                  |L43.28|
;;;3042     {
;;;3043       /* Disable EVT and ERR interrupt */
;;;3044       /* Workaround - Wong data read into data register */
;;;3045       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
;;;3046   
;;;3047       /* Generate Stop */
;;;3048       SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3049   
;;;3050       /* Read data from DR */
;;;3051       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;3052       hi2c->XferCount--;
;;;3053   
;;;3054       /* Read data from DR */
;;;3055       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
;;;3056       hi2c->XferCount--;
;;;3057   
;;;3058       if(hi2c->Mode == HAL_I2C_MODE_MEM)
;;;3059       {
;;;3060         hi2c->State = HAL_I2C_STATE_READY;
;;;3061   
;;;3062         HAL_I2C_MemRxCpltCallback(hi2c);
;;;3063       }
;;;3064       else
;;;3065       {
;;;3066         hi2c->State = HAL_I2C_STATE_READY;
;;;3067   
;;;3068         HAL_I2C_MasterRxCpltCallback(hi2c);
;;;3069       }
;;;3070     }
;;;3071     else
;;;3072     {
;;;3073       /* Read data from DR */
;;;3074       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
00001c  690a              LDR      r2,[r1,#0x10]
00001e  6a41              LDR      r1,[r0,#0x24]
000020  1c4b              ADDS     r3,r1,#1
000022  6243              STR      r3,[r0,#0x24]
000024  700a              STRB     r2,[r1,#0]
;;;3075       hi2c->XferCount--;
000026  8d41              LDRH     r1,[r0,#0x2a]
000028  1e49              SUBS     r1,r1,#1
00002a  8541              STRH     r1,[r0,#0x2a]
                  |L43.44|
;;;3076     }
;;;3077     return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;3078   }
00002e  bd10              POP      {r4,pc}
                  |L43.48|
000030  684a              LDR      r2,[r1,#4]            ;3045
000032  f4227240          BIC      r2,r2,#0x300          ;3045
000036  604a              STR      r2,[r1,#4]            ;3045
000038  6801              LDR      r1,[r0,#0]            ;3048
00003a  680a              LDR      r2,[r1,#0]            ;3048
00003c  f4427200          ORR      r2,r2,#0x200          ;3048
000040  600a              STR      r2,[r1,#0]            ;3048
000042  6801              LDR      r1,[r0,#0]            ;3051
000044  690a              LDR      r2,[r1,#0x10]         ;3051
000046  6a41              LDR      r1,[r0,#0x24]         ;3051
000048  1c4b              ADDS     r3,r1,#1              ;3051
00004a  6243              STR      r3,[r0,#0x24]         ;3051
00004c  700a              STRB     r2,[r1,#0]            ;3051
00004e  8d41              LDRH     r1,[r0,#0x2a]         ;3052
000050  1e49              SUBS     r1,r1,#1              ;3052
000052  8541              STRH     r1,[r0,#0x2a]         ;3052
000054  6801              LDR      r1,[r0,#0]            ;3055
000056  690a              LDR      r2,[r1,#0x10]         ;3055
000058  6a41              LDR      r1,[r0,#0x24]         ;3055
00005a  1c4b              ADDS     r3,r1,#1              ;3055
00005c  6243              STR      r3,[r0,#0x24]         ;3055
00005e  700a              STRB     r2,[r1,#0]            ;3055
000060  8d41              LDRH     r1,[r0,#0x2a]         ;3056
000062  1e49              SUBS     r1,r1,#1              ;3056
000064  8541              STRH     r1,[r0,#0x2a]         ;3056
000066  f8902036          LDRB     r2,[r0,#0x36]         ;3058
00006a  2120              MOVS     r1,#0x20              ;3060
00006c  2a40              CMP      r2,#0x40              ;3058
00006e  f8801035          STRB     r1,[r0,#0x35]         ;3066
000072  d002              BEQ      |L43.122|
000074  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
000078  e7d8              B        |L43.44|
                  |L43.122|
00007a  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
00007e  e7d5              B        |L43.44|
;;;3079   
                          ENDP


                          AREA ||i.I2C_MasterReceive_RXNE||, CODE, READONLY, ALIGN=1

                  I2C_MasterReceive_RXNE PROC
;;;2982     */
;;;2983   static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;2984   {
;;;2985     uint32_t tmp = 0;
;;;2986   
;;;2987     tmp = hi2c->XferCount;
000002  8d42              LDRH     r2,[r0,#0x2a]
;;;2988     if(tmp > 3)
000004  6801              LDR      r1,[r0,#0]
000006  2a03              CMP      r2,#3
000008  d908              BLS      |L44.28|
;;;2989     {
;;;2990       /* Read data from DR */
;;;2991       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
00000a  690a              LDR      r2,[r1,#0x10]
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  1c4b              ADDS     r3,r1,#1
000010  6243              STR      r3,[r0,#0x24]
000012  700a              STRB     r2,[r1,#0]
;;;2992       hi2c->XferCount--;
000014  8d41              LDRH     r1,[r0,#0x2a]
000016  1e49              SUBS     r1,r1,#1
000018  8541              STRH     r1,[r0,#0x2a]
00001a  e019              B        |L44.80|
                  |L44.28|
;;;2993     }
;;;2994     else if((tmp == 2) || (tmp == 3))
00001c  2a02              CMP      r2,#2
00001e  d019              BEQ      |L44.84|
000020  2a03              CMP      r2,#3
000022  d017              BEQ      |L44.84|
;;;2995     {
;;;2996       /* Disable BUF interrupt */
;;;2997       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
;;;2998     }
;;;2999     else
;;;3000     {
;;;3001       /* Disable EVT, BUF and ERR interrupt */
;;;3002       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
000024  684a              LDR      r2,[r1,#4]
000026  f42262e0          BIC      r2,r2,#0x700
00002a  604a              STR      r2,[r1,#4]
;;;3003   
;;;3004       /* Read data from DR */
;;;3005       (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
00002c  6801              LDR      r1,[r0,#0]
00002e  690a              LDR      r2,[r1,#0x10]
000030  6a41              LDR      r1,[r0,#0x24]
000032  1c4b              ADDS     r3,r1,#1
000034  6243              STR      r3,[r0,#0x24]
000036  700a              STRB     r2,[r1,#0]
;;;3006       hi2c->XferCount--;
000038  8d41              LDRH     r1,[r0,#0x2a]
00003a  1e49              SUBS     r1,r1,#1
00003c  8541              STRH     r1,[r0,#0x2a]
;;;3007   
;;;3008       if(hi2c->Mode == HAL_I2C_MODE_MEM)
00003e  f8902036          LDRB     r2,[r0,#0x36]
;;;3009       {
;;;3010         hi2c->State = HAL_I2C_STATE_READY;
000042  2120              MOVS     r1,#0x20
000044  2a40              CMP      r2,#0x40              ;3008
;;;3011   
;;;3012         HAL_I2C_MemRxCpltCallback(hi2c);
;;;3013       }
;;;3014       else
;;;3015       {
;;;3016         hi2c->State = HAL_I2C_STATE_READY;
000046  f8801035          STRB     r1,[r0,#0x35]
00004a  d008              BEQ      |L44.94|
;;;3017   
;;;3018         HAL_I2C_MasterRxCpltCallback(hi2c);
00004c  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L44.80|
;;;3019       }
;;;3020     }
;;;3021     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;3022   }
000052  bd10              POP      {r4,pc}
                  |L44.84|
000054  6848              LDR      r0,[r1,#4]            ;2997
000056  f4206080          BIC      r0,r0,#0x400          ;2997
00005a  6048              STR      r0,[r1,#4]            ;2997
00005c  e7f8              B        |L44.80|
                  |L44.94|
00005e  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
000062  e7f5              B        |L44.80|
;;;3023   
                          ENDP


                          AREA ||i.I2C_MasterRequestRead||, CODE, READONLY, ALIGN=1

                  I2C_MasterRequestRead PROC
;;;3279     */
;;;3280   static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3281   {
000004  4604              MOV      r4,r0
;;;3282     /* Enable Acknowledge */
;;;3283     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000006  6800              LDR      r0,[r0,#0]
000008  460d              MOV      r5,r1                 ;3281
00000a  4691              MOV      r9,r2                 ;3281
00000c  6801              LDR      r1,[r0,#0]
00000e  f4416180          ORR      r1,r1,#0x400
000012  6001              STR      r1,[r0,#0]
;;;3284   
;;;3285     /* Generate Start */
;;;3286     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000014  6820              LDR      r0,[r4,#0]
000016  6801              LDR      r1,[r0,#0]
000018  f4417180          ORR      r1,r1,#0x100
00001c  6001              STR      r1,[r0,#0]
;;;3287   
;;;3288     /* Wait until SB flag is set */
;;;3289     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
00001e  4613              MOV      r3,r2
000020  f04f1701          MOV      r7,#0x10001
000024  2200              MOVS     r2,#0
000026  4639              MOV      r1,r7
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00002e  bb98              CBNZ     r0,|L45.152|
;;;3290     {
;;;3291       return HAL_TIMEOUT;
;;;3292     }
;;;3293   
;;;3294     if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000030  6920              LDR      r0,[r4,#0x10]
;;;3295     {
;;;3296       /* Send slave address */
;;;3297       hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;3298     }
;;;3299     else
;;;3300     {
;;;3301       /* Send header of slave address */
;;;3302       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
;;;3303   
;;;3304       /* Wait until ADD10 flag is set */
;;;3305       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
;;;3306       {
;;;3307         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3308         {
;;;3309           return HAL_ERROR;
;;;3310         }
;;;3311         else
;;;3312         {
;;;3313           return HAL_TIMEOUT;
;;;3314         }
;;;3315       }
;;;3316   
;;;3317       /* Send slave address */
;;;3318       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;3319   
;;;3320       /* Wait until ADDR flag is set */
;;;3321       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
000032  f1070801          ADD      r8,r7,#1
000036  f5b04f80          CMP      r0,#0x4000            ;3294
00003a  d010              BEQ      |L45.94|
00003c  2006              MOVS     r0,#6                 ;3302
00003e  6821              LDR      r1,[r4,#0]            ;3302
000040  ea0016d5          AND      r6,r0,r5,LSR #7       ;3302
000044  f04600f0          ORR      r0,r6,#0xf0           ;3302
000048  6108              STR      r0,[r1,#0x10]         ;3302
00004a  464a              MOV      r2,r9                 ;3305
00004c  1df9              ADDS     r1,r7,#7              ;3305
00004e  4620              MOV      r0,r4                 ;3305
000050  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000054  b138              CBZ      r0,|L45.102|
                  |L45.86|
000056  6ba0              LDR      r0,[r4,#0x38]         ;3307
000058  2804              CMP      r0,#4                 ;3307
00005a  d02c              BEQ      |L45.182|
00005c  e01c              B        |L45.152|
                  |L45.94|
00005e  b2e8              UXTB     r0,r5                 ;3297
000060  f0400001          ORR      r0,r0,#1              ;3297
000064  e01d              B        |L45.162|
                  |L45.102|
000066  6821              LDR      r1,[r4,#0]            ;3318
000068  b2e8              UXTB     r0,r5                 ;3318
00006a  6108              STR      r0,[r1,#0x10]         ;3318
00006c  464a              MOV      r2,r9
00006e  4641              MOV      r1,r8
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000076  2800              CMP      r0,#0
000078  d1ed              BNE      |L45.86|
;;;3322       {
;;;3323         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3324         {
;;;3325           return HAL_ERROR;
;;;3326         }
;;;3327         else
;;;3328         {
;;;3329           return HAL_TIMEOUT;
;;;3330         }
;;;3331       }
;;;3332   
;;;3333       /* Clear ADDR flag */
;;;3334       __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
00007a  6820              LDR      r0,[r4,#0]
00007c  6941              LDR      r1,[r0,#0x14]
00007e  6981              LDR      r1,[r0,#0x18]
;;;3335   
;;;3336       /* Generate Restart */
;;;3337       SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000080  9100              STR      r1,[sp,#0]
000082  6801              LDR      r1,[r0,#0]
000084  f4417180          ORR      r1,r1,#0x100
000088  6001              STR      r1,[r0,#0]
;;;3338   
;;;3339       /* Wait until SB flag is set */
;;;3340       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
00008a  464b              MOV      r3,r9
00008c  2200              MOVS     r2,#0
00008e  4639              MOV      r1,r7
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000096  b110              CBZ      r0,|L45.158|
                  |L45.152|
;;;3341       {
;;;3342         return HAL_TIMEOUT;
;;;3343       }
;;;3344   
;;;3345       /* Send header of slave address */
;;;3346       hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
;;;3347     }
;;;3348   
;;;3349     /* Wait until ADDR flag is set */
;;;3350     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
;;;3351     {
;;;3352       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3353       {
;;;3354         return HAL_ERROR;
;;;3355       }
;;;3356       else
;;;3357       {
;;;3358         return HAL_TIMEOUT;
000098  2003              MOVS     r0,#3
                  |L45.154|
;;;3359       }
;;;3360     }
;;;3361   
;;;3362     return HAL_OK;
;;;3363   }
00009a  e8bd83f8          POP      {r3-r9,pc}
                  |L45.158|
00009e  f04600f1          ORR      r0,r6,#0xf1           ;3346
                  |L45.162|
0000a2  6821              LDR      r1,[r4,#0]            ;3346
0000a4  6108              STR      r0,[r1,#0x10]         ;3346
0000a6  464a              MOV      r2,r9                 ;3350
0000a8  4641              MOV      r1,r8                 ;3350
0000aa  4620              MOV      r0,r4                 ;3350
0000ac  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000b0  2800              CMP      r0,#0                 ;3350
0000b2  d1d0              BNE      |L45.86|
0000b4  e7f1              B        |L45.154|
                  |L45.182|
0000b6  2001              MOVS     r0,#1                 ;3354
0000b8  e7ef              B        |L45.154|
;;;3364   
                          ENDP


                          AREA ||i.I2C_MasterRequestWrite||, CODE, READONLY, ALIGN=2

                  I2C_MasterRequestWrite PROC
;;;3217     */
;;;3218   static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;3219   {
000002  4604              MOV      r4,r0
;;;3220     /* Generate Start */
;;;3221     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000004  6800              LDR      r0,[r0,#0]
000006  460d              MOV      r5,r1                 ;3219
000008  4616              MOV      r6,r2                 ;3219
00000a  6801              LDR      r1,[r0,#0]
00000c  f4417180          ORR      r1,r1,#0x100
000010  6001              STR      r1,[r0,#0]
;;;3222   
;;;3223     /* Wait until SB flag is set */
;;;3224     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
000012  4613              MOV      r3,r2
000014  2200              MOVS     r2,#0
000016  f04f1101          MOV      r1,#0x10001
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000020  b998              CBNZ     r0,|L46.74|
;;;3225     {
;;;3226       return HAL_TIMEOUT;
;;;3227     }
;;;3228   
;;;3229     if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
000022  6920              LDR      r0,[r4,#0x10]
000024  f5b04f80          CMP      r0,#0x4000
000028  d011              BEQ      |L46.78|
;;;3230     {
;;;3231       /* Send slave address */
;;;3232       hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
;;;3233     }
;;;3234     else
;;;3235     {
;;;3236       /* Send header of slave address */
;;;3237       hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
00002a  2006              MOVS     r0,#6
00002c  6821              LDR      r1,[r4,#0]
00002e  ea0010d5          AND      r0,r0,r5,LSR #7
000032  f04000f0          ORR      r0,r0,#0xf0
000036  6108              STR      r0,[r1,#0x10]
;;;3238   
;;;3239       /* Wait until ADD10 flag is set */
;;;3240       if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
000038  4632              MOV      r2,r6
00003a  490d              LDR      r1,|L46.112|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000042  b138              CBZ      r0,|L46.84|
                  |L46.68|
;;;3241       {
;;;3242         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000044  6ba0              LDR      r0,[r4,#0x38]
000046  2804              CMP      r0,#4
000048  d010              BEQ      |L46.108|
                  |L46.74|
;;;3243         {
;;;3244           return HAL_ERROR;
;;;3245         }
;;;3246         else
;;;3247         {
;;;3248           return HAL_TIMEOUT;
;;;3249         }
;;;3250       }
;;;3251   
;;;3252       /* Send slave address */
;;;3253       hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
;;;3254     }
;;;3255   
;;;3256     /* Wait until ADDR flag is set */
;;;3257     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
;;;3258     {
;;;3259       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3260       {
;;;3261         return HAL_ERROR;
;;;3262       }
;;;3263       else
;;;3264       {
;;;3265         return HAL_TIMEOUT;
00004a  2003              MOVS     r0,#3
;;;3266       }
;;;3267     }
;;;3268   
;;;3269     return HAL_OK;
;;;3270   }
00004c  bd70              POP      {r4-r6,pc}
                  |L46.78|
00004e  f00500fe          AND      r0,r5,#0xfe           ;3232
000052  e000              B        |L46.86|
                  |L46.84|
000054  b2e8              UXTB     r0,r5                 ;3253
                  |L46.86|
000056  6821              LDR      r1,[r4,#0]            ;3253
000058  6108              STR      r0,[r1,#0x10]         ;3253
00005a  4905              LDR      r1,|L46.112|
00005c  4632              MOV      r2,r6                 ;3257
00005e  1f89              SUBS     r1,r1,#6              ;3257
000060  4620              MOV      r0,r4                 ;3257
000062  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
000066  2800              CMP      r0,#0                 ;3257
000068  d1ec              BNE      |L46.68|
00006a  bd70              POP      {r4-r6,pc}
                  |L46.108|
00006c  2001              MOVS     r0,#1                 ;3261
00006e  bd70              POP      {r4-r6,pc}
;;;3271   
                          ENDP

                  |L46.112|
                          DCD      0x00010008

                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=1

                  I2C_RequestMemoryRead PROC
;;;3463     */
;;;3464   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3465   {
000004  4604              MOV      r4,r0
;;;3466     /* Enable Acknowledge */
;;;3467     SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
000006  6800              LDR      r0,[r0,#0]
000008  460f              MOV      r7,r1                 ;3465
00000a  f8ddb028          LDR      r11,[sp,#0x28]
00000e  6801              LDR      r1,[r0,#0]
000010  4698              MOV      r8,r3                 ;3465
000012  4616              MOV      r6,r2                 ;3465
000014  f4416180          ORR      r1,r1,#0x400
000018  6001              STR      r1,[r0,#0]
;;;3468   
;;;3469     /* Generate Start */
;;;3470     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f4417180          ORR      r1,r1,#0x100
000022  6001              STR      r1,[r0,#0]
;;;3471   
;;;3472     /* Wait until SB flag is set */
;;;3473     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
000024  f04f1901          MOV      r9,#0x10001
000028  465b              MOV      r3,r11
00002a  2200              MOVS     r2,#0
00002c  4649              MOV      r1,r9
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000034  bbf0              CBNZ     r0,|L47.180|
;;;3474     {
;;;3475       return HAL_TIMEOUT;
;;;3476     }
;;;3477   
;;;3478     /* Send slave address */
;;;3479     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
000036  6821              LDR      r1,[r4,#0]
000038  f00700fe          AND      r0,r7,#0xfe
00003c  6108              STR      r0,[r1,#0x10]
;;;3480   
;;;3481     /* Wait until ADDR flag is set */
;;;3482     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
00003e  f1090a01          ADD      r10,r9,#1
000042  465a              MOV      r2,r11
000044  4651              MOV      r1,r10
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00004c  b118              CBZ      r0,|L47.86|
                  |L47.78|
;;;3483     {
;;;3484       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00004e  6ba0              LDR      r0,[r4,#0x38]
000050  2804              CMP      r0,#4
000052  d011              BEQ      |L47.120|
000054  e036              B        |L47.196|
                  |L47.86|
;;;3485       {
;;;3486         return HAL_ERROR;
;;;3487       }
;;;3488       else
;;;3489       {
;;;3490         return HAL_TIMEOUT;
;;;3491       }
;;;3492     }
;;;3493   
;;;3494     /* Clear ADDR flag */
;;;3495     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
000056  6820              LDR      r0,[r4,#0]
000058  6941              LDR      r1,[r0,#0x14]
00005a  6980              LDR      r0,[r0,#0x18]
;;;3496   
;;;3497     /* Wait until TXE flag is set */
;;;3498     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
00005c  9000              STR      r0,[sp,#0]
00005e  4659              MOV      r1,r11
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000066  b150              CBZ      r0,|L47.126|
                  |L47.104|
;;;3499     {
;;;3500       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
000068  6ba0              LDR      r0,[r4,#0x38]
00006a  2804              CMP      r0,#4
00006c  d12a              BNE      |L47.196|
;;;3501       {
;;;3502         /* Generate Stop */
;;;3503         SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
00006e  6820              LDR      r0,[r4,#0]
000070  6801              LDR      r1,[r0,#0]
000072  f4417100          ORR      r1,r1,#0x200
000076  6001              STR      r1,[r0,#0]
                  |L47.120|
;;;3504         return HAL_ERROR;
;;;3505       }
;;;3506       else
;;;3507       {
;;;3508         return HAL_TIMEOUT;
;;;3509       }
;;;3510     }
;;;3511   
;;;3512     /* If Memory address size is 8Bit */
;;;3513     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;3514     {
;;;3515       /* Send Memory Address */
;;;3516       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;3517     }
;;;3518     /* If Memory address size is 16Bit */
;;;3519     else
;;;3520     {
;;;3521       /* Send MSB of Memory Address */
;;;3522       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;3523   
;;;3524       /* Wait until TXE flag is set */
;;;3525       if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;3526       {
;;;3527         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3528         {
;;;3529           /* Generate Stop */
;;;3530           SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;3531           return HAL_ERROR;
;;;3532         }
;;;3533         else
;;;3534         {
;;;3535           return HAL_TIMEOUT;
;;;3536         }
;;;3537       }
;;;3538   
;;;3539       /* Send LSB of Memory Address */
;;;3540       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;3541     }
;;;3542   
;;;3543     /* Wait until TXE flag is set */
;;;3544     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;3545     {
;;;3546       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3547       {
;;;3548         /* Generate Stop */
;;;3549         SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;3550         return HAL_ERROR;
;;;3551       }
;;;3552       else
;;;3553       {
;;;3554         return HAL_TIMEOUT;
;;;3555       }
;;;3556     }
;;;3557   
;;;3558     /* Generate Restart */
;;;3559     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
;;;3560   
;;;3561     /* Wait until SB flag is set */
;;;3562     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
;;;3563     {
;;;3564       return HAL_TIMEOUT;
;;;3565     }
;;;3566   
;;;3567     /* Send slave address */
;;;3568     hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
;;;3569   
;;;3570     /* Wait until ADDR flag is set */
;;;3571     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
;;;3572     {
;;;3573       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3574       {
;;;3575         return HAL_ERROR;
000078  2001              MOVS     r0,#1
                  |L47.122|
;;;3576       }
;;;3577       else
;;;3578       {
;;;3579         return HAL_TIMEOUT;
;;;3580       }
;;;3581     }
;;;3582   
;;;3583     return HAL_OK;
;;;3584   }
00007a  e8bd8ff8          POP      {r3-r11,pc}
                  |L47.126|
00007e  b2f5              UXTB     r5,r6                 ;3516
000080  f1b80f01          CMP      r8,#1                 ;3513
000084  d008              BEQ      |L47.152|
000086  6821              LDR      r1,[r4,#0]            ;3522
000088  0a30              LSRS     r0,r6,#8              ;3522
00008a  6108              STR      r0,[r1,#0x10]         ;3522
00008c  4659              MOV      r1,r11                ;3525
00008e  4620              MOV      r0,r4                 ;3525
000090  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
000094  2800              CMP      r0,#0                 ;3525
000096  d1e7              BNE      |L47.104|
                  |L47.152|
000098  6820              LDR      r0,[r4,#0]            ;3540
00009a  6105              STR      r5,[r0,#0x10]         ;3540
00009c  4659              MOV      r1,r11                ;3544
00009e  4620              MOV      r0,r4                 ;3544
0000a0  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
0000a4  2800              CMP      r0,#0                 ;3544
0000a6  d1df              BNE      |L47.104|
0000a8  6820              LDR      r0,[r4,#0]            ;3559
0000aa  6801              LDR      r1,[r0,#0]            ;3559
0000ac  f4417180          ORR      r1,r1,#0x100          ;3559
0000b0  6001              STR      r1,[r0,#0]            ;3559
0000b2  e000              B        |L47.182|
                  |L47.180|
0000b4  e006              B        |L47.196|
                  |L47.182|
0000b6  465b              MOV      r3,r11                ;3562
0000b8  2200              MOVS     r2,#0                 ;3562
0000ba  4649              MOV      r1,r9                 ;3562
0000bc  4620              MOV      r0,r4                 ;3562
0000be  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000c2  b108              CBZ      r0,|L47.200|
                  |L47.196|
0000c4  2003              MOVS     r0,#3                 ;3579
0000c6  e7d8              B        |L47.122|
                  |L47.200|
0000c8  6821              LDR      r1,[r4,#0]            ;3568
0000ca  b2f8              UXTB     r0,r7                 ;3568
0000cc  f0400001          ORR      r0,r0,#1              ;3568
0000d0  6108              STR      r0,[r1,#0x10]         ;3568
0000d2  465a              MOV      r2,r11                ;3571
0000d4  4651              MOV      r1,r10                ;3571
0000d6  4620              MOV      r0,r4                 ;3571
0000d8  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
0000dc  2800              CMP      r0,#0                 ;3571
0000de  d1b6              BNE      |L47.78|
0000e0  e7cb              B        |L47.122|
;;;3585   
                          ENDP


                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=2

                  I2C_RequestMemoryWrite PROC
;;;3374     */
;;;3375   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3376   {
000004  4604              MOV      r4,r0
;;;3377     /* Generate Start */
;;;3378     SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
000006  6800              LDR      r0,[r0,#0]
000008  460e              MOV      r6,r1                 ;3376
00000a  f8dd8020          LDR      r8,[sp,#0x20]
00000e  6801              LDR      r1,[r0,#0]
000010  461f              MOV      r7,r3                 ;3376
000012  4615              MOV      r5,r2                 ;3376
000014  f4417180          ORR      r1,r1,#0x100
000018  6001              STR      r1,[r0,#0]
;;;3379   
;;;3380     /* Wait until SB flag is set */
;;;3381     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
00001a  4643              MOV      r3,r8
00001c  2200              MOVS     r2,#0
00001e  f04f1101          MOV      r1,#0x10001
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000028  b9d8              CBNZ     r0,|L48.98|
;;;3382     {
;;;3383       return HAL_TIMEOUT;
;;;3384     }
;;;3385   
;;;3386     /* Send slave address */
;;;3387     hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
00002a  6821              LDR      r1,[r4,#0]
00002c  f00600fe          AND      r0,r6,#0xfe
000030  6108              STR      r0,[r1,#0x10]
;;;3388   
;;;3389     /* Wait until ADDR flag is set */
;;;3390     if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
000032  4642              MOV      r2,r8
000034  4917              LDR      r1,|L48.148|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       I2C_WaitOnMasterAddressFlagUntilTimeout
00003c  b128              CBZ      r0,|L48.74|
;;;3391     {
;;;3392       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00003e  6ba0              LDR      r0,[r4,#0x38]
000040  2804              CMP      r0,#4
000042  d10e              BNE      |L48.98|
                  |L48.68|
;;;3393       {
;;;3394         return HAL_ERROR;
000044  2001              MOVS     r0,#1
                  |L48.70|
;;;3395       }
;;;3396       else
;;;3397       {
;;;3398         return HAL_TIMEOUT;
;;;3399       }
;;;3400     }
;;;3401   
;;;3402     /* Clear ADDR flag */
;;;3403     __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
;;;3404   
;;;3405     /* Wait until TXE flag is set */
;;;3406     if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;3407     {
;;;3408       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3409       {
;;;3410         /* Generate Stop */
;;;3411         SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;3412         return HAL_ERROR;
;;;3413       }
;;;3414       else
;;;3415       {
;;;3416         return HAL_TIMEOUT;
;;;3417       }
;;;3418     }
;;;3419   
;;;3420     /* If Memory address size is 8Bit */
;;;3421     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;3422     {
;;;3423       /* Send Memory Address */
;;;3424       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;3425     }
;;;3426     /* If Memory address size is 16Bit */
;;;3427     else
;;;3428     {
;;;3429       /* Send MSB of Memory Address */
;;;3430       hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
;;;3431   
;;;3432       /* Wait until TXE flag is set */
;;;3433       if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
;;;3434       {
;;;3435         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3436         {
;;;3437           /* Generate Stop */
;;;3438           SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
;;;3439           return HAL_ERROR;
;;;3440         }
;;;3441         else
;;;3442         {
;;;3443           return HAL_TIMEOUT;
;;;3444         }
;;;3445       }
;;;3446   
;;;3447       /* Send LSB of Memory Address */
;;;3448       hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
;;;3449     }
;;;3450   
;;;3451     return HAL_OK;
;;;3452   }
000046  e8bd83f8          POP      {r3-r9,pc}
                  |L48.74|
00004a  6820              LDR      r0,[r4,#0]            ;3403
00004c  6941              LDR      r1,[r0,#0x14]         ;3403
00004e  6980              LDR      r0,[r0,#0x18]         ;3403
000050  9000              STR      r0,[sp,#0]            ;3406
000052  4641              MOV      r1,r8                 ;3406
000054  4620              MOV      r0,r4                 ;3406
000056  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00005a  b120              CBZ      r0,|L48.102|
                  |L48.92|
00005c  6ba0              LDR      r0,[r4,#0x38]         ;3408
00005e  2804              CMP      r0,#4                 ;3408
000060  d011              BEQ      |L48.134|
                  |L48.98|
000062  2003              MOVS     r0,#3                 ;3443
000064  e7ef              B        |L48.70|
                  |L48.102|
000066  b2ee              UXTB     r6,r5                 ;3424
000068  2f01              CMP      r7,#1                 ;3421
00006a  d008              BEQ      |L48.126|
00006c  6821              LDR      r1,[r4,#0]            ;3430
00006e  0a28              LSRS     r0,r5,#8              ;3430
000070  6108              STR      r0,[r1,#0x10]         ;3430
000072  4641              MOV      r1,r8                 ;3433
000074  4620              MOV      r0,r4                 ;3433
000076  f7fffffe          BL       I2C_WaitOnTXEFlagUntilTimeout
00007a  2800              CMP      r0,#0                 ;3433
00007c  d1ee              BNE      |L48.92|
                  |L48.126|
00007e  6820              LDR      r0,[r4,#0]            ;3448
000080  6106              STR      r6,[r0,#0x10]         ;3448
000082  2000              MOVS     r0,#0                 ;3451
000084  e7df              B        |L48.70|
                  |L48.134|
000086  6820              LDR      r0,[r4,#0]            ;3438
000088  6801              LDR      r1,[r0,#0]            ;3438
00008a  f4417100          ORR      r1,r1,#0x200          ;3438
00008e  6001              STR      r1,[r0,#0]            ;3438
000090  e7d8              B        |L48.68|
;;;3453   
                          ENDP

000092  0000              DCW      0x0000
                  |L48.148|
                          DCD      0x00010002

                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;3905     */
;;;3906   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3907   {
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  460c              MOV      r4,r1
00000a  4605              MOV      r5,r0
;;;3908     uint32_t tickstart = 0;
;;;3909   
;;;3910     /* Get tick */
;;;3911     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4681              MOV      r9,r0
000012  f04f0a00          MOV      r10,#0
;;;3912   
;;;3913     /* Wait until flag is set */
;;;3914     if(Status == RESET)
;;;3915     {
;;;3916       while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
;;;3917       {
;;;3918         /* Check for the Timeout */
;;;3919         if(Timeout != HAL_MAX_DELAY)
;;;3920         {
;;;3921           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;3922           {
;;;3923             hi2c->State= HAL_I2C_STATE_READY;
000016  f04f0b20          MOV      r11,#0x20
00001a  f3c44707          UBFX     r7,r4,#16,#8          ;3916
00001e  f1b80f00          CMP      r8,#0                 ;3914
000022  d009              BEQ      |L49.56|
000024  e024              B        |L49.112|
                  |L49.38|
000026  1c70              ADDS     r0,r6,#1              ;3919
000028  d006              BEQ      |L49.56|
00002a  b1d6              CBZ      r6,|L49.98|
00002c  f7fffffe          BL       HAL_GetTick
000030  eba00009          SUB      r0,r0,r9              ;3921
000034  42b0              CMP      r0,r6                 ;3921
000036  d814              BHI      |L49.98|
                  |L49.56|
000038  6828              LDR      r0,[r5,#0]            ;3916
00003a  2f01              CMP      r7,#1                 ;3916
00003c  d006              BEQ      |L49.76|
00003e  6980              LDR      r0,[r0,#0x18]         ;3916
                  |L49.64|
000040  ea240000          BIC      r0,r4,r0              ;3916
000044  0400              LSLS     r0,r0,#16             ;3916
000046  0c00              LSRS     r0,r0,#16             ;3916
000048  d01b              BEQ      |L49.130|
00004a  e7ec              B        |L49.38|
                  |L49.76|
00004c  6940              LDR      r0,[r0,#0x14]         ;3916
00004e  e7f7              B        |L49.64|
                  |L49.80|
;;;3924   
;;;3925             /* Process Unlocked */
;;;3926             __HAL_UNLOCK(hi2c);
;;;3927   
;;;3928             return HAL_TIMEOUT;
;;;3929           }
;;;3930         }
;;;3931       }
;;;3932     }
;;;3933     else
;;;3934     {
;;;3935       while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
;;;3936       {
;;;3937         /* Check for the Timeout */
;;;3938         if(Timeout != HAL_MAX_DELAY)
000050  1c70              ADDS     r0,r6,#1
000052  d00d              BEQ      |L49.112|
;;;3939         {
;;;3940           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000054  b12e              CBZ      r6,|L49.98|
000056  f7fffffe          BL       HAL_GetTick
00005a  eba00009          SUB      r0,r0,r9
00005e  42b0              CMP      r0,r6
000060  d906              BLS      |L49.112|
                  |L49.98|
;;;3941           {
;;;3942             hi2c->State= HAL_I2C_STATE_READY;
000062  f885b035          STRB     r11,[r5,#0x35]
;;;3943   
;;;3944             /* Process Unlocked */
;;;3945             __HAL_UNLOCK(hi2c);
000066  f885a034          STRB     r10,[r5,#0x34]
;;;3946   
;;;3947             return HAL_TIMEOUT;
00006a  2003              MOVS     r0,#3
                  |L49.108|
;;;3948           }
;;;3949         }
;;;3950       }
;;;3951     }
;;;3952     return HAL_OK;
;;;3953   }
00006c  e8bd9ff0          POP      {r4-r12,pc}
                  |L49.112|
000070  6828              LDR      r0,[r5,#0]            ;3935
000072  2f01              CMP      r7,#1                 ;3935
000074  d007              BEQ      |L49.134|
000076  6980              LDR      r0,[r0,#0x18]         ;3935
                  |L49.120|
000078  ea240000          BIC      r0,r4,r0              ;3935
00007c  0400              LSLS     r0,r0,#16             ;3935
00007e  0c00              LSRS     r0,r0,#16             ;3935
000080  d0e6              BEQ      |L49.80|
                  |L49.130|
000082  2000              MOVS     r0,#0                 ;3952
000084  e7f2              B        |L49.108|
                  |L49.134|
000086  6940              LDR      r0,[r0,#0x14]         ;3935
000088  e7f6              B        |L49.120|
;;;3954   
                          ENDP


                          AREA ||i.I2C_WaitOnMasterAddressFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnMasterAddressFlagUntilTimeout PROC
;;;3962     */
;;;3963   static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3964   {
000004  4691              MOV      r9,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;3965     uint32_t tickstart = 0;
;;;3966   
;;;3967     /* Get tick */
;;;3968     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4682              MOV      r10,r0
000010  2700              MOVS     r7,#0
;;;3969   
;;;3970     while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
;;;3971     {
;;;3972       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
;;;3973       {
;;;3974         /* Generate Stop */
;;;3975         SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
;;;3976   
;;;3977         /* Clear AF Flag */
;;;3978         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3979   
;;;3980         hi2c->ErrorCode = HAL_I2C_ERROR_AF;
;;;3981         hi2c->State= HAL_I2C_STATE_READY;
000012  f04f0820          MOV      r8,#0x20
000016  f3c54607          UBFX     r6,r5,#16,#8          ;3970
00001a  e029              B        |L50.112|
                  |L50.28|
00001c  6820              LDR      r0,[r4,#0]            ;3972
00001e  6940              LDR      r0,[r0,#0x14]         ;3972
000020  43c0              MVNS     r0,r0                 ;3972
000022  0540              LSLS     r0,r0,#21             ;3972
000024  d412              BMI      |L50.76|
000026  6820              LDR      r0,[r4,#0]            ;3975
000028  6801              LDR      r1,[r0,#0]            ;3975
00002a  f4417100          ORR      r1,r1,#0x200          ;3975
00002e  6001              STR      r1,[r0,#0]            ;3975
000030  6820              LDR      r0,[r4,#0]            ;3978
000032  6941              LDR      r1,[r0,#0x14]         ;3978
000034  f4216180          BIC      r1,r1,#0x400          ;3978
000038  6141              STR      r1,[r0,#0x14]         ;3978
00003a  2004              MOVS     r0,#4                 ;3980
00003c  63a0              STR      r0,[r4,#0x38]         ;3980
00003e  f8848035          STRB     r8,[r4,#0x35]
;;;3982   
;;;3983         /* Process Unlocked */
;;;3984         __HAL_UNLOCK(hi2c);
000042  f8847034          STRB     r7,[r4,#0x34]
;;;3985   
;;;3986         return HAL_ERROR;
000046  2001              MOVS     r0,#1
                  |L50.72|
;;;3987       }
;;;3988   
;;;3989       /* Check for the Timeout */
;;;3990       if(Timeout != HAL_MAX_DELAY)
;;;3991       {
;;;3992         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;3993         {
;;;3994           hi2c->State= HAL_I2C_STATE_READY;
;;;3995   
;;;3996           /* Process Unlocked */
;;;3997           __HAL_UNLOCK(hi2c);
;;;3998   
;;;3999           return HAL_TIMEOUT;
;;;4000         }
;;;4001       }
;;;4002     }
;;;4003     return HAL_OK;
;;;4004   }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L50.76|
00004c  f1b93fff          CMP      r9,#0xffffffff        ;3990
000050  d00e              BEQ      |L50.112|
000052  f1b90f00          CMP      r9,#0                 ;3992
000056  d005              BEQ      |L50.100|
000058  f7fffffe          BL       HAL_GetTick
00005c  eba0010a          SUB      r1,r0,r10             ;3992
000060  4549              CMP      r1,r9                 ;3992
000062  d905              BLS      |L50.112|
                  |L50.100|
000064  f8848035          STRB     r8,[r4,#0x35]         ;3994
000068  f8847034          STRB     r7,[r4,#0x34]         ;3997
00006c  2003              MOVS     r0,#3                 ;3999
00006e  e7eb              B        |L50.72|
                  |L50.112|
000070  6820              LDR      r0,[r4,#0]            ;3970
000072  2e01              CMP      r6,#1                 ;3970
000074  d006              BEQ      |L50.132|
000076  6980              LDR      r0,[r0,#0x18]         ;3970
                  |L50.120|
000078  ea250000          BIC      r0,r5,r0              ;3970
00007c  0400              LSLS     r0,r0,#16             ;3970
00007e  0c00              LSRS     r0,r0,#16             ;3970
000080  d0e2              BEQ      |L50.72|
000082  e7cb              B        |L50.28|
                  |L50.132|
000084  6940              LDR      r0,[r0,#0x14]         ;3970
000086  e7f7              B        |L50.120|
;;;4005   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;4121     */
;;;4122   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4123   {  
000004  4688              MOV      r8,r1
000006  4604              MOV      r4,r0
;;;4124     uint32_t tickstart = 0x00;
;;;4125     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  2500              MOVS     r5,#0
00000e  4606              MOV      r6,r0
;;;4126     
;;;4127     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
;;;4128     {
;;;4129       /* Check if a STOPF is detected */
;;;4130       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
;;;4131       {
;;;4132         /* Clear STOP Flag */
;;;4133         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;4134   
;;;4135         hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4136         hi2c->State= HAL_I2C_STATE_READY;
000010  2720              MOVS     r7,#0x20
000012  e021              B        |L51.88|
                  |L51.20|
000014  6941              LDR      r1,[r0,#0x14]         ;4130
000016  43c9              MVNS     r1,r1                 ;4130
000018  06c9              LSLS     r1,r1,#27             ;4130
00001a  d40b              BMI      |L51.52|
00001c  6941              LDR      r1,[r0,#0x14]         ;4133
00001e  f0210110          BIC      r1,r1,#0x10           ;4133
000022  6141              STR      r1,[r0,#0x14]         ;4133
000024  63a5              STR      r5,[r4,#0x38]         ;4135
000026  f8847035          STRB     r7,[r4,#0x35]
;;;4137   
;;;4138         /* Process Unlocked */
;;;4139         __HAL_UNLOCK(hi2c);
00002a  f8845034          STRB     r5,[r4,#0x34]
;;;4140   
;;;4141         return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L51.48|
;;;4142       }
;;;4143   		
;;;4144       /* Check for the Timeout */
;;;4145       if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
;;;4146       {
;;;4147         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4148         hi2c->State= HAL_I2C_STATE_READY;
;;;4149   
;;;4150         /* Process Unlocked */
;;;4151         __HAL_UNLOCK(hi2c);
;;;4152   
;;;4153         return HAL_TIMEOUT;
;;;4154       }
;;;4155     }
;;;4156     return HAL_OK;
;;;4157   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L51.52|
000034  f1b80f00          CMP      r8,#0                 ;4145
000038  d004              BEQ      |L51.68|
00003a  f7fffffe          BL       HAL_GetTick
00003e  1b81              SUBS     r1,r0,r6              ;4145
000040  4541              CMP      r1,r8                 ;4145
000042  d909              BLS      |L51.88|
                  |L51.68|
000044  f8540f38          LDR      r0,[r4,#0x38]!        ;4147
000048  f0400020          ORR      r0,r0,#0x20           ;4147
00004c  f8440904          STR      r0,[r4],#-4           ;4147
000050  7067              STRB     r7,[r4,#1]            ;4148
000052  7025              STRB     r5,[r4,#0]            ;4151
000054  2003              MOVS     r0,#3                 ;4153
000056  e7eb              B        |L51.48|
                  |L51.88|
000058  6820              LDR      r0,[r4,#0]            ;4127
00005a  6941              LDR      r1,[r0,#0x14]         ;4127
00005c  43c9              MVNS     r1,r1                 ;4127
00005e  0649              LSLS     r1,r1,#25             ;4127
000060  d4d8              BMI      |L51.20|
000062  2000              MOVS     r0,#0                 ;4156
000064  e7e4              B        |L51.48|
;;;4158   
                          ENDP


                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;4086     */
;;;4087   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;4088   {  
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;4089     uint32_t tickstart = 0x00;
;;;4090     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;4091     
;;;4092     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
00000c  e017              B        |L52.62|
                  |L52.14|
;;;4093     {
;;;4094       /* Check if a NACK is detected */
;;;4095       if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  b108              CBZ      r0,|L52.26|
;;;4096       {
;;;4097         return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;4098       }
;;;4099   		
;;;4100       /* Check for the Timeout */
;;;4101       if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
;;;4102       {
;;;4103         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4104         hi2c->State= HAL_I2C_STATE_READY;
;;;4105   
;;;4106         /* Process Unlocked */
;;;4107         __HAL_UNLOCK(hi2c);
;;;4108   
;;;4109         return HAL_TIMEOUT;
;;;4110       }
;;;4111     }
;;;4112     return HAL_OK;
;;;4113   }
000018  bd70              POP      {r4-r6,pc}
                  |L52.26|
00001a  b125              CBZ      r5,|L52.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1b80              SUBS     r0,r0,r6              ;4101
000022  42a8              CMP      r0,r5                 ;4101
000024  d90b              BLS      |L52.62|
                  |L52.38|
000026  f8540f38          LDR      r0,[r4,#0x38]!        ;4103
00002a  f0400020          ORR      r0,r0,#0x20           ;4103
00002e  f8440904          STR      r0,[r4],#-4           ;4103
000032  2020              MOVS     r0,#0x20              ;4104
000034  7060              STRB     r0,[r4,#1]            ;4104
000036  2000              MOVS     r0,#0                 ;4107
000038  7020              STRB     r0,[r4,#0]            ;4107
00003a  2003              MOVS     r0,#3                 ;4109
00003c  bd70              POP      {r4-r6,pc}
                  |L52.62|
00003e  6820              LDR      r0,[r4,#0]            ;4092
000040  6940              LDR      r0,[r0,#0x14]         ;4092
000042  43c0              MVNS     r0,r0                 ;4092
000044  06c0              LSLS     r0,r0,#27             ;4092
000046  d4e2              BMI      |L52.14|
000048  2000              MOVS     r0,#0                 ;4112
00004a  bd70              POP      {r4-r6,pc}
;;;4114   
                          ENDP


                          AREA ||i.I2C_WaitOnTXEFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXEFlagUntilTimeout PROC
;;;4012     */
;;;4013   static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
000000  b570              PUSH     {r4-r6,lr}
;;;4014   {  
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;4015     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;4016     
;;;4017     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
00000c  e019              B        |L53.66|
                  |L53.14|
;;;4018     {
;;;4019       /* Check if a NACK is detected */
;;;4020       if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  b108              CBZ      r0,|L53.26|
;;;4021       {
;;;4022         return HAL_ERROR;
000016  2001              MOVS     r0,#1
;;;4023       }
;;;4024   		
;;;4025       /* Check for the Timeout */
;;;4026       if(Timeout != HAL_MAX_DELAY)
;;;4027       {
;;;4028         if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
;;;4029         {
;;;4030           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4031           hi2c->State= HAL_I2C_STATE_READY;
;;;4032   
;;;4033           /* Process Unlocked */
;;;4034           __HAL_UNLOCK(hi2c);
;;;4035   
;;;4036           return HAL_TIMEOUT;
;;;4037         }
;;;4038       }
;;;4039     }
;;;4040     return HAL_OK;      
;;;4041   }
000018  bd70              POP      {r4-r6,pc}
                  |L53.26|
00001a  1c68              ADDS     r0,r5,#1              ;4026
00001c  d011              BEQ      |L53.66|
00001e  b125              CBZ      r5,|L53.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1b80              SUBS     r0,r0,r6              ;4028
000026  42a8              CMP      r0,r5                 ;4028
000028  d90b              BLS      |L53.66|
                  |L53.42|
00002a  f8540f38          LDR      r0,[r4,#0x38]!        ;4030
00002e  f0400020          ORR      r0,r0,#0x20           ;4030
000032  f8440904          STR      r0,[r4],#-4           ;4030
000036  2020              MOVS     r0,#0x20              ;4031
000038  7060              STRB     r0,[r4,#1]            ;4031
00003a  2000              MOVS     r0,#0                 ;4034
00003c  7020              STRB     r0,[r4,#0]            ;4034
00003e  2003              MOVS     r0,#3                 ;4036
000040  bd70              POP      {r4-r6,pc}
                  |L53.66|
000042  6820              LDR      r0,[r4,#0]            ;4017
000044  6940              LDR      r0,[r0,#0x14]         ;4017
000046  43c0              MVNS     r0,r0                 ;4017
000048  0600              LSLS     r0,r0,#24             ;4017
00004a  d4e0              BMI      |L53.14|
00004c  2000              MOVS     r0,#0                 ;4040
00004e  bd70              POP      {r4-r6,pc}
;;;4042   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REV16|
#line 463 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____RRX|
#line 665
|__asm___19_stm32f1xx_hal_i2c_c_0eb271f4____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
