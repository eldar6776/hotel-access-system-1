/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
/* Includes ------------------------------------------------------------------*/
#include <string.h>
#include "hotel_room_controller.h"
#include "stm32f429i_lcd.h"
#include "RTP_Touch.h"
#include "Display.h"
#include "DIALOG.h"
#include "common.h"
#include "main.h"
#include "rtc.h"
#include "uart.h"
#include "ff.h"
#include "netconf.h"
#include "netif.h"
#include "lwip/ip_addr.h"
#include "i2c_eeprom.h"


/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

extern void RAM_Init(void);
extern struct netif netif;
extern GUI_CONST_STORAGE GUI_BITMAP bmNetworkError;
extern GUI_CONST_STORAGE GUI_BITMAP bmNetworkConnected;
extern GUI_CONST_STORAGE GUI_BITMAP bmusd_ok;
extern GUI_CONST_STORAGE GUI_BITMAP bmusd_error;

WM_HWIN hSELECTED;
BUTTON_Handle hBUTTON_Settings;
#define GUI_ID_BUTTON_Settings   				0x801
BUTTON_Handle hBUTTON_Tools;
#define GUI_ID_BUTTON_Tools   					0x802
BUTTON_Handle hBUTTON_Control;
#define GUI_ID_BUTTON_Control   				0x803
BUTTON_Handle hBUTTON_Unlock;
#define GUI_ID_BUTTON_Unlock   					0x804
BUTTON_Handle hBUTTON_Scan;
#define GUI_ID_BUTTON_Scan   					0x805
BUTTON_Handle hBUTTON_AddressSet;
#define GUI_ID_BUTTON_AddressSet   				0x806
BUTTON_Handle hBUTTON_ExitRS485Scanner;
#define GUI_ID_BUTTON_ExitRS485Scanner  		0x807
BUTTON_Handle hBUTTON_ExitInfo;
#define GUI_ID_BUTTON_ExitInfo   				0x808

BUTTON_Handle hBUTTON_SettingsOk;
#define GUI_ID_BUTTON_SettingsOk   				0x80a
BUTTON_Handle hBUTTON_SettingsCancel;
#define GUI_ID_BUTTON_SettingsCancel   			0x80b
BUTTON_Handle hBUTTON_SettingsApply;
#define GUI_ID_BUTTON_SettingsApply   			0x80c
BUTTON_Handle hBUTTON_SettingsEdit;
#define GUI_ID_BUTTON_SettingsEdit   			0x80d

BUTTON_Handle hBUTTON_ToolScanRS485;
#define GUI_ID_BUTTON_ToolScanRS485   			0x810
BUTTON_Handle hBUTTON_ToolUploadImage;
#define GUI_ID_BUTTON_ToolUploadImage   		0x811
BUTTON_Handle hBUTTON_ToolUploadFirmware;
#define GUI_ID_BUTTON_ToolUploadFirmware   		0x812
BUTTON_Handle hBUTTON_ToolUpdateFW;
#define GUI_ID_BUTTON_ToolUpdateFW   			0x813
BUTTON_Handle hBUTTON_ToolDisplayCalibration;
#define GUI_ID_BUTTON_ToolDisplayCalibration  	0x814
BUTTON_Handle hBUTTON_ToolFileList;
#define GUI_ID_BUTTON_ToolFileList   			0x815
BUTTON_Handle hBUTTON_ToolFormatCard;
#define GUI_ID_BUTTON_ToolFormatCard   			0x816
BUTTON_Handle hBUTTON_ToolLoadList;
#define GUI_ID_BUTTON_ToolLoadList   			0x817
BUTTON_Handle hBUTTON_ToolExit;
#define GUI_ID_BUTTON_ToolExit   				0x818

BUTTON_Handle hBUTTON_OnScreenKeypad_1;
#define GUI_ID_BUTTON_OnScreenKeypad_1   		0x819
BUTTON_Handle hBUTTON_OnScreenKeypad_2;
#define GUI_ID_BUTTON_OnScreenKeypad_2   		0x81a
BUTTON_Handle hBUTTON_OnScreenKeypad_3;
#define GUI_ID_BUTTON_OnScreenKeypad_3   		0x81b
BUTTON_Handle hBUTTON_OnScreenKeypad_4;
#define GUI_ID_BUTTON_OnScreenKeypad_4   		0x81c
BUTTON_Handle hBUTTON_OnScreenKeypad_5;
#define GUI_ID_BUTTON_OnScreenKeypad_5   		0x81d
BUTTON_Handle hBUTTON_OnScreenKeypad_6;
#define GUI_ID_BUTTON_OnScreenKeypad_6   		0x81e
BUTTON_Handle hBUTTON_OnScreenKeypad_7;
#define GUI_ID_BUTTON_OnScreenKeypad_7   		0x81f
BUTTON_Handle hBUTTON_OnScreenKeypad_8;
#define GUI_ID_BUTTON_OnScreenKeypad_8   		0x820
BUTTON_Handle hBUTTON_OnScreenKeypad_9;
#define GUI_ID_BUTTON_OnScreenKeypad_9   		0x821
BUTTON_Handle hBUTTON_OnScreenKeypad_0;
#define GUI_ID_BUTTON_OnScreenKeypad_0   		0x818
BUTTON_Handle hBUTTON_OnScreenKeypad_Ok;
#define GUI_ID_BUTTON_OnScreenKeypad_Ok   		0x822
BUTTON_Handle hBUTTON_OnScreenKeypad_Back;
#define GUI_ID_BUTTON_OnScreenKeypad_Back  		0x823

GUI_HWIN hCHECKBOX_EnableDHCP;
#define GUI_ID_CHECK_EnableDHCP					0x850
GUI_HWIN hCHECKBOX_EnableBroadcastTime;
#define GUI_ID_CHECK_EnableBroadcastTime		0x851
GUI_HWIN hCHECKBOX_EnableHTTP;
#define GUI_ID_CHECK_EnableHTTP					0x852
GUI_HWIN hCHECKBOX_EnableWebConfig;
#define GUI_ID_CHECK_EnableWebConfig			0x853
GUI_HWIN hCHECKBOX_EnableTFTP;
#define GUI_ID_CHECK_EnableTFTP					0x854

GUI_HWIN hEDIT_TcpIpAddress;
#define GUI_ID_EDIT_TcpIpAddress				0x900
GUI_HWIN hEDIT_TcpIpGateway;
#define GUI_ID_EDIT_TcpIpGateway				0x901
GUI_HWIN hEDIT_TcpIpSubnet;
#define GUI_ID_EDIT_TcpIpSubnet					0x902
GUI_HWIN hEDIT_RS485_InterfaceAddress;
#define GUI_ID_EDIT_RS485_InterfaceAddress		0x903
GUI_HWIN hEDIT_RS485_BroadcastAddress;
#define GUI_ID_EDIT_RS485_BroadcastAddress		0x904
GUI_HWIN hEDIT_DateTime;
#define GUI_ID_EDIT_DateTime					0x905
GUI_HWIN hEDIT_Password;
#define GUI_ID_EDIT_Password					0x906
GUI_HWIN hEDIT_SysID;
#define GUI_ID_EDIT_SysID						0x907

GUI_HWIN hSPINBOX_StartAddress;
#define GUI_ID_SPINBOX_StartAddress				0xa00
GUI_HWIN hSPINBOX_EndAddress;
#define GUI_ID_SPINBOX_EndAddress				0xa01
GUI_HWIN hSPINBOX_OldAddress;
#define GUI_ID_SPINBOX_OldAddress				0xa02
GUI_HWIN hSPINBOX_NewAddress;
#define GUI_ID_SPINBOX_NewAddress				0xa03
GUI_HWIN hSPINBOX_SetAddress;
#define GUI_ID_SPINBOX_SetAddress				0xa04

GUI_HWIN hLISTVIEW_AddresseFound;
#define GUI_ID_LISTVIEW_AddresseFound			0xa50

GUI_HWIN hRADIO_ScanMode;
#define GUI_ID_RADIO_ScanMode					0xb00

GUI_HMEM hPROGBAR_FileTransfer;
#define GUI_ID_PROGBAR_FileTransfer  			0xb50

WM_HWIN              hTree;
TREEVIEW_ITEM_Handle hItem;
TREEVIEW_ITEM_Handle hNode;
#define GUI_ID_TREEVIEW_FileList				0xba0

#define OSK_IDLE					0
#define OSK_EDIT_IP_ADDRESS			1
#define OSK_EDIT_GW_ADDRESS			2
#define OSK_EDIT_SUBNET_MASK		3
#define OSK_EDIT_RS485_INTERFACE	4
#define OSK_EDIT_RS485_BROADCAST	5
#define OSK_EDIT_PASSWORD			6
#define OSK_ENTER_PASSWORD			7
#define OSK_EDIT_SYS_ID				8

eActivDisplayTypeDef eActivDisplay;

extern GUI_PID_STATE State;
int xPhys;
int yPhys;
uint8_t GUI_Initialized;
uint8_t log_list_row;
uint8_t string[84];
uint8_t string1[84];
uint8_t string2[84];
uint8_t string3[84];
uint8_t string4[84];
uint8_t string5[84];
uint8_t str_value[16];
uint8_t osk_entry[6];
uint8_t osk_entry_cnt;
uint8_t password_set[6] = {'4', '3', '8', '9', '1', NULL};
uint8_t password_set_cnt = 5;
uint8_t password_default[6] = {'1','2','3','4', NULL, NULL};
uint8_t password_default_cnt = 4;
uint8_t *pString;
uint8_t row = 0;
int32_t ret_1, ret_2, ret_3, ret_4;
uint8_t usd_status;
uint32_t display_flags;
uint32_t display_timer;
uint32_t display_timeout_timer;
uint8_t cursor_pos;
uint32_t converted;
uint32_t osk_call;
uint8_t osk_ipadd[4];
uint8_t osk_ipedit;
struct ip_addr new_ip;
struct ip_addr new_nm;
struct ip_addr new_gw;

FRESULT res;
FATFS f_sys;
FIL f_SD;
DIR f_dir;
UINT i;
static FILINFO fno;

/*********************************************************************
*
*       Function prototypes
*
**********************************************************************
*/
void CreateDefaultDisplay(void);
void DeleteDefaultDisplay(void);
void CreateToolsDisplay(void);
void DeleteToolsDisplay(void);
void CreateScanRS485BusDisplay(void);
void DeleteScanRS485BusDisplay(void);
void CreateSettingsMenuDisplay(void);
void DeleteSettingsMenuDisplay(void);
void CreateOnScreenKeypad(void);
void DeleteOnScreenKeypad(void);
void UpdateDateTime(void);
void CreateAddControllerDisplay(void);
void DeleteAddControllerDisplay(void);
void UpdateRS485_FoundDeviceList(void);
int CheckControllerStatus(uint16_t address);
void OnScreenKeypad(uint32_t edit_val, uint8_t key_pressed);

/*********************************************************************
*
*       Program Code
*
**********************************************************************
*/
void DisplayInit(void)
{
	GUI_Init();	
	GUI_SelectLayer(0);
	GUI_Clear();
	
	if (f_mount(&f_sys, "0:", 0) == FR_OK)
	{
		if (f_opendir(&f_dir, "/") == FR_OK)
		{
			if (f_open(&f_SD, "BCK_GND.BMP", FA_READ) == FR_OK) 
			{
				GUI_BMP_DrawEx(APP_GetData, (void *) &f_SD, 0, 0);
				DISPLAY_uSD_CardReadyStatusSet();
			}
			else DISPLAY_uSD_CardErrorStatusSet();
		}
		else DISPLAY_uSD_CardErrorStatusSet();
	}
	else DISPLAY_uSD_CardErrorStatusSet();
	
	f_mount(0,"0:",0);
	GUI_SelectLayer(1);
	GUI_SetBkColor(GUI_TRANSPARENT); 
	GUI_Clear();
	GUI_CURSOR_Select(&GUI_CursorCrossM);

	RADIO_SetDefaultSkin(RADIO_SKIN_FLEX);
	BUTTON_SetDefaultSkin(BUTTON_SKIN_FLEX);
	SPINBOX_SetDefaultSkin(SPINBOX_SKIN_FLEX);
	SPINBOX_SetDefaultButtonSize(20);
	RADIO_SetDefaultTextColor(GUI_WHITE);
	EDIT_SetDefaultTextAlign(GUI_TA_RIGHT);
	GUI_SetTextMode(GUI_TEXTMODE_TRANS);
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font20B_1);
	hPROGBAR_FileTransfer = PROGBAR_Create(120, 110, 355, 25, WM_CF_SHOW);
	PROGBAR_SetMinMax(hPROGBAR_FileTransfer, 0, 100);
	PROGBAR_SetTextColor(hPROGBAR_FileTransfer, 0, GUI_BLACK);
	PROGBAR_SetTextColor(hPROGBAR_FileTransfer, 1, GUI_WHITE);
	PROGBAR_SetBarColor(hPROGBAR_FileTransfer, 0, GUI_LIGHTGREEN);
	PROGBAR_SetBarColor(hPROGBAR_FileTransfer, 1, GUI_LIGHTGRAY);
	PROGBAR_SetTextAlign(hPROGBAR_FileTransfer, GUI_TA_HCENTER);
	PROGBAR_SetFont(hPROGBAR_FileTransfer, &GUI_Font13_1);
	PROGBAR_SetText(hPROGBAR_FileTransfer, "0%");
	PROGBAR_SetSkin(hPROGBAR_FileTransfer, PROGBAR_SKIN_FLEX);	
	WM_HideWindow(hPROGBAR_FileTransfer);
	CreateDefaultDisplay();
}

void DisplayService(void)
{
	static uint32_t touch_timing = 0;
	static uint8_t tmp_sec = 0;
	uint8_t add, attempts, k;
	
	
	if(SystickCnt >= (touch_timing + 10))
	{
		touch_timing = SystickCnt;
		GUI_TOUCH_Exec();
		GUI_Exec();	
	}
	else return;

	switch(eActivDisplay)
	{	
		case DISPLAY_DEFAULT:
		{
			if(IsDISPLAY_TimerExpired())
			{
				if(IsDISPLAY_RefreshActiv())
				{
					DISPLAY_RefreshReset();
					
					if(IsDISPLAY_OnScreenKeypadActiv())
					{
						DISPLAY_OnScreenKeypadReset();
						DeleteOnScreenKeypad();
					}
					
					DeleteDefaultDisplay();
					CreateDefaultDisplay();
				}
				
			}
			
			if(IsDISPLAY_TimeoutTimerExpired())
			{
				if(IsDISPLAY_UnlockActiv())
				{
					DISPLAY_UnlockReset();
					DeleteDefaultDisplay();
					CreateDefaultDisplay();
				}
			}
			
			UpdateDateTime();
			
			if(BUTTON_IsPressed(hBUTTON_Tools) && IsDISPLAY_UnlockActiv()) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_Tools)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteDefaultDisplay();
				CreateToolsDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}				
			else if(BUTTON_IsPressed(hBUTTON_Settings) && IsDISPLAY_UnlockActiv()) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_Settings)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteDefaultDisplay();
				CreateSettingsMenuDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}	
			else if(BUTTON_IsPressed(hBUTTON_Unlock) && !IsDISPLAY_OnScreenKeypadActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_Unlock)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				if(IsDISPLAY_UnlockActiv())
				{
					DISPLAY_TimeoutTimerStop();
				}
				else
				{				
					CreateOnScreenKeypad();
					ClearBuffer(osk_entry, 5);
					osk_entry_cnt = 0;
					GUI_SetColor(GUI_WHITE);
					GUI_SetFont(&GUI_Font24B_1);
					GUI_SetTextMode(GUI_TEXTMODE_TRANS);	
					GUI_DispStringAt("ENTER PASSWORD", 150, 15);
					DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
					DISPLAY_RefreshSet();
					GUI_Delay(100);
				}				
			}
			else if(BUTTON_IsPressed(hBUTTON_Control) && IsDISPLAY_UnlockActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_Control)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
			}
			else if((rs485_bus_status == RS485_BUS_CONNECTED) && !IsRS485BusStatusFlagSet())
			{
				RS485_BusStatusFlagSet();
				GUI_ClearRect(435, 5, 475, 65);
				GUI_DrawBitmap(&bmNetworkConnected, 435, 5);
				GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
				GUI_SetBkColor(GUI_BLACK);
				GUI_SetColor(GUI_GREEN);
				GUI_SetFont(&GUI_Font16B_1);
				GUI_GotoXY(445, 47);
				GUI_DispString("RUN");
				GUI_SetBkColor(GUI_TRANSPARENT);
			}
			else if((rs485_bus_status != RS485_BUS_CONNECTED) && IsRS485BusStatusFlagSet())
			{
				RS485_BusStatusFlagReset();
				GUI_ClearRect(435, 5, 475, 65);
				GUI_DrawBitmap(&bmNetworkError, 435, 5);
				GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
				GUI_SetBkColor(GUI_BLACK);
				GUI_SetColor(GUI_RED);
				GUI_SetFont(&GUI_Font16B_1);
				GUI_GotoXY(435, 47);
				
				if(rs485_bus_status == RS485_BUS_ERROR) GUI_DispString("ERROR");
				else if(rs485_bus_status == RS485_BUS_DISCONNECTED) GUI_DispString(" STOP");
				GUI_SetBkColor(GUI_TRANSPARENT);
			}
			
			if(IsDISPLAY_FileProgressBarShowActiv())
			{
				DISPLAY_FileProgressBarShowReset();
				PROGBAR_SetValue(hPROGBAR_FileTransfer, 0);
				WM_ShowWindow(hPROGBAR_FileTransfer);
			}
			else if(IsDISPLAY_FileProgressBarDeleteActiv())
			{
				DISPLAY_FileProgressBarDeleteReset();
				WM_HideWindow(hPROGBAR_FileTransfer);
				GUI_ClearRect(120, 110, 475, 135);
			}
			
			if(IsDISPLAY_uSD_CardReadyActiv())
			{
				DISPLAY_uSD_CardReadyReset();
				DISPLAY_uSD_CardReadyStatusSet();
				GUI_ClearRect(390, 5, 430, 65);
				GUI_DrawBitmap(&bmusd_ok, 390, 5);
				GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
				GUI_SetBkColor(GUI_BLACK);
				GUI_SetColor(GUI_GREEN);
				GUI_SetFont(&GUI_Font16B_1);
				GUI_DispStringAt("uSD", 395, 47);
				GUI_SetBkColor(GUI_TRANSPARENT);
			}
			else if(IsDISPLAY_uSD_CardErrorActiv())
			{
				DISPLAY_uSD_CardErrorReset();
				DISPLAY_uSD_CardErrorStatusSet();
				GUI_ClearRect(390, 5, 430, 65);
				GUI_DrawBitmap(&bmusd_error, 390, 5);
				GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
				GUI_SetBkColor(GUI_BLACK);
				GUI_SetColor(GUI_RED);
				GUI_SetFont(&GUI_Font16B_1);
				GUI_DispStringAt("uSD", 395, 47);
				GUI_SetBkColor(GUI_TRANSPARENT);
			}
			
			if(IsDISPLAY_OnScreenKeypadActiv())
			{
				hSELECTED = NULL;
				
				if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_0)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_0)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '0');					
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_1)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_1)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '1');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_2)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_2)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '2');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_3)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_3)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '3');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_4)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_4)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '4');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_5)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_5)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '5');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_6)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_6)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '6');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_7)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_7)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '7');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_8)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_8)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '8');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_9)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_9)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, '9');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Ok)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Ok)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, 'O');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Back)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Back)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(OSK_ENTER_PASSWORD, 'B');
				}
			}
			break;
		}
		
		case DISPLAY_SCAN_RS485_BUS:
		{
			if(BUTTON_IsPressed(hBUTTON_Scan))
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_Scan)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				ClearBuffer(rubicon_ctrl_buffer, RUBICON_BUFFER_SIZE);
				ret_1 = SPINBOX_GetValue(hSPINBOX_StartAddress);
				ret_2 = SPINBOX_GetValue(hSPINBOX_EndAddress);
				ret_3 = RADIO_GetValue(hRADIO_ScanMode);
				ret_4 = RUBICON_ScanRS485_Bus(ret_1, ret_2, ret_3);

				if (ret_4 == -1)
				{
					
				}
				else if (ret_4 == 0)
				{
					
				}
				else if ((ret_3 == 2) || (ret_3 == 3))
				{
					add = 0;
					attempts = RS485_SCAN_MAX_ATTEMPTS;
					
					while (ret_4)
					{
						ret_1 = rubicon_firmware_update_address_list[add];
						ret_2 = ret_1 + 1;
						
						if (RUBICON_ScanRS485_Bus(ret_1, ret_2, RS485_SCANNER_FIND_ADDRESSED) == 1)
						{
							UpdateRS485_FoundDeviceList();
							--ret_4;
							++add;
							GUI_Delay(100);
						}
						else
						{
							--attempts;
							
							if(attempts == 0)
							{
								--ret_4;
								++add;
								attempts = RS485_SCAN_MAX_ATTEMPTS;
							}
							
							GUI_Delay(100);
						}
					}					
				}
				else
				{
					UpdateRS485_FoundDeviceList();
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_AddressSet))
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_AddressSet)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				ClearBuffer(rubicon_ctrl_buffer, RUBICON_BUFFER_SIZE);
				ret_1 = SPINBOX_GetValue(hSPINBOX_OldAddress);
				Int2Str(rubicon_ctrl_buffer, ret_1);
				ret_2 = 0;
				while(rubicon_ctrl_buffer[ret_2] != NULL) ++ret_2;
				++ret_2;
				ret_4 = SPINBOX_GetValue(hSPINBOX_NewAddress);
				Int2Str(&rubicon_ctrl_buffer[ret_2], ret_4);
				rubicon_ctrl_request = RUBICON_SET_RS485_CONFIG;
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ExitRS485Scanner))
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ExitRS485Scanner)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteScanRS485BusDisplay();
				CreateToolsDisplay();
				SPINBOX_SetValue(hSPINBOX_SetAddress, converted);
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else
			{
				ClearBuffer((uint8_t*)str_value, 16);
				converted = LISTVIEW_GetSelUnsorted(hLISTVIEW_AddresseFound);
				LISTVIEW_GetItemText(hLISTVIEW_AddresseFound,0,  converted, (char *)str_value, 16);				
				Str2Int(str_value, &converted);
			}
			break;
		}
		
		
		case DISPLAY_SETTINGS:
		{
			RTC_GetTime(RTC_Format_BCD, &RTC_Time);
			
			if(BUTTON_IsPressed(hBUTTON_SettingsCancel) && !IsDISPLAY_OnScreenKeypadActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_SettingsCancel)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				RAM_Init();
				DeleteSettingsMenuDisplay();
				CreateDefaultDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_SettingsOk)  && !IsDISPLAY_OnScreenKeypadActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_SettingsOk)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				IP4_ADDR(&new_ip, ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
				IP4_ADDR(&new_nm, subnet_mask[0], subnet_mask[1], subnet_mask[2], subnet_mask[3]);
				IP4_ADDR(&new_gw, gateway_address[0], gateway_address[1], gateway_address[2], gateway_address[3]);				
				netif_set_addr(&netif, &new_ip , &new_nm, &new_gw);				
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableDHCP) == 1) DHCP_ClientEnable();
				else DHCP_ClientDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableBroadcastTime) == 1) TIME_BroadcastEnable();
				else TIME_BroadcastDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableHTTP) == 1) HTTP_ServerEnable();
				else HTTP_ServerDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableWebConfig) == 1) WEB_ConfigEnable();
				else WEB_ConfigDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableTFTP) == 1) TFTP_ServerEnable();
				else TFTP_ServerDisable();
				
				DeleteSettingsMenuDisplay();
				CreateDefaultDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_SettingsApply)  && !IsDISPLAY_OnScreenKeypadActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_SettingsApply)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				IP4_ADDR(&new_ip, ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
				IP4_ADDR(&new_nm, subnet_mask[0], subnet_mask[1], subnet_mask[2], subnet_mask[3]);
				IP4_ADDR(&new_gw, gateway_address[0], gateway_address[1], gateway_address[2], gateway_address[3]);
				
				netif_set_addr(&netif, &new_ip , &new_nm, &new_gw);
				i2c_ee_buffer[0] = ip_address[0];
				i2c_ee_buffer[1] = ip_address[1];
				i2c_ee_buffer[2] = ip_address[2];
				i2c_ee_buffer[3] = ip_address[3];
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_ETHERNET_IP_ADDRESS, 4);
				delay(I2C_EE_WRITE_DELAY);
				i2c_ee_buffer[0] = subnet_mask[0];
				i2c_ee_buffer[1] = subnet_mask[1];
				i2c_ee_buffer[2] = subnet_mask[2];
				i2c_ee_buffer[3] = subnet_mask[3];
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_ETHERNET_SUBNET_ADDRESS, 4);
				delay(I2C_EE_WRITE_DELAY);
				i2c_ee_buffer[0] = gateway_address[0];
				i2c_ee_buffer[1] = gateway_address[1];
				i2c_ee_buffer[2] = gateway_address[2];
				i2c_ee_buffer[3] = gateway_address[3];
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_ETHERNET_GATEWAY_ADDRESS, 4);
				delay(I2C_EE_WRITE_DELAY);	
				
				i2c_ee_buffer[0] = (rs485_interface_address >> 8);
				i2c_ee_buffer[1] = (rs485_interface_address & 0xff);
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_RS485_INTERFACE_ADDRESS, 2);
				delay(I2C_EE_WRITE_DELAY);
				i2c_ee_buffer[0] = (rs485_broadcast_address >> 8);
				i2c_ee_buffer[1] = (rs485_broadcast_address & 0xff);
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_RS485_BROADCAST_ADDRESS, 2);
				delay(I2C_EE_WRITE_DELAY);
				I2C_EERPOM_WriteByte16(I2C_EE_WRITE_PAGE_0, EE_RS485_INTERFACE_BAUDRATE_ADDRESS, rs485_interface_baudrate);
				delay(I2C_EE_WRITE_DELAY);
					
				i2c_ee_buffer[0] = password_set[0];
				i2c_ee_buffer[1] = password_set[1];
				i2c_ee_buffer[2] = password_set[2];
				i2c_ee_buffer[3] = password_set[3];
				i2c_ee_buffer[4] = password_set[4];
				i2c_ee_buffer[5] = password_set[5];
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_PASSWORD_ADDRESS, 6);
				delay(I2C_EE_WRITE_DELAY);
				
				i2c_ee_buffer[0] = (system_id >> 8);
				i2c_ee_buffer[1] = (system_id & 0xff);
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_SYSTEM_ID_ADDRESS, 2);
				delay(I2C_EE_WRITE_DELAY);
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableDHCP) == 1) DHCP_ClientEnable();
				else DHCP_ClientDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableBroadcastTime) == 1) TIME_BroadcastEnable();
				else TIME_BroadcastDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableHTTP) == 1) HTTP_ServerEnable();
				else HTTP_ServerDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableWebConfig) == 1) WEB_ConfigEnable();
				else WEB_ConfigDisable();
				
				if(CHECKBOX_GetState(hCHECKBOX_EnableTFTP) == 1) TFTP_ServerEnable();
				else TFTP_ServerDisable();
				
				i2c_ee_buffer[0] = (system_config << 24);
				i2c_ee_buffer[1] = (system_config << 16);
				i2c_ee_buffer[2] = (system_config << 8);
				i2c_ee_buffer[3] = (system_config & 0xff);
				I2C_EERPOM_WriteBytes16(I2C_EE_WRITE_PAGE_0, EE_SYSTEM_CONFIG_ADDRESS, 4);
				delay(I2C_EE_WRITE_DELAY);
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_SettingsEdit)  && !IsDISPLAY_OnScreenKeypadActiv())
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_SettingsEdit)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}		
				
				if(hSELECTED != NULL)
				{
					if(hSELECTED == hEDIT_TcpIpAddress) osk_call = OSK_EDIT_IP_ADDRESS;
					else if(hSELECTED == hEDIT_TcpIpGateway) osk_call = OSK_EDIT_GW_ADDRESS;
					else if(hSELECTED == hEDIT_TcpIpSubnet) osk_call = OSK_EDIT_SUBNET_MASK;
					else if(hSELECTED == hEDIT_RS485_InterfaceAddress) osk_call = OSK_EDIT_RS485_INTERFACE;
					else if(hSELECTED == hEDIT_RS485_BroadcastAddress) osk_call = OSK_EDIT_RS485_BROADCAST;
					else if(hSELECTED == hEDIT_Password) osk_call = OSK_EDIT_PASSWORD;
					else if(hSELECTED == hEDIT_SysID) osk_call = OSK_EDIT_SYS_ID;
					
					osk_entry_cnt = 0;
					ClearBuffer(osk_entry, 6);					
					ClearBuffer(string, 84);
					EDIT_GetText(hSELECTED, (char *)string, 24);
					
					DeleteSettingsMenuDisplay();
					GUI_SetBkColor(GUI_BLACK);
					GUI_Clear();
					CreateOnScreenKeypad();				
					eActivDisplay = DISPLAY_SETTINGS_EDIT;
				}
				
				OnScreenKeypad(osk_call, cursor_pos);
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(tmp_sec != RTC_Time.RTC_Seconds)				
			{
				tmp_sec = RTC_Time.RTC_Seconds;
				ClearBuffer(string, 32);
				k = 0;
				string[k++] = (RTC_Time.RTC_Hours >> 4) + 48;
				string[k++] = (RTC_Time.RTC_Hours & 0x0f) + 48;
				string[k++] = ':';
				string[k++] = (RTC_Time.RTC_Minutes >> 4) + 48;
				string[k++] = (RTC_Time.RTC_Minutes & 0x0f) + 48;
				string[k++] = ':';
				string[k++] = (RTC_Time.RTC_Seconds >> 4) + 48;
				string[k++] = (RTC_Time.RTC_Seconds & 0x0f) + 48;
				string[k++] = ' ';
				string[k++] = ' ';
				string[k++] = (RTC_Date.RTC_Date >> 4) + 48;
				string[k++] = (RTC_Date.RTC_Date & 0x0f) + 48;
				string[k++] = '.';
				string[k++] = (RTC_Date.RTC_Month >> 4) + 48;
				string[k++] = (RTC_Date.RTC_Month & 0x0f) + 48;
				string[k++] = '.';
				string[k++] = '2';
				string[k++] = '0';
				string[k++] = (RTC_Date.RTC_Year >> 4) + 48;
				string[k++] = (RTC_Date.RTC_Year & 0x0f) + 48;
				string[k++] = NULL;
				EDIT_SetText(hEDIT_DateTime, (char *)string);
			}
			else
			{
				if(WM_HasFocus(hEDIT_TcpIpAddress) == 1) 
				{
					hSELECTED = hEDIT_TcpIpAddress;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_TcpIpAddress);
				}
				else if(WM_HasFocus(hEDIT_TcpIpGateway) == 1)
				{					
					hSELECTED = hEDIT_TcpIpGateway;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_TcpIpGateway);
				}
				else if(WM_HasFocus(hEDIT_TcpIpSubnet) == 1)
				{					
					hSELECTED = hEDIT_TcpIpSubnet;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_TcpIpSubnet);
				}
				else if(WM_HasFocus(hEDIT_RS485_InterfaceAddress) == 1)
				{					
					hSELECTED = hEDIT_RS485_InterfaceAddress;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_RS485_InterfaceAddress);
				}
				else if(WM_HasFocus(hEDIT_RS485_BroadcastAddress) == 1)
				{					
					hSELECTED = hEDIT_RS485_BroadcastAddress;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_RS485_BroadcastAddress);
				}
				else if(WM_HasFocus(hEDIT_DateTime) == 1)
				{					
					hSELECTED = hEDIT_DateTime;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_DateTime);
				}
				else if(WM_HasFocus(hEDIT_Password) == 1)
				{					
					hSELECTED = hEDIT_Password;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_Password);
				}
				else if(WM_HasFocus(hEDIT_SysID) == 1)
				{					
					hSELECTED = hEDIT_SysID;
					cursor_pos = EDIT_GetCursorCharPos(hEDIT_SysID);
				}
				else 
				{					
					hSELECTED = NULL;
					cursor_pos = NULL;
				}
				
				if(hSELECTED == NULL) WM_DisableWindow(hBUTTON_SettingsEdit);
				else WM_EnableWindow(hBUTTON_SettingsEdit);
			}
			break;
		}
	
		case DISPLAY_SETTINGS_EDIT:
		{
			if(IsDISPLAY_OnScreenKeypadActiv())
			{
				if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_0)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_0)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '0');					
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_1)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_1)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '1');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_2)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_2)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '2');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_3)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_3)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '3');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_4)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_4)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '4');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_5)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_5)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '5');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_6)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_6)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '6');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_7)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_7)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '7');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_8)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_8)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '8');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_9)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_9)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, '9');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Ok)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Ok)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, 'O');
				}
				else if(BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Back)) 
				{
					while(1)
					{
						if(!BUTTON_IsPressed(hBUTTON_OnScreenKeypad_Back)) break;
						GUI_TOUCH_Exec();
						GUI_Delay(50);
					}
					
					OnScreenKeypad(osk_call, 'B');
				}
			}
			
			DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
			DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
			DISPLAY_RefreshSet();
			GUI_Delay(100);
			break;
		}
		
		
		case DISPLAY_TOOLS:
		{
			if(BUTTON_IsPressed(hBUTTON_ToolScanRS485)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolScanRS485)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteToolsDisplay();
				CreateScanRS485BusDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolDisplayCalibration)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolDisplayCalibration)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteToolsDisplay();
				Calibration(480,272);
				GUI_Delay(1000);;
				GUI_Clear();
				CreateToolsDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolUpdateFW)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolUpdateFW)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);				
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolUploadImage)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolUploadImage)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolUploadFirmware)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolUploadFirmware)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);				
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolFileList)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolFileList)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				hItem = 0;
				ret_1 = 0;
				if (f_mount(&f_sys, "0:", 0) != FR_OK) break;
				res =  f_opendir(&f_dir, "/");                   /* Open the directory */
				if (res == FR_OK)
				{
					hNode = TREEVIEW_InsertItem(hTree, TREEVIEW_ITEM_TYPE_NODE, 0, 0, "uSD_Card");
					for (;;) 
					{
						ret_1 = hItem ? TREEVIEW_INSERT_BELOW : TREEVIEW_INSERT_FIRST_CHILD;
						 /* Read a directory item */
						res = f_readdir(&f_dir, &fno);                  
						if (res != FR_OK || fno.fname[0] == 0)
						{	/* Break on error or end of dir */
							f_closedir(&f_dir);
							break;  							
						}
						if (fno.fattrib & AM_DIR) 
						{   /* It is a directory */							
							hItem = TREEVIEW_ITEM_Create(1,  fno.fname, 0);
							if(hItem == 0)
							{
								f_closedir(&f_dir);
								break; 
							}
						} 
						else 
						{   /* It is a file. */
							hItem = TREEVIEW_ITEM_Create(0,  fno.fname, 0);
							if(hItem == 0)
							{
								f_closedir(&f_dir);
								break; 
							}
						}						
						TREEVIEW_AttachItem(hTree, hItem, hNode, ret_1);
						GUI_Exec();
					}
					f_closedir(&f_dir);
				}
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolFormatCard)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolFormatCard)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolLoadList)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolLoadList)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			else if(BUTTON_IsPressed(hBUTTON_ToolExit)) 
			{
				while(1)
				{
					if(!BUTTON_IsPressed(hBUTTON_ToolExit)) break;
					GUI_TOUCH_Exec();
					GUI_Delay(50);
				}
				
				DeleteToolsDisplay();
				CreateDefaultDisplay();
				DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				DISPLAY_RefreshSet();
				GUI_Delay(100);
			}
			break;
		}
		
		
		default:
		{
			GUI_Delay(100);
			break;
		}
	}
}
int APP_GetData(void * p, const U8 * * ppData, unsigned NumBytesReq, U32 Off) 
{
	FIL *phFile;
	UINT NumBytesRead;
	phFile = (FIL*)p;
	static char _acBuffer[0x1000];
	
//	if(NumBytesReq > sizeof(_acBuffer)) NumBytesReq = sizeof(_acBuffer);
	f_lseek(phFile,Off);
	f_read(phFile, _acBuffer, NumBytesReq, &NumBytesRead);
	*ppData = (const U8*) &_acBuffer;
	return NumBytesRead;
}

void CreateDefaultDisplay(void)
{
	GUI_SetBkColor(GUI_TRANSPARENT); 
	GUI_Clear();
	GUI_SetFont(&GUI_Font8x16);
	GUI_SetColor((0x62ul << 24) | GUI_BLACK);
	GUI_FillRect(120, 65, 475, 105);
	GUI_FillRect(5, 65, 115, 225);
	GUI_FillRect(5, 230, 475, 270);
	
	if (rs485_bus_status == RS485_BUS_CONNECTED) RS485_BusStatusFlagReset();
	else RS485_BusStatusFlagSet();	
	
	if(GetDisplay_uSD_CardActivStatus()) DISPLAY_uSD_CardReadySet();
	else DISPLAY_uSD_CardErrorSet();	
	
	hBUTTON_Settings = BUTTON_Create(10, 240, 80, 30, GUI_ID_BUTTON_Settings, WM_CF_SHOW); // Settings
	BUTTON_SetText(hBUTTON_Settings, "Settings");
	hBUTTON_Tools = BUTTON_Create(135, 240, 80, 30, GUI_ID_BUTTON_Tools, WM_CF_SHOW); // Tools
	BUTTON_SetText(hBUTTON_Tools, "Tools");
	hBUTTON_Control = BUTTON_Create(260, 240, 80, 30, GUI_ID_BUTTON_Control, WM_CF_SHOW); //Control
	BUTTON_SetText(hBUTTON_Control, "Control");
	hBUTTON_Unlock = BUTTON_Create(390, 240, 80, 30, GUI_ID_BUTTON_Unlock, WM_CF_SHOW); //Unlock
	if(IsDISPLAY_UnlockActiv()) BUTTON_SetText(hBUTTON_Unlock, "Lock");
	else BUTTON_SetText(hBUTTON_Unlock, "Unlock");
	
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font32B_1);
	GUI_SetTextMode(GUI_TEXTMODE_TRANS);	
	GUI_GotoXY(150, 0);
	GUI_DispString("HOTEL NAME");
	GUI_SetFont(&GUI_Font24_1);
	GUI_SetColor(GUI_YELLOW);
	GUI_GotoXY(10, 0);
	GUI_DispString("SHORT");
	GUI_GotoXY(10, 25);
	GUI_DispString("ABOUT");
	GUI_SetColor(GUI_WHITE);
//	GUI_SetFont(&GUI_Font8x8);
//	GUI_DispCharAt('V', 316, 3);
	DISPLAY_UpdateTimeSet();
	eActivDisplay = DISPLAY_DEFAULT;
}


void DeleteDefaultDisplay(void)
{
	WM_DeleteWindow(hBUTTON_Settings);
	WM_DeleteWindow(hBUTTON_Tools);
	WM_DeleteWindow(hBUTTON_Control);
	WM_DeleteWindow(hBUTTON_Unlock);
}

void CreateToolsDisplay(void)
{
	GUI_SetBkColor(GUI_BLACK);
	GUI_Clear();
	GUI_SetColor(GUI_WHITE);

	hBUTTON_ToolFileList = BUTTON_Create(190, 10, 60, 60, GUI_ID_BUTTON_ToolFileList, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolFileList, "uSD\nFILE LIST");	
	hBUTTON_ToolUpdateFW = BUTTON_Create(300, 10, 60, 60, GUI_ID_BUTTON_ToolUpdateFW, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolUpdateFW, "UPDATE\nFW");
	hBUTTON_ToolLoadList = BUTTON_Create(410, 10, 60, 60, GUI_ID_BUTTON_ToolLoadList, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolLoadList, "LOAD\nCTRL LIST");
	
	hBUTTON_ToolScanRS485 = BUTTON_Create(190, 85, 60, 60, GUI_ID_BUTTON_ToolScanRS485, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolScanRS485, "BUS\nSCAN");
	hBUTTON_ToolUploadImage = BUTTON_Create(300, 85, 60, 60, GUI_ID_BUTTON_ToolUploadImage, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolUploadImage, "IMAGE\nUPLOAD");
	hBUTTON_ToolUploadFirmware = BUTTON_Create(410, 85, 60, 60, GUI_ID_BUTTON_ToolUploadFirmware, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolUploadFirmware, "FIRMW.\nUPLOAD");

	hBUTTON_ToolFormatCard = BUTTON_Create(300, 160, 60, 60, GUI_ID_BUTTON_ToolFormatCard, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolFormatCard, "uSD\nFORMAT");	
	hBUTTON_ToolDisplayCalibration = BUTTON_Create(410, 160, 60, 60, GUI_ID_BUTTON_ToolDisplayCalibration, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_ToolDisplayCalibration, "DISPLAY\nCALIBR.");
	
	GUI_DispStringAt("CONTROLLER", 190, 160);
	hSPINBOX_SetAddress = SPINBOX_CreateEx(190, 180, 80, 40, 0, WM_CF_SHOW, GUI_ID_SPINBOX_SetAddress, 10, 65500);
	SPINBOX_SetValue(hSPINBOX_SetAddress, 100);
	SPINBOX_SetEdge(hSPINBOX_SetAddress, SPINBOX_EDGE_CENTER);
	
	hBUTTON_ToolExit = BUTTON_Create(390, 240, 80, 30, GUI_ID_BUTTON_ToolExit, WM_CF_SHOW); //Info
	BUTTON_SetText(hBUTTON_ToolExit, "EXIT");

	hTree = TREEVIEW_CreateEx(10, 10, 160, 260, 0, WM_CF_SHOW, 0, GUI_ID_TREEVIEW_FileList);
	TREEVIEW_SetAutoScrollV(hTree, 1);
	TREEVIEW_SetSelMode(hTree, TREEVIEW_SELMODE_ROW);
	eActivDisplay = DISPLAY_TOOLS;
}	

void DeleteToolsDisplay(void)
{
	WM_DeleteWindow(hBUTTON_ToolScanRS485);
	WM_DeleteWindow(hBUTTON_ToolDisplayCalibration);
	WM_DeleteWindow(hBUTTON_ToolUpdateFW);
	WM_DeleteWindow(hBUTTON_ToolUploadImage);
	WM_DeleteWindow(hBUTTON_ToolUploadFirmware);
	WM_DeleteWindow(hBUTTON_ToolFileList);
	WM_DeleteWindow(hBUTTON_ToolFormatCard);
	WM_DeleteWindow(hBUTTON_ToolLoadList);
	WM_DeleteWindow(hBUTTON_ToolExit);
	WM_DeleteWindow(hSPINBOX_SetAddress);
	WM_DeleteWindow(hTree);
}

void CreateScanRS485BusDisplay(void)
{
	GUI_SetBkColor(GUI_BLACK);
	GUI_Clear();
	hLISTVIEW_AddresseFound = LISTVIEW_Create(10, 10, 460, 145, 0, GUI_ID_LISTVIEW_AddresseFound, WM_CF_SHOW, NULL);
	LISTVIEW_AddColumn(hLISTVIEW_AddresseFound, 50, "Address", GUI_TA_HCENTER | GUI_TA_VCENTER);
	LISTVIEW_AddColumn(hLISTVIEW_AddresseFound, 205, "Hardware Version", GUI_TA_HCENTER | GUI_TA_VCENTER);
	LISTVIEW_AddColumn(hLISTVIEW_AddresseFound, 205, "Firmware Version", GUI_TA_HCENTER | GUI_TA_VCENTER);
	LISTVIEW_SetGridVis(hLISTVIEW_AddresseFound, 1);
	LISTVIEW_SetAutoScrollV(hLISTVIEW_AddresseFound, 1);
	hSPINBOX_StartAddress = SPINBOX_CreateEx(10, 185, 80, 30, 0, WM_CF_SHOW, GUI_ID_SPINBOX_StartAddress, 10, 65500);
	SPINBOX_SetValue(hSPINBOX_StartAddress, 100);
	SPINBOX_EnableBlink(hSPINBOX_StartAddress, 250, 1);
	SPINBOX_SetEdge(hSPINBOX_StartAddress, SPINBOX_EDGE_CENTER);
	hSPINBOX_EndAddress = SPINBOX_CreateEx(135, 185, 80, 30, 0, WM_CF_SHOW, GUI_ID_SPINBOX_EndAddress, 10, 65500);
	SPINBOX_EnableBlink(hSPINBOX_EndAddress, 250, 1);
	SPINBOX_SetValue(hSPINBOX_EndAddress, 100);
	SPINBOX_SetEdge(hSPINBOX_EndAddress, SPINBOX_EDGE_CENTER);
	hSPINBOX_OldAddress = SPINBOX_CreateEx(10, 240, 80, 30, 0, WM_CF_SHOW, GUI_ID_SPINBOX_OldAddress, 10, 65500);
	SPINBOX_EnableBlink(hSPINBOX_OldAddress, 250, 1);
	SPINBOX_SetValue(hSPINBOX_OldAddress, 100);
	SPINBOX_SetEdge(hSPINBOX_OldAddress, SPINBOX_EDGE_CENTER);
	hSPINBOX_NewAddress = SPINBOX_CreateEx(135, 240, 80, 30, 0, WM_CF_SHOW, GUI_ID_SPINBOX_NewAddress, 10, 65500);
	SPINBOX_EnableBlink(hSPINBOX_NewAddress, 250, 1);
	SPINBOX_SetValue(hSPINBOX_StartAddress, 100);
	SPINBOX_SetEdge(hSPINBOX_NewAddress, SPINBOX_EDGE_CENTER);	
	hRADIO_ScanMode = RADIO_CreateEx( 260, 165, 90, 0, 0,WM_CF_SHOW, 0, GUI_ID_RADIO_ScanMode, 4, 15);
	RADIO_SetText(hRADIO_ScanMode, "Find FIRST", 0);
	RADIO_SetText(hRADIO_ScanMode, "Find NEXT", 1);
	RADIO_SetText(hRADIO_ScanMode, "Find ALL NEW", 2);
	RADIO_SetText(hRADIO_ScanMode, "Find ALL", 3);
	RADIO_SetValue(hRADIO_ScanMode, 3);
	hBUTTON_Scan = BUTTON_Create(390, 185, 80, 30, GUI_ID_BUTTON_Scan, WM_CF_SHOW); // Settings
	BUTTON_SetText(hBUTTON_Scan, "SCAN");
	hBUTTON_AddressSet = BUTTON_Create(260, 240, 80, 30, GUI_ID_BUTTON_AddressSet, WM_CF_SHOW); // Tools
	BUTTON_SetText(hBUTTON_AddressSet, "SET ADDRESS");
	hBUTTON_ExitRS485Scanner = BUTTON_Create(390, 240, 80, 30, GUI_ID_BUTTON_ExitRS485Scanner, WM_CF_SHOW); //Info
	BUTTON_SetText(hBUTTON_ExitRS485Scanner, "EXIT");
	GUI_SetFont(&GUI_Font13_ASCII);
	GUI_GotoXY(10, 168);
	GUI_DispString("START ADDRESS");
	GUI_GotoXY(135, 168);
	GUI_DispString("END ADDRESS");
	GUI_GotoXY(10, 223);
	GUI_DispString("OLD ADDRESS");
	GUI_GotoXY(135, 223);
	GUI_DispString("NEW ADDRESS");
	row = 0;
	eActivDisplay = DISPLAY_SCAN_RS485_BUS;
}

void DeleteScanRS485BusDisplay(void)
{
	WM_DeleteWindow(hLISTVIEW_AddresseFound);
	WM_DeleteWindow(hSPINBOX_StartAddress);
	WM_DeleteWindow(hSPINBOX_EndAddress);;
	WM_DeleteWindow(hSPINBOX_OldAddress);
	WM_DeleteWindow(hSPINBOX_NewAddress);
	WM_DeleteWindow(hRADIO_ScanMode);
	WM_DeleteWindow(hBUTTON_Scan);
	WM_DeleteWindow(hBUTTON_AddressSet);
	WM_DeleteWindow(hBUTTON_ExitRS485Scanner);
}


void CreateSettingsMenuDisplay(void)
{
	GUI_SetBkColor(GUI_BLACK);
	GUI_Clear();
	GUI_SetColor(GUI_GREEN);
	
	hBUTTON_SettingsEdit = BUTTON_Create(10, 240, 80, 30, GUI_ID_BUTTON_SettingsEdit, WM_CF_SHOW); // Settings Apply
	BUTTON_SetText(hBUTTON_SettingsEdit, "Edit");
	WM_DisableWindow(hBUTTON_SettingsEdit);
	hBUTTON_SettingsOk = BUTTON_Create(133, 240, 80, 30, GUI_ID_BUTTON_SettingsOk, WM_CF_SHOW); // Settings OK
	BUTTON_SetText(hBUTTON_SettingsOk, "OK");
	hBUTTON_SettingsApply = BUTTON_Create(260, 240, 80, 30, GUI_ID_BUTTON_SettingsApply, WM_CF_SHOW); // Settings Apply
	BUTTON_SetText(hBUTTON_SettingsApply, "Apply");
	hBUTTON_SettingsCancel = BUTTON_Create(390, 240, 80, 30, GUI_ID_BUTTON_SettingsCancel, WM_CF_SHOW); // Settings Cancel
	BUTTON_SetText(hBUTTON_SettingsCancel, "Cancel");
	
	hCHECKBOX_EnableDHCP = CHECKBOX_Create(10, 110, 80, 20, 0, GUI_ID_CHECK_EnableDHCP, WM_CF_SHOW);
	CHECKBOX_SetTextColor(hCHECKBOX_EnableDHCP, GUI_GREEN);	
	CHECKBOX_SetText(hCHECKBOX_EnableDHCP, "DHCP client");
	
	hCHECKBOX_EnableBroadcastTime = CHECKBOX_Create(200, 65, 100, 20, 0, GUI_ID_CHECK_EnableBroadcastTime, WM_CF_SHOW);	
	CHECKBOX_SetTextColor(hCHECKBOX_EnableBroadcastTime, GUI_GREEN);	
	CHECKBOX_SetText(hCHECKBOX_EnableBroadcastTime, "Broadcast Time");
	
	hCHECKBOX_EnableHTTP = CHECKBOX_Create(355, 35, 96, 20, 0, GUI_ID_CHECK_EnableHTTP, WM_CF_SHOW);
	CHECKBOX_SetTextColor(hCHECKBOX_EnableHTTP, GUI_GREEN);		
	CHECKBOX_SetText(hCHECKBOX_EnableHTTP, "Enable Server");
	
	hCHECKBOX_EnableWebConfig = CHECKBOX_Create(355, 60, 120, 20, 0, GUI_ID_CHECK_EnableWebConfig, WM_CF_SHOW);	
	CHECKBOX_SetTextColor(hCHECKBOX_EnableWebConfig, GUI_GREEN);
	CHECKBOX_SetText(hCHECKBOX_EnableWebConfig, "Enable Web Config");
	
	hCHECKBOX_EnableTFTP = CHECKBOX_Create(355, 110, 96, 20, 0, GUI_ID_CHECK_EnableTFTP, WM_CF_SHOW);
	CHECKBOX_SetTextColor(hCHECKBOX_EnableTFTP, GUI_GREEN);
	CHECKBOX_SetText(hCHECKBOX_EnableTFTP, "Enable Server");
	
	hEDIT_TcpIpAddress = EDIT_Create(10, 35, 100, 20, GUI_ID_EDIT_TcpIpAddress, 16, WM_CF_SHOW);
	EDIT_SetText(hEDIT_TcpIpAddress, (char *)iptxt);
	EDIT_EnableBlink(hEDIT_TcpIpAddress, 250, 1);
	
	hEDIT_TcpIpGateway = EDIT_Create(10, 60, 100, 20, GUI_ID_EDIT_TcpIpGateway, 16, WM_CF_SHOW);
	EDIT_SetText(hEDIT_TcpIpGateway, (char *)gtwtxt);
	EDIT_EnableBlink(hEDIT_TcpIpGateway, 250, 1);
	
	hEDIT_TcpIpSubnet = EDIT_Create(10, 85, 100, 20, GUI_ID_EDIT_TcpIpSubnet, 16, WM_CF_SHOW);
	EDIT_SetText(hEDIT_TcpIpSubnet, (char *)sbnttxt);
	EDIT_EnableBlink(hEDIT_TcpIpSubnet, 250, 1);
	
	hEDIT_RS485_InterfaceAddress = EDIT_Create(10, 170, 50, 20, GUI_ID_EDIT_RS485_InterfaceAddress, 5, WM_CF_SHOW);
	ClearBuffer(string, 16);
	Int2Str(string, rs485_interface_address);
	EDIT_SetText(hEDIT_RS485_InterfaceAddress, (char *)string);
	EDIT_EnableBlink(hEDIT_RS485_InterfaceAddress, 250, 1);
	
	hEDIT_RS485_BroadcastAddress = EDIT_Create(10, 195, 50, 20, GUI_ID_EDIT_RS485_BroadcastAddress, 5, WM_CF_SHOW);
	ClearBuffer(string, 16);
	Int2Str(string, rs485_broadcast_address);
	EDIT_SetText(hEDIT_RS485_BroadcastAddress, (char *)string);
	EDIT_EnableBlink(hEDIT_RS485_BroadcastAddress, 250, 1);
	
	hEDIT_Password = EDIT_Create(200, 170, 50, 20, GUI_ID_EDIT_Password, 5, WM_CF_SHOW);
	EDIT_SetText(hEDIT_Password, (char *)password_set);
	EDIT_EnableBlink(hEDIT_Password, 250, 1);
	
	hEDIT_SysID = EDIT_Create(355, 170, 50, 20, GUI_ID_EDIT_SysID, 5, WM_CF_SHOW);
	ClearBuffer(string, 16);
	Int2Str(string, system_id);
	EDIT_SetText(hEDIT_SysID, (char *)string);
	EDIT_EnableBlink(hEDIT_SysID, 250, 1);
	
	hEDIT_DateTime = EDIT_Create(200, 35, 120, 20, GUI_ID_EDIT_DateTime, 21, WM_CF_SHOW);
	EDIT_EnableBlink(hEDIT_DateTime, 250, 1);
	
	GUI_SetFont(&GUI_Font13_ASCII);
	GUI_GotoXY(5, 15);
	GUI_DispString("TCP/IP SETTINGS");
	GUI_GotoXY(115, 37);
	GUI_DispString("IPv4 Address");
	GUI_GotoXY(115, 62);
	GUI_DispString("Def. Gateway");
	GUI_GotoXY(115, 87);
	GUI_DispString("Subnet Mask");
	GUI_GotoXY(195, 15);
	GUI_DispString("DATE & TIME");
	GUI_GotoXY(350, 15);
	GUI_DispString("HTTP SERVER");
	GUI_GotoXY(350, 90);
	GUI_DispString("TFTP SERVER");
	GUI_GotoXY(5, 150);
	GUI_DispString("RS485 INTERFACE");
	GUI_GotoXY(67, 173);
	GUI_DispString("Interface Address");
	GUI_GotoXY(67, 198);
	GUI_DispString("Broadcast Address");
	GUI_GotoXY(195, 150);
	GUI_DispString("PASSSWORD");
	GUI_GotoXY(350, 150);
	GUI_DispString("SYSTEM ID");
	eActivDisplay = DISPLAY_SETTINGS;
}

void DeleteSettingsMenuDisplay(void)
{
	WM_DeleteWindow(hBUTTON_SettingsEdit);
	WM_DeleteWindow(hBUTTON_SettingsOk);
	WM_DeleteWindow(hBUTTON_SettingsCancel);
	WM_DeleteWindow(hBUTTON_SettingsApply);
	WM_DeleteWindow(hCHECKBOX_EnableDHCP);
	WM_DeleteWindow(hCHECKBOX_EnableBroadcastTime);
	WM_DeleteWindow(hCHECKBOX_EnableHTTP);
	WM_DeleteWindow(hCHECKBOX_EnableWebConfig);
	WM_DeleteWindow(hCHECKBOX_EnableTFTP);
	WM_DeleteWindow(hEDIT_TcpIpAddress);
	WM_DeleteWindow(hEDIT_TcpIpGateway);
	WM_DeleteWindow(hEDIT_TcpIpSubnet);
	WM_DeleteWindow(hEDIT_RS485_InterfaceAddress);
	WM_DeleteWindow(hEDIT_RS485_BroadcastAddress);
	WM_DeleteWindow(hEDIT_DateTime);
	WM_DeleteWindow(hEDIT_Password);
	WM_DeleteWindow(hEDIT_SysID);
}



void CreateOnScreenKeypad(void)
{
	GUI_SetBkColor(GUI_BLACK);
	GUI_SetColor(GUI_BLACK);
	GUI_FillRect(130, 5, 390, 240);
	hBUTTON_OnScreenKeypad_1 = BUTTON_Create(140, 50, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_1, WM_CF_SHOW); 
	BUTTON_SetText(hBUTTON_OnScreenKeypad_1, "1");
	hBUTTON_OnScreenKeypad_2 = BUTTON_Create(200, 50, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_2, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_2, "2");	
	hBUTTON_OnScreenKeypad_3 = BUTTON_Create(260, 50, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_3, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_3, "3");
	hBUTTON_OnScreenKeypad_4 = BUTTON_Create(320, 50, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_4, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_4, "4");
	hBUTTON_OnScreenKeypad_5 = BUTTON_Create(140, 110, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_5, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_5, "5");
	hBUTTON_OnScreenKeypad_6 = BUTTON_Create(200, 110, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_6, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_6, "6");
	hBUTTON_OnScreenKeypad_7 = BUTTON_Create(260, 110, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_7, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_7, "7");
	hBUTTON_OnScreenKeypad_8 = BUTTON_Create(320, 110, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_8, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_8, "8");
	hBUTTON_OnScreenKeypad_9 = BUTTON_Create(140, 170, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_9, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_9, "9");
	hBUTTON_OnScreenKeypad_0 = BUTTON_Create(200, 170, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_0, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_0, "0");
	hBUTTON_OnScreenKeypad_Ok = BUTTON_Create(260, 170, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_Ok, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_Ok, "OK");
	hBUTTON_OnScreenKeypad_Back = BUTTON_Create(320, 170, 60, 60, GUI_ID_BUTTON_OnScreenKeypad_Back, WM_CF_SHOW);
	BUTTON_SetText(hBUTTON_OnScreenKeypad_Back, "<BCK");
	DISPLAY_OnScreenKeypadSet();
}


void DeleteOnScreenKeypad(void)
{
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_0);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_1);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_2);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_3);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_4);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_5);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_6);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_7);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_8);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_9);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_Ok);
	WM_DeleteWindow(hBUTTON_OnScreenKeypad_Back);
}


void OnScreenKeypad(uint32_t edit_val, uint8_t key_pressed)
{
	uint8_t k;
	
	if((edit_val == OSK_EDIT_IP_ADDRESS) || (edit_val == OSK_EDIT_GW_ADDRESS) || (edit_val == OSK_EDIT_SUBNET_MASK))
	{
		GUI_SetColor(GUI_BLACK);
		GUI_FillRect(130, 15, 360, 50);
		GUI_SetFont(&GUI_Font24B_1);
		GUI_SetColor(GUI_WHITE);
		GUI_SetTextMode(GUI_TEXTMODE_TRANS);
		
		if(key_pressed == 'B')
		{				
			if(osk_ipedit == 1)
			{
				string1[osk_entry_cnt] = NULL;
				if(osk_entry_cnt > 0) osk_entry_cnt--;
				string1[osk_entry_cnt] = NULL;
				Str2Int(string1, &converted);
			}
			else if(osk_ipedit == 2)
			{
				string2[osk_entry_cnt] = NULL;
				if(osk_entry_cnt > 0) osk_entry_cnt--;
				string2[osk_entry_cnt] = NULL;
				Str2Int(string2, &converted);
			}
			else if(osk_ipedit == 3)
			{
				string3[osk_entry_cnt] = NULL;
				if(osk_entry_cnt > 0) osk_entry_cnt--;
				string3[osk_entry_cnt] = NULL;
				Str2Int(string3, &converted);
			}
			else if(osk_ipedit == 4)
			{
				string4[osk_entry_cnt] = NULL;
				if(osk_entry_cnt > 0) osk_entry_cnt--;
				string4[osk_entry_cnt] = NULL;
				Str2Int(string4, &converted);
			}
			
			GUI_GotoXY(150, 15);
			GUI_DispDecMin(converted);
		}
		else if(key_pressed == 'O')
		{
			if(osk_ipedit == 1)
			{
				Str2Int(string1, &converted);
				if(edit_val == OSK_EDIT_IP_ADDRESS) ip_address[0] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_GW_ADDRESS) gateway_address[0] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_SUBNET_MASK) subnet_mask[0] = (converted & 0xff);
			}
			else if(osk_ipedit == 2)
			{
				Str2Int(string2, &converted);
				if(edit_val == OSK_EDIT_IP_ADDRESS) ip_address[1] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_GW_ADDRESS) gateway_address[1] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_SUBNET_MASK) subnet_mask[1] = (converted & 0xff);
			}
			else if(osk_ipedit == 3)
			{
				Str2Int(string3, &converted);
				if(edit_val == OSK_EDIT_IP_ADDRESS) ip_address[2] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_GW_ADDRESS) gateway_address[2] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_SUBNET_MASK) subnet_mask[2] = (converted & 0xff);
			}
			else if(osk_ipedit == 4)
			{
				Str2Int(string4, &converted);
				if(edit_val == OSK_EDIT_IP_ADDRESS) ip_address[3] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_GW_ADDRESS) gateway_address[3] = (converted & 0xff);
				else if (edit_val == OSK_EDIT_SUBNET_MASK) subnet_mask[3] = (converted & 0xff);
			}
			
			
			if(edit_val == OSK_EDIT_IP_ADDRESS) 
			{
				ClearBuffer(iptxt, 20);
				sprintf((char*)iptxt, "%d.%d.%d.%d", ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
			}
			else if (edit_val == OSK_EDIT_GW_ADDRESS)
			{
				ClearBuffer(gtwtxt, 20);
				sprintf((char*)gtwtxt, "%d.%d.%d.%d", gateway_address[0], gateway_address[1], gateway_address[2], gateway_address[3]);
			}
			else if (edit_val == OSK_EDIT_SUBNET_MASK)
			{
				ClearBuffer(sbnttxt, 20);
				sprintf((char*)sbnttxt, "%d.%d.%d.%d", subnet_mask[0], subnet_mask[1], subnet_mask[2], subnet_mask[3]);	
			}

			DeleteOnScreenKeypad();
			CreateSettingsMenuDisplay();
			DISPLAY_OnScreenKeypadReset();
			return;
		}
		else if(IS_09(key_pressed))
		{		
			if(osk_ipedit == 1)
			{
				string1[osk_entry_cnt++] = key_pressed;
				if(osk_entry_cnt > 3) 
				{
					osk_entry_cnt--;
					string1[osk_entry_cnt] = NULL;
				}
				Str2Int(string1, &converted);
			}
			else if(osk_ipedit == 2)
			{
				string2[osk_entry_cnt++] = key_pressed;
				if(osk_entry_cnt > 3) 
				{
					osk_entry_cnt--;
					string2[osk_entry_cnt] = NULL;
				}
				Str2Int(string2, &converted);
			}
			else if(osk_ipedit == 3)
			{
				string3[osk_entry_cnt++] = key_pressed;
				if(osk_entry_cnt > 3) 
				{
					osk_entry_cnt--;
					string3[osk_entry_cnt] = NULL;
				}
				Str2Int(string3, &converted);
			}
			else if(osk_ipedit == 4)
			{
				string4[osk_entry_cnt++] = key_pressed;
				if(osk_entry_cnt > 3) 
				{						
					osk_entry_cnt--;
					string4[osk_entry_cnt] = NULL;
				}
				Str2Int(string4, &converted);
			}			
			
			GUI_GotoXY(150, 15);
			GUI_DispDecMin(converted);
		}
		else
		{
			ClearBuffer(string1, 8);
			ClearBuffer(string2, 8);
			ClearBuffer(string3, 8);
			ClearBuffer(string4, 8);
			k = 0;
			osk_entry_cnt = 0;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != '.') && (string[osk_entry_cnt] != NULL)) 
			{
				string1[k++] = string[osk_entry_cnt++];
			}
			k = 0;
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != '.') && (string[osk_entry_cnt] != NULL)) 
			{
				string2[k++] = string[osk_entry_cnt++];
			}
			k = 0;
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != '.') && (string[osk_entry_cnt] != NULL)) 
			{
				string3[k++] = string[osk_entry_cnt++];
			}
			k = 0;
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != NULL)) 
			{
				string4[k++] = string[osk_entry_cnt++];
			}
			
			osk_ipedit = 0;
			osk_entry_cnt = 0;			
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != NULL)) 
			{
				if(osk_entry_cnt <= key_pressed) 
				{
					osk_ipedit = 1;
					Str2Int(string1, &converted);
				}	
				osk_entry_cnt++;
			}
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != NULL)) 
			{
				if(osk_entry_cnt <= key_pressed) 
				{
					osk_ipedit = 2;
					Str2Int(string2, &converted);
				}	
				osk_entry_cnt++;
			}
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != NULL)) 
			{
				if(osk_entry_cnt <= key_pressed) 
				{
					osk_ipedit = 3;
					Str2Int(string3, &converted);
				}	
				osk_entry_cnt++;
			}
			osk_entry_cnt++;
			while(IS_09(string[osk_entry_cnt]) && (string[osk_entry_cnt] != NULL)) 
			{
				if(osk_entry_cnt <= key_pressed) 
				{
					osk_ipedit = 4;
					Str2Int(string4, &converted);
				}	
				osk_entry_cnt++;
			}
			
			osk_entry_cnt = 0;
			if(osk_ipedit == 1) while(string1[osk_entry_cnt] != NULL) osk_entry_cnt++;
			else if(osk_ipedit == 2) while(string2[osk_entry_cnt] != NULL) osk_entry_cnt++;
			else if(osk_ipedit == 3) while(string3[osk_entry_cnt] != NULL) osk_entry_cnt++;
			else if(osk_ipedit == 4) while(string4[osk_entry_cnt] != NULL) osk_entry_cnt++;				
			GUI_GotoXY(150, 15);
			GUI_DispDecMin(converted);
		}
	}
	else
	{
		switch(edit_val)
		{
			case OSK_EDIT_RS485_INTERFACE:
			{
				
				GUI_SetColor(GUI_BLACK);
				GUI_FillRect(130, 15, 360, 50);
				GUI_SetFont(&GUI_Font24B_1);
				GUI_SetColor(GUI_WHITE);
				GUI_SetTextMode(GUI_TEXTMODE_TRANS);
				
				if(key_pressed == 'B')
				{
					osk_entry[osk_entry_cnt] = NULL;				
					if(osk_entry_cnt > 0) osk_entry_cnt--;
					osk_entry[osk_entry_cnt] = NULL;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else if(key_pressed == 'O')
				{
					Str2Int(osk_entry, &converted);
					rs485_interface_address = (converted & 0xffff);
					DeleteOnScreenKeypad();
					CreateSettingsMenuDisplay();
					DISPLAY_OnScreenKeypadReset();
					return;
				}
				else if((key_pressed >= 0x30) && (key_pressed <= 0x39))
				{				
					osk_entry[osk_entry_cnt++] = key_pressed;
					if(osk_entry_cnt > 5) osk_entry_cnt--;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else
				{
					Str2Int(string, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				break;
			}
			
			
			case OSK_EDIT_RS485_BROADCAST:
			{
				GUI_SetColor(GUI_BLACK);
				GUI_FillRect(130, 15, 360, 50);
				GUI_SetFont(&GUI_Font24B_1);
				GUI_SetColor(GUI_WHITE);
				GUI_SetTextMode(GUI_TEXTMODE_TRANS);
				
				if(key_pressed == 'B')
				{
					osk_entry[osk_entry_cnt] = NULL;				
					if(osk_entry_cnt > 0) osk_entry_cnt--;
					osk_entry[osk_entry_cnt] = NULL;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else if(key_pressed == 'O')
				{
					Str2Int(osk_entry, &converted);
					rs485_broadcast_address = (converted & 0xffff);
					DeleteOnScreenKeypad();
					CreateSettingsMenuDisplay();
					DISPLAY_OnScreenKeypadReset();
					return;
				}
				else if((key_pressed >= 0x30) && (key_pressed <= 0x39))
				{				
					osk_entry[osk_entry_cnt++] = key_pressed;
					if(osk_entry_cnt > 5) osk_entry_cnt--;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else
				{
					Str2Int(string, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				break;
			}
			
			
			case OSK_EDIT_PASSWORD:
			{
				GUI_SetColor(GUI_BLACK);
				GUI_FillRect(130, 15, 360, 50);
				GUI_SetFont(&GUI_Font24B_1);
				GUI_SetColor(GUI_WHITE);
				GUI_SetTextMode(GUI_TEXTMODE_TRANS);
				
				if(key_pressed == 'B')
				{
					osk_entry[osk_entry_cnt] = NULL;				
					if(osk_entry_cnt > 0) osk_entry_cnt--;
					osk_entry[osk_entry_cnt] = NULL;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else if(key_pressed == 'O')
				{
					ClearBuffer(password_set, 6);
					osk_entry[5] = NULL;
					password_set_cnt = 0;
					while(osk_entry[password_set_cnt] != NULL) password_set_cnt++;
					memcpy(password_set, osk_entry, password_set_cnt);
					password_set_cnt = 0;
					while(password_set[password_set_cnt] != NULL) password_set_cnt++;
					DeleteOnScreenKeypad();
					CreateSettingsMenuDisplay();
					DISPLAY_OnScreenKeypadReset();
					return;
				}
				else if(IS_09(key_pressed))
				{				
					osk_entry[osk_entry_cnt++] = key_pressed;
					if(osk_entry_cnt > 5) osk_entry_cnt--;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else
				{
					Str2Int(string, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				break;
			}
			
			
			case OSK_ENTER_PASSWORD:
			{
				if((key_pressed == 'B') || (key_pressed == 'O'))				
				{
					GUI_SetColor(GUI_BLACK);
					GUI_FillRect(130, 15, 360, 50);
					GUI_SetFont(&GUI_Font24B_1);
					GUI_SetColor(GUI_WHITE);
					GUI_SetTextMode(GUI_TEXTMODE_TRANS);
					
					if(key_pressed == 'B')
					{
						osk_entry[osk_entry_cnt] = NULL;	
						
						if(osk_entry_cnt > 0)
						{
							--osk_entry_cnt;
							ret_1 = 0;
							while(ret_1 < osk_entry_cnt)
							{
								GUI_DispCharAt('*', ((ret_1 * 40) + 180), 15);
								ret_1++;
							}
						}
						
						osk_entry[osk_entry_cnt] = NULL;	
						DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
					}
					else if(key_pressed == 'O')
					{
						osk_entry[5] = NULL;
						
						if (strncmp((char*)osk_entry, (char*)password_set, password_set_cnt) == 0)
						{
							GUI_DispStringAt("PASSWORD OK", 150, 15);
							DISPLAY_UnlockSet();
						}
						else
						{
							GUI_DispStringAt("WRONG PASSWORD", 150, 15);
							DISPLAY_UnlockReset();
						}
						
						DISPLAY_TimerStart(DISPLAY_KEYPAD_DELAY);
					}
				}
				else if((key_pressed >= '0') || (key_pressed <= '9'))
				{
					if(osk_entry_cnt == 0)
					{
						GUI_SetColor(GUI_BLACK);
						GUI_FillRect(130, 15, 360, 50);
					}
					
					GUI_SetColor(GUI_WHITE);
					GUI_SetTextMode(GUI_TEXTMODE_TRANS);				
					GUI_SetFont(&GUI_Font24B_1);
					if(osk_entry_cnt < 5) GUI_DispCharAt('*', ((osk_entry_cnt * 40) + 180), 15);
					osk_entry[osk_entry_cnt++] = key_pressed;
					if(osk_entry_cnt > 5) osk_entry_cnt--;
					DISPLAY_TimerStart(DISPLAY_UNLOCK_TIMEOUT);
				}
				
				if(IsDISPLAY_UnlockActiv()) DISPLAY_TimeoutTimerStart(DISPLAY_UNLOCK_TIMEOUT);			
				GUI_SetTextMode(GUI_TEXTMODE_NORMAL);			
				DISPLAY_RefreshSet();
				break;
			}
			
			
			case OSK_EDIT_SYS_ID:
			{
				GUI_SetColor(GUI_BLACK);
				GUI_FillRect(130, 15, 360, 50);
				GUI_SetFont(&GUI_Font24B_1);
				GUI_SetColor(GUI_WHITE);
				GUI_SetTextMode(GUI_TEXTMODE_TRANS);
				
				if(key_pressed == 'B')
				{
					osk_entry[osk_entry_cnt] = NULL;				
					if(osk_entry_cnt > 0) osk_entry_cnt--;
					osk_entry[osk_entry_cnt] = NULL;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else if(key_pressed == 'O')
				{
					Str2Int(osk_entry, &converted);
					system_id = (converted & 0xffff);
					DeleteOnScreenKeypad();
					CreateSettingsMenuDisplay();
					DISPLAY_OnScreenKeypadReset();
					return;
				}
				else if((key_pressed >= 0x30) && (key_pressed <= 0x39))
				{				
					osk_entry[osk_entry_cnt++] = key_pressed;
					if(osk_entry_cnt > 5) osk_entry_cnt--;
					Str2Int(osk_entry, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				else
				{
					Str2Int(string, &converted);
					GUI_GotoXY(150, 15);
					GUI_DispDecMin(converted);
				}
				break;
			}
			
			
			default:
			{
				break;
			}
		}		
	}
}


void UpdateLogDisplay(void)
{
	uint8_t js;

	if(eActivDisplay != DISPLAY_DEFAULT) return;
	
	GUI_ClearRect(120, 110, 480, 220);
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font16B_1);
	GUI_SetTextMode(GUI_TEXTMODE_TRANS);
	
	js = 0;							
	while(js < sizeof(string1))
	{
		string5[js] = string4[js];
		string4[js] = string3[js];
		string3[js] = string2[js];
		string2[js] = string1[js];
		string1[js] = NULL;
		js++;
	}	
	
	memcpy(string1, "CONTROLLER: ", 12);
	Int2Str(&string1[12], rs485_rubicon_address);
	js = 0;							
	while(string1[js] != NULL) js++;
	string1[js++] = ' ';
	string1[js++] = '=';
	string1[js++] = ' ';
	
	switch (rx_buffer[9])
	{
		
		case RUBICON_LOG_GUEST_CARD_VALID:
			memcpy(&string1[js], "GUEST_CARD VALID", 16);
			break;
		
		case RUBICON_LOG_GUEST_CARD_INVALID:
			memcpy(&string1[js], "GUEST CARD INVALID", 17);
			break;
			
		case RUBICON_LOG_HANDMAID_CARD_VALID:
			memcpy(&string1[js], "HANDMAID CARD VALID", 19);
			break;
		
		case RUBICON_LOG_ENTRY_DOOR_CLOSED:
			memcpy(&string1[js], "ENTRY DOOR CLOSED", 17);
			break;
		
		case RUBICON_LOG_PRESET_CARD:
			memcpy(&string1[js], "PRESSET CARD USED", 17);
			break;
		
		case RUBICON_LOG_HANDMAID_SERVICE_END:
			memcpy(&string1[js], "HANDMAID SERVICE END", 20);
			break;
		
		case RUBICON_LOG_MANAGER_CARD:
			memcpy(&string1[js], "MANAGER CARD USED", 17);
			break;
		
		case RUBICON_LOG_SERVICE_CARD:
			memcpy(&string1[js], "SERVICE CARD USED", 17);
			break;
		
		case RUBICON_LOG_ENTRY_DOOR_OPENED:
			memcpy(&string1[js], "ENTRY DOOR OPENED", 17);
			break;
		
		case RUBICON_LOG_MINIBAR_USED:
			memcpy(&string1[js], "MINIBAR USED", 12);
			break;
		
		case RUBICON_LOG_BALCON_DOOR_OPENED:
			memcpy(&string1[js], "BALCONY DOOR OPENED", 19);
			break;
		
		case RUBICON_LOG_BALCON_DOOR_CLOSED:
			memcpy(&string1[js], "BALCONY DOOR CLOSED", 19);
			break;
		
		case RUBICON_LOG_CARD_STACKER_ON:
			memcpy(&string1[js], "CARD IN STACKER", 15);
			break;							
		
		case RUBICON_LOG_CARD_STACKER_OFF:
			memcpy(&string1[js], "CARD OUT OF STACKER", 19);
			break;
		
		case RUBICON_LOG_HANDMAID_SWITCH_ON:
			memcpy(&string1[js], "HANDMAID CALL ON", 16);
			break;
		
		case RUBICON_LOG_HANDMAID_SWITCH_OFF:
			memcpy(&string1[js], "HANDMAID CALL OFF", 17);
			break;
		
		case RUBICON_LOG_SOS_ALARM_TRIGGER:
			memcpy(&string1[js], "SOS ALARM TRIGGER", 17);
			GUI_ClearRect(5, 190, 115, 225);
			GUI_SetColor(GUI_RED);
			GUI_FillRect(5, 190, 115, 225);
			GUI_SetTextMode(GUI_TEXTMODE_TRANS);
			GUI_SetColor(GUI_YELLOW);
			GUI_SetFont(&GUI_Font24B_1);
			GUI_GotoXY(10, 195);
			GUI_DispDecMin(rs485_rubicon_address);
			GUI_SetFont(&GUI_Font24B_1);
			GUI_DispStringAt("SOS", 70, 195);
			break;
				
		case RUBICON_LOG_SOS_ALARM_RESET:
			memcpy(&string1[js], "SOS ALARM RESET", 15);
			GUI_ClearRect(5, 190, 115, 225);
			GUI_SetColor((0x62ul << 24) | GUI_BLACK);
			GUI_FillRect(5, 190, 115, 225);
			break;
		
		case RUBICON_LOG_FIRE_ALARM_TRIGGER:
			memcpy(&string1[js], "FIRE ALARM TRIGGER", 18);
			GUI_ClearRect(5, 190, 115, 225);
			GUI_SetColor(GUI_RED);
			GUI_FillRect(5, 190, 115, 225);
			GUI_SetTextMode(GUI_TEXTMODE_TRANS);
			GUI_SetColor(GUI_YELLOW);
			GUI_SetFont(&GUI_Font24B_1);
			GUI_GotoXY(10, 195);
			GUI_DispDecMin(rs485_rubicon_address);
			GUI_SetFont(&GUI_Font20B_1);
			GUI_DispStringAt("FIRE", 70, 195);
			break;
		
		case RUBICON_LOG_FIRE_ALARM_RESET:
			memcpy(&string1[js], "FIRE ALARM RESET", 16);
			GUI_ClearRect(5, 185, 115, 225);
			GUI_SetColor((0x62ul << 24) | GUI_BLACK);
			GUI_FillRect(5, 185, 115, 225);
			break;
		
		case RUBICON_LOG_UNKNOWN_CARD:		
			memcpy(&string1[js], "UNKNOWN CARD", 12);
			break;
		
		case RUBICON_LOG_DO_NOT_DISTURB_SWITCH_ON:		
			memcpy(&string1[js], "DO NOT DISTURB ON", 17);
			break;

		case RUBICON_LOG_DO_NOT_DISTURB_SWITCH_OFF:						
			memcpy(&string1[js], "DO NOT DISTURB OFF", 18);	
			break;
		
		case RUBICON_LOG_CARD_EXPIRED:					
			memcpy(&string1[js], "CARD TIME EXPIRED", 17);
			break;
		
		case RUBICON_LOG_WRONG_ROOM:							
			memcpy(&string1[js], "WRONG ROOM", 10);
			break;
		
		case RUBICON_LOG_WRONG_SYSTEM_ID:										
			memcpy(&string1[js], "WRONG SYSTEM ID", 15);
			break;
		
		case RUBICON_CONTROLLER_RESET:
			memcpy(&string1[js], "CONTROLLER RESET", 16);
			break;
		
		case RUBICON_ENTRY_DOOR_NOT_CLOSED:
			memcpy(&string1[js], "ENTRY DOOR NOT CLOSED", 21);
			break;
		
		case RUBICON_DOOR_BELL_ACTIVE:
			memcpy(&string1[js], "DOOR BELL ACTIV", 15);
			break;
        
        case RUBICON_DOOR_LOCK_USER_OPEN:
			memcpy(&string1[js], "DOOR OPEN BY USER", 17);
			break;
		
		case RUBICON_PIN_RESET:
			memcpy(&string1[js], "PIN RESET", 9);
			break;
		
		case RUBICON_POWER_ON_RESET:
			memcpy(&string1[js], "POWER-ON RESET", 14);
			break;
		
		case RUBICON_SOFTWARE_RESET:
			memcpy(&string1[js], "SOFTWARE  RESET", 15);
			break;
		
		case RUBICON_IWDG_RESET:
			memcpy(&string1[js], "IWDG RESET", 10);
			break;
		
		case RUBICON_WWDG_RESET:
			memcpy(&string1[js], "WWDG RESET", 10);
			break;
		
		case RUBICON_LOW_POWER_RESET:
			memcpy(&string1[js], "LOW POWER RESET", 15);
			break;
		
		case RUBICON_FIRMWARE_UPDATE:
			memcpy(&string1[js], "FIRMWARE UPDATED", 16);
			break;
		
		case RUBICON_IMAGE_UPDATE_FAIL:
			memcpy(&string1[js], "IMAGE UPDATE FAIL", 17);
			break;
		
		case RUBICON_FIRMWARE_UPDATE_FAIL:
			memcpy(&string1[js], "FIRMWARE UPDATE FAIL", 20);
			break;
		
		case RUBICON_IMAGE_UPDATED:
			memcpy(&string1[js], "IMAGE UPDATED", 13);
			break;
		
		case RUBICON_BOOTLOADER_UPDATED:
			memcpy(&string1[js], "BOOTLOADER UPDATED", 18);
			break;
		
		case RUBICON_BOOTLOADER_UPDATE_FAIL:
			memcpy(&string1[js], "BOOTLOADER UPDATE FAIL", 22);
			break;
		
		case RUBICON_RS485_BUS_ERROR:
			memcpy(&string1[js], "RS485 BUS ERROR", 15);
			break;
		
		case RUBICON_NOT_RESPONDING:
			memcpy(&string1[js], "DEVICE NOT RESPONDING", 21);
			break;
        
        case RUBICON_DISPLAY_FAIL:
			memcpy(&string1[js], "DISPLAY ERROR", 13);
			break;
        
        case RUBICON_DRIVER_OR_FUNCTION_FAIL:
			memcpy(&string1[js], "FUNCTION OR DRIVER FAIL", 23);
			break;
        
        case FANCOIL_RPM_SENSOR_ERROR:
			memcpy(&string1[js], "FUNCTION OR DRIVER FAIL", 23);
			break;
        
        case FANCOIL_NTC_SENSOR_ERROR:
			memcpy(&string1[js], "FANCOIL NTC SENSOR ERROR", 24);
			break;
        
        case FANCOIL_LO_TEMP_ERROR:
			memcpy(&string1[js], "FANCOIL TEMPER. TOO LOW", 24);
			break;
        
        case FANCOIL_HI_TEMP_ERROR:
			memcpy(&string1[js], "FANCOIL TEMPER. TOO HIGH", 25);
			break;
        
        case FANCOIL_FREEZING_PROTECTION:
			memcpy(&string1[js], "FANCOIL FREEZING ALARM", 23);
			break;
        
        case THERMOSTAT_NTC_SENSOR_ERROR:
			memcpy(&string1[js], "THERMOSTAT NTC SENSOR ERROR", 28);
			break;
        
        case THERMOSTAT_ERROR:
			memcpy(&string1[js], "THERMOSTAT ERROR", 17);
			break;
	}
	
	
	js = 0;							
	while(string1[js] != NULL) js++;
	
	while(js < sizeof(string1)) 
	{
		string1[js] = ' ';
		++js;
	}
	string1[js - 1] = NULL;
	GUI_SetBkColor(GUI_TRANSPARENT); 
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font16B_1);	
	GUI_DispStringAt((char *)string1, 125, 200);
	GUI_DispStringAt((char *)string2, 125, 180);
	GUI_DispStringAt((char *)string3, 125, 160);
	GUI_DispStringAt((char *)string4, 125, 140);
	GUI_DispStringAt((char *)string5, 125, 120);
	GUI_DispCEOL();
	
	GUI_ClearRect(120, 65, 475, 105);
	GUI_SetColor((0x62ul << 24) | GUI_BLACK);
	GUI_FillRect(120, 65, 475, 105);
	GUI_SetTextMode(GUI_TEXTMODE_TRANS);
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font16B_1);
	GUI_GotoXY(130, 74);
	GUI_DispString((char *)string1);
	GUI_Exec();
}

void UpdateDateTime(void)
{
	static uint8_t old_min;
	uint8_t x;
	
	if(eActivDisplay != DISPLAY_DEFAULT) return;
	
	RTC_GetTime(RTC_Format_BCD, &RTC_Time);

	if((old_min != RTC_Time.RTC_Minutes) || IsDISPLAY_UpdateTimeActiv())
	{
		DISPLAY_UpdateTimeReset();
		old_min = RTC_Time.RTC_Minutes;

		RTC_GetDate(RTC_Format_BCD, &RTC_Date);

		GUI_ClearRect(5, 65, 115, 190);
		GUI_SetColor((0x62ul << 24) | GUI_BLACK);
		GUI_FillRect(5, 65, 115, 190);

		GUI_SetTextMode(GUI_TEXTMODE_TRANS);

		pString = string;
		while(pString < string + sizeof(string)) *pString++ = NULL;
		x = 0;
		string[x++] = (RTC_Time.RTC_Hours >> 4) + 48;
		string[x++] = (RTC_Time.RTC_Hours & 0x0f) + 48;
		string[x++] = ':';
		string[x++] = (RTC_Time.RTC_Minutes >> 4) + 48;
		string[x++] = (RTC_Time.RTC_Minutes & 0x0f) + 48;
		string[x++] = NULL;		
		GUI_GotoXY(60, 75);
		GUI_SetColor(GUI_RED);
		GUI_SetFont(&GUI_Font32B_1);
		GUI_SetTextAlign(GUI_TA_CENTER);
		GUI_DispString((char *)string);			
		ClearBuffer(string, 84);
		x = 0;
		if(RTC_Date.RTC_WeekDay == 0x01) memcpy(string, 		"Ponedjeljak", 11);
		else if(RTC_Date.RTC_WeekDay == 0x02) memcpy(string, 	"Utorak", 11);
		else if(RTC_Date.RTC_WeekDay == 0x03) memcpy(string, 	"Srijeda", 11);
		else if(RTC_Date.RTC_WeekDay == 0x04) memcpy(string, 	"Cetvrtak", 11);
		else if(RTC_Date.RTC_WeekDay == 0x05) memcpy(string, 	"Petak", 11);
		else if(RTC_Date.RTC_WeekDay == 0x06) memcpy(string, 	"Subota", 11);
		else if(RTC_Date.RTC_WeekDay == 0x07) memcpy(string, 	"Nedelja", 11);
		GUI_GotoXY(60, 110);		
		GUI_SetColor(GUI_WHITE);
		GUI_SetFont(&GUI_Font24_1);
		GUI_SetTextAlign(GUI_TA_CENTER);
		GUI_DispString((char *)string);
		ClearBuffer(string, 84);
		x = 0;
		string[x++] = (RTC_Date.RTC_Date >> 4) + 48;
		string[x++] = (RTC_Date.RTC_Date & 0x0f) + 48;
		string[x++] = '.';
		if(RTC_Date.RTC_Month == 0x01) memcpy(&string[x], "Januar", 7);		
		else if(RTC_Date.RTC_Month == 0x02) memcpy(&string[x], "Februar", 8);
		else if(RTC_Date.RTC_Month == 0x03) memcpy(&string[x], "Mart", 5);
		else if(RTC_Date.RTC_Month == 0x04) memcpy(&string[x], "April", 5);
		else if(RTC_Date.RTC_Month == 0x05) memcpy(&string[x], "Maj", 3);
		else if(RTC_Date.RTC_Month == 0x06) memcpy(&string[x], "Juni", 4);
		else if(RTC_Date.RTC_Month == 0x07) memcpy(&string[x], "Juli", 4);
		else if(RTC_Date.RTC_Month == 0x08) memcpy(&string[x], "August", 6);
		else if(RTC_Date.RTC_Month == 0x09) memcpy(&string[x], "Septembar", 9);
		else if(RTC_Date.RTC_Month == 0x10) memcpy(&string[x], "Oktobar", 7);
		else if(RTC_Date.RTC_Month == 0x11) memcpy(&string[x], "Novembar", 8);
		else if(RTC_Date.RTC_Month == 0x12) memcpy(&string[x], "Decembar", 8);
		x = 0;
		while(string[x] != NULL) x++;
		if(x > 10)GUI_SetFont(&GUI_Font16B_1);
		else GUI_SetFont(&GUI_Font20B_1);
		GUI_SetColor(GUI_RED);
		GUI_GotoXY(60, 140);
		GUI_SetTextAlign(GUI_TA_CENTER);
		GUI_DispString((char *)string);	
		ClearBuffer(string, 84);
		x = 0;
		if(eActivDisplay == DISPLAY_DEFAULT) string[x++] = ' ';
		string[x++] = '2';
		string[x++] = '0';
		string[x++] = (RTC_Date.RTC_Year >> 4) + 48;
		string[x++] = (RTC_Date.RTC_Year & 0x0f) + 48;
		GUI_SetFont(&GUI_Font20B_1);
		GUI_SetColor(GUI_WHITE);
		GUI_GotoXY(60, 165);
		GUI_SetTextAlign(GUI_TA_CENTER);
		GUI_DispString((char *)string);
		GUI_Exec();
	}
}

void UpdateFileTransferDisplay(void)
{
	uint8_t cnt;
	
	if(eActivDisplay != DISPLAY_DEFAULT) return;
	
	cnt = 0;
	while(cnt < 84)
	{
		string5[cnt] = NULL;
		string4[cnt] = NULL;
		string3[cnt] = NULL;
		string2[cnt] = NULL;
		string1[cnt] = NULL;
		cnt++;
	}
	
	GUI_ClearRect(120, 65, 475, 105);
	GUI_SetColor((0x62ul << 24) | GUI_BLACK);
	GUI_FillRect(120, 65, 475, 105);
	GUI_SetTextMode(GUI_TEXTMODE_TRANS);
	GUI_SetColor(GUI_WHITE);
	GUI_SetFont(&GUI_Font16B_1);
	GUI_GotoXY(130, 74);
	
	GUI_DispString("CONTROLLER:");
	Int2Str(string5, rs485_rubicon_address);
	GUI_DispStringAt((char *)string5, 230, 74);
	
	if(RUBICON_FirmwareUpdatePacket.update_state == FW_UPDATE_RUN) 					GUI_DispStringAt("FIRMWARE UPDATE RUN" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == FW_UPDATE_FAIL) 			GUI_DispStringAt("FW UPDATE FAIL - RS485 BUS  ERROR" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == FILE_SYS_ERROR) 			GUI_DispStringAt("FW UPDATE FAIL - FILE SYS. ERROR" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == FILE_DIR_ERROR) 			GUI_DispStringAt("FW UPDATE FAIL - FILE DIR. ERROR" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == FILE_ERROR) 				GUI_DispStringAt("FW UPDATE FAIL - FILE ERROR" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == FW_UPDATE_FINISHED) 		GUI_DispStringAt("FIRMWARE UPDATE SUCCESS" ,260, 74);
	else if(RUBICON_FirmwareUpdatePacket.update_state == RUBICON_BOOTLOADER_UPDATED)GUI_DispStringAt("BOOTLOADER UPDATE SUCCESS" ,260, 74);
	else if(RUBICON_FileUpdatePacket.update_state == FILE_UPDATE_FINISHED) 			GUI_DispStringAt("FILE UPDATE SUCCESS" ,260, 74);
	else if(RUBICON_FileUpdatePacket.update_state == FILE_UPDATE_FAIL) 				GUI_DispStringAt("FILE UPDATE FAIL - RS485 BUS  ERROR" ,260, 74);
	else if(RUBICON_FileUpdatePacket.update_state == FILE_SYS_ERROR) 				GUI_DispStringAt("FILE UPDATE FAIL - FILE SYS. ERROR" ,260, 74);
	else if(RUBICON_FileUpdatePacket.update_state == FILE_DIR_ERROR) 				GUI_DispStringAt("FILE UPDATE FAIL - FILE DIR. ERROR" ,260, 74);
	else if(RUBICON_FileUpdatePacket.update_state == FILE_ERROR) 					GUI_DispStringAt("FILE UPDATE FAIL - FILE ERROR" ,260, 74);
	else if(eRubiconUpdate == RUBICON_UPDATE_FILE)
	{
		GUI_DispStringAt("IMAGE" ,270, 74);
		
		if(RUBICON_FileUpdatePacket.update_state == FILE_UPDATE_FROM_CONFIG_FILE)
		{	
			Int2Str(string4, config_file_image_cnt);
			GUI_DispStringAt((char *)string4 ,320, 74);
			GUI_DispStringAt("UPDATE RUN" ,350, 74);
		}
		else
		{
			Int2Str(string4, rubicon_file_update_list[rubicon_file_update_list_cnt]);
			GUI_DispStringAt((char *)string4 ,320, 74);
			GUI_DispStringAt("UPDATE RUN" ,350, 74);
		}	
	}
	else if(eRubiconUpdate == RUBICON_UPDATE_BINARY)
	{
		GUI_DispStringAt("OLD FIRMWARE UPDATE RUN" ,270, 74);		
	}
	GUI_Exec();
}

void UpdateRS485_FoundDeviceList(void)
{
	LISTVIEW_AddRow(hLISTVIEW_AddresseFound, 0);
	Int2Str(rubicon_ctrl_buffer, rubicon_firmware_update_address_list[0]);
	LISTVIEW_SetItemText(hLISTVIEW_AddresseFound, 0, row, (char *)rubicon_ctrl_buffer);
	LISTVIEW_SetItemText(hLISTVIEW_AddresseFound, 1, row, "DE-200216_03");
	ClearBuffer(rubicon_ctrl_buffer, RUBICON_BUFFER_SIZE);
	ret_1 = 34;
	ret_2 = 0;
	while(ret_1 < 44) rubicon_ctrl_buffer[ret_2++] = rx_buffer[ret_1++];
	LISTVIEW_SetItemText(hLISTVIEW_AddresseFound, 2, row, (char *)rubicon_ctrl_buffer);
	++row;
	GUI_Exec();
}

/*************************** End of file ****************************/
